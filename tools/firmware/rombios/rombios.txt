00001                                           ! 1 
00002                                           ! 1 # 1 "_rombios_.c"
00003                                           ! 1 struct bios_info {
00004                                           ! 2     unsigned char com1_present:1;
00005                                           !BCC_EOS
00006                                           ! 3     unsigned char com2_present:1;
00007                                           !BCC_EOS
00008                                           ! 4     unsigned char hpet_present:1;
00009                                           !BCC_EOS
00010                                           ! 5     unsigned long pci_min, pci_len;
00011                                           !BCC_EOS
00012                                           ! 6     unsigned short xen_pfiob;
00013                                           !BCC_EOS
00014                                           ! 7 };
00015                                           !BCC_EOS
00016                                           ! 8 #asm
00017                                           !BCC_ASM
00018 0000                                      .rom
00019 0000                                      .org 0x0000
00020                                           use16 386
00021                                           MACRO HALT
00022                                             ;; the HALT macro is called with the line number of the HALT call.
00023                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00024                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00025                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00026                                             ;; However, users can choose to make panics non-fatal and continue.
00027                                             mov dx,#0x400
00028                                             mov ax,#?1
00029                                             out dx,ax
00030                                           MEND
00031                                           MACRO JMP_AP
00032                                             db 0xea
00033                                             dw ?2
00034                                             dw ?1
00035                                           MEND
00036                                           MACRO SET_INT_VECTOR
00037                                             mov ax, ?3
00038                                             mov ?1*4, ax
00039                                             mov ax, ?2
00040                                             mov ?1*4+2, ax
00041                                           MEND
00042                                           ! 33 endasm
00043                                           !BCC_ENDASM
00044                                           ! 34 typedef unsigned char Bit8u;
00045                                           !BCC_EOS
00046                                           ! 35 typedef unsigned short Bit16u;
00047                                           !BCC_EOS
00048                                           ! 36 typedef unsigned short bx_bool;
00049                                           !BCC_EOS
00050                                           ! 37 typedef unsigned long Bit32u;
00051                                           !BCC_EOS
00052                                           ! 38   void memsetb(seg,offset,value,count);
00053                                           !BCC_EOS
00054                                           ! 39   void memcpyb(dseg,doffset,sseg,soffset,count);
00055                                           !BCC_EOS
00056                                           ! 40   void memcpyd(dseg,doffset,sseg,soffset,count);
00057                                           !BCC_EOS
00058                                           ! 41     void
00059                                           ! 42   memsetb(seg,offset,value,count)
00060                                           ! 43     Bit16u seg;
00061                                           export	_memsetb
00062                       00000000            _memsetb:
00063                                           !BCC_EOS
00064                                           ! 44     Bit16u offset;
00065                                           !BCC_EOS
00066                                           ! 45     Bit16u value;
00067                                           !BCC_EOS
00068                                           ! 46     Bit16u count;
00069                                           !BCC_EOS
00070                                           ! 47   {
00071                                           ! 48 #asm
00072                                           !BCC_ASM
00073                       00000008            _memsetb.count	set	8
00074                       00000002            _memsetb.seg	set	2
00075                       00000006            _memsetb.value	set	6
00076                       00000004            _memsetb.offset	set	4
00077 0000           55                             push bp
00078 0001           89E5                           mov bp, sp
00079 0003           50                               push ax
00080 0004           51                               push cx
00081 0005           06                               push es
00082 0006           57                               push di
00083 0007           8B4E         0A                  mov cx, 10[bp] ; count
00084 000A           83F9                   00        cmp cx, #0x00
00085 000D           74           10                  je memsetb_end
00086 000F           8B46         04                  mov ax, 4[bp] ; segment
00087 0012           8EC0                             mov es, ax
00088 0014           8B46         06                  mov ax, 6[bp] ; offset
00089 0017           89C7                             mov di, ax
00090 0019           8A46         08                  mov al, 8[bp] ; value
00091 001C           FC                               cld
00092 001D           F3                               rep
00093 001E           AA                                stosb
00094                       0000001F              memsetb_end:
00095 001F           5F                               pop di
00096 0020           07                               pop es
00097 0021           59                               pop cx
00098 0022           58                               pop ax
00099 0023           5D                             pop bp
00100                                           ! 72 endasm
00101                                           !BCC_ENDASM
00102                                           ! 73   }
00103 0024           C3                         ret
00104                                           ! 74     void
00105                                           ! 75   memcpyb(dseg,doffset,sseg,soffset,count)
00106                                           ! 76     Bit16u dseg;
00107                                           export	_memcpyb
00108                       00000025            _memcpyb:
00109                                           !BCC_EOS
00110                                           ! 77     Bit16u doffset;
00111                                           !BCC_EOS
00112                                           ! 78     Bit16u sseg;
00113                                           !BCC_EOS
00114                                           ! 79     Bit16u soffset;
00115                                           !BCC_EOS
00116                                           ! 80     Bit16u count;
00117                                           !BCC_EOS
00118                                           ! 81   {
00119                                           ! 82 #asm
00120                                           !BCC_ASM
00121                       0000000A            _memcpyb.count	set	$A
00122                       00000006            _memcpyb.sseg	set	6
00123                       00000008            _memcpyb.soffset	set	8
00124                       00000002            _memcpyb.dseg	set	2
00125                       00000004            _memcpyb.doffset	set	4
00126 0025           55                             push bp
00127 0026           89E5                           mov bp, sp
00128 0028           50                               push ax
00129 0029           51                               push cx
00130 002A           06                               push es
00131 002B           57                               push di
00132 002C           1E                               push ds
00133 002D           56                               push si
00134 002E           8B4E         0C                  mov cx, 12[bp] ; count
00135 0031           83F9                   00        cmp cx, #0x0000
00136 0034           74           17                  je memcpyb_end
00137 0036           8B46         04                  mov ax, 4[bp] ; dsegment
00138 0039           8EC0                             mov es, ax
00139 003B           8B46         06                  mov ax, 6[bp] ; doffset
00140 003E           89C7                             mov di, ax
00141 0040           8B46         08                  mov ax, 8[bp] ; ssegment
00142 0043           8ED8                             mov ds, ax
00143 0045           8B46         0A                  mov ax, 10[bp] ; soffset
00144 0048           89C6                             mov si, ax
00145 004A           FC                               cld
00146 004B           F3                               rep
00147 004C           A4                                movsb
00148                       0000004D              memcpyb_end:
00149 004D           5E                               pop si
00150 004E           1F                               pop ds
00151 004F           5F                               pop di
00152 0050           07                               pop es
00153 0051           59                               pop cx
00154 0052           58                               pop ax
00155 0053           5D                             pop bp
00156                                           ! 113 endasm
00157                                           !BCC_ENDASM
00158                                           ! 114   }
00159 0054           C3                         ret
00160                                           ! 115   static Bit32u read_dword();
00161                                           !BCC_EOS
00162                                           ! 116   static void write_dword();
00163                                           !BCC_EOS
00164                                           ! 117     Bit32u
00165                                           ! 118   read_dword(seg, offset)
00166                                           ! 119     Bit16u seg;
00167                                           export	_read_dword
00168                       00000055            _read_dword:
00169                                           !BCC_EOS
00170                                           ! 120     Bit16u offset;
00171                                           !BCC_EOS
00172                                           ! 121   {
00173                                           ! 122 #asm
00174                                           !BCC_ASM
00175                       00000002            _read_dword.seg	set	2
00176                       00000004            _read_dword.offset	set	4
00177 0055           55                             push bp
00178 0056           89E5                           mov bp, sp
00179 0058           53                               push bx
00180 0059           1E                               push ds
00181 005A           8B46         04                  mov ax, 4[bp] ; segment
00182 005D           8ED8                             mov ds, ax
00183 005F           8B5E         06                  mov bx, 6[bp] ; offset
00184 0062           8B07                             mov ax, [bx]
00185 0064           43                               inc bx
00186 0065           43                               inc bx
00187 0066           8B17                             mov dx, [bx]
00188                                                 ;; ax = return value (word)
00189                                                 ;; dx = return value (word)
00190 0068           1F                               pop ds
00191 0069           5B                               pop bx
00192 006A           5D                             pop bp
00193                                           ! 139 endasm
00194                                           !BCC_ENDASM
00195                                           ! 140   }
00196 006B           C3                         ret
00197                                           ! 141     void
00198                                           ! 142   write_dword(seg, offset, data)
00199                                           ! 143     Bit16u seg;
00200                                           export	_write_dword
00201                       0000006C            _write_dword:
00202                                           !BCC_EOS
00203                                           ! 144     Bit16u offset;
00204                                           !BCC_EOS
00205                                           ! 145     Bit32u data;
00206                                           !BCC_EOS
00207                                           ! 146   {
00208                                           ! 147 #asm
00209                                           !BCC_ASM
00210                       00000002            _write_dword.seg	set	2
00211                       00000006            _write_dword.data	set	6
00212                       00000004            _write_dword.offset	set	4
00213 006C           55                             push bp
00214 006D           89E5                           mov bp, sp
00215 006F           50                               push ax
00216 0070           53                               push bx
00217 0071           1E                               push ds
00218 0072           8B46         04                  mov ax, 4[bp] ; segment
00219 0075           8ED8                             mov ds, ax
00220 0077           8B5E         06                  mov bx, 6[bp] ; offset
00221 007A           8B46         08                  mov ax, 8[bp] ; data word
00222 007D           8907                             mov [bx], ax ; write data word
00223 007F           43                               inc bx
00224 0080           43                               inc bx
00225 0081           8B46         0A                  mov ax, 10[bp] ; data word
00226 0084           8907                             mov [bx], ax ; write data word
00227 0086           1F                               pop ds
00228 0087           5B                               pop bx
00229 0088           58                               pop ax
00230 0089           5D                             pop bp
00231                                           ! 166 endasm
00232                                           !BCC_ENDASM
00233                                           ! 167   }
00234 008A           C3                         ret
00235                                           ! 168 #asm
00236                                           !BCC_ASM
00237                       00000002            _write_dword.seg	set	2
00238                       00000006            _write_dword.data	set	6
00239                       00000004            _write_dword.offset	set	4
00240                                             ;; and function
00241                       0000008B              landl:
00242                       0000008B              landul:
00243 008B           36                             SEG SS
00244 008C           2305                             and ax,[di]
00245 008E           36                             SEG SS
00246 008F           235D         02                  and bx,2[di]
00247 0092           C3                             ret
00248                                             ;; add function
00249                       00000093              laddl:
00250                       00000093              laddul:
00251 0093           36                             SEG SS
00252 0094           0305                             add ax,[di]
00253 0096           36                             SEG SS
00254 0097           135D         02                  adc bx,2[di]
00255 009A           C3                             ret
00256                                             ;; cmp function
00257                       0000009B              lcmpl:
00258                       0000009B              lcmpul:
00259 009B     66    25               0000FFFF      and eax, #0x0000FFFF
00260 00A1     66    C1E3                   10      shl ebx, #16
00261 00A5     66    01D8                           add eax, ebx
00262 00A8     66    C1EB                   10      shr ebx, #16
00263 00AC           36                             SEG SS
00264 00AD     66    3B05                             cmp eax, dword ptr [di]
00265 00B0           C3                             ret
00266                                             ;; sub function
00267                       000000B1              lsubl:
00268                       000000B1              lsubul:
00269 00B1           36                             SEG SS
00270 00B2           2B05                           sub ax,[di]
00271 00B4           36                             SEG SS
00272 00B5           1B5D         02                sbb bx,2[di]
00273 00B8           C3                             ret
00274                                             ;; mul function
00275                       000000B9              lmull:
00276                       000000B9              lmulul:
00277 00B9     66    25               0000FFFF      and eax, #0x0000FFFF
00278 00BF     66    C1E3                   10      shl ebx, #16
00279 00C3     66    01D8                           add eax, ebx
00280 00C6           36                             SEG SS
00281 00C7     66    F725                           mul eax, dword ptr [di]
00282 00CA     66    89C3                           mov ebx, eax
00283 00CD     66    C1EB                   10      shr ebx, #16
00284 00D1           C3                             ret
00285                                             ;; dec function
00286                       000000D2              ldecl:
00287                       000000D2              ldecul:
00288 00D2           36                             SEG SS
00289 00D3     66    FF0F                           dec dword ptr [bx]
00290 00D6           C3                             ret
00291                                             ;; or function
00292                       000000D7              lorl:
00293                       000000D7              lorul:
00294 00D7           36                             SEG SS
00295 00D8           0B05                           or ax,[di]
00296 00DA           36                             SEG SS
00297 00DB           0B5D         02                or bx,2[di]
00298 00DE           C3                             ret
00299                                             ;; inc function
00300                       000000DF              lincl:
00301                       000000DF              lincul:
00302 00DF           36                             SEG SS
00303 00E0     66    FF07                           inc dword ptr [bx]
00304 00E3           C3                             ret
00305                                             ;; tst function
00306                       000000E4              ltstl:
00307                       000000E4              ltstul:
00308 00E4     66    25               0000FFFF      and eax, #0x0000FFFF
00309 00EA     66    C1E3                   10      shl ebx, #16
00310 00EE     66    01D8                           add eax, ebx
00311 00F1     66    C1EB                   10      shr ebx, #16
00312 00F5     66    85C0                           test eax, eax
00313 00F8           C3                             ret
00314                                             ;; sr function
00315                       000000F9              lsrul:
00316 00F9           89F9                           mov cx,di
00317 00FB           E3           19                jcxz lsr_exit
00318 00FD     66    25               0000FFFF      and eax, #0x0000FFFF
00319 0103     66    C1E3                   10      shl ebx, #16
00320 0107     66    01D8                           add eax, ebx
00321                       0000010A              lsr_loop:
00322 010A     66    D1E8                           shr eax, #1
00323 010D           E2           FB                loop lsr_loop
00324 010F     66    89C3                           mov ebx, eax
00325 0112     66    C1EB                   10      shr ebx, #16
00326                       00000116              lsr_exit:
00327 0116           C3                             ret
00328                                             ;; sl function
00329                       00000117              lsll:
00330                       00000117              lslul:
00331 0117           89F9                           mov cx,di
00332 0119           E3           19                jcxz lsl_exit
00333 011B     66    25               0000FFFF      and eax, #0x0000FFFF
00334 0121     66    C1E3                   10      shl ebx, #16
00335 0125     66    01D8                           add eax, ebx
00336                       00000128              lsl_loop:
00337 0128     66    D1E0                           shl eax, #1
00338 012B           E2           FB                loop lsl_loop
00339 012D     66    89C3                           mov ebx, eax
00340 0130     66    C1EB                   10      shr ebx, #16
00341                       00000134              lsl_exit:
00342 0134           C3                             ret
00343                       00000135              idiv_:
00344 0135           99                             cwd
00345 0136           F7FB                           idiv bx
00346 0138           C3                             ret
00347                       00000139              idiv_u:
00348 0139           31D2                           xor dx,dx
00349 013B           F7F3                           div bx
00350 013D           C3                             ret
00351                       0000013E              ldivul:
00352 013E     66    25               0000FFFF      and eax, #0x0000FFFF
00353 0144     66    C1E3                   10      shl ebx, #16
00354 0148     66    01D8                           add eax, ebx
00355 014B     66    31D2                           xor edx, edx
00356 014E           36                             SEG SS
00357 014F           8B5D         02                mov bx, 2[di]
00358 0152     66    C1E3                   10      shl ebx, #16
00359 0156           36                             SEG SS
00360 0157           8B1D                           mov bx, [di]
00361 0159     66    F7F3                           div ebx
00362 015C     66    89C3                           mov ebx, eax
00363 015F     66    C1EB                   10      shr ebx, #16
00364 0163           C3                             ret
00365                                           ! 294 endasm
00366                                           !BCC_ENDASM
00367                                           ! 295 typedef struct {
00368                                           ! 296   unsigned char filler1[0x400];
00369                                           !BCC_EOS
00370                                           ! 297   unsigned char filler2[0x6c];
00371                                           !BCC_EOS
00372                                           ! 298   Bit16u ticks_low;
00373                                           !BCC_EOS
00374                                           ! 299   Bit16u ticks_high;
00375                                           !BCC_EOS
00376                                           ! 300   Bit8u midnight_flag;
00377                                           !BCC_EOS
00378                                           ! 301   } bios_data_t;
00379                                           !BCC_EOS
00380                                           ! 302   typedef struct {
00381                                           ! 303     Bit16u heads;
00382                                           !BCC_EOS
00383                                           ! 304     Bit16u cylinders;
00384                                           !BCC_EOS
00385                                           ! 305     Bit16u spt;
00386                                           !BCC_EOS
00387                                           ! 306     } chs_t;
00388                                           !BCC_EOS
00389                                           ! 307   typedef struct {
00390                                           ! 308     Bit16u iobase1;
00391                                           !BCC_EOS
00392                                           ! 309     Bit16u iobase2;
00393                                           !BCC_EOS
00394                                           ! 310     Bit8u prefix;
00395                                           !BCC_EOS
00396                                           ! 311     Bit8u unused;
00397                                           !BCC_EOS
00398                                           ! 312     Bit8u irq;
00399                                           !BCC_EOS
00400                                           ! 313     Bit8u blkcount;
00401                                           !BCC_EOS
00402                                           ! 314     Bit8u dma;
00403                                           !BCC_EOS
00404                                           ! 315     Bit8u pio;
00405                                           !BCC_EOS
00406                                           ! 316     Bit16u options;
00407                                           !BCC_EOS
00408                                           ! 317     Bit16u reserved;
00409                                           !BCC_EOS
00410                                           ! 318     Bit8u revision;
00411                                           !BCC_EOS
00412                                           ! 319     Bit8u checksum;
00413                                           !BCC_EOS
00414                                           ! 320     } dpte_t;
00415                                           !BCC_EOS
00416                                           ! 321   typedef struct {
00417                                           ! 322     Bit8u iface;
00418                                           !BCC_EOS
00419                                           ! 323     Bit16u iobase1;
00420                                           !BCC_EOS
00421                                           ! 324     Bit16u iobase2;
00422                                           !BCC_EOS
00423                                           ! 325     Bit8u irq;
00424                                           !BCC_EOS
00425                                           ! 326     } ata_channel_t;
00426                                           !BCC_EOS
00427                                           ! 327   typedef struct {
00428                                           ! 328     Bit8u type;
00429                                           !BCC_EOS
00430                                           ! 329     Bit8u device;
00431                                           !BCC_EOS
00432                                           ! 330     Bit8u removable;
00433                                           !BCC_EOS
00434                                           ! 331     Bit8u lock;
00435                                           !BCC_EOS
00436                                           ! 332     Bit8u mode;
00437                                           !BCC_EOS
00438                                           ! 333     Bit16u blksize;
00439                                           !BCC_EOS
00440                                           ! 334     Bit8u translation;
00441                                           !BCC_EOS
00442                                           ! 335     chs_t lchs;
00443                                           !BCC_EOS
00444                                           ! 336     chs_t pchs;
00445                                           !BCC_EOS
00446                                           ! 337     Bit32u sectors;
00447                                           !BCC_EOS
00448                                           ! 338     } ata_device_t;
00449                                           !BCC_EOS
00450                                           ! 339   typedef struct {
00451                                           ! 340     ata_channel_t channels[4];
00452                                           !BCC_EOS
00453                                           ! 341     ata_device_t devices[(4*2)];
00454                                           !BCC_EOS
00455                                           ! 342     Bit8u hdcount, hdidmap[(4*2)];
00456                                           !BCC_EOS
00457                                           ! 343     Bit8u cdcount, cdidmap[(4*2)];
00458                                           !BCC_EOS
00459                                           ! 344     dpte_t dpte;
00460                                           !BCC_EOS
00461                                           ! 345     Bit16u trsfsectors;
00462                                           !BCC_EOS
00463                                           ! 346     Bit32u trsfbytes;
00464                                           !BCC_EOS
00465                                           ! 347     } ata_t;
00466                                           !BCC_EOS
00467                                           ! 348   typedef struct {
00468                                           ! 349     Bit8u active;
00469                                           !BCC_EOS
00470                                           ! 350     Bit8u media;
00471                                           !BCC_EOS
00472                                           ! 351     Bit8u emulated_drive;
00473                                           !BCC_EOS
00474                                           ! 352     Bit8u controller_index;
00475                                           !BCC_EOS
00476                                           ! 353     Bit16u device_spe
00477                                           ! 353 c;
00478                                           !BCC_EOS
00479                                           ! 354     Bit32u ilba;
00480                                           !BCC_EOS
00481                                           ! 355     Bit16u buffer_segment;
00482                                           !BCC_EOS
00483                                           ! 356     Bit16u load_segment;
00484                                           !BCC_EOS
00485                                           ! 357     Bit16u sector_count;
00486                                           !BCC_EOS
00487                                           ! 358     chs_t vdevice;
00488                                           !BCC_EOS
00489                                           ! 359     } cdemu_t;
00490                                           !BCC_EOS
00491                                           ! 360 Bit32u TCGInterruptHandler( );
00492                                           !BCC_EOS
00493                                           ! 361 void tcpa_acpi_init( );
00494                                           !BCC_EOS
00495                                           ! 362 Bit32u tcpa_extend_acpi_log( );
00496                                           !BCC_EOS
00497                                           ! 363 void tcpa_calling_int19h( );
00498                                           !BCC_EOS
00499                                           ! 364 void tcpa_returned_int19h( );
00500                                           !BCC_EOS
00501                                           ! 365 void tcpa_add_event_separators( );
00502                                           !BCC_EOS
00503                                           ! 366 void tcpa_wake_event( );
00504                                           !BCC_EOS
00505                                           ! 367 void tcpa_add_bootdevice( );
00506                                           !BCC_EOS
00507                                           ! 368 void tcpa_start_option_rom_scan( );
00508                                           !BCC_EOS
00509                                           ! 369 void tcpa_option_rom( );
00510                                           !BCC_EOS
00511                                           ! 370 void tcpa_ipl( );
00512                                           !BCC_EOS
00513                                           ! 371 void tcpa_measure_post( );
00514                                           !BCC_EOS
00515                                           ! 372 Bit32u tcpa_initialize_tpm( );
00516                                           !BCC_EOS
00517                                           ! 373 Bit32u get_s3_waking_vector( );
00518                                           !BCC_EOS
00519                                           ! 374 void test_gateway();
00520                                           !BCC_EOS
00521                                           ! 375 typedef struct {
00522                                           ! 376   Bit16u reg_ss;
00523                                           !BCC_EOS
00524                                           ! 377   Bit16u reg_cs;
00525                                           !BCC_EOS
00526                                           ! 378   Bit16u reg_ds;
00527                                           !BCC_EOS
00528                                           ! 379   Bit16u reg_es;
00529                                           !BCC_EOS
00530                                           ! 380   Bit16u esp_hi;
00531                                           !BCC_EOS
00532                                           ! 381   Bit16u retaddr;
00533                                           !BCC_EOS
00534                                           ! 382 } upcall_t;
00535                                           !BCC_EOS
00536                                           ! 383   typedef struct {
00537                                           ! 384     unsigned char ebda_size;
00538                                           !BCC_EOS
00539                                           ! 385     unsigned char cmos_shutdown_status;
00540                                           !BCC_EOS
00541                                           ! 386     unsigned char filler1[0x3B];
00542                                           !BCC_EOS
00543                                           ! 387     unsigned char fdpt0[0x10];
00544                                           !BCC_EOS
00545                                           ! 388     unsigned char fdpt1[0x10];
00546                                           !BCC_EOS
00547                                           ! 389     unsigned char filler2[0xC4];
00548                                           !BCC_EOS
00549                                           ! 390     ata_t ata;
00550                                           !BCC_EOS
00551                                           ! 391     cdemu_t cdemu;
00552                                           !BCC_EOS
00553                                           ! 392     upcall_t upcall;
00554                                           !BCC_EOS
00555                                           ! 393     } ebda_data_t;
00556                                           !BCC_EOS
00557                                           ! 394   typedef struct {
00558                                           ! 395     Bit8u size;
00559                                           !BCC_EOS
00560                                           ! 396     Bit8u reserved;
00561                                           !BCC_EOS
00562                                           ! 397     Bit16u count;
00563                                           !BCC_EOS
00564                                           ! 398     Bit16u offset;
00565                                           !BCC_EOS
00566                                           ! 399     Bit16u segment;
00567                                           !BCC_EOS
00568                                           ! 400     Bit32u lba1;
00569                                           !BCC_EOS
00570                                           ! 401     Bit32u lba2;
00571                                           !BCC_EOS
00572                                           ! 402     } int13ext_t;
00573                                           !BCC_EOS
00574                                           ! 403   typedef struct {
00575                                           ! 404     Bit16u size;
00576                                           !BCC_EOS
00577                                           ! 405     Bit16u infos;
00578                                           !BCC_EOS
00579                                           ! 406     Bit32u cylinders;
00580                                           !BCC_EOS
00581                                           ! 407     Bit32u heads;
00582                                           !BCC_EOS
00583                                           ! 408     Bit32u spt;
00584                                           !BCC_EOS
00585                                           ! 409     Bit32u sector_count1;
00586                                           !BCC_EOS
00587                                           ! 410     Bit32u sector_count2;
00588                                           !BCC_EOS
00589                                           ! 411     Bit16u blksize;
00590                                           !BCC_EOS
00591                                           ! 412     Bit16u dpte_offset;
00592                                           !BCC_EOS
00593                                           ! 413     Bit16u dpte_segment;
00594                                           !BCC_EOS
00595                                           ! 414     Bit16u key;
00596                                           !BCC_EOS
00597                                           ! 415     Bit8u dpi_length;
00598                                           !BCC_EOS
00599                                           ! 416     Bit8u reserved1;
00600                                           !BCC_EOS
00601                                           ! 417     Bit16u reserved2;
00602                                           !BCC_EOS
00603                                           ! 418     Bit8u host_bus[4];
00604                                           !BCC_EOS
00605                                           ! 419     Bit8u iface_type[8];
00606                                           !BCC_EOS
00607                                           ! 420     Bit8u iface_path[8];
00608                                           !BCC_EOS
00609                                           ! 421     Bit8u device_path[8];
00610                                           !BCC_EOS
00611                                           ! 422     Bit8u reserved3;
00612                                           !BCC_EOS
00613                                           ! 423     Bit8u checksum;
00614                                           !BCC_EOS
00615                                           ! 424     } dpt_t;
00616                                           !BCC_EOS
00617                                           ! 425 typedef struct {
00618                                           ! 426   union {
00619                                           ! 427     struct {
00620                                           ! 428       Bit16u di, si, bp, sp;
00621                                           !BCC_EOS
00622                                           ! 429       Bit16u bx, dx, cx, ax;
00623                                           !BCC_EOS
00624                                           ! 430       } r16;
00625                                           !BCC_EOS
00626                                           ! 431     struct {
00627                                           ! 432       Bit16u filler[4];
00628                                           !BCC_EOS
00629                                           ! 433       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00630                                           !BCC_EOS
00631                                           ! 434       } r8;
00632                                           !BCC_EOS
00633                                           ! 435     } u;
00634                                           !BCC_EOS
00635                                           ! 436   } pusha_regs_t;
00636                                           !BCC_EOS
00637                                           ! 437 typedef struct {
00638                                           ! 438  union {
00639                                           ! 439   struct {
00640                                           ! 440     Bit32u edi, esi, ebp, esp;
00641                                           !BCC_EOS
00642                                           ! 441     Bit32u ebx, edx, ecx, eax;
00643                                           !BCC_EOS
00644                                           ! 442     } r32;
00645                                           !BCC_EOS
00646                                           ! 443   struct {
00647                                           ! 444     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00648                                           !BCC_EOS
00649                                           ! 445     Bit16u bx, filler5, dx
00650                                           ! 445 , filler6, cx, filler7, ax, filler8;
00651                                           !BCC_EOS
00652                                           ! 446     } r16;
00653                                           !BCC_EOS
00654                                           ! 447   struct {
00655                                           ! 448     Bit32u filler[4];
00656                                           !BCC_EOS
00657                                           ! 449     Bit8u bl, bh;
00658                                           !BCC_EOS
00659                                           ! 450     Bit16u filler1;
00660                                           !BCC_EOS
00661                                           ! 451     Bit8u dl, dh;
00662                                           !BCC_EOS
00663                                           ! 452     Bit16u filler2;
00664                                           !BCC_EOS
00665                                           ! 453     Bit8u cl, ch;
00666                                           !BCC_EOS
00667                                           ! 454     Bit16u filler3;
00668                                           !BCC_EOS
00669                                           ! 455     Bit8u al, ah;
00670                                           !BCC_EOS
00671                                           ! 456     Bit16u filler4;
00672                                           !BCC_EOS
00673                                           ! 457     } r8;
00674                                           !BCC_EOS
00675                                           ! 458   } u;
00676                                           !BCC_EOS
00677                                           ! 459 } pushad_regs_t;
00678                                           !BCC_EOS
00679                                           ! 460 typedef struct {
00680                                           ! 461   union {
00681                                           ! 462     struct {
00682                                           ! 463       Bit16u flags;
00683                                           !BCC_EOS
00684                                           ! 464       } r16;
00685                                           !BCC_EOS
00686                                           ! 465     struct {
00687                                           ! 466       Bit8u flagsl;
00688                                           !BCC_EOS
00689                                           ! 467       Bit8u flagsh;
00690                                           !BCC_EOS
00691                                           ! 468       } r8;
00692                                           !BCC_EOS
00693                                           ! 469     } u;
00694                                           !BCC_EOS
00695                                           ! 470   } flags_t;
00696                                           !BCC_EOS
00697                                           ! 471 typedef struct {
00698                                           ! 472   Bit16u ip;
00699                                           !BCC_EOS
00700                                           ! 473   Bit16u cs;
00701                                           !BCC_EOS
00702                                           ! 474   flags_t flags;
00703                                           !BCC_EOS
00704                                           ! 475   } iret_addr_t;
00705                                           !BCC_EOS
00706                                           ! 476 static Bit8u inb();
00707                                           !BCC_EOS
00708                                           ! 477 static Bit8u inb_cmos();
00709                                           !BCC_EOS
00710                                           ! 478 static void outb();
00711                                           !BCC_EOS
00712                                           ! 479 static void outb_cmos();
00713                                           !BCC_EOS
00714                                           ! 480 static Bit16u inw();
00715                                           !BCC_EOS
00716                                           ! 481 static void outw();
00717                                           !BCC_EOS
00718                                           ! 482 static void init_rtc();
00719                                           !BCC_EOS
00720                                           ! 483 static bx_bool rtc_updating();
00721                                           !BCC_EOS
00722                                           ! 484 static Bit8u read_byte();
00723                                           !BCC_EOS
00724                                           ! 485 static Bit16u read_word();
00725                                           !BCC_EOS
00726                                           ! 486 static void write_byte();
00727                                           !BCC_EOS
00728                                           ! 487 static void write_word();
00729                                           !BCC_EOS
00730                                           ! 488 static void bios_printf();
00731                                           !BCC_EOS
00732                                           ! 489 static void copy_e820_table();
00733                                           !BCC_EOS
00734                                           ! 490 static Bit8u inhibit_mouse_int_and_events();
00735                                           !BCC_EOS
00736                                           ! 491 static void enable_mouse_int_and_events();
00737                                           !BCC_EOS
00738                                           ! 492 static Bit8u send_to_mouse_ctrl();
00739                                           !BCC_EOS
00740                                           ! 493 static Bit8u get_mouse_data();
00741                                           !BCC_EOS
00742                                           ! 494 static void set_kbd_command_byte();
00743                                           !BCC_EOS
00744                                           ! 495 static void int09_function();
00745                                           !BCC_EOS
00746                                           ! 496 static void int13_harddisk();
00747                                           !BCC_EOS
00748                                           ! 497 static void int13_cdrom();
00749                                           !BCC_EOS
00750                                           ! 498 static void int13_cdemu();
00751                                           !BCC_EOS
00752                                           ! 499 static void int13_eltorito();
00753                                           !BCC_EOS
00754                                           ! 500 static void int13_diskette_function();
00755                                           !BCC_EOS
00756                                           ! 501 static void int14_function();
00757                                           !BCC_EOS
00758                                           ! 502 static void int15_function();
00759                                           !BCC_EOS
00760                                           ! 503 static void int16_function();
00761                                           !BCC_EOS
00762                                           ! 504 static void int17_function();
00763                                           !BCC_EOS
00764                                           ! 505 static void int18_function();
00765                                           !BCC_EOS
00766                                           ! 506 static void int1a_function();
00767                                           !BCC_EOS
00768                                           ! 507 static void int70_function();
00769                                           !BCC_EOS
00770                                           ! 508 static void int74_function();
00771                                           !BCC_EOS
00772                                           ! 509 static Bit16u get_CS();
00773                                           !BCC_EOS
00774                                           ! 510 static Bit16u get_SS();
00775                                           !BCC_EOS
00776                                           ! 511 static unsigned int enqueue_key();
00777                                           !BCC_EOS
00778                                           ! 512 static unsigned int dequeue_key();
00779                                           !BCC_EOS
00780                                           ! 513 static void get_hd_geometry();
00781                                           !BCC_EOS
00782                                           ! 514 static void set_diskette_ret_status();
00783                                           !BCC_EOS
00784                                           ! 515 static void set_diskette_current_cyl();
00785                                           !BCC_EOS
00786                                           ! 516 static void determine_floppy_media();
00787                                           !BCC_EOS
00788                                           ! 517 static bx_bool floppy_drive_exists();
00789                                           !BCC_EOS
00790                                           ! 518 static bx_bool floppy_drive_recal();
00791                                           !BCC_EOS
00792                                           ! 519 static bx_bool floppy_media_known();
00793                                           !BCC_EOS
00794                                           ! 520 static bx_bool floppy_media_sense();
00795                                           !BCC_EOS
00796                                           ! 521 static bx_bool set_enable_a20();
00797                                           !BCC_EOS
00798                                           ! 522 static void debugger_on();
00799                                           !BCC_EOS
00800                                           ! 523 static void debugger_off();
00801                                           !BCC_EOS
00802                                           ! 524 static void keyboard_init();
00803                                           !BCC_EOS
00804                                           ! 525 static void keyboard_panic();
00805                                           !BCC_EOS
00806                                           ! 526 static void shutdown
00807                                           ! 526 _status_panic();
00808                                           !BCC_EOS
00809                                           ! 527 static void nmi_handler_msg();
00810                                           !BCC_EOS
00811                                           ! 528 static void print_bios_banner();
00812                                           !BCC_EOS
00813                                           ! 529 static void print_boot_device();
00814                                           !BCC_EOS
00815                                           ! 530 static void print_boot_failure();
00816                                           !BCC_EOS
00817                                           ! 531 static void print_cdromboot_failure();
00818                                           !BCC_EOS
00819                                           ! 532 void ata_init();
00820                                           !BCC_EOS
00821                                           ! 533 void ata_detect();
00822                                           !BCC_EOS
00823                                           ! 534 void ata_reset();
00824                                           !BCC_EOS
00825                                           ! 535 Bit16u ata_cmd_non_data();
00826                                           !BCC_EOS
00827                                           ! 536 Bit16u ata_cmd_data_in();
00828                                           !BCC_EOS
00829                                           ! 537 Bit16u ata_cmd_data_out();
00830                                           !BCC_EOS
00831                                           ! 538 Bit16u ata_cmd_packet();
00832                                           !BCC_EOS
00833                                           ! 539 Bit16u atapi_get_sense();
00834                                           !BCC_EOS
00835                                           ! 540 Bit16u atapi_is_ready();
00836                                           !BCC_EOS
00837                                           ! 541 Bit16u atapi_is_cdrom();
00838                                           !BCC_EOS
00839                                           ! 542 void cdemu_init();
00840                                           !BCC_EOS
00841                                           ! 543 Bit8u cdemu_isactive();
00842                                           !BCC_EOS
00843                                           ! 544 Bit8u cdemu_emulated_drive();
00844                                           !BCC_EOS
00845                                           ! 545 Bit16u cdrom_boot();
00846                                           !BCC_EOS
00847                                           ! 546 static char bios_cvs_version_string[] = "$Revision: 1.138 $";
00848                                           
00849                       00000164            _bios_cvs_version_string:
00850                       00000164            .1:
00851 0164                        24            .ascii	"$Revision: 1.138 $"
00852 0176                        00            .byte	0
00853                                           !BCC_EOS
00854                                           ! 547 static char bios_date_string[] = "$Date: 2005/05/07 15:55:26 $";
00855                       00000177            _bios_date_string:
00856                       00000177            .2:
00857 0177                        24            .ascii	"$Date: 2005/05/07 15:55:26 $"
00858 0193                        00            .byte	0
00859                                           !BCC_EOS
00860                                           ! 548 static char CVSID[] = "$Id: rombios.c,v 1.138 2005/05/07 15:55:26 vruppert Exp $";
00861                       00000194            _CVSID:
00862                       00000194            .3:
00863 0194                        24            .ascii	"$Id: rombios.c,v 1.138 2005/05/07 15:55:"
00864 01BC                        32            .ascii	"26 vruppert Exp $"
00865 01CD                        00            .byte	0
00866                                           !BCC_EOS
00867                                           ! 549 static struct {
00868                                           ! 550   Bit16u normal;
00869                                           !BCC_EOS
00870                                           ! 551   Bit16u shift;
00871                                           !BCC_EOS
00872                                           ! 552   Bit16u control;
00873                                           !BCC_EOS
00874                                           ! 553   Bit16u alt;
00875                                           !BCC_EOS
00876                                           ! 554   Bit8u lock_flags;
00877                                           !BCC_EOS
00878                                           ! 555   } scan_to_scanascii[0x58 + 1] = {
00879                       000001CE            _scan_to_scanascii:
00880                                           ! 556       { 0, 0, 0, 0, 0 },
00881 01CE                      0000            .word	0
00882 01D0                      0000            .word	0
00883 01D2                      0000            .word	0
00884 01D4                      0000            .word	0
00885 01D6                        00            .byte	0
00886 01D7                  00000001            .blkb	1
00887                                           ! 557       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00888 01D8                      011B            .word	$11B
00889 01DA                      011B            .word	$11B
00890 01DC                      011B            .word	$11B
00891 01DE                      0100            .word	$100
00892 01E0                        00            .byte	0
00893 01E1                  00000001            .blkb	1
00894                                           ! 558       { 0x0231, 0x0221, 0, 0x7800, 0 },
00895 01E2                      0231            .word	$231
00896 01E4                      0221            .word	$221
00897 01E6                      0000            .word	0
00898 01E8                      7800            .word	$7800
00899 01EA                        00            .byte	0
00900 01EB                  00000001            .blkb	1
00901                                           ! 559       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00902 01EC                      0332            .word	$332
00903 01EE                      0340            .word	$340
00904 01F0                      0300            .word	$300
00905 01F2                      7900            .word	$7900
00906 01F4                        00            .byte	0
00907 01F5                  00000001            .blkb	1
00908                                           ! 560       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00909 01F6                      0433            .word	$433
00910 01F8                      0423            .word	$423
00911 01FA                      0000            .word	0
00912 01FC                      7A00            .word	$7A00
00913 01FE                        00            .byte	0
00914 01FF                  00000001            .blkb	1
00915                                           ! 561       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00916 0200                      0534            .word	$534
00917 0202                      0524            .word	$524
00918 0204                      0000            .word	0
00919 0206                      7B00            .word	$7B00
00920 0208                        00            .byte	0
00921 0209                  00000001            .blkb	1
00922                                           ! 562       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00923 020A                      0635            .word	$635
00924 020C                      0625            .word	$625
00925 020E                      0000            .word	0
00926 0210                      7C00            .word	$7C00
00927 0212                        00            .byte	0
00928 0213                  00000001            .blkb	1
00929                                           ! 563       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00930 0214                      0736            .word	$736
00931 0216                      075E            .word	$75E
00932 0218                      071E            .word	$71E
00933 021A                      7D00            .word	$7D00
00934 021C                        00            .byte	0
00935 021D                  00000001            .blkb	1
00936                                           ! 564       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00937 021E                      0837            .word	$837
00938 0220                      0826            .word	$826
00939 0222                      0000            .word	0
00940 0224                      7E00            .word	$7E00
00941 0226                        00            .byte	0
00942 0227                  00000001            .blkb	1
00943                                           ! 565       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00944 0228                      0938            .word	$938
00945 022A                      092A            .word	$92A
00946 022C                      0000            .word	0
00947 022E                      7F00            .word	$7F00
00948 0230                        00            .byte	0
00949 0231                  00000001            .blkb	1
00950                                           ! 566       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
00951 0232                      0A39            .word	$A39
00952 0234                      0A28            .word	$A28
00953 0236                      0000            .word	0
00954 0238                      8000            .word	$8000
00955 023A                        00            .byte	0
00956 023B                  00000001            .blkb	1
00957                                           ! 567       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
00958 023C                      0B30            .word	$B30
00959 023E                      0B29            .word	$B29
00960 0240                      0000            .word	0
00961 0242                      8100            .word	$8100
00962 0244                        00            .byte	0
00963 0245                  00000001            .blkb	1
00964                                           ! 568       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
00965 0246                      0C2D            .word	$C2D
00966 0248                      0C5F            .word	$C5F
00967 024A                      0C1F            .word	$C1F
00968 024C                      8200            .word	$8200
00969 024E                        00            .byte	0
00970 024F                  00000001            .blkb	1
00971                                           ! 569       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
00972 0250                      0D3D            .word	$D3D
00973 0252                      0D2B            .word	$D2B
00974 0254                      0000            .word	0
00975 0256                      8300            .word	$8300
00976 0258                        00            .byte	0
00977 0259                  00000001            .blkb	1
00978                                           ! 570       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
00979 025A                      0E08            .word	$E08
00980 025C                      0E08            .word	$E08
00981 025E                      0E7F            .word	$E7F
00982 0260                      0000            .word	0
00983 0262                        00            .byte	0
00984 0263                  00000001            .blkb	1
00985                                           ! 571       { 0x0f09, 0x0f00, 0, 0, 0 },
00986 0264                      0F09            .word	$F09
00987 0266                      0F00            .word	$F00
00988 0268                      0000            .word	0
00989 026A                      0000            .word	0
00990 026C                        00            .byte	0
00991 026D                  00000001            .blkb	1
00992                                           ! 572       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
00993 026E                      1071            .word	$1071
00994 0270                      1051            .word	$1051
00995 0272                      1011            .word	$1011
00996 0274                      1000            .word	$1000
00997 0276                        40            .byte	$40
00998 0277                  00000001            .blkb	1
00999                                           ! 573       { 0x1177, 0x1157, 0x1117, 0x1100, 0x40 },
01000 0278                      1177            .word	$1177
01001 027A                      1157            .word	$1157
01002 027C                      1117            .word	$1117
01003 027E                      1100            .word	$1100
01004 0280                        40            .byte	$40
01005 0281                  00000001            .blkb	1
01006                                           ! 574       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01007 0282                      1265            .word	$1265
01008 0284                      1245            .word	$1245
01009 0286                      1205            .word	$1205
01010 0288                      1200            .word	$1200
01011 028A                        40            .byte	$40
01012 028B                  00000001            .blkb	1
01013                                           ! 575       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
01014 028C                      1372            .word	$1372
01015 028E                      1352            .word	$1352
01016 0290                      1312            .word	$1312
01017 0292                      1300            .word	$1300
01018 0294                        40            .byte	$40
01019 0295                  00000001            .blkb	1
01020                                           ! 576       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
01021 0296                      1474            .word	$1474
01022 0298                      1454            .word	$1454
01023 029A                      1414            .word	$1414
01024 029C                      1400            .word	$1400
01025 029E                        40            .byte	$40
01026 029F                  00000001            .blkb	1
01027                                           ! 577       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01028 02A0                      1579            .word	$1579
01029 02A2                      1559            .word	$1559
01030 02A4                      1519            .word	$1519
01031 02A6                      1500            .word	$1500
01032 02A8                        40            .byte	$40
01033 02A9                  00000001            .blkb	1
01034                                           ! 578       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01035 02AA                      1675            .word	$1675
01036 02AC                      1655            .word	$1655
01037 02AE                      1615            .word	$1615
01038 02B0                      1600            .word	$1600
01039 02B2                        40            .byte	$40
01040 02B3                  00000001            .blkb	1
01041                                           ! 579       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01042 02B4                      1769            .word	$1769
01043 02B6                      1749            .word	$1749
01044 02B8                      1709            .word	$1709
01045 02BA                      1700            .word	$1700
01046 02BC                        40            .byte	$40
01047 02BD                  00000001            .blkb	1
01048                                           ! 580       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01049 02BE                      186F            .word	$186F
01050 02C0                      184F            .word	$184F
01051 02C2                      180F            .word	$180F
01052 02C4                      1800            .word	$1800
01053 02C6                        40            .byte	$40
01054 02C7                  00000001            .blkb	1
01055                                           ! 581       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01056 02C8                      1970            .word	$1970
01057 02CA                      1950            .word	$1950
01058 02CC                      1910            .word	$1910
01059 02CE                      1900            .word	$1900
01060 02D0                        40            .byte	$40
01061 02D1                  00000001            .blkb	1
01062                                           ! 582       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01063 02D2                      1A5B            .word	$1A5B
01064 02D4                      1A7B            .word	$1A7B
01065 02D6                      1A1B            .word	$1A1B
01066 02D8                      0000            .word	0
01067 02DA                        00            .byte	0
01068 02DB                  00000001            .blkb	1
01069                                           ! 583       { 0x1b5d, 0x1b7d, 0
01070 02DC                      1B5D            .word	$1B5D
01071 02DE                      1B7D            .word	$1B7D
01072                                           ! 583 x1b1d, 0, 0 },
01073 02E0                      1B1D            .word	$1B1D
01074 02E2                      0000            .word	0
01075 02E4                        00            .byte	0
01076 02E5                  00000001            .blkb	1
01077                                           ! 584       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01078 02E6                      1C0D            .word	$1C0D
01079 02E8                      1C0D            .word	$1C0D
01080 02EA                      1C0A            .word	$1C0A
01081 02EC                      0000            .word	0
01082 02EE                        00            .byte	0
01083 02EF                  00000001            .blkb	1
01084                                           ! 585       { 0, 0, 0, 0, 0 },
01085 02F0                      0000            .word	0
01086 02F2                      0000            .word	0
01087 02F4                      0000            .word	0
01088 02F6                      0000            .word	0
01089 02F8                        00            .byte	0
01090 02F9                  00000001            .blkb	1
01091                                           ! 586       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
01092 02FA                      1E61            .word	$1E61
01093 02FC                      1E41            .word	$1E41
01094 02FE                      1E01            .word	$1E01
01095 0300                      1E00            .word	$1E00
01096 0302                        40            .byte	$40
01097 0303                  00000001            .blkb	1
01098                                           ! 587       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01099 0304                      1F73            .word	$1F73
01100 0306                      1F53            .word	$1F53
01101 0308                      1F13            .word	$1F13
01102 030A                      1F00            .word	$1F00
01103 030C                        40            .byte	$40
01104 030D                  00000001            .blkb	1
01105                                           ! 588       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01106 030E                      2064            .word	$2064
01107 0310                      2044            .word	$2044
01108 0312                      2004            .word	$2004
01109 0314                      2000            .word	$2000
01110 0316                        40            .byte	$40
01111 0317                  00000001            .blkb	1
01112                                           ! 589       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01113 0318                      2166            .word	$2166
01114 031A                      2146            .word	$2146
01115 031C                      2106            .word	$2106
01116 031E                      2100            .word	$2100
01117 0320                        40            .byte	$40
01118 0321                  00000001            .blkb	1
01119                                           ! 590       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01120 0322                      2267            .word	$2267
01121 0324                      2247            .word	$2247
01122 0326                      2207            .word	$2207
01123 0328                      2200            .word	$2200
01124 032A                        40            .byte	$40
01125 032B                  00000001            .blkb	1
01126                                           ! 591       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01127 032C                      2368            .word	$2368
01128 032E                      2348            .word	$2348
01129 0330                      2308            .word	$2308
01130 0332                      2300            .word	$2300
01131 0334                        40            .byte	$40
01132 0335                  00000001            .blkb	1
01133                                           ! 592       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01134 0336                      246A            .word	$246A
01135 0338                      244A            .word	$244A
01136 033A                      240A            .word	$240A
01137 033C                      2400            .word	$2400
01138 033E                        40            .byte	$40
01139 033F                  00000001            .blkb	1
01140                                           ! 593       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01141 0340                      256B            .word	$256B
01142 0342                      254B            .word	$254B
01143 0344                      250B            .word	$250B
01144 0346                      2500            .word	$2500
01145 0348                        40            .byte	$40
01146 0349                  00000001            .blkb	1
01147                                           ! 594       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01148 034A                      266C            .word	$266C
01149 034C                      264C            .word	$264C
01150 034E                      260C            .word	$260C
01151 0350                      2600            .word	$2600
01152 0352                        40            .byte	$40
01153 0353                  00000001            .blkb	1
01154                                           ! 595       { 0x273b, 0x273a, 0, 0, 0 },
01155 0354                      273B            .word	$273B
01156 0356                      273A            .word	$273A
01157 0358                      0000            .word	0
01158 035A                      0000            .word	0
01159 035C                        00            .byte	0
01160 035D                  00000001            .blkb	1
01161                                           ! 596       { 0x2827, 0x2822, 0, 0, 0 },
01162 035E                      2827            .word	$2827
01163 0360                      2822            .word	$2822
01164 0362                      0000            .word	0
01165 0364                      0000            .word	0
01166 0366                        00            .byte	0
01167 0367                  00000001            .blkb	1
01168                                           ! 597       { 0x2960, 0x297e, 0, 0, 0 },
01169 0368                      2960            .word	$2960
01170 036A                      297E            .word	$297E
01171 036C                      0000            .word	0
01172 036E                      0000            .word	0
01173 0370                        00            .byte	0
01174 0371                  00000001            .blkb	1
01175                                           ! 598       { 0, 0, 0, 0, 0 },
01176 0372                      0000            .word	0
01177 0374                      0000            .word	0
01178 0376                      0000            .word	0
01179 0378                      0000            .word	0
01180 037A                        00            .byte	0
01181 037B                  00000001            .blkb	1
01182                                           ! 599       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01183 037C                      2B5C            .word	$2B5C
01184 037E                      2B7C            .word	$2B7C
01185 0380                      2B1C            .word	$2B1C
01186 0382                      0000            .word	0
01187 0384                        00            .byte	0
01188 0385                  00000001            .blkb	1
01189                                           ! 600       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01190 0386                      2C7A            .word	$2C7A
01191 0388                      2C5A            .word	$2C5A
01192 038A                      2C1A            .word	$2C1A
01193 038C                      2C00            .word	$2C00
01194 038E                        40            .byte	$40
01195 038F                  00000001            .blkb	1
01196                                           ! 601       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01197 0390                      2D78            .word	$2D78
01198 0392                      2D58            .word	$2D58
01199 0394                      2D18            .word	$2D18
01200 0396                      2D00            .word	$2D00
01201 0398                        40            .byte	$40
01202 0399                  00000001            .blkb	1
01203                                           ! 602       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01204 039A                      2E63            .word	$2E63
01205 039C                      2E43            .word	$2E43
01206 039E                      2E03            .word	$2E03
01207 03A0                      2E00            .word	$2E00
01208 03A2                        40            .byte	$40
01209 03A3                  00000001            .blkb	1
01210                                           ! 603       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01211 03A4                      2F76            .word	$2F76
01212 03A6                      2F56            .word	$2F56
01213 03A8                      2F16            .word	$2F16
01214 03AA                      2F00            .word	$2F00
01215 03AC                        40            .byte	$40
01216 03AD                  00000001            .blkb	1
01217                                           ! 604       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01218 03AE                      3062            .word	$3062
01219 03B0                      3042            .word	$3042
01220 03B2                      3002            .word	$3002
01221 03B4                      3000            .word	$3000
01222 03B6                        40            .byte	$40
01223 03B7                  00000001            .blkb	1
01224                                           ! 605       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01225 03B8                      316E            .word	$316E
01226 03BA                      314E            .word	$314E
01227 03BC                      310E            .word	$310E
01228 03BE                      3100            .word	$3100
01229 03C0                        40            .byte	$40
01230 03C1                  00000001            .blkb	1
01231                                           ! 606       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01232 03C2                      326D            .word	$326D
01233 03C4                      324D            .word	$324D
01234 03C6                      320D            .word	$320D
01235 03C8                      3200            .word	$3200
01236 03CA                        40            .byte	$40
01237 03CB                  00000001            .blkb	1
01238                                           ! 607       { 0x332c, 0x333c, 0, 0, 0 },
01239 03CC                      332C            .word	$332C
01240 03CE                      333C            .word	$333C
01241 03D0                      0000            .word	0
01242 03D2                      0000            .word	0
01243 03D4                        00            .byte	0
01244 03D5                  00000001            .blkb	1
01245                                           ! 608       { 0x342e, 0x343e, 0, 0, 0 },
01246 03D6                      342E            .word	$342E
01247 03D8                      343E            .word	$343E
01248 03DA                      0000            .word	0
01249 03DC                      0000            .word	0
01250 03DE                        00            .byte	0
01251 03DF                  00000001            .blkb	1
01252                                           ! 609       { 0x352f, 0x353f, 0, 0, 0 },
01253 03E0                      352F            .word	$352F
01254 03E2                      353F            .word	$353F
01255 03E4                      0000            .word	0
01256 03E6                      0000            .word	0
01257 03E8                        00            .byte	0
01258 03E9                  00000001            .blkb	1
01259                                           ! 610       { 0, 0, 0, 0, 0 },
01260 03EA                      0000            .word	0
01261 03EC                      0000            .word	0
01262 03EE                      0000            .word	0
01263 03F0                      0000            .word	0
01264 03F2                        00            .byte	0
01265 03F3                  00000001            .blkb	1
01266                                           ! 611       { 0x372a, 0x372a, 0, 0, 0 },
01267 03F4                      372A            .word	$372A
01268 03F6                      372A            .word	$372A
01269 03F8                      0000            .word	0
01270 03FA                      0000            .word	0
01271 03FC                        00            .byte	0
01272 03FD                  00000001            .blkb	1
01273                                           ! 612       { 0, 0, 0, 0, 0 },
01274 03FE                      0000            .word	0
01275 0400                      0000            .word	0
01276 0402                      0000            .word	0
01277 0404                      0000            .word	0
01278 0406                        00            .byte	0
01279 0407                  00000001            .blkb	1
01280                                           ! 613       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01281 0408                      3920            .word	$3920
01282 040A                      3920            .word	$3920
01283 040C                      3920            .word	$3920
01284 040E                      3920            .word	$3920
01285 0410                        00            .byte	0
01286 0411                  00000001            .blkb	1
01287                                           ! 614       { 0, 0, 0, 0, 0 },
01288 0412                      0000            .word	0
01289 0414                      0000            .word	0
01290 0416                      0000            .word	0
01291 0418                      0000            .word	0
01292 041A                        00            .byte	0
01293 041B                  00000001            .blkb	1
01294                                           ! 615       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
01295 041C                      3B00            .word	$3B00
01296 041E                      5400            .word	$5400
01297 0420                      5E00            .word	$5E00
01298 0422                      6800            .word	$6800
01299 0424                        00            .byte	0
01300 0425                  00000001            .blkb	1
01301                                           ! 616       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01302 0426                      3C00            .word	$3C00
01303 0428                      5500            .word	$5500
01304 042A                      5F00            .word	$5F00
01305 042C                      6900            .word	$6900
01306 042E                        00            .byte	0
01307 042F                  00000001            .blkb	1
01308                                           ! 617       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01309 0430                      3D00            .word	$3D00
01310 0432                      5600            .word	$5600
01311 0434                      6000            .word	$6000
01312 0436                      6A00            .word	$6A00
01313 0438                        00            .byte	0
01314 0439                  00000001            .blkb	1
01315                                           ! 618       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01316 043A                      3E00            .word	$3E00
01317 043C                      5700            .word	$5700
01318 043E                      6100            .word	$6100
01319 0440                      6B00            .word	$6B00
01320 0442                        00            .byte	0
01321 0443                  00000001            .blkb	1
01322                                           ! 619       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01323 0444                      3F00            .word	$3F00
01324 0446                      5800            .word	$5800
01325 0448                      6200            .word	$6200
01326 044A                      6C00            .word	$6C00
01327 044C                        00            .byte	0
01328 044D                  00000001            .blkb	1
01329                                           ! 620       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01330 044E                      4000            .word	$4000
01331 0450                      5900            .word	$5900
01332 0452                      6300            .word	$6300
01333 0454                      6D00            .word	$6D00
01334 0456                        00            .byte	0
01335 0457                  00000001            .blkb	1
01336                                           ! 621       { 0x4100, 0x5a00, 0x6400, 0x6e00, 0 },
01337 0458                      4100            .word	$4100
01338 045A                      5A00            .word	$5A00
01339 045C                      6400            .word	$6400
01340 045E                      6E00            .word	$6E00
01341 0460                        00            .byte	0
01342 0461                  00000001            .blkb	1
01343                                           ! 622       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01344 0462                      4200            .word	$4200
01345 0464                      5B00            .word	$5B00
01346 0466                      6500            .word	$6500
01347 0468                      6F00            .word	$6F00
01348 046A                        00            .byte	0
01349 046B                  00000001            .blkb	1
01350                                           ! 623       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
01351 046C                      4300            .word	$4300
01352 046E                      5C00            .word	$5C00
01353 0470                      6600            .word	$6600
01354 0472                      7000            .word	$7000
01355 0474                        00            .byte	0
01356 0475                  00000001            .blkb	1
01357                                           ! 624       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
01358 0476                      4400            .word	$4400
01359 0478                      5D00            .word	$5D00
01360 047A                      6700            .word	$6700
01361 047C                      7100            .word	$7100
01362 047E                        00            .byte	0
01363 047F                  00000001            .blkb	1
01364                                           ! 625       { 0, 0, 0, 0, 0 },
01365 0480                      0000            .word	0
01366 0482                      0000            .word	0
01367 0484                      0000            .word	0
01368 0486                      0000            .word	0
01369 0488                        00            .byte	0
01370 0489                  00000001            .blkb	1
01371                                           ! 626       { 0, 0, 0, 0, 0 },
01372 048A                      0000            .word	0
01373 048C                      0000            .word	0
01374 048E                      0000            .word	0
01375 0490                      0000            .word	0
01376 0492                        00            .byte	0
01377 0493                  00000001            .blkb	1
01378                                           ! 627       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01379 0494                      4700            .word	$4700
01380 0496                      4737            .word	$4737
01381 0498                      7700            .word	$7700
01382 049A                      0000            .word	0
01383 049C                        20            .byte	$20
01384 049D                  00000001            .blkb	1
01385                                           ! 628       { 0x4800, 0x4838, 0, 0, 0x20 },
01386 049E                      4800            .word	$4800
01387 04A0                      4838            .word	$4838
01388 04A2                      0000            .word	0
01389 04A4                      0000            .word	0
01390 04A6                        20            .byte	$20
01391 04A7                  00000001            .blkb	1
01392                                           ! 629       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01393 04A8                      4900            .word	$4900
01394 04AA                      4939            .word	$4939
01395 04AC                      8400            .word	$8400
01396 04AE                      0000            .word	0
01397 04B0                        20            .byte	$20
01398 04B1                  00000001            .blkb	1
01399                                           ! 630       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01400 04B2                      4A2D            .word	$4A2D
01401 04B4                      4A2D            .word	$4A2D
01402 04B6                      0000            .word	0
01403 04B8                      0000            .word	0
01404 04BA                        00            .byte	0
01405 04BB                  00000001            .blkb	1
01406                                           ! 631       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01407 04BC                      4B00            .word	$4B00
01408 04BE                      4B34            .word	$4B34
01409 04C0                      7300            .word	$7300
01410 04C2                      0000            .word	0
01411 04C4                        20            .byte	$20
01412 04C5                  00000001            .blkb	1
01413                                           ! 632       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01414 04C6                      4C00            .word	$4C00
01415 04C8                      4C35            .word	$4C35
01416 04CA                      0000            .word	0
01417 04CC                      0000            .word	0
01418 04CE                        20            .byte	$20
01419 04CF                  00000001            .blkb	1
01420                                           ! 633       { 0x4d00, 0x4d36, 0x7400
01421 04D0                      4D00            .word	$4D00
01422 04D2                      4D36            .word	$4D36
01423                                           ! 633 , 0, 0x20 },
01424 04D4                      7400            .word	$7400
01425 04D6                      0000            .word	0
01426 04D8                        20            .byte	$20
01427 04D9                  00000001            .blkb	1
01428                                           ! 634       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01429 04DA                      4E2B            .word	$4E2B
01430 04DC                      4E2B            .word	$4E2B
01431 04DE                      0000            .word	0
01432 04E0                      0000            .word	0
01433 04E2                        00            .byte	0
01434 04E3                  00000001            .blkb	1
01435                                           ! 635       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01436 04E4                      4F00            .word	$4F00
01437 04E6                      4F31            .word	$4F31
01438 04E8                      7500            .word	$7500
01439 04EA                      0000            .word	0
01440 04EC                        20            .byte	$20
01441 04ED                  00000001            .blkb	1
01442                                           ! 636       { 0x5000, 0x5032, 0, 0, 0x20 },
01443 04EE                      5000            .word	$5000
01444 04F0                      5032            .word	$5032
01445 04F2                      0000            .word	0
01446 04F4                      0000            .word	0
01447 04F6                        20            .byte	$20
01448 04F7                  00000001            .blkb	1
01449                                           ! 637       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01450 04F8                      5100            .word	$5100
01451 04FA                      5133            .word	$5133
01452 04FC                      7600            .word	$7600
01453 04FE                      0000            .word	0
01454 0500                        20            .byte	$20
01455 0501                  00000001            .blkb	1
01456                                           ! 638       { 0x5200, 0x5230, 0, 0, 0x20 },
01457 0502                      5200            .word	$5200
01458 0504                      5230            .word	$5230
01459 0506                      0000            .word	0
01460 0508                      0000            .word	0
01461 050A                        20            .byte	$20
01462 050B                  00000001            .blkb	1
01463                                           ! 639       { 0x5300, 0x532e, 0, 0, 0x20 },
01464 050C                      5300            .word	$5300
01465 050E                      532E            .word	$532E
01466 0510                      0000            .word	0
01467 0512                      0000            .word	0
01468 0514                        20            .byte	$20
01469 0515                  00000001            .blkb	1
01470                                           ! 640       { 0, 0, 0, 0, 0 },
01471 0516                      0000            .word	0
01472 0518                      0000            .word	0
01473 051A                      0000            .word	0
01474 051C                      0000            .word	0
01475 051E                        00            .byte	0
01476 051F                  00000001            .blkb	1
01477                                           ! 641       { 0, 0, 0, 0, 0 },
01478 0520                      0000            .word	0
01479 0522                      0000            .word	0
01480 0524                      0000            .word	0
01481 0526                      0000            .word	0
01482 0528                        00            .byte	0
01483 0529                  00000001            .blkb	1
01484                                           ! 642       { 0, 0, 0, 0, 0 },
01485 052A                      0000            .word	0
01486 052C                      0000            .word	0
01487 052E                      0000            .word	0
01488 0530                      0000            .word	0
01489 0532                        00            .byte	0
01490 0533                  00000001            .blkb	1
01491                                           ! 643       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01492 0534                      8500            .word	$8500
01493 0536                      8700            .word	$8700
01494 0538                      8900            .word	$8900
01495 053A                      8B00            .word	$8B00
01496 053C                        00            .byte	0
01497 053D                  00000001            .blkb	1
01498                                           ! 644       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01499 053E                      8600            .word	$8600
01500 0540                      8800            .word	$8800
01501 0542                      8A00            .word	$8A00
01502 0544                      8C00            .word	$8C00
01503 0546                        00            .byte	0
01504 0547                  00000001            .blkb	1
01505                                           ! 645       };
01506                                           !BCC_EOS
01507                                           ! 646   Bit8u
01508                                           ! 647 inb(port)
01509                                           ! 648   Bit16u port;
01510                                           
01511                                           export	_inb
01512                       00000548            _inb:
01513                                           !BCC_EOS
01514                                           ! 649 {
01515                                           ! 650 #asm
01516                                           !BCC_ASM
01517                       00000002            _inb.port	set	2
01518 0548           55                           push bp
01519 0549           89E5                         mov bp, sp
01520 054B           52                             push dx
01521 054C           8B56         04                mov dx, 4[bp]
01522 054F           EC                             in al, dx
01523 0550           5A                             pop dx
01524 0551           5D                           pop bp
01525                                           ! 658 endasm
01526                                           !BCC_ENDASM
01527                                           ! 659 }
01528 0552           C3                         ret
01529                                           ! 660   Bit16u
01530                                           ! 661 inw(port)
01531                                           ! 662   Bit16u port;
01532                                           export	_inw
01533                       00000553            _inw:
01534                                           !BCC_EOS
01535                                           ! 663 {
01536                                           ! 664 #asm
01537                                           !BCC_ASM
01538                       00000002            _inw.port	set	2
01539 0553           55                           push bp
01540 0554           89E5                         mov bp, sp
01541 0556           52                             push dx
01542 0557           8B56         04                mov dx, 4[bp]
01543 055A           ED                             in ax, dx
01544 055B           5A                             pop dx
01545 055C           5D                           pop bp
01546                                           ! 672 endasm
01547                                           !BCC_ENDASM
01548                                           ! 673 }
01549 055D           C3                         ret
01550                                           ! 674   void
01551                                           ! 675 outb(port, val)
01552                                           ! 676   Bit16u port;
01553                                           export	_outb
01554                       0000055E            _outb:
01555                                           !BCC_EOS
01556                                           ! 677   Bit8u val;
01557                                           !BCC_EOS
01558                                           ! 678 {
01559                                           ! 679 #asm
01560                                           !BCC_ASM
01561                       00000004            _outb.val	set	4
01562                       00000002            _outb.port	set	2
01563 055E           55                           push bp
01564 055F           89E5                         mov bp, sp
01565 0561           50                             push ax
01566 0562           52                             push dx
01567 0563           8B56         04                mov dx, 4[bp]
01568 0566           8A46         06                mov al, 6[bp]
01569 0569           EE                             out dx, al
01570 056A           5A                             pop dx
01571 056B           58                             pop ax
01572 056C           5D                           pop bp
01573                                           ! 690 endasm
01574                                           !BCC_ENDASM
01575                                           ! 691 }
01576 056D           C3                         ret
01577                                           ! 692   void
01578                                           ! 693 outw(port, val)
01579                                           ! 694   Bit16u port;
01580                                           export	_outw
01581                       0000056E            _outw:
01582                                           !BCC_EOS
01583                                           ! 695   Bit16u val;
01584                                           !BCC_EOS
01585                                           ! 696 {
01586                                           ! 697 #asm
01587                                           !BCC_ASM
01588                       00000004            _outw.val	set	4
01589                       00000002            _outw.port	set	2
01590 056E           55                           push bp
01591 056F           89E5                         mov bp, sp
01592 0571           50                             push ax
01593 0572           52                             push dx
01594 0573           8B56         04                mov dx, 4[bp]
01595 0576           8B46         06                mov ax, 6[bp]
01596 0579           EF                             out dx, ax
01597 057A           5A                             pop dx
01598 057B           58                             pop ax
01599 057C           5D                           pop bp
01600                                           ! 708 endasm
01601                                           !BCC_ENDASM
01602                                           ! 709 }
01603 057D           C3                         ret
01604                                           ! 710   void
01605                                           ! 711 outb_cmos(cmos_reg, val)
01606                                           ! 712   Bit8u cmos_reg;
01607                                           export	_outb_cmos
01608                       0000057E            _outb_cmos:
01609                                           !BCC_EOS
01610                                           ! 713   Bit8u val;
01611                                           !BCC_EOS
01612                                           ! 714 {
01613                                           ! 715 #asm
01614                                           !BCC_ASM
01615                       00000002            _outb_cmos.cmos_reg	set	2
01616                       00000004            _outb_cmos.val	set	4
01617 057E           55                           push bp
01618 057F           89E5                         mov bp, sp
01619 0581           8A46         04                mov al, 4[bp] ;; cmos_reg
01620 0584           E6                     70      out 0x70, al
01621 0586           8A46         06                mov al, 6[bp] ;; val
01622 0589           E6                     71      out 0x71, al
01623 058B           5D                           pop bp
01624                                           ! 723 endasm
01625                                           !BCC_ENDASM
01626                                           ! 724 }
01627 058C           C3                         ret
01628                                           ! 725   Bit8u
01629                                           ! 726 inb_cmos(cmos_reg)
01630                                           ! 727   Bit8u cmos_reg;
01631                                           export	_inb_cmos
01632                       0000058D            _inb_cmos:
01633                                           !BCC_EOS
01634                                           ! 728 {
01635                                           ! 729 #asm
01636                                           !BCC_ASM
01637                       00000002            _inb_cmos.cmos_reg	set	2
01638 058D           55                           push bp
01639 058E           89E5                         mov bp, sp
01640 0590           8A46         04                mov al, 4[bp] ;; cmos_reg
01641 0593           E6                     70      out 0x70, al
01642 0595           E4                     71      in al, 0x71
01643 0597           5D                           pop bp
01644                                           ! 736 endasm
01645                                           !BCC_ENDASM
01646                                           ! 737 }
01647 0598           C3                         ret
01648                                           ! 738   void
01649                                           ! 739 init_rtc()
01650                                           ! 740 {
01651                                           export	_init_rtc
01652                       00000599            _init_rtc:
01653                                           ! 741   outb_cmos(0x0a, 0x26);
01654 0599           55                         push	bp
01655 059A           89E5                       mov	bp,sp
01656                                           ! Debug: list int = const $26 (used reg = )
01657 059C           B8                   0026  mov	ax,*$26
01658 059F           50                         push	ax
01659                                           ! Debug: list int = const $A (used reg = )
01660 05A0           B8                   000A  mov	ax,*$A
01661 05A3           50                         push	ax
01662                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01663 05A4           E8         FFD7            call	_outb_cmos
01664 05A7           89EC                       mov	sp,bp
01665                                           !BCC_EOS
01666                                           ! 742   outb_cmos(0x0b, 0x02);
01667                                           ! Debug: list int = const 2 (used reg = )
01668 05A9           B8                   0002  mov	ax,*2
01669 05AC           50                         push	ax
01670                                           ! Debug: list int = const $B (used reg = )
01671 05AD           B8                   000B  mov	ax,*$B
01672 05B0           50                         push	ax
01673                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01674 05B1           E8         FFCA            call	_outb_cmos
01675 05B4           89EC                       mov	sp,bp
01676                                           !BCC_EOS
01677                                           ! 743   inb_cmos(0x0c);
01678                                           ! Debug: list int = const $C (used reg = )
01679 05B6           B8                   000C  mov	ax,*$C
01680 05B9           50                         push	ax
01681                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01682 05BA           E8         FFD0            call	_inb_cmos
01683 05BD           89EC                       mov	sp,bp
01684                                           !BCC_EOS
01685                                           ! 744   inb_cmos(0x0d);
01686                                           ! Debug: list int = const $D (used reg = )
01687 05BF           B8                   000D  mov	ax,*$D
01688 05C2           50                         push	ax
01689                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01690 05C3           E8         FFC7            call	_inb_cmos
01691 05C6           89EC                       mov	sp,bp
01692                                           !BCC_EOS
01693                                           ! 745 }
01694 05C8           5D                         pop	bp
01695 05C9           C3                         ret
01696                                           ! 746   bx_bool
01697                                           ! 747 rtc_updating()
01698                                           ! 748 {
01699                                           export	_rtc_updating
01700                       000005CA            _rtc_updating:
01701                                           ! 749   Bit16u count;
01702                                           !BCC_EOS
01703                                           ! 750   count = 25000;
01704 05CA           55                         push	bp
01705 05CB           89E5                       mov	bp,sp
01706 05CD           4C                         dec	sp
01707 05CE           4C                         dec	sp
01708                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01709 05CF           B8                   61A8  mov	ax,#$61A8
01710 05D2           8946         FE            mov	-2[bp],ax
01711                                           !BCC_EOS
01712                                           ! 751   while (--count != 0) {
01713 05D5           EB           15            jmp .5
01714                       000005D7            .6:
01715                                           ! 752     if ( (inb_cmos(0x0a) & 0x80) == 0 )
01716                                           ! Debug: list int = const $A (used reg = )
01717 05D7           B8                   000A  mov	ax,*$A
01718 05DA           50                         push	ax
01719                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01720 05DB           E8         FFAF            call	_inb_cmos
01721 05DE           44                         inc	sp
01722 05DF           44                         inc	sp
01723                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01724 05E0           24                     80  and	al,#$80
01725                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01726 05E2           84C0                       test	al,al
01727 05E4           75           06            jne 	.7
01728                       000005E6            .8:
01729                                           ! 753       return(0);
01730 05E6           31C0                       xor	ax,ax
01731 05E8           89EC                       mov	sp,bp
01732 05EA           5D                         pop	bp
01733 05EB           C3                         ret
01734                                           !BCC_EOS
01735                                           ! 754     }
01736                       000005EC            .7:
01737                                           ! 755   return(1);
01738                       000005EC            .5:
01739                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01740 05EC           8B46         FE            mov	ax,-2[bp]
01741 05EF           48                         dec	ax
01742 05F0           8946         FE            mov	-2[bp],ax
01743                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01744 05F3           85C0                       test	ax,ax
01745 05F5           75           E0            jne	.6
01746                       000005F7            .9:
01747                       000005F7            .4:
01748 05F7           B8                   0001  mov	ax,*1
01749 05FA           89EC                       mov	sp,bp
01750 05FC           5D                         pop	bp
01751 05FD           C3                         ret
01752                                           !BCC_EOS
01753                                           ! 756 }
01754                                           ! 757   Bit8u
01755                                           ! 758 read_byte(seg, offset)
01756                                           ! 759   Bit16u seg;
01757                                           export	_read_byte
01758                       000005FE            _read_byte:
01759                                           !BCC_EOS
01760                                           ! 760   Bit16u offset;
01761                                           !BCC_EOS
01762                                           ! 761 {
01763                                           ! 762 #asm
01764                                           !BCC_ASM
01765                       00000002            _read_byte.seg	set	2
01766                       00000004            _read_byte.offset	set	4
01767 05FE           55                           push bp
01768 05FF           89E5                         mov bp, sp
01769 0601           53                             push bx
01770 0602           1E                             push ds
01771 0603           8B46         04                mov ax, 4[bp] ; segment
01772 0606           8ED8                           mov ds, ax
01773 0608           8B5E         06                mov bx, 6[bp] ; offset
01774 060B           8A07                           mov al, [bx]
01775                                               ;; al = return value (byte)
01776 060D           1F                             pop ds
01777 060E           5B                             pop bx
01778 060F           5D                           pop bp
01779                                           ! 775 endasm
01780                                           !BCC_ENDASM
01781                                           ! 776 }
01782 0610           C3                         ret
01783                                           ! 777   Bit16u
01784                                           ! 778 read_word(seg, offset)
01785                                           ! 779   Bit16u seg;
01786                                           export	_read_word
01787                       00000611            _read_word:
01788                                           !BCC_EOS
01789                                           ! 780   Bit
01790                                           ! 780 16u offset;
01791                                           !BCC_EOS
01792                                           ! 781 {
01793                                           ! 782 #asm
01794                                           !BCC_ASM
01795                       00000002            _read_word.seg	set	2
01796                       00000004            _read_word.offset	set	4
01797 0611           55                           push bp
01798 0612           89E5                         mov bp, sp
01799 0614           53                             push bx
01800 0615           1E                             push ds
01801 0616           8B46         04                mov ax, 4[bp] ; segment
01802 0619           8ED8                           mov ds, ax
01803 061B           8B5E         06                mov bx, 6[bp] ; offset
01804 061E           8B07                           mov ax, [bx]
01805                                               ;; ax = return value (word)
01806 0620           1F                             pop ds
01807 0621           5B                             pop bx
01808 0622           5D                           pop bp
01809                                           ! 795 endasm
01810                                           !BCC_ENDASM
01811                                           ! 796 }
01812 0623           C3                         ret
01813                                           ! 797   void
01814                                           ! 798 write_byte(seg, offset, data)
01815                                           ! 799   Bit16u seg;
01816                                           export	_write_byte
01817                       00000624            _write_byte:
01818                                           !BCC_EOS
01819                                           ! 800   Bit16u offset;
01820                                           !BCC_EOS
01821                                           ! 801   Bit8u data;
01822                                           !BCC_EOS
01823                                           ! 802 {
01824                                           ! 803 #asm
01825                                           !BCC_ASM
01826                       00000002            _write_byte.seg	set	2
01827                       00000006            _write_byte.data	set	6
01828                       00000004            _write_byte.offset	set	4
01829 0624           55                           push bp
01830 0625           89E5                         mov bp, sp
01831 0627           50                             push ax
01832 0628           53                             push bx
01833 0629           1E                             push ds
01834 062A           8B46         04                mov ax, 4[bp] ; segment
01835 062D           8ED8                           mov ds, ax
01836 062F           8B5E         06                mov bx, 6[bp] ; offset
01837 0632           8A46         08                mov al, 8[bp] ; data byte
01838 0635           8807                           mov [bx], al ; write data byte
01839 0637           1F                             pop ds
01840 0638           5B                             pop bx
01841 0639           58                             pop ax
01842 063A           5D                           pop bp
01843                                           ! 818 endasm
01844                                           !BCC_ENDASM
01845                                           ! 819 }
01846 063B           C3                         ret
01847                                           ! 820   void
01848                                           ! 821 write_word(seg, offset, data)
01849                                           ! 822   Bit16u seg;
01850                                           export	_write_word
01851                       0000063C            _write_word:
01852                                           !BCC_EOS
01853                                           ! 823   Bit16u offset;
01854                                           !BCC_EOS
01855                                           ! 824   Bit16u data;
01856                                           !BCC_EOS
01857                                           ! 825 {
01858                                           ! 826 #asm
01859                                           !BCC_ASM
01860                       00000002            _write_word.seg	set	2
01861                       00000006            _write_word.data	set	6
01862                       00000004            _write_word.offset	set	4
01863 063C           55                           push bp
01864 063D           89E5                         mov bp, sp
01865 063F           50                             push ax
01866 0640           53                             push bx
01867 0641           1E                             push ds
01868 0642           8B46         04                mov ax, 4[bp] ; segment
01869 0645           8ED8                           mov ds, ax
01870 0647           8B5E         06                mov bx, 6[bp] ; offset
01871 064A           8B46         08                mov ax, 8[bp] ; data word
01872 064D           8907                           mov [bx], ax ; write data word
01873 064F           1F                             pop ds
01874 0650           5B                             pop bx
01875 0651           58                             pop ax
01876 0652           5D                           pop bp
01877                                           ! 841 endasm
01878                                           !BCC_ENDASM
01879                                           ! 842 }
01880 0653           C3                         ret
01881                                           ! 843   Bit16u
01882                                           ! 844 get_CS()
01883                                           ! 845 {
01884                                           export	_get_CS
01885                       00000654            _get_CS:
01886                                           ! 846 #asm
01887                                           !BCC_ASM
01888 0654           8CC8                         mov ax, cs
01889                                           ! 848 endasm
01890                                           !BCC_ENDASM
01891                                           ! 849 }
01892 0656           C3                         ret
01893                                           ! 850   Bit16u
01894                                           ! 851 get_SS()
01895                                           ! 852 {
01896                                           export	_get_SS
01897                       00000657            _get_SS:
01898                                           ! 853 #asm
01899                                           !BCC_ASM
01900 0657           8CD0                         mov ax, ss
01901                                           ! 855 endasm
01902                                           !BCC_ENDASM
01903                                           ! 856 }
01904 0659           C3                         ret
01905                                           ! 857 void
01906                                           ! 858 copy_e820_table()
01907                                           ! 859 {
01908                                           export	_copy_e820_table
01909                       0000065A            _copy_e820_table:
01910                                           ! 860   Bit8u nr_entries = read_byte(0x9000, 0x1e8);
01911 065A           55                         push	bp
01912 065B           89E5                       mov	bp,sp
01913 065D           4C                         dec	sp
01914                                           ! Debug: list int = const $1E8 (used reg = )
01915 065E           B8                   01E8  mov	ax,#$1E8
01916 0661           50                         push	ax
01917                                           ! Debug: list unsigned int = const $9000 (used reg = )
01918 0662           B8                   9000  mov	ax,#$9000
01919 0665           50                         push	ax
01920                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
01921 0666           E8         FF95            call	_read_byte
01922 0669           83C4                   04  add	sp,*4
01923                                           ! Debug: eq unsigned char = al+0 to unsigned char nr_entries = [S+3-3] (used reg = )
01924 066C           8846         FF            mov	-1[bp],al
01925                                           !BCC_EOS
01926                                           ! 861   Bit32u base_mem;
01927                                           !BCC_EOS
01928                                           ! 862   if (nr_entries > 32)
01929 066F           83C4                   FB  add	sp,*-5
01930                                           ! Debug: gt int = const $20 to unsigned char nr_entries = [S+8-3] (used reg = )
01931 0672           8A46         FF            mov	al,-1[bp]
01932 0675           3C                     20  cmp	al,*$20
01933 0677           76           05            jbe 	.A
01934                       00000679            .B:
01935                                           ! 863    nr_entries = 32;
01936                                           ! Debug: eq int = const $20 to unsigned char nr_entries = [S+8-3] (used reg = )
01937 0679           B0                     20  mov	al,*$20
01938 067B           8846         FF            mov	-1[bp],al
01939                                           !BCC_EOS
01940                                           ! 864   write_word(0xe000, 0x8, nr_entries);
01941                       0000067E            .A:
01942                                           ! Debug: list unsigned char nr_entries = [S+8-3] (used reg = )
01943 067E           8A46         FF            mov	al,-1[bp]
01944 0681           30E4                       xor	ah,ah
01945 0683           50                         push	ax
01946                                           ! Debug: list int = const 8 (used reg = )
01947 0684           B8                   0008  mov	ax,*8
01948 0687           50                         push	ax
01949                                           ! Debug: list unsigned int = const $E000 (used reg = )
01950 0688           B8                   E000  mov	ax,#$E000
01951 068B           50                         push	ax
01952                                           ! Debug: func () void = write_word+0 (used reg = )
01953 068C           E8         FFAD            call	_write_word
01954 068F           83C4                   06  add	sp,*6
01955                                           !BCC_EOS
01956                                           ! 865   memcpyb(0xe000, 0x10, 0x9000, 0x2d0, nr_entries * 0x14);
01957                                           ! Debug: mul int = const $14 to unsigned char nr_entries = [S+8-3] (used reg = )
01958 0692           8A46         FF            mov	al,-1[bp]
01959 0695           30E4                       xor	ah,ah
01960 0697           B9                   0014  mov	cx,*$14
01961 069A           F7E9                       imul	cx
01962                                           ! Debug: list unsigned int = ax+0 (used reg = )
01963 069C           50                         push	ax
01964                                           ! Debug: list int = const $2D0 (used reg = )
01965 069D           B8                   02D0  mov	ax,#$2D0
01966 06A0           50                         push	ax
01967                                           ! Debug: list unsigned int = const $9000 (used reg = )
01968 06A1           B8                   9000  mov	ax,#$9000
01969 06A4           50                         push	ax
01970                                           ! Debug: list int = const $10 (used reg = )
01971 06A5           B8                   0010  mov	ax,*$10
01972 06A8           50                         push	ax
01973                                           ! Debug: list unsigned int = const $E000 (used reg = )
01974 06A9           B8                   E000  mov	ax,#$E000
01975 06AC           50                         push	ax
01976                                           ! Debug: func () void = memcpyb+0 (used reg = )
01977 06AD           E8         F975            call	_memcpyb
01978 06B0           83C4                   0A  add	sp,*$A
01979                                           !BCC_EOS
01980                                           ! 866   base_mem = read_dword(0x9000, 0x2d0 + 8);
01981                                           ! Debug: list int = const $2D8 (used reg = )
01982 06B3           B8                   02D8  mov	ax,#$2D8
01983 06B6           50                         push	ax
01984                                           ! Debug: list unsigned int = const $9000 (used reg = )
01985 06B7           B8                   9000  mov	ax,#$9000
01986 06BA           50                         push	ax
01987                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
01988 06BB           E8         F997            call	_read_dword
01989 06BE           89D3                       mov	bx,dx
01990 06C0           83C4                   04  add	sp,*4
01991                                           ! Debug: eq unsigned long = bx+0 to unsigned long base_mem = [S+8-8] (used reg = )
01992 06C3           8946         FA            mov	-6[bp],ax
01993 06C6           895E         FC            mov	-4[bp],bx
01994                                           !BCC_EOS
01995                                           ! 867   write_word(0x40, 0x13, base_mem >> 10);
01996                                           ! Debug: sr int = const $A to unsigned long base_mem = [S+8-8] (used reg = )
01997 06C9           8B46         FA            mov	ax,-6[bp]
01998 06CC           8B5E         FC            mov	bx,-4[bp]
01999 06CF           88E0                       mov	al,ah
02000 06D1           88DC                       mov	ah,bl
02001 06D3           88FB                       mov	bl,bh
02002 06D5           28FF                       sub	bh,bh
02003 06D7           BF                   0002  mov	di,*2
02004 06DA           E8         FA1C            call	lsrul
02005                                           ! Debug: list unsigned long = bx+0 (used reg = )
02006 06DD           53                         push	bx
02007 06DE           50                         push	ax
02008                                           ! Debug: list int = const $13 (used reg = )
02009 06DF           B8                   0013  mov	ax,*$13
02010 06E2           50                         push	ax
02011                                           ! Debug: list int = const $40 (used reg = )
02012 06E3           B8                   0040  mov	ax,*$40
02013 06E6           50                         push	ax
02014                                           ! Debug: func () void = write_word+0 (used reg = )
02015 06E7           E8         FF52            call	_write_word
02016 06EA           83C4                   08  add	sp,*8
02017                                           !BCC_EOS
02018                                           ! 868 }
02019 06ED           89EC                       mov	sp,bp
02020 06EF           5D                         pop	bp
02021 06F0           C3                         ret
02022                                           ! 869 void
02023                                           ! Register BX used in function copy_e820_table
02024                                           ! 870 set_rom_write_access(action)
02025                                           ! 871   Bit16u action;
02026                                           export	_set_rom_write_access
02027                       000006F1            _set_rom_write_access:
02028                                           !BCC_EOS
02029                                           ! 872 {
02030                                           ! 873     Bit16u off = (Bit16u)&((struct bios_info *)0)->xen_pfiob;
02031 06F1           55                         push	bp
02032 06F2           89E5                       mov	bp,sp
02033 06F4           4C                         dec	sp
02034 06F5           4C                         dec	sp
02035                                           ! Debug: eq unsigned short = const $C to unsigned short off = [S+4-4] (used reg = )
02036 06F6           B8                   000C  mov	ax,*$C
02037 06F9           8946         FE            mov	-2[bp],ax
02038                                           !BCC_EOS
02039                                           ! 874 #asm
02040                                           !BCC_EOS
02041                                           !BCC_ASM
02042                       00000006            _set_rom_write_access.action	set	6
02043                       00000004            .set_rom_write_access.action	set	4
02044                       00000000            _set_rom_write_access.off	set	0
02045                       FFFFFFFE            .set_rom_write_access.off	set	-2
02046 06FC           8B76         FE                mov si,.set_rom_write_access.off[bp]
02047 06FF           1E                             push ds
02048 0700           B8                   EA00      mov ax,#(0x000EA000 >> 4)
02049 0703           8ED8                           mov ds,ax
02050 0705           8B14                           mov dx,[si]
02051 0707           1F                             pop ds
02052 0708           8B46         04                mov ax,.set_rom_write_access.action[bp]
02053 070B           EE                             out dx,al
02054                                           ! 883 endasm
02055                                           !BCC_ENDASM
02056                                           !BCC_EOS
02057                                           ! 884 }
02058 070C           89EC                       mov	sp,bp
02059 070E           5D                         pop	bp
02060 070F           C3                         ret
02061                                           ! 885 void enable_rom_write_access()
02062                                           ! 886 {
02063                                           export	_enable_rom_write_access
02064                       00000710            _enable_rom_write_access:
02065                                           ! 887     set_rom_write_access(0);
02066 0710           55                         push	bp
02067 0711           89E5                       mov	bp,sp
02068                                           ! Debug: list int = const 0 (used reg = )
02069 0713           31C0                       xor	ax,ax
02070 0715           50                         push	ax
02071                                           ! Debug: func () void = set_rom_write_access+0 (used reg = )
02072 0716           E8         FFD8            call	_set_rom_write_access
02073 0719           89EC                       mov	sp,bp
02074                                           !BCC_EOS
02075                                           ! 888 }
02076 071B           5D                         pop	bp
02077 071C           C3                         ret
02078                                           ! 889 void disable_rom_write_access()
02079                                           ! 890 {
02080                                           export	_disable_rom_write_access
02081                       0000071D            _disable_rom_write_access:
02082                                           ! 891     set_rom_write_access(1);
02083 071D           55                         push	bp
02084 071E           89E5                       mov	bp,sp
02085                                           ! Debug: list int = const 1 (used reg = )
02086 0720           B8                   0001  mov	ax,*1
02087 0723           50                         push	ax
02088                                           ! Debug: func () void = set_rom_write_access+0 (used reg = )
02089 0724           E8         FFCA            call	_set_rom_write_access
02090 0727           89EC                       mov	sp,bp
02091                                           !BCC_EOS
02092                                           ! 892 }
02093 0729           5D                         pop	bp
02094 072A           C3                         ret
02095                                           ! 893   void
02096                                           ! 894 wrch(c)
02097                                           ! 895   Bit8u c;
02098                                           export	_wrch
02099                       0000072B            _wrch:
02100                                           !BCC_EOS
02101                                           ! 896 {
02102                                           ! 897 #asm
02103                                           !BCC_ASM
02104                       00000002            _wrch.c	set	2
02105 072B           55                           push bp
02106 072C           89E5                         mov bp, sp
02107 072E           53                           push bx
02108 072F           B4                     0E    mov ah, #0x0e
02109 0731           8A46         04              mov al, 4[bp]
02110 0734           31DB                         xor bx,bx
02111 0736           CD                     10    int #0x10
02112 0738           5B                           pop bx
02113 0739           5D                           pop bp
02114                                           ! 907 endasm
02115                                           !BCC_ENDASM
02116                                           ! 908 }
02117 073A           C3                         ret
02118                                           ! 909   void
02119                                           ! 910 send(action, c)
02120                                           ! 911   Bit16u action;
02121                                           export	_send
02122                       0000073B            _send:
02123                                           !BCC_EOS
02124                                           ! 912   Bit8u c;
02125                                           !BCC_EOS
02126                                           ! 913 {
02127                                           ! 914   outb(0xE9, c);
02128 073B           55                         push	bp
02129 073C           89E5                       mov	bp,sp
02130                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02131 073E           8A46         06            mov	al,6[bp]
02132 0741           30E4                       xor	ah,ah
02133 0743           50                         push	ax
02134                                           ! Debug: list int = const $E9 (used reg = )
02135 0744           B8                   00E9  mov	ax,#$E9
02136 0747           50                         push	ax
02137                                           ! Debug: func () void = outb+0 (used reg = )
02138 0748           E8         FE13            call	_outb
02139 074B           89EC                       mov	sp,bp
02140                                           !BCC_EOS
02141                                           ! 915   if (action & 8) outb(0x403, c);
02142                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
02143 074D           8A46         04            mov	al,4[bp]
02144 0750           24                     08  and	al,*8
02145 0752           84C0                       test	al,al
02146 0754           74           0F            je  	.C
02147                       00000756            .D:
02148                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02149 0756           8A46         06            mov	al,6[bp]
02150 0759           30E4                       xor	ah,ah
02151 075B           50                         push	ax
02152                                           ! Debug: list int = const $403 (used reg = )
02153 075C           B8                   0403  mov	ax,#$403
02154 075F           50                         push	ax
02155                                           ! Debug: func () void = outb+0 (used reg = )
02156 0760           E8         FDFB            call	_outb
02157 0763           89EC                       mov	sp,bp
02158                                           !BCC_EOS
02159                                           ! 916   if (action & 4) outb(0x402, c);
02160                       00000765            .C:
02161                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
02162 0765           8A46         04            mov	al,4[bp]
02163 0768           24                     04  and	al,*4
02164 076A           84C0                       test	al,al
02165 076C           74           0F            je  	.E
02166                       0000076E            .F:
02167                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02168 076E           8A46         06            mov	al,6[bp]
02169 0771           30E4                       xor	ah,ah
02170 0773           50                         push	ax
02171                                           ! Debug: list int = const $402 (used reg = )
02172 0774           B8                   0402  mov	ax,#$402
02173 0777           50                         push	ax
02174                                           ! Debug: func () void = outb+0 (used reg = )
02175 0778           E8         FDE3            call	_outb
02176 077B           89EC                       mov	sp,bp
02177                                           !BCC_EOS
02178                                           ! 917   if (
02179                       0000077D            .E:
02180                                           ! 917 action & 2) {
02181                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
02182 077D           8A46         04            mov	al,4[bp]
02183 0780           24                     02  and	al,*2
02184 0782           84C0                       test	al,al
02185 0784           74           1B            je  	.10
02186                       00000786            .11:
02187                                           ! 918     if (c == '\n') wrch('\r');
02188                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
02189 0786           8A46         06            mov	al,6[bp]
02190 0789           3C                     0A  cmp	al,*$A
02191 078B           75           09            jne 	.12
02192                       0000078D            .13:
02193                                           ! Debug: list int = const $D (used reg = )
02194 078D           B8                   000D  mov	ax,*$D
02195 0790           50                         push	ax
02196                                           ! Debug: func () void = wrch+0 (used reg = )
02197 0791           E8         FF97            call	_wrch
02198 0794           89EC                       mov	sp,bp
02199                                           !BCC_EOS
02200                                           ! 919     wrch(c);
02201                       00000796            .12:
02202                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02203 0796           8A46         06            mov	al,6[bp]
02204 0799           30E4                       xor	ah,ah
02205 079B           50                         push	ax
02206                                           ! Debug: func () void = wrch+0 (used reg = )
02207 079C           E8         FF8C            call	_wrch
02208 079F           89EC                       mov	sp,bp
02209                                           !BCC_EOS
02210                                           ! 920   }
02211                                           ! 921 }
02212                       000007A1            .10:
02213 07A1           5D                         pop	bp
02214 07A2           C3                         ret
02215                                           ! 922   void
02216                                           ! 923 put_int(action, val, width, neg)
02217                                           ! 924   Bit16u action;
02218                                           export	_put_int
02219                       000007A3            _put_int:
02220                                           !BCC_EOS
02221                                           ! 925   short val, width;
02222                                           !BCC_EOS
02223                                           ! 926   bx_bool neg;
02224                                           !BCC_EOS
02225                                           ! 927 {
02226                                           ! 928   short nval = val / 10;
02227 07A3           55                         push	bp
02228 07A4           89E5                       mov	bp,sp
02229 07A6           4C                         dec	sp
02230 07A7           4C                         dec	sp
02231                                           ! Debug: div int = const $A to short val = [S+4+4] (used reg = )
02232 07A8           8B46         06            mov	ax,6[bp]
02233 07AB           BB                   000A  mov	bx,*$A
02234 07AE           99                         cwd
02235 07AF           F7FB                       idiv	bx
02236                                           ! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
02237 07B1           8946         FE            mov	-2[bp],ax
02238                                           !BCC_EOS
02239                                           ! 929   if (nval)
02240 07B4           8B46         FE            mov	ax,-2[bp]
02241 07B7           85C0                       test	ax,ax
02242 07B9           74           16            je  	.14
02243                       000007BB            .15:
02244                                           ! 930     put_int(action, nval, width - 1, neg);
02245                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02246 07BB           FF76         0A            push	$A[bp]
02247                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02248 07BE           8B46         08            mov	ax,8[bp]
02249                                           ! Debug: list int = ax-1 (used reg = )
02250 07C1           48                         dec	ax
02251 07C2           50                         push	ax
02252                                           ! Debug: list short nval = [S+8-4] (used reg = )
02253 07C3           FF76         FE            push	-2[bp]
02254                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02255 07C6           FF76         04            push	4[bp]
02256                                           ! Debug: func () void = put_int+0 (used reg = )
02257 07C9           E8         FFD7            call	_put_int
02258 07CC           83C4                   08  add	sp,*8
02259                                           !BCC_EOS
02260                                           ! 931   else {
02261 07CF           EB           2E            jmp .16
02262                       000007D1            .14:
02263                                           ! 932     while (--width > 0) send(action, ' ');
02264 07D1           EB           0D            jmp .18
02265                       000007D3            .19:
02266                                           ! Debug: list int = const $20 (used reg = )
02267 07D3           B8                   0020  mov	ax,*$20
02268 07D6           50                         push	ax
02269                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02270 07D7           FF76         04            push	4[bp]
02271                                           ! Debug: func () void = send+0 (used reg = )
02272 07DA           E8         FF5E            call	_send
02273 07DD           83C4                   04  add	sp,*4
02274                                           !BCC_EOS
02275                                           ! 933     if (neg) send(action, '-');
02276                       000007E0            .18:
02277                                           ! Debug: predec short width = [S+4+6] (used reg = )
02278 07E0           8B46         08            mov	ax,8[bp]
02279 07E3           48                         dec	ax
02280 07E4           8946         08            mov	8[bp],ax
02281                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02282 07E7           85C0                       test	ax,ax
02283 07E9           7F           E8            jg 	.19
02284                       000007EB            .1A:
02285                       000007EB            .17:
02286 07EB           8B46         0A            mov	ax,$A[bp]
02287 07EE           85C0                       test	ax,ax
02288 07F0           74           0D            je  	.1B
02289                       000007F2            .1C:
02290                                           ! Debug: list int = const $2D (used reg = )
02291 07F2           B8                   002D  mov	ax,*$2D
02292 07F5           50                         push	ax
02293                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02294 07F6           FF76         04            push	4[bp]
02295                                           ! Debug: func () void = send+0 (used reg = )
02296 07F9           E8         FF3F            call	_send
02297 07FC           83C4                   04  add	sp,*4
02298                                           !BCC_EOS
02299                                           ! 934   }
02300                       000007FF            .1B:
02301                                           ! 935   send(action, val - (nval * 10) + '0');
02302                       000007FF            .16:
02303                                           ! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
02304 07FF           8B46         FE            mov	ax,-2[bp]
02305 0802           89C2                       mov	dx,ax
02306 0804           D1E0                       shl	ax,*1
02307 0806           D1E0                       shl	ax,*1
02308 0808           01D0                       add	ax,dx
02309 080A           D1E0                       shl	ax,*1
02310                                           ! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
02311 080C           50                         push	ax
02312 080D           8B46         06            mov	ax,6[bp]
02313 0810           2B46         FC            sub	ax,-4[bp]
02314 0813           44                         inc	sp
02315 0814           44                         inc	sp
02316                                           ! Debug: add int = const $30 to int = ax+0 (used reg = )
02317                                           ! Debug: list int = ax+$30 (used reg = )
02318 0815           05                   0030  add	ax,*$30
02319 0818           50                         push	ax
02320                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02321 0819           FF76         04            push	4[bp]
02322                                           ! Debug: func () void = send+0 (used reg = )
02323 081C           E8         FF1C            call	_send
02324 081F           83C4                   04  add	sp,*4
02325                                           !BCC_EOS
02326                                           ! 936 }
02327 0822           89EC                       mov	sp,bp
02328 0824           5D                         pop	bp
02329 0825           C3                         ret
02330                                           ! 937   void
02331                                           ! Register BX used in function put_int
02332                                           ! 938 put_uint(action, val, width, neg)
02333                                           ! 939   Bit16u action;
02334                                           export	_put_uint
02335                       00000826            _put_uint:
02336                                           !BCC_EOS
02337                                           ! 940   unsigned short val;
02338                                           !BCC_EOS
02339                                           ! 941   short width;
02340                                           !BCC_EOS
02341                                           ! 942   bx_bool neg;
02342                                           !BCC_EOS
02343                                           ! 943 {
02344                                           ! 944   unsigned short nval = val / 10;
02345 0826           55                         push	bp
02346 0827           89E5                       mov	bp,sp
02347 0829           4C                         dec	sp
02348 082A           4C                         dec	sp
02349                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02350 082B           8B46         06            mov	ax,6[bp]
02351 082E           BB                   000A  mov	bx,*$A
02352 0831           E8         F905            call	idiv_u
02353                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02354 0834           8946         FE            mov	-2[bp],ax
02355                                           !BCC_EOS
02356                                           ! 945   if (nval)
02357 0837           8B46         FE            mov	ax,-2[bp]
02358 083A           85C0                       test	ax,ax
02359 083C           74           16            je  	.1D
02360                       0000083E            .1E:
02361                                           ! 946     put_uint(action, nval, width - 1, neg);
02362                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02363 083E           FF76         0A            push	$A[bp]
02364                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02365 0841           8B46         08            mov	ax,8[bp]
02366                                           ! Debug: list int = ax-1 (used reg = )
02367 0844           48                         dec	ax
02368 0845           50                         push	ax
02369                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02370 0846           FF76         FE            push	-2[bp]
02371                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02372 0849           FF76         04            push	4[bp]
02373                                           ! Debug: func () void = put_uint+0 (used reg = )
02374 084C           E8         FFD7            call	_put_uint
02375 084F           83C4                   08  add	sp,*8
02376                                           !BCC_EOS
02377                                           ! 947   else {
02378 0852           EB           2E            jmp .1F
02379                       00000854            .1D:
02380                                           ! 948     while (--width > 0) send(action, ' ');
02381 0854           EB           0D            jmp .21
02382                       00000856            .22:
02383                                           ! Debug: list int = const $20 (used reg = )
02384 0856           B8                   0020  mov	ax,*$20
02385 0859           50                         push	ax
02386                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02387 085A           FF76         04            push	4[bp]
02388                                           ! Debug: func () void = send+0 (used reg = )
02389 085D           E8         FEDB            call	_send
02390 0860           83C4                   04  add	sp,*4
02391                                           !BCC_EOS
02392                                           ! 949     if (neg) send(action, '-');
02393                       00000863            .21:
02394                                           ! Debug: predec short width = [S+4+6] (used reg = )
02395 0863           8B46         08            mov	ax,8[bp]
02396 0866           48                         dec	ax
02397 0867           8946         08            mov	8[bp],ax
02398                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02399 086A           85C0                       test	ax,ax
02400 086C           7F           E8            jg 	.22
02401                       0000086E            .23:
02402                       0000086E            .20:
02403 086E           8B46         0A            mov	ax,$A[bp]
02404 0871           85C0                       test	ax,ax
02405 0873           74           0D            je  	.24
02406                       00000875            .25:
02407                                           ! Debug: list int = const $2D (used reg = )
02408 0875           B8                   002D  mov	ax,*$2D
02409 0878           50                         push	ax
02410                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02411 0879           FF76         04            push	4[bp]
02412                                           ! Debug: func () void = send+0 (used reg = )
02413 087C           E8         FEBC            call	_send
02414 087F           83C4                   04  add	sp,*4
02415                                           !BCC_EOS
02416                                           ! 950   }
02417                       00000882            .24:
02418                                           ! 951   send(action, val - (nval * 10) + '0');
02419                       00000882            .1F:
02420                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02421 0882           8B46         FE            mov	ax,-2[bp]
02422 0885           89C2                       mov	dx,ax
02423 0887           D1E0                       shl	ax,*1
02424 0889           D1E0                       shl	ax,*1
02425 088B           01D0                       add	ax,dx
02426 088D           D1E0                       shl	ax,*1
02427                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02428 088F           50                         push	ax
02429 0890           8B46         06            mov	ax,6[bp]
02430 0893           2B46         FC            sub	ax,-4[bp]
02431 0896           44                         inc	sp
02432 0897           44                         inc	sp
02433                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02434                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02435 0898           05                   0030  add	ax,*$30
02436 089B           50                         push	ax
02437                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02438 089C           FF76         04            push	4[bp]
02439                                           ! Debug: func () void = send+0 (used reg = )
02440 089F           E8         FE99            call	_send
02441 08A2           83C4                   04  add	sp,*4
02442                                           !BCC_EOS
02443                                           ! 952 }
02444 08A5           89EC                       mov	sp,bp
02445 08A7           5D                         pop	bp
02446 08A8           C3                         ret
02447                                           ! 953   void
02448                                           ! Register BX used in function put_uint
02449                                           ! 954 bios_printf(action, s)
02450                                           ! 955   Bit16u action;
02451                                           export	_bios_printf
02452                       000008A9            _bios_printf:
02453                                           !BCC_EOS
02454                                           ! 956   Bit8u *s;
02455                                           !BCC_EOS
02456                                           ! 957 {
02457                                           ! 958   Bit8u c, format_char;
02458                                           !BCC_EOS
02459                                           ! 959   bx_bool in_format;
02460                                           !BCC_EOS
02461                                           ! 960   short i;
02462                                           !BCC_EOS
02463                                           ! 961   Bit16u *arg_ptr;
02464                                           !BCC_EOS
02465                                           ! 962   Bit16u arg_seg, arg, nibble, shift_count, format_width;
02466                                           !BCC_EOS
02467                                           ! 963   arg_ptr = &s;
02468 08A9           55                         push	bp
02469 08AA           89E5                       mov	bp,sp
02470 08AC           83C4                   EE  add	sp,*-$12
02471                                           ! Debug: eq * * unsigned char s = S+$14+4 to * unsigned short arg_ptr = [S+$14-$A] (used reg = )
02472 08AF           8D5E         06            lea	bx,6[bp]
02473 08B2           895E         F8            mov	-8[bp],bx
02474                                           !BCC_EOS
02475                                           ! 964   arg_seg = get_SS();
02476                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
02477 08B5           E8         FD9F            call	_get_SS
02478                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$14-$C] (used reg = )
02479 08B8           8946         F6            mov	-$A[bp],ax
02480                                           !BCC_EOS
02481                                           ! 965   in_format = 0;
02482                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$14-6] (used reg = )
02483 08BB           31C0                       xor	ax,ax
02484 08BD           8946         FC            mov	-4[bp],ax
02485                                           !BCC_EOS
02486                                           ! 966   format_width = 0;
02487                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$14-$14] (used reg = )
02488 08C0           31C0                       xor	ax,ax
02489 08C2           8946         EE            mov	-$12[bp],ax
02490                                           !BCC_EOS
02491                                           ! 967   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02492                                           ! Debug: and int = const 7 to unsigned short action = [S+$14+2] (used reg = )
02493 08C5           8A46         04            mov	al,4[bp]
02494 08C8           24                     07  and	al,*7
02495                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02496 08CA           3C                     07  cmp	al,*7
02497 08CC           75           1B            jne 	.26
02498                       000008CE            .27:
02499                                           ! 968     outb(0x401, 0x00);
02500                                           ! Debug: list int = const 0 (used reg = )
02501 08CE           31C0                       xor	ax,ax
02502 08D0           50                         push	ax
02503                                           ! Debug: list int = const $401 (used reg = )
02504 08D1           B8                   0401  mov	ax,#$401
02505 08D4           50                         push	ax
02506                                           ! Debug: func () void = outb+0 (used reg = )
02507 08D5           E8         FC86            call	_outb
02508 08D8           83C4                   04  add	sp,*4
02509                                           !BCC_EOS
02510                                           ! 969     bios_printf (2, "FATAL: ");
02511                                           ! Debug: list * char = .28+0 (used reg = )
02512 08DB           BB                   DD11  mov	bx,#.28
02513 08DE           53                         push	bx
02514                                           ! Debug: list int = const 2 (used reg = )
02515 08DF           B8                   0002  mov	ax,*2
02516 08E2           50                         push	ax
02517                                           ! Debug: func () void = bios_printf+0 (used reg = )
02518 08E3           E8         FFC3            call	_bios_printf
02519 08E6           83C4                   04  add	sp,*4
02520                                           !BCC_EOS
02521                                           ! 970   }
02522                                           ! 971   while (c = read_byte(get_CS(), s)) {
02523                       000008E9            .26:
02524 08E9           E9         017B            br 	.2A
02525                       000008EC            .2B:
02526                                           ! 972     if ( c == '%' ) {
02527                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$14-3] (used reg = )
02528 08EC           8A46         FF            mov	al,-1[bp]
02529 08EF           3C                     25  cmp	al,*$25
02530 08F1           75           0E            jne 	.2C
02531                       000008F3            .2D:
02532                                           ! 973       in_format = 1;
02533                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$14-6] (used reg = )
02534 08F3           B8                   0001  mov	ax,*1
02535 08F6           8946         FC            mov	-4[bp],ax
02536                                           !BCC_EOS
02537                                           ! 974       format_width = 0;
02538                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$14-$14] (used reg = )
02539 08F9           31C0                       xor	ax,ax
02540 08FB           8946         EE            mov	-$12[bp],ax
02541                                           !BCC_EOS
02542                                           ! 975       }
02543                                           ! 976     else if (in_format) {
02544 08FE           E9         015F            br 	.2E
02545                       00000901            .2C:
02546 0901           8B46         FC            mov	ax,-4[bp]
02547 0904           85C0                       test	ax,ax
02548 0906         0F84         0147            beq 	.2F
02549                       0000090A            .30:
02550                                           ! 977       if ( (c>='0') && (c<='9') ) {
02551                                           ! Debug: ge int = const $30 to unsigned char c = [S+$14-3] (used reg = )
02552 090A           8A46         FF            mov	al,-1[bp]
02553 090D           3C                     30  cmp	al,*$30
02554 090F           72           28            jb  	.31
02555                       00000911            .33:
02556                                           ! Debug: le int = const $39 to unsigned char c = [S+$14-3] (used reg = )
02557 0911           8A46         FF            mov	al,-1[bp]
02558 0914           3C                     39  cmp	al,*$39
02559 0916           77           21            ja  	.31
02560                       00000918            .32:
02561                                           ! 978         format_width = (format_width * 10) + (c - '0');
02562                                           ! Debug: sub int = const $30 to unsigned char c = [S+$14-3] (used reg = )
02563 0918           8A46         FF            mov	al,-1[bp]
02564 091B           30E4                       xor	ah,ah
02565 091D           05                   FFD0  add	ax,*-$30
02566 0920           50                         push	ax
02567                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$16-$14] (used reg = )
02568 0921           8B46         EE            mov	ax,-$12[bp]
02569 0924           89C2                       mov	dx,ax
02570 0926           D1E0                       shl	ax,*1
02571 0928           D1E0                       shl	ax,*1
02572 092A           01D0                       add	ax,dx
02573 092C           D1E0                       shl	ax,*1
02574                                           ! Debug: add unsigned int (temp) = [S+$16-$16] to unsigned int = ax+0 (used reg = )
02575 092E           0346         EC            add	ax,-$14[bp]
02576 0931           44                         inc	sp
02577 0932           44                         inc	sp
02578                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$14-$14] (used reg = )
02579 0933           8946         EE            mov	-$12[bp],ax
02580                                           !BCC_EOS
02581                                           ! 979         }
02582                                           ! 980       else {
02583 0936           E9         0116            br 	.34
02584                       00000939            .31:
02585                                           ! 981         arg_ptr++;
02586                                           ! Debug: postinc * unsigned short arg_ptr = [S+$14-$A] (used reg = )
02587 0939           8B5E         F8            mov	bx,-8[bp]
02588 093C           43                         inc	bx
02589 093D           43                         inc	bx
02590 093E           895E         F8            mov	-8[bp],bx
02591                                           !BCC_EOS
02592                                           ! 982         arg = read_word(arg_seg, arg_ptr);
02593                                           ! Debug: list * unsigned short arg_ptr = [S+$14-$A] (used reg = )
02594 0941           FF76         F8            push	-8[bp]
02595                                           ! Debug: list unsigned short arg_seg = [S+$16-$C] (used reg = )
02596 0944           FF76         F6            push	-$A[bp]
02597                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
02598 0947           E8         FCC7            call	_read_word
02599 094A           83C4                   04  add	sp,*4
02600                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$14-$E] (used reg = )
02601 094D           8946         F4            mov	-$C[bp],ax
02602                                           !BCC_EOS
02603                                           ! 983         if (c == 'x') {
02604                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$14-3] (used reg = )
02605 0950           8A46         FF            mov	al,-1[bp]
02606 0953           3C                     78  cmp	al,*$78
02607 0955           75           5E            jne 	.35
02608                       00000957            .36:
02609                                           ! 984           if (format_width == 0)
02610                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$14-$14] (used reg = )
02611 0957           8B46         EE            mov	ax,-$12[bp]
02612 095A           85C0                       test	ax,ax
02613 095C           75           06            jne 	.37
02614                       0000095E            .38:
02615                                           ! 985             format_width = 4;
02616                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$14-$14] (used reg = )
02617 095E           B8                   0004  mov	ax,*4
02618 0961           8946         EE            mov	-$12[bp],ax
02619                                           !BCC_EOS
02620                                           ! 986           for (i=format_width-1; i>=0; i--) {
02621                       00000964            .37:
02622                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$14-$14] (used reg = )
02623 0964           8B46         EE            mov	ax,-$12[bp]
02624                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$14-8] (used reg = )
02625 0967           48                         dec	ax
02626 0968           8946         FA            mov	-6[bp],ax
02627                                           !BCC_EOS
02628                                           !BCC_EOS
02629 096B           EB           3E            jmp .3B
02630                       0000096D            .3C:
02631                                           ! 987             nibble = (arg >> (4 * i)) & 0x000f;
02632                                           ! Debug: mul short i = [S+$14-8] to int = const 4 (used reg = )
02633                                           ! Debug: expression subtree swapping
02634 096D           8B46         FA            mov	ax,-6[bp]
02635 0970           D1E0                       shl	ax,*1
02636 0972           D1E0                       shl	ax,*1
02637                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$14-$E] (used reg = )
02638 0974           89C3                       mov	bx,ax
02639 0976           8B46         F4            mov	ax,-$C[bp]
02640 0979           89D9                       mov	cx,bx
02641 097B           D3E8                       shr	ax,cl
02642                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
02643 097D           24                     0F  and	al,*$F
02644                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$14-$10] (used reg = )
02645 097F           30E4                       xor	ah,ah
02646 0981           8946         F2            mov	-$E[bp],ax
02647                                           !BCC_EOS
02648                                           ! 988             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+'A'));
02649                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$14-$10] (used reg = )
02650 0984           8B46         F2            mov	ax,-$E[bp]
02651 0987           3D                   0009  cmp	ax,*9
02652 098A           77           08            ja  	.3D
02653                       0000098C            .3E:
02654                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$14-$10] (used reg = )
02655 098C           8B46         F2            mov	ax,-$E[bp]
02656 098F           05                   0030  add	ax,*$30
02657 0992           EB           06            jmp .3F
02658                       00000994            .3D:
02659                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$14-$10] (used reg = )
02660 0994           8B46         F2            mov	ax,-$E[bp]
02661                                           ! Debug: add int = const $41 to unsigned int = ax-$A (used reg = )
02662 0997           05                   0037  add	ax,*$37
02663                       0000099A            .3F:
02664                                           ! Debug: list unsigned int = ax+0 (used reg = )
02665 099A           50                         push	ax
02666                                           ! Debug: list unsigned short action = [S+$16+2] (used reg = )
02667 099B           FF76         04            push	4[bp]
02668                                           ! Debug: func () void = send+0 (used reg = )
02669 099E           E8         FD9A            call	_send
02670 09A1           83C4                   04  add	sp,*4
02671                                           !BCC_EOS
02672                                           ! 989             }
02673                                           ! 990           }
02674                       000009A4            .3A:
02675                                           ! Debug: postdec short i = [S+$14-8] (used reg = )
02676 09A4           8B46         FA            mov	ax,-6[bp]
02677 09A7           48                         dec	ax
02678 09A8           8946         FA            mov	-6[bp],ax
02679                       000009AB            .3B:
02680                                           ! Debug: ge int = const 0 to short i = [S+$14-8] (used reg = )
02681 09AB           8B46         FA            mov	ax,-6[bp]
02682 09AE           85C0                       test	ax,ax
02683 09B0           7D           BB            jge	.3C
02684                       000009B2            .40:
02685                       000009B2            .39:
02686                                           ! 991         else if (c == 'u') {
02687 09B2           E9         0095            br 	.41
02688                       000009B5            .35:
02689                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$14-3] (used reg = )
02690 09B5           8A46         FF            mov	al,-1[bp]
02691 09B8           3C                     75  cmp	al,*$75
02692 09BA           75           14            jne 	.42
02693                       000009BC            .43:
02694                                           ! 992           put_uint(action, arg, format_width, 0);
02695                                           ! Debug: list int = const 0 (used reg = )
02696 09BC           31C0                       xor	ax,ax
02697 09BE           50                         push	ax
02698                                           ! Debug: list unsigned short format_width = [S+$16-$14] (used reg = )
02699 09BF           FF76         EE            push	-$12[bp]
02700                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
02701 09C2           FF76         F4            push	-$C[bp]
02702                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
02703 09C5           FF76         04            push	4[bp]
02704                                           ! Debug: func () void = put_uint+0 (used reg = )
02705 09C8           E8         FE5B            call	_put_uint
02706 09CB           83C4                   08  add	sp,*8
02707                                           !BCC_EOS
02708                                           ! 993           }
02709                                           ! 994         else if (c == 'd') {
02710 09CE           EB           7A            jmp .44
02711                       000009D0            .42:
02712                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$14-3] (used reg = )
02713 09D0           8A46         FF            mov	al,-1[bp]
02714 09D3           3C                     64  cmp	al,*$64
02715 09D5           75           38            jne 	.45
02716                       000009D7            .46:
02717                                           ! 995           if (arg & 0x8000)
02718                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$14-$E] (used reg = )
02719 09D7           8B46         F4            mov	ax,-$C[bp]
02720 09DA           25                   8000  and	ax,#$8000
02721 09DD           85C0                       test	ax,ax
02722 09DF           74           1A            je  	.47
02723                       000009E1            .48:
02724                                           ! 996             put_int(action, -arg, format_width - 1, 1);
02725                                           ! Debug: list int = const 1 (used reg = )
02726 09E1           B8                   0001  mov	ax,*1
02727 09E4           50                         push	ax
02728                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$16-$14] (used reg = )
02729 09E5           8B46         EE            mov	ax,-$12[bp]
02730                                           ! Debug: list unsigned int = ax-1 (used reg = )
02731 09E8           48                         dec	ax
02732 09E9           50                         push	ax
02733                                           ! Debug: neg unsigned short arg = [S+$18-$E] (used reg = )
02734 09EA           31C0                       xor	ax,ax
02735 09EC           2B46         F4            sub	ax,-$C[bp]
02736                                           ! Debug: list unsigned int = ax+0 (used reg = )
02737 09EF           50                         push	ax
02738                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
02739 09F0           FF76         04            push	4[bp]
02740                                           ! Debug: func () void = put_int+0 (used reg = )
02741 09F3           E8         FDAD            call	_put_int
02742 09F6           83C4                   08  add	sp,*8
02743                                           !BCC_EOS
02744                                           ! 997           else
02745                                           ! 998             put_int(action, arg, format_width, 0);
02746 09F9           EB           12            jmp .49
02747                       000009FB            .47:
02748                                           ! Debug: list int = const 0 (used reg = )
02749 09FB           31C0                       xor	ax,ax
02750 09FD           50                         push	ax
02751                                           ! Debug: list unsigned short format_width = [S+$16-$14] (used reg = )
02752 09FE           FF76         EE            push	-$12[bp]
02753                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
02754 0A01           FF76         F4            push	-$C[bp]
02755                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
02756 0A04           FF76         04            push	4[bp]
02757                                           ! Debug: func () void = put_int+0 (used reg = )
02758 0A07           E8         FD99            call	_put_int
02759 0A0A           83C4                   08  add	sp,*8
02760                                           !BCC_EOS
02761                                           ! 999           }
02762                       00000A0D            .49:
02763                                           ! 1000         else if (c == 's') {
02764 0A0D           EB           3B            jmp .4A
02765                       00000A0F            .45:
02766                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$14-3] (used reg = )
02767 0A0F           8A46         FF            mov	al,-1[bp]
02768 0A12           3C                     73  cmp	al,*$73
02769 0A14           75           11            jne 	.4B
02770                       00000A16            .4C:
02771                                           ! 1001           bios_printf(action & (~1), arg);
02772                                           ! Debug: list unsigned short arg = [S+$14-$E] (used reg = )
02773 0A16           FF76         F4            push	-$C[bp]
02774                                           ! Debug: and int = const -2 to unsigned short action = [S+$16+2] (used reg = )
02775 0A19           8B46         04            mov	ax,4[bp]
02776 0A1C           24                     FE  and	al,#$FE
02777                                           ! Debug: list unsigned int = ax+0 (used reg = )
02778 0A1E           50                         push	ax
02779                                           ! Debug: func () void = bios_printf+0 (used reg = )
02780 0A1F           E8         FE87            call	_bios_printf
02781 0A22           83C4                   04  add	sp,*4
02782                                           !BCC_EOS
02783                                           ! 1002           }
02784                                           ! 1003         e
02785                                           ! 1003 lse if (c == 'c') {
02786 0A25           EB           23            jmp .4D
02787                       00000A27            .4B:
02788                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$14-3] (used reg = )
02789 0A27           8A46         FF            mov	al,-1[bp]
02790 0A2A           3C                     63  cmp	al,*$63
02791 0A2C           75           0E            jne 	.4E
02792                       00000A2E            .4F:
02793                                           ! 1004           send(action, arg);
02794                                           ! Debug: list unsigned short arg = [S+$14-$E] (used reg = )
02795 0A2E           FF76         F4            push	-$C[bp]
02796                                           ! Debug: list unsigned short action = [S+$16+2] (used reg = )
02797 0A31           FF76         04            push	4[bp]
02798                                           ! Debug: func () void = send+0 (used reg = )
02799 0A34           E8         FD04            call	_send
02800 0A37           83C4                   04  add	sp,*4
02801                                           !BCC_EOS
02802                                           ! 1005           }
02803                                           ! 1006         else
02804                                           ! 1007           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
02805 0A3A           EB           0E            jmp .50
02806                       00000A3C            .4E:
02807                                           ! Debug: list * char = .51+0 (used reg = )
02808 0A3C           BB                   DCF4  mov	bx,#.51
02809 0A3F           53                         push	bx
02810                                           ! Debug: list int = const 7 (used reg = )
02811 0A40           B8                   0007  mov	ax,*7
02812 0A43           50                         push	ax
02813                                           ! Debug: func () void = bios_printf+0 (used reg = )
02814 0A44           E8         FE62            call	_bios_printf
02815 0A47           83C4                   04  add	sp,*4
02816                                           !BCC_EOS
02817                                           ! 1008           in_format = 0;
02818                       00000A4A            .50:
02819                       00000A4A            .4D:
02820                       00000A4A            .4A:
02821                       00000A4A            .44:
02822                       00000A4A            .41:
02823                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$14-6] (used reg = )
02824 0A4A           31C0                       xor	ax,ax
02825 0A4C           8946         FC            mov	-4[bp],ax
02826                                           !BCC_EOS
02827                                           ! 1009         }
02828                                           ! 1010       }
02829                       00000A4F            .34:
02830                                           ! 1011     else {
02831 0A4F           EB           0F            jmp .52
02832                       00000A51            .2F:
02833                                           ! 1012       send(action, c);
02834                                           ! Debug: list unsigned char c = [S+$14-3] (used reg = )
02835 0A51           8A46         FF            mov	al,-1[bp]
02836 0A54           30E4                       xor	ah,ah
02837 0A56           50                         push	ax
02838                                           ! Debug: list unsigned short action = [S+$16+2] (used reg = )
02839 0A57           FF76         04            push	4[bp]
02840                                           ! Debug: func () void = send+0 (used reg = )
02841 0A5A           E8         FCDE            call	_send
02842 0A5D           83C4                   04  add	sp,*4
02843                                           !BCC_EOS
02844                                           ! 1013       }
02845                                           ! 1014     s ++;
02846                       00000A60            .52:
02847                       00000A60            .2E:
02848                                           ! Debug: postinc * unsigned char s = [S+$14+4] (used reg = )
02849 0A60           8B5E         06            mov	bx,6[bp]
02850 0A63           43                         inc	bx
02851 0A64           895E         06            mov	6[bp],bx
02852                                           !BCC_EOS
02853                                           ! 1015     }
02854                                           ! 1016   if (action & 1) {
02855                       00000A67            .2A:
02856                                           ! Debug: list * unsigned char s = [S+$14+4] (used reg = )
02857 0A67           FF76         06            push	6[bp]
02858                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
02859 0A6A           E8         FBE7            call	_get_CS
02860                                           ! Debug: list unsigned short = ax+0 (used reg = )
02861 0A6D           50                         push	ax
02862                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
02863 0A6E           E8         FB8D            call	_read_byte
02864 0A71           83C4                   04  add	sp,*4
02865                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$14-3] (used reg = )
02866 0A74           8846         FF            mov	-1[bp],al
02867 0A77           84C0                       test	al,al
02868 0A79         0F85         FE6F            bne 	.2B
02869                       00000A7D            .53:
02870                       00000A7D            .29:
02871                                           ! Debug: and int = const 1 to unsigned short action = [S+$14+2] (used reg = )
02872 0A7D           8A46         04            mov	al,4[bp]
02873 0A80           24                     01  and	al,*1
02874 0A82           84C0                       test	al,al
02875 0A84           74           04            je  	.54
02876                       00000A86            .55:
02877                                           ! 1017 #asm
02878                                           !BCC_EOS
02879                                           !BCC_ASM
02880                       00000000            _bios_printf.format_width	set	0
02881                       FFFFFFEE            .bios_printf.format_width	set	-$12
02882                       00000010            _bios_printf.format_char	set	$10
02883                       FFFFFFFE            .bios_printf.format_char	set	-2
02884                       0000000A            _bios_printf.arg_ptr	set	$A
02885                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
02886                       00000016            _bios_printf.action	set	$16
02887                       00000004            .bios_printf.action	set	4
02888                       0000000C            _bios_printf.i	set	$C
02889                       FFFFFFFA            .bios_printf.i	set	-6
02890                       00000008            _bios_printf.arg_seg	set	8
02891                       FFFFFFF6            .bios_printf.arg_seg	set	-$A
02892                       00000002            _bios_printf.shift_count	set	2
02893                       FFFFFFF0            .bios_printf.shift_count	set	-$10
02894                       0000000E            _bios_printf.in_format	set	$E
02895                       FFFFFFFC            .bios_printf.in_format	set	-4
02896                       00000018            _bios_printf.s	set	$18
02897                       00000006            .bios_printf.s	set	6
02898                       00000004            _bios_printf.nibble	set	4
02899                       FFFFFFF2            .bios_printf.nibble	set	-$E
02900                       00000011            _bios_printf.c	set	$11
02901                       FFFFFFFF            .bios_printf.c	set	-1
02902                       00000006            _bios_printf.arg	set	6
02903                       FFFFFFF4            .bios_printf.arg	set	-$C
02904 0A86           FA                             cli
02905                       00000A87             halt2_loop:
02906 0A87           F4                             hlt
02907 0A88           EB           FD                jmp halt2_loop
02908                                           ! 1022 endasm
02909                                           !BCC_ENDASM
02910                                           !BCC_EOS
02911                                           ! 1023     }
02912                                           ! 1024 }
02913                       00000A8A            .54:
02914 0A8A           89EC                       mov	sp,bp
02915 0A8C           5D                         pop	bp
02916 0A8D           C3                         ret
02917                                           ! 1025   void
02918                                           ! Register BX used in function bios_printf
02919                                           ! 1026 keyboard_init()
02920                                           ! 1027 {
02921                                           export	_keyboard_init
02922                       00000A8E            _keyboard_init:
02923                                           ! 1028     Bit16u max;
02924                                           !BCC_EOS
02925                                           ! 1029     max=0xffff;
02926 0A8E           55                         push	bp
02927 0A8F           89E5                       mov	bp,sp
02928 0A91           4C                         dec	sp
02929 0A92           4C                         dec	sp
02930                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
02931 0A93           B8                   FFFF  mov	ax,#$FFFF
02932 0A96           8946         FE            mov	-2[bp],ax
02933                                           !BCC_EOS
02934                                           ! 1030     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
02935 0A99           EB           0D            jmp .57
02936                       00000A9B            .58:
02937                                           ! Debug: list int = const 0 (used reg = )
02938 0A9B           31C0                       xor	ax,ax
02939 0A9D           50                         push	ax
02940                                           ! Debug: list int = const $80 (used reg = )
02941 0A9E           B8                   0080  mov	ax,#$80
02942 0AA1           50                         push	ax
02943                                           ! Debug: func () void = outb+0 (used reg = )
02944 0AA2           E8         FAB9            call	_outb
02945 0AA5           83C4                   04  add	sp,*4
02946                                           !BCC_EOS
02947                                           ! 1031     max=0x2000;
02948                       00000AA8            .57:
02949                                           ! Debug: list int = const $64 (used reg = )
02950 0AA8           B8                   0064  mov	ax,*$64
02951 0AAB           50                         push	ax
02952                                           ! Debug: func () unsigned char = inb+0 (used reg = )
02953 0AAC           E8         FA99            call	_inb
02954 0AAF           44                         inc	sp
02955 0AB0           44                         inc	sp
02956                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
02957 0AB1           24                     02  and	al,*2
02958 0AB3           84C0                       test	al,al
02959 0AB5           74           0B            je  	.59
02960                       00000AB7            .5A:
02961                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
02962 0AB7           8B46         FE            mov	ax,-2[bp]
02963 0ABA           48                         dec	ax
02964 0ABB           8946         FE            mov	-2[bp],ax
02965                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
02966 0ABE           85C0                       test	ax,ax
02967 0AC0           75           D9            jne	.58
02968                       00000AC2            .59:
02969                       00000AC2            .56:
02970                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
02971 0AC2           B8                   2000  mov	ax,#$2000
02972 0AC5           8946         FE            mov	-2[bp],ax
02973                                           !BCC_EOS
02974                                           ! 1032     while (--max > 0) {
02975 0AC8           EB           2B            jmp .5C
02976                       00000ACA            .5D:
02977                                           ! 1033         outb(0x80, 0x00);
02978                                           ! Debug: list int = const 0 (used reg = )
02979 0ACA           31C0                       xor	ax,ax
02980 0ACC           50                         push	ax
02981                                           ! Debug: list int = const $80 (used reg = )
02982 0ACD           B8                   0080  mov	ax,#$80
02983 0AD0           50                         push	ax
02984                                           ! Debug: func () void = outb+0 (used reg = )
02985 0AD1           E8         FA8A            call	_outb
02986 0AD4           83C4                   04  add	sp,*4
02987                                           !BCC_EOS
02988                                           ! 1034         if (inb(0x64) & 0x01) {
02989                                           ! Debug: list int = const $64 (used reg = )
02990 0AD7           B8                   0064  mov	ax,*$64
02991 0ADA           50                         push	ax
02992                                           ! Debug: func () unsigned char = inb+0 (used reg = )
02993 0ADB           E8         FA6A            call	_inb
02994 0ADE           44                         inc	sp
02995 0ADF           44                         inc	sp
02996                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
02997 0AE0           24                     01  and	al,*1
02998 0AE2           84C0                       test	al,al
02999 0AE4           74           0F            je  	.5E
03000                       00000AE6            .5F:
03001                                           ! 1035             inb(0x60);
03002                                           ! Debug: list int = const $60 (used reg = )
03003 0AE6           B8                   0060  mov	ax,*$60
03004 0AE9           50                         push	ax
03005                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03006 0AEA           E8         FA5B            call	_inb
03007 0AED           44                         inc	sp
03008 0AEE           44                         inc	sp
03009                                           !BCC_EOS
03010                                           ! 1036             max = 0x2000;
03011                                           ! Debug: eq int = const $2000 to unsigned short max = [S+4-4] (used reg = )
03012 0AEF           B8                   2000  mov	ax,#$2000
03013 0AF2           8946         FE            mov	-2[bp],ax
03014                                           !BCC_EOS
03015                                           ! 1037             }
03016                                           ! 1038         }
03017                       00000AF5            .5E:
03018                                           ! 1039     outb(0x64, 0xaa);
03019                       00000AF5            .5C:
03020                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03021 0AF5           8B46         FE            mov	ax,-2[bp]
03022 0AF8           48                         dec	ax
03023 0AF9           8946         FE            mov	-2[bp],ax
03024                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03025 0AFC           85C0                       test	ax,ax
03026 0AFE           75           CA            jne	.5D
03027                       00000B00            .60:
03028                       00000B00            .5B:
03029                                           ! Debug: list int = const $AA (used reg = )
03030 0B00           B8                   00AA  mov	ax,#$AA
03031 0B03           50                         push	ax
03032                                           ! Debug: list int = const $64 (used reg = )
03033 0B04           B8                   0064  mov	ax,*$64
03034 0B07           50                         push	ax
03035                                           ! Debug: func () void = outb+0 (used reg = )
03036 0B08           E8         FA53            call	_outb
03037 0B0B           83C4                   04  add	sp,*4
03038                                           !BCC_EOS
03039                                           ! 1040     max=0xffff;
03040                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03041 0B0E           B8                   FFFF  mov	ax,#$FFFF
03042 0B11           8946         FE            mov	-2[bp],ax
03043                                           !BCC_EOS
03044                                           ! 1041     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03045 0B14           EB           0D            jmp .62
03046                       00000B16            .63:
03047                                           ! Debug: list int = const 0 (used reg = )
03048 0B16           31C0                       xor	ax,ax
03049 0B18           50                         push	ax
03050                                           ! Debug: list int = const $80 (used reg = )
03051 0B19           B8                   0080  mov	ax,#$80
03052 0B1C           50                         push	ax
03053                                           ! Debug: func () void = outb+0 (used reg = )
03054 0B1D           E8         FA3E            call	_outb
03055 0B20           83C4                   04  add	sp,*4
03056                                           !BCC_EOS
03057                                           ! 1042     if (max==0x0) keyboard_panic(00);
03058                       00000B23            .62:
03059                                           ! Debug: list int = const $64 (used reg = )
03060 0B23           B8                   0064  mov	ax,*$64
03061 0B26           50                         push	ax
03062                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03063 0B27           E8         FA1E            call	_inb
03064 0B2A           44                         inc	sp
03065 0B2B           44                         inc	sp
03066                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03067 0B2C           24                     02  and	al,*2
03068 0B2E           84C0                       test	al,al
03069 0B30           74           0B            je  	.64
03070                       00000B32            .65:
03071                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03072 0B32           8B46         FE            mov	ax,-2[bp]
03073 0B35           48                         dec	ax
03074 0B36           8946         FE            mov	-2[bp],ax
03075                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03076 0B39           85C0                       test	ax,ax
03077 0B3B           75           D9            jne	.63
03078                       00000B3D            .64:
03079                       00000B3D            .61:
03080                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03081 0B3D           8B46         FE            mov	ax,-2[bp]
03082 0B40           85C0                       test	ax,ax
03083 0B42           75           08            jne 	.66
03084                       00000B44            .67:
03085                                           ! Debug: list int = const 0 (used reg = )
03086 0B44           31C0                       xor	ax,ax
03087 0B46           50                         push	ax
03088                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03089 0B47           E8         0408            call	_keyboard_panic
03090 0B4A           44                         inc	sp
03091 0B4B           44                         inc	sp
03092                                           !BCC_EOS
03093                                           ! 1043     max=0xffff;
03094                       00000B4C            .66:
03095                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03096 0B4C           B8                   FFFF  mov	ax,#$FFFF
03097 0B4F           8946         FE            mov	-2[bp],ax
03098                                           !BCC_EOS
03099                                           ! 1044     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
03100 0B52           EB           0E            jmp .69
03101                       00000B54            .6A:
03102                                           ! Debug: list int = const 1 (used reg = )
03103 0B54           B8                   0001  mov	ax,*1
03104 0B57           50                         push	ax
03105                                           ! Debug: list int = const $80 (used reg = )
03106 0B58           B8                   0080  mov	ax,#$80
03107 0B5B           50                         push	ax
03108                                           ! Debug: func () void = outb+0 (used reg = )
03109 0B5C           E8         F9FF            call	_outb
03110 0B5F           83C4                   04  add	sp,*4
03111                                           !BCC_EOS
03112                                           ! 1045     if (max==0x0) keyboard_panic(01);
03113                       00000B62            .69:
03114                                           ! Debug: list int = const $64 (used reg = )
03115 0B62           B8                   0064  mov	ax,*$64
03116 0B65           50                         push	ax
03117                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03118 0B66           E8         F9DF            call	_inb
03119 0B69           44                         inc	sp
03120 0B6A           44                         inc	sp
03121                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03122 0B6B           24                     01  and	al,*1
03123                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03124 0B6D           84C0                       test	al,al
03125 0B6F           75           0B            jne 	.6B
03126                       00000B71            .6C:
03127                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03128 0B71           8B46         FE            mov	ax,-2[bp]
03129 0B74           48                         dec	ax
03130 0B75           8946         FE            mov	-2[bp],ax
03131                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03132 0B78           85C0                       test	ax,ax
03133 0B7A           75           D8            jne	.6A
03134                       00000B7C            .6B:
03135                       00000B7C            .68:
03136                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03137 0B7C           8B46         FE            mov	ax,-2[bp]
03138 0B7F           85C0                       test	ax,ax
03139 0B81           75           09            jne 	.6D
03140                       00000B83            .6E:
03141                                           ! Debug: list int = const 1 (used reg = )
03142 0B83           B8                   0001  mov	ax,*1
03143 0B86           50                         push	ax
03144                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03145 0B87           E8         03C8            call	_keyboard_panic
03146 0B8A           44                         inc	sp
03147 0B8B           44                         inc	sp
03148                                           !BCC_EOS
03149                                           ! 1046     if ((inb(0x60) != 0x55)){
03150                       00000B8C            .6D:
03151                                           ! Debug: list int = const $60 (used reg = )
03152 0B8C           B8                   0060  mov	ax,*$60
03153 0B8F           50                         push	ax
03154                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03155 0B90           E8         F9B5            call	_inb
03156 0B93           44                         inc	sp
03157 0B94           44                         inc	sp
03158                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03159 0B95           3C                     55  cmp	al,*$55
03160 0B97           74           09            je  	.6F
03161                       00000B99            .70:
03162                                           ! 1047         keyboard_panic(991);
03163                                           ! Debug: list int = const $3DF (used reg = )
03164 0B99           B8                   03DF  mov	ax,#$3DF
03165 0B9C           50                         push	ax
03166                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03167 0B9D           E8         03B2            call	_keyboard_panic
03168 0BA0           44                         inc	sp
03169 0BA1           44                         inc	sp
03170                                           !BCC_EOS
03171                                           ! 1048     }
03172                                           ! 1049     outb(0x64,0xab);
03173                       00000BA2            .6F:
03174                                           ! Debug: list int = const $AB (used reg = )
03175 0BA2           B8                   00AB  mov	ax,#$AB
03176 0BA5           50                         push	ax
03177                                           ! Debug: list int = const $64 (used reg = )
03178 0BA6           B8                   0064  mov	ax,*$64
03179 0BA9           50                         push	ax
03180                                           ! Debug: func () void = outb+0 (used reg = )
03181 0BAA           E8         F9B1            call	_outb
03182 0BAD           83C4                   04  add	sp,*4
03183                                           !BCC_EOS
03184                                           ! 1050     max=0xffff;
03185                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03186 0BB0           B8                   FFFF  mov	ax,#$FFFF
03187 0BB3           8946         FE            mov	-2[bp],ax
03188                                           !BCC_EOS
03189                                           ! 1051     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
03190 0BB6           EB           0E            jmp .72
03191                       00000BB8            .73:
03192                                           ! Debug: list int = const $10 (used reg = )
03193 0BB8           B8                   0010  mov	ax,*$10
03194 0BBB           50                         push	ax
03195                                           ! Debug: list int = const $80 (used reg = )
03196 0BBC           B8                   0080  mov	ax,#$80
03197 0BBF           50                         push	ax
03198                                           ! Debug: func () void = outb+0 (used reg = )
03199 0BC0           E8         F99B            call	_outb
03200 0BC3           83C4                   04  add	sp,*4
03201                                           !BCC_EOS
03202                                           ! 1052     if (max==0x0) keyboard_panic(10);
03203                       00000BC6            .72:
03204                                           ! Debug: list int = const $64 (used reg = )
03205 0BC6           B8                   0064  mov	ax,*$64
03206 0BC9           50                         push	ax
03207                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03208 0BCA           E8         F97B            call	_inb
03209 0BCD           44                         inc	sp
03210 0BCE           44                         inc	sp
03211                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03212 0BCF           24                     02  and	al,*2
03213 0BD1           84C0                       test	al,al
03214 0BD3           74           0B            je  	.74
03215                       00000BD5            .75:
03216                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03217 0BD5           8B46         FE            mov	ax,-2[bp]
03218 0BD8           48                         dec	ax
03219 0BD9           8946         FE            mov	-2[bp],ax
03220                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03221 0BDC           85C0                       test	ax,ax
03222 0BDE           75           D8            jne	.73
03223                       00000BE0            .74:
03224                       00000BE0            .71:
03225                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03226 0BE0           8B46         FE            mov	ax,-2[bp]
03227 0BE3           85C0                       test	ax,ax
03228 0BE5           75           09            jne 	.76
03229                       00000BE7            .77:
03230                                           ! Debug: list int = const $A (used reg = )
03231 0BE7           B8                   000A  mov	ax,*$A
03232 0BEA           50                         push	ax
03233                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03234 0BEB           E8         0364            call	_keyboard_panic
03235 0BEE           44                         inc	sp
03236 0BEF           44                         inc	sp
03237                                           !BCC_EOS
03238                                           ! 1053     max=0xffff;
03239                       00000BF0            .76:
03240                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03241 0BF0           B8                   FFFF  mov	ax,#$FFFF
03242 0BF3           8946         FE            mov	-2[bp],ax
03243                                           !BCC_EOS
03244                                           ! 1054     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
03245 0BF6           EB           0E            jmp .79
03246                       00000BF8            .7A:
03247                                           ! Debug: list int = const $11 (used reg = )
03248 0BF8           B8                   0011  mov	ax,*$11
03249 0BFB           50                         push	ax
03250                                           ! Debug: list int = const $80 (used reg = )
03251 0BFC           B8                   0080  mov	ax,#$80
03252 0BFF           50                         push	ax
03253                                           ! Debug: func () void = outb+0 (used reg = )
03254 0C00           E8         F95B            call	_outb
03255 0C03           83C4                   04  add	sp,*4
03256                                           !BCC_EOS
03257                                           ! 1055     if (max==0x0) keyboard_panic(11);
03258                       00000C06            .79:
03259                                           ! Debug: list int = const $64 (used reg = )
03260 0C06           B8                   0064  mov	ax,*$64
03261 0C09           50                         push	ax
03262                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03263 0C0A           E8         F93B            call	_inb
03264 0C0D           44                         inc	sp
03265 0C0E           44                         inc	sp
03266                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03267 0C0F           24                     01  and	al,*1
03268                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03269 0C11           84C0                       test	al,al
03270 0C13           75           0B            jne 	.7B
03271                       00000C15            .7C:
03272                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03273 0C15           8B46         FE            mov	ax,-2[bp]
03274 0C18           48                         dec	ax
03275 0C19           8946         FE            mov	-2[bp],ax
03276                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03277 0C1C           85C0                       test	ax,ax
03278 0C1E           75           D8            jne	.7A
03279                       00000C20            .7B:
03280                       00000C20            .78:
03281                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03282 0C20           8B46         FE            mov	ax,-2[bp]
03283 0C23           85C0                       test	ax,ax
03284 0C25           75           09            jne 	.7D
03285                       00000C27            .7E:
03286                                           ! Debug: list int = const $B (used reg = )
03287 0C27           B8                   000B  mov	ax,*$B
03288 0C2A           50                         push	ax
03289                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03290 0C2B           E8         0324            call	_keyboard_panic
03291 0C2E           44                         inc	sp
03292 0C2F           44                         inc	sp
03293                                           !BCC_EOS
03294                                           ! 1056     if ((inb(0x60) != 0x00)) {
03295                       00000C30            .7D:
03296                                           ! Debug: list int = const $60 (used reg = )
03297 0C30           B8                   0060  mov	ax,*$60
03298 0C33           50                         push	ax
03299                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03300 0C34           E8         F911            call	_inb
03301 0C37           44                         inc	sp
03302 0C38           44                         inc	sp
03303                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
03304 0C39           84C0                       test	al,al
03305 0C3B           74           09            je  	.7F
03306                       00000C3D            .80:
03307                                           ! 1057         keyboard_panic(992);
03308                                           ! Debug: list int = const $3E0 (used reg = )
03309 0C3D           B8                   03E0  mov	ax,#$3E0
03310 0C40           50                         push	ax
03311                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03312 0C41           E8         030E            call	_keyboard_panic
03313 0C44           44                         inc	sp
03314 0C45           44                         inc	sp
03315                                           !BCC_EOS
03316                                           ! 1058     }
03317                                           ! 1059     outb(0x64,0xae);
03318                       00000C46            .7F:
03319                                           ! Debug: list int = const $AE (used reg = )
03320 0C46           B8                   00AE  mov	ax,#$AE
03321 0C49           50                         push	ax
03322                                           ! Debug: list int = const $64 (used reg = )
03323 0C4A           B8                   0064  mov	ax,*$64
03324 0C4D           50                         push	ax
03325                                           ! Debug: func () void = outb+0 (used reg = )
03326 0C4E           E8         F90D            call	_outb
03327 0C51           83C4                   04  add	sp,*4
03328                                           !BCC_EOS
03329                                           ! 1060     outb(0x64,0xa8);
03330                                           ! Debug: list int = const $A8 (used reg = )
03331 0C54           B8                   00A8  mov	ax,#$A8
03332 0C57           50                         push	ax
03333                                           ! Debug: list int = const $64 (used reg = )
03334 0C58           B8                   0064  mov	ax,*$64
03335 0C5B           50                         push	ax
03336                                           ! Debug: func () void = outb+0 (used reg = )
03337 0C5C           E8         F8FF            call	_outb
03338 0C5F           83C4                   04  add	sp,*4
03339                                           !BCC_EOS
03340                                           ! 1061     outb(0x60, 0xff);
03341                                           ! Debug: list int = const $FF (used reg = )
03342 0C62           B8                   00FF  mov	ax,#$FF
03343 0C65           50                         push	ax
03344                                           ! Debug: list int = const $60 (used reg = )
03345 0C66           B8                   0060  mov	ax,*$60
03346 0C69           50                         push	ax
03347                                           ! Debug: func () void = outb+0 (used reg = )
03348 0C6A           E8         F8F1            call	_outb
03349 0C6D           83C4                   04  add	sp,*4
03350                                           !BCC_EOS
03351                                           ! 1062     max=0xffff;
03352                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03353 0C70           B8                   FFFF  mov	ax,#$FFFF
03354 0C73           8946         FE            mov	-2[bp],ax
03355                                           !BCC_EOS
03356                                           ! 1063     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20);
03357 0C76           EB           0E            jmp .82
03358                       00000C78            .83:
03359                                           ! Debug: list int = const $20 (used reg = )
03360 0C78           B8                   0020  mov	ax,*$20
03361 0C7B           50                         push	ax
03362                                           ! Debug: list int = const $80 (used reg = )
03363 0C7C           B8                   0080  mov	ax,#$80
03364 0C7F           50                         push	ax
03365                                           ! Debug: func () void = outb+0 (used reg = )
03366 0C80           E8         F8DB            call	_outb
03367 0C83           83C4                   04  add	sp,*4
03368                                           !BCC_EOS
03369                                           ! 1064     if (max==0x0) keyboard_panic(20);
03370                       00000C86            .82:
03371                                           ! Debug: list int = const $64 (used reg = )
03372 0C86           B8                   0064  mov	ax,*$64
03373 0C89           50                         push	ax
03374                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03375 0C8A           E8         F8BB            call	_inb
03376 0C8D           44                         inc	sp
03377 0C8E           44                         inc	sp
03378                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03379 0C8F           24                     02  and	al,*2
03380 0C91           84C0                       test	al,al
03381 0C93           74           0B            je  	.84
03382                       00000C95            .85:
03383                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03384 0C95           8B46         FE            mov	ax,-2[bp]
03385 0C98           48                         dec	ax
03386 0C99           8946         FE            mov	-2[bp],ax
03387                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03388 0C9C           85C0                       test	ax,ax
03389 0C9E           75           D8            jne	.83
03390                       00000CA0            .84:
03391                       00000CA0            .81:
03392                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03393 0CA0           8B46         FE            mov	ax,-2[bp]
03394 0CA3           85C0                       test	ax,ax
03395 0CA5           75           09            jne 	.86
03396                       00000CA7            .87:
03397                                           ! Debug: list int = const $14 (used reg = )
03398 0CA7           B8                   0014  mov	ax,*$14
03399 0CAA           50                         push	ax
03400                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03401 0CAB           E8         02A4            call	_keyboard_panic
03402 0CAE           44                         inc	sp
03403 0CAF           44                         inc	sp
03404                                           !BCC_EOS
03405                                           ! 1065     max=0xffff;
03406                       00000CB0            .86:
03407                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03408 0CB0           B8                   FFFF  mov	ax,#$FFFF
03409 0CB3           8946         FE            mov	-2[bp],ax
03410                                           !BCC_EOS
03411                                           ! 1066     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
03412 0CB6           EB           0E            jmp .89
03413                       00000CB8            .8A:
03414                                           ! Debug: list int = const $21 (used reg = )
03415 0CB8           B8                   0021  mov	ax,*$21
03416 0CBB           50                         push	ax
03417                                           ! Debug: list int = const $80 (used reg = )
03418 0CBC           B8                   0080  mov	ax,#$80
03419 0CBF           50                         push	ax
03420                                           ! Debug: func () void = outb+0 (used reg = )
03421 0CC0           E8         F89B            call	_outb
03422 0CC3           83C4                   04  add	sp,*4
03423                                           !BCC_EOS
03424                                           ! 1067     if (max==0x0) keyboard_panic(21);
03425                       00000CC6            .89:
03426                                           ! Debug: list int = const $64 (used reg = )
03427 0CC6           B8                   0064  mov	ax,*$64
03428 0CC9           50                         push	ax
03429                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03430 0CCA           E8         F87B            call	_inb
03431 0CCD           44                         inc	sp
03432 0CCE           44                         inc	sp
03433                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03434 0CCF           24                     01  and	al,*1
03435                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03436 0CD1           84C0                       test	al,al
03437 0CD3           75           0B            jne 	.8B
03438                       00000CD5            .8C:
03439                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03440 0CD5           8B46         FE            mov	ax,-2[bp]
03441 0CD8           48                         dec	ax
03442 0CD9           8946         FE            mov	-2[bp],ax
03443                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03444 0CDC           85C0                       test	ax,ax
03445 0CDE           75           D8            jne	.8A
03446                       00000CE0            .8B:
03447                       00000CE0            .88:
03448                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03449 0CE0           8B46         FE            mov	ax,-2[bp]
03450 0CE3           85C0                       test	ax,ax
03451 0CE5           75           09            jne 	.8D
03452                       00000CE7            .8E:
03453                                           ! Debug: list int = const $15 (used reg = )
03454 0CE7           B8                   0015  mov	ax,*$15
03455 0CEA           50                         push	ax
03456                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03457 0CEB           E8         0264            call	_keyboard_panic
03458 0CEE           44                         inc	sp
03459 0CEF           44                         inc	sp
03460                                           !BCC_EOS
03461                                           ! 1068     if ((inb(0x60) != 0xfa)) {
03462                       00000CF0            .8D:
03463                                           ! Debug: list int = const $60 (used reg = )
03464 0CF0           B8                   0060  mov	ax,*$60
03465 0CF3           50                         push	ax
03466                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03467 0CF4           E8         F851            call	_inb
03468 0CF7           44                         inc	sp
03469 0CF8           44                         inc	sp
03470                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
03471 0CF9           3C                     FA  cmp	al,#$FA
03472 0CFB           74           09            je  	.8F
03473                       00000CFD            .90:
03474                                           ! 1069         keyboard_panic(993);
03475                                           ! Debug: list int = const $3E1 (used reg = )
03476 0CFD           B8                   03E1  mov	ax,#$3E1
03477 0D00           50                         push	ax
03478                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03479 0D01           E8         024E            call	_keyboard_panic
03480 0D04           44                         inc	sp
03481 0D05           44                         inc	sp
03482                                           !BCC_EOS
03483                                           ! 1070     }
03484                                           ! 1071     max=0xffff;
03485                       00000D06            .8F:
03486                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03487 0D06           B8                   FFFF  mov	ax,#$FFFF
03488 0D09           8946         FE            mov	-2[bp],ax
03489                                           !BCC_EOS
03490                                           ! 1072     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
03491 0D0C           EB           0E            jmp .92
03492                       00000D0E            .93:
03493                                           ! Debug: list int = const $31 (used reg = )
03494 0D0E           B8                   0031  mov	ax,*$31
03495 0D11           50                         push	ax
03496                                           ! Debug: list int = const $80 (used reg = )
03497 0D12           B8                   0080  mov	ax,#$80
03498 0D15           50                         push	ax
03499                                           ! Debug: func () void = outb+0 (used reg = )
03500 0D16           E8         F845            call	_outb
03501 0D19           83C4                   04  add	sp,*4
03502                                           !BCC_EOS
03503                                           ! 1073     if (max==0x0) keyboard_panic(31);
03504                       00000D1C            .92:
03505                                           ! Debug: list int = const $64 (used reg = )
03506 0D1C           B8                   0064  mov	ax,*$64
03507 0D1F           50                         push	ax
03508                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03509 0D20           E8         F825            call	_inb
03510 0D23           44                         inc	sp
03511 0D24           44                         inc	sp
03512                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03513 0D25           24                     01  and	al,*1
03514                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03515 0D27           84C0                       test	al,al
03516 0D29           75           0B            jne 	.94
03517                       00000D2B            .95:
03518                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03519 0D2B           8B46         FE            mov	ax,-2[bp]
03520 0D2E           48                         dec	ax
03521 0D2F           8946         FE            mov	-2[bp],ax
03522                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03523 0D32           85C0                       test	ax,ax
03524 0D34           75           D8            jne	.93
03525                       00000D36            .94:
03526                       00000D36            .91:
03527                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03528 0D36           8B46         FE            mov	ax,-2[bp]
03529 0D39           85C0                       test	ax,ax
03530 0D3B           75           09            jne 	.96
03531                       00000D3D            .97:
03532                                           ! Debug: list int = const $1F (used reg = )
03533 0D3D           B8                   001F  mov	ax,*$1F
03534 0D40           50                         push	ax
03535                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03536 0D41           E8         020E            call	_keyboard_panic
03537 0D44           44                         inc	sp
03538 0D45           44                         inc	sp
03539                                           !BCC_EOS
03540                                           ! 1074     if ((inb(0x60) != 0xaa)) {
03541                       00000D46            .96:
03542                                           ! Debug: list int = const $60 (used reg = )
03543 0D46           B8                   0060  mov	ax,*$60
03544 0D49           50                         push	ax
03545                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03546 0D4A           E8         F7FB            call	_inb
03547 0D4D           44                         inc	sp
03548 0D4E           44                         inc	sp
03549                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
03550 0D4F           3C                     AA  cmp	al,#$AA
03551 0D51           74           09            je  	.98
03552                       00000D53            .99:
03553                                           ! 1075         keyboard_panic(994);
03554                                           ! Debug: list int = const $3E2 (used reg = )
03555 0D53           B8                   03E2  mov	ax,#$3E2
03556 0D56           50                         push	ax
03557                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03558 0D57           E8         01F8            call	_keyboard_panic
03559 0D5A           44                         inc	sp
03560 0D5B           44                         inc	sp
03561                                           !BCC_EOS
03562                                           ! 1076     }
03563                                           ! 1077     outb(0x60, 0xf5);
03564                       00000D5C            .98:
03565                                           ! Debug: list int = const $F5 (used reg = )
03566 0D5C           B8                   00F5  mov	ax,#$F5
03567 0D5F           50                         push	ax
03568                                           ! Debug: list int = const $60 (used reg = )
03569 0D60           B8                   0060  mov	ax,*$60
03570 0D63           50                         push	ax
03571                                           ! Debug: func () void = outb+0 (used reg = )
03572 0D64           E8         F7F7            call	_outb
03573 0D67           83C4                   04  add	sp,*4
03574                                           !BCC_EOS
03575                                           ! 1078     max=0xffff;
03576                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03577 0D6A           B8                   FFFF  mov	ax,#$FFFF
03578 0D6D           8946         FE            mov	-2[bp],ax
03579                                           !BCC_EOS
03580                                           ! 1079     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
03581 0D70           EB           0E            jmp .9B
03582                       00000D72            .9C:
03583                                           ! Debug: list int = const $40 (used reg = )
03584 0D72           B8                   0040  mov	ax,*$40
03585 0D75           50                         push	ax
03586                                           ! Debug: list int = const $80 (used reg = )
03587 0D76           B8                   0080  mov	ax,#$80
03588 0D79           50                         push	ax
03589                                           ! Debug: func () void = outb+0 (used reg = )
03590 0D7A           E8         F7E1            call	_outb
03591 0D7D           83C4                   04  add	sp,*4
03592                                           !BCC_EOS
03593                                           ! 1080     if (max==0x0) keyboard_panic(40);
03594                       00000D80            .9B:
03595                                           ! Debug: list int = const $64 (used reg = )
03596 0D80           B8                   0064  mov	ax,*$64
03597 0D83           50                         push	ax
03598                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03599 0D84           E8         F7C1            call	_inb
03600 0D87           44                         inc	sp
03601 0D88           44                         inc	sp
03602                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03603 0D89           24                     02  and	al,*2
03604 0D8B           84C0                       test	al,al
03605 0D8D           74           0B            je  	.9D
03606                       00000D8F            .9E:
03607                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03608 0D8F           8B46         FE            mov	ax,-2[bp]
03609 0D92           48                         dec	ax
03610 0D93           8946         FE            mov	-2[bp],ax
03611                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03612 0D96           85C0                       test	ax,ax
03613 0D98           75           D8            jne	.9C
03614                       00000D9A            .9D:
03615                       00000D9A            .9A:
03616                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03617 0D9A           8B46         FE            mov	ax,-2[bp]
03618 0D9D           85C0                       test	ax,ax
03619 0D9F           75           09            jne 	.9F
03620                       00000DA1            .A0:
03621                                           ! Debug: list int = const $28 (used reg = )
03622 0DA1           B8                   0028  mov	ax,*$28
03623 0DA4           50                         push	ax
03624                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03625 0DA5           E8         01AA            call	_keyboard_panic
03626 0DA8           44                         inc	sp
03627 0DA9           44                         inc	sp
03628                                           !BCC_EOS
03629                                           ! 1081     max=0xffff;
03630                       00000DAA            .9F:
03631                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03632 0DAA           B8                   FFFF  mov	ax,#$FFFF
03633 0DAD           8946         FE            mov	-2[bp],ax
03634                                           !BCC_EOS
03635                                           ! 1082     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) 
03636                                           ! 1082 ) outb(0x80, 0x41);
03637 0DB0           EB           0E            jmp .A2
03638                       00000DB2            .A3:
03639                                           ! Debug: list int = const $41 (used reg = )
03640 0DB2           B8                   0041  mov	ax,*$41
03641 0DB5           50                         push	ax
03642                                           ! Debug: list int = const $80 (used reg = )
03643 0DB6           B8                   0080  mov	ax,#$80
03644 0DB9           50                         push	ax
03645                                           ! Debug: func () void = outb+0 (used reg = )
03646 0DBA           E8         F7A1            call	_outb
03647 0DBD           83C4                   04  add	sp,*4
03648                                           !BCC_EOS
03649                                           ! 1083     if (max==0x0) keyboard_panic(41);
03650                       00000DC0            .A2:
03651                                           ! Debug: list int = const $64 (used reg = )
03652 0DC0           B8                   0064  mov	ax,*$64
03653 0DC3           50                         push	ax
03654                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03655 0DC4           E8         F781            call	_inb
03656 0DC7           44                         inc	sp
03657 0DC8           44                         inc	sp
03658                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03659 0DC9           24                     01  and	al,*1
03660                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03661 0DCB           84C0                       test	al,al
03662 0DCD           75           0B            jne 	.A4
03663                       00000DCF            .A5:
03664                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03665 0DCF           8B46         FE            mov	ax,-2[bp]
03666 0DD2           48                         dec	ax
03667 0DD3           8946         FE            mov	-2[bp],ax
03668                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03669 0DD6           85C0                       test	ax,ax
03670 0DD8           75           D8            jne	.A3
03671                       00000DDA            .A4:
03672                       00000DDA            .A1:
03673                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03674 0DDA           8B46         FE            mov	ax,-2[bp]
03675 0DDD           85C0                       test	ax,ax
03676 0DDF           75           09            jne 	.A6
03677                       00000DE1            .A7:
03678                                           ! Debug: list int = const $29 (used reg = )
03679 0DE1           B8                   0029  mov	ax,*$29
03680 0DE4           50                         push	ax
03681                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03682 0DE5           E8         016A            call	_keyboard_panic
03683 0DE8           44                         inc	sp
03684 0DE9           44                         inc	sp
03685                                           !BCC_EOS
03686                                           ! 1084     if ((inb(0x60) != 0xfa)) {
03687                       00000DEA            .A6:
03688                                           ! Debug: list int = const $60 (used reg = )
03689 0DEA           B8                   0060  mov	ax,*$60
03690 0DED           50                         push	ax
03691                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03692 0DEE           E8         F757            call	_inb
03693 0DF1           44                         inc	sp
03694 0DF2           44                         inc	sp
03695                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
03696 0DF3           3C                     FA  cmp	al,#$FA
03697 0DF5           74           09            je  	.A8
03698                       00000DF7            .A9:
03699                                           ! 1085         keyboard_panic(995);
03700                                           ! Debug: list int = const $3E3 (used reg = )
03701 0DF7           B8                   03E3  mov	ax,#$3E3
03702 0DFA           50                         push	ax
03703                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03704 0DFB           E8         0154            call	_keyboard_panic
03705 0DFE           44                         inc	sp
03706 0DFF           44                         inc	sp
03707                                           !BCC_EOS
03708                                           ! 1086     }
03709                                           ! 1087     outb(0x64, 0x60);
03710                       00000E00            .A8:
03711                                           ! Debug: list int = const $60 (used reg = )
03712 0E00           B8                   0060  mov	ax,*$60
03713 0E03           50                         push	ax
03714                                           ! Debug: list int = const $64 (used reg = )
03715 0E04           B8                   0064  mov	ax,*$64
03716 0E07           50                         push	ax
03717                                           ! Debug: func () void = outb+0 (used reg = )
03718 0E08           E8         F753            call	_outb
03719 0E0B           83C4                   04  add	sp,*4
03720                                           !BCC_EOS
03721                                           ! 1088     max=0xffff;
03722                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03723 0E0E           B8                   FFFF  mov	ax,#$FFFF
03724 0E11           8946         FE            mov	-2[bp],ax
03725                                           !BCC_EOS
03726                                           ! 1089     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
03727 0E14           EB           0E            jmp .AB
03728                       00000E16            .AC:
03729                                           ! Debug: list int = const $50 (used reg = )
03730 0E16           B8                   0050  mov	ax,*$50
03731 0E19           50                         push	ax
03732                                           ! Debug: list int = const $80 (used reg = )
03733 0E1A           B8                   0080  mov	ax,#$80
03734 0E1D           50                         push	ax
03735                                           ! Debug: func () void = outb+0 (used reg = )
03736 0E1E           E8         F73D            call	_outb
03737 0E21           83C4                   04  add	sp,*4
03738                                           !BCC_EOS
03739                                           ! 1090     if (max==0x0) keyboard_panic(50);
03740                       00000E24            .AB:
03741                                           ! Debug: list int = const $64 (used reg = )
03742 0E24           B8                   0064  mov	ax,*$64
03743 0E27           50                         push	ax
03744                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03745 0E28           E8         F71D            call	_inb
03746 0E2B           44                         inc	sp
03747 0E2C           44                         inc	sp
03748                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03749 0E2D           24                     02  and	al,*2
03750 0E2F           84C0                       test	al,al
03751 0E31           74           0B            je  	.AD
03752                       00000E33            .AE:
03753                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03754 0E33           8B46         FE            mov	ax,-2[bp]
03755 0E36           48                         dec	ax
03756 0E37           8946         FE            mov	-2[bp],ax
03757                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03758 0E3A           85C0                       test	ax,ax
03759 0E3C           75           D8            jne	.AC
03760                       00000E3E            .AD:
03761                       00000E3E            .AA:
03762                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03763 0E3E           8B46         FE            mov	ax,-2[bp]
03764 0E41           85C0                       test	ax,ax
03765 0E43           75           09            jne 	.AF
03766                       00000E45            .B0:
03767                                           ! Debug: list int = const $32 (used reg = )
03768 0E45           B8                   0032  mov	ax,*$32
03769 0E48           50                         push	ax
03770                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03771 0E49           E8         0106            call	_keyboard_panic
03772 0E4C           44                         inc	sp
03773 0E4D           44                         inc	sp
03774                                           !BCC_EOS
03775                                           ! 1091     outb(0x60, 0x61);
03776                       00000E4E            .AF:
03777                                           ! Debug: list int = const $61 (used reg = )
03778 0E4E           B8                   0061  mov	ax,*$61
03779 0E51           50                         push	ax
03780                                           ! Debug: list int = const $60 (used reg = )
03781 0E52           B8                   0060  mov	ax,*$60
03782 0E55           50                         push	ax
03783                                           ! Debug: func () void = outb+0 (used reg = )
03784 0E56           E8         F705            call	_outb
03785 0E59           83C4                   04  add	sp,*4
03786                                           !BCC_EOS
03787                                           ! 1092     max=0xffff;
03788                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03789 0E5C           B8                   FFFF  mov	ax,#$FFFF
03790 0E5F           8946         FE            mov	-2[bp],ax
03791                                           !BCC_EOS
03792                                           ! 1093     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
03793 0E62           EB           0E            jmp .B2
03794                       00000E64            .B3:
03795                                           ! Debug: list int = const $60 (used reg = )
03796 0E64           B8                   0060  mov	ax,*$60
03797 0E67           50                         push	ax
03798                                           ! Debug: list int = const $80 (used reg = )
03799 0E68           B8                   0080  mov	ax,#$80
03800 0E6B           50                         push	ax
03801                                           ! Debug: func () void = outb+0 (used reg = )
03802 0E6C           E8         F6EF            call	_outb
03803 0E6F           83C4                   04  add	sp,*4
03804                                           !BCC_EOS
03805                                           ! 1094     if (max==0x0) keyboard_panic(60);
03806                       00000E72            .B2:
03807                                           ! Debug: list int = const $64 (used reg = )
03808 0E72           B8                   0064  mov	ax,*$64
03809 0E75           50                         push	ax
03810                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03811 0E76           E8         F6CF            call	_inb
03812 0E79           44                         inc	sp
03813 0E7A           44                         inc	sp
03814                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03815 0E7B           24                     02  and	al,*2
03816 0E7D           84C0                       test	al,al
03817 0E7F           74           0B            je  	.B4
03818                       00000E81            .B5:
03819                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03820 0E81           8B46         FE            mov	ax,-2[bp]
03821 0E84           48                         dec	ax
03822 0E85           8946         FE            mov	-2[bp],ax
03823                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03824 0E88           85C0                       test	ax,ax
03825 0E8A           75           D8            jne	.B3
03826                       00000E8C            .B4:
03827                       00000E8C            .B1:
03828                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03829 0E8C           8B46         FE            mov	ax,-2[bp]
03830 0E8F           85C0                       test	ax,ax
03831 0E91           75           09            jne 	.B6
03832                       00000E93            .B7:
03833                                           ! Debug: list int = const $3C (used reg = )
03834 0E93           B8                   003C  mov	ax,*$3C
03835 0E96           50                         push	ax
03836                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03837 0E97           E8         00B8            call	_keyboard_panic
03838 0E9A           44                         inc	sp
03839 0E9B           44                         inc	sp
03840                                           !BCC_EOS
03841                                           ! 1095     outb(0x60, 0xf4);
03842                       00000E9C            .B6:
03843                                           ! Debug: list int = const $F4 (used reg = )
03844 0E9C           B8                   00F4  mov	ax,#$F4
03845 0E9F           50                         push	ax
03846                                           ! Debug: list int = const $60 (used reg = )
03847 0EA0           B8                   0060  mov	ax,*$60
03848 0EA3           50                         push	ax
03849                                           ! Debug: func () void = outb+0 (used reg = )
03850 0EA4           E8         F6B7            call	_outb
03851 0EA7           83C4                   04  add	sp,*4
03852                                           !BCC_EOS
03853                                           ! 1096     max=0xffff;
03854                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03855 0EAA           B8                   FFFF  mov	ax,#$FFFF
03856 0EAD           8946         FE            mov	-2[bp],ax
03857                                           !BCC_EOS
03858                                           ! 1097     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
03859 0EB0           EB           0E            jmp .B9
03860                       00000EB2            .BA:
03861                                           ! Debug: list int = const $70 (used reg = )
03862 0EB2           B8                   0070  mov	ax,*$70
03863 0EB5           50                         push	ax
03864                                           ! Debug: list int = const $80 (used reg = )
03865 0EB6           B8                   0080  mov	ax,#$80
03866 0EB9           50                         push	ax
03867                                           ! Debug: func () void = outb+0 (used reg = )
03868 0EBA           E8         F6A1            call	_outb
03869 0EBD           83C4                   04  add	sp,*4
03870                                           !BCC_EOS
03871                                           ! 1098     if (max==0x0) keyboard_panic(70);
03872                       00000EC0            .B9:
03873                                           ! Debug: list int = const $64 (used reg = )
03874 0EC0           B8                   0064  mov	ax,*$64
03875 0EC3           50                         push	ax
03876                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03877 0EC4           E8         F681            call	_inb
03878 0EC7           44                         inc	sp
03879 0EC8           44                         inc	sp
03880                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03881 0EC9           24                     02  and	al,*2
03882 0ECB           84C0                       test	al,al
03883 0ECD           74           0B            je  	.BB
03884                       00000ECF            .BC:
03885                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03886 0ECF           8B46         FE            mov	ax,-2[bp]
03887 0ED2           48                         dec	ax
03888 0ED3           8946         FE            mov	-2[bp],ax
03889                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03890 0ED6           85C0                       test	ax,ax
03891 0ED8           75           D8            jne	.BA
03892                       00000EDA            .BB:
03893                       00000EDA            .B8:
03894                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03895 0EDA           8B46         FE            mov	ax,-2[bp]
03896 0EDD           85C0                       test	ax,ax
03897 0EDF           75           09            jne 	.BD
03898                       00000EE1            .BE:
03899                                           ! Debug: list int = const $46 (used reg = )
03900 0EE1           B8                   0046  mov	ax,*$46
03901 0EE4           50                         push	ax
03902                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03903 0EE5           E8         006A            call	_keyboard_panic
03904 0EE8           44                         inc	sp
03905 0EE9           44                         inc	sp
03906                                           !BCC_EOS
03907                                           ! 1099     max=0xffff;
03908                       00000EEA            .BD:
03909                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03910 0EEA           B8                   FFFF  mov	ax,#$FFFF
03911 0EED           8946         FE            mov	-2[bp],ax
03912                                           !BCC_EOS
03913                                           ! 1100     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
03914 0EF0           EB           0E            jmp .C0
03915                       00000EF2            .C1:
03916                                           ! Debug: list int = const $71 (used reg = )
03917 0EF2           B8                   0071  mov	ax,*$71
03918 0EF5           50                         push	ax
03919                                           ! Debug: list int = const $80 (used reg = )
03920 0EF6           B8                   0080  mov	ax,#$80
03921 0EF9           50                         push	ax
03922                                           ! Debug: func () void = outb+0 (used reg = )
03923 0EFA           E8         F661            call	_outb
03924 0EFD           83C4                   04  add	sp,*4
03925                                           !BCC_EOS
03926                                           ! 1101     if (max==0x0) keyboard_panic(70);
03927                       00000F00            .C0:
03928                                           ! Debug: list int = const $64 (used reg = )
03929 0F00           B8                   0064  mov	ax,*$64
03930 0F03           50                         push	ax
03931                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03932 0F04           E8         F641            call	_inb
03933 0F07           44                         inc	sp
03934 0F08           44                         inc	sp
03935                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03936 0F09           24                     01  and	al,*1
03937                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03938 0F0B           84C0                       test	al,al
03939 0F0D           75           0B            jne 	.C2
03940                       00000F0F            .C3:
03941                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03942 0F0F           8B46         FE            mov	ax,-2[bp]
03943 0F12           48                         dec	ax
03944 0F13           8946         FE            mov	-2[bp],ax
03945                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03946 0F16           85C0                       test	ax,ax
03947 0F18           75           D8            jne	.C1
03948                       00000F1A            .C2:
03949                       00000F1A            .BF:
03950                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03951 0F1A           8B46         FE            mov	ax,-2[bp]
03952 0F1D           85C0                       test	ax,ax
03953 0F1F           75           09            jne 	.C4
03954                       00000F21            .C5:
03955                                           ! Debug: list int = const $46 (used reg = )
03956 0F21           B8                   0046  mov	ax,*$46
03957 0F24           50                         push	ax
03958                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03959 0F25           E8         002A            call	_keyboard_panic
03960 0F28           44                         inc	sp
03961 0F29           44                         inc	sp
03962                                           !BCC_EOS
03963                                           ! 1102     if ((inb(0x60) != 0xfa)) {
03964                       00000F2A            .C4:
03965                                           ! Debug: list int = const $60 (used reg = )
03966 0F2A           B8                   0060  mov	ax,*$60
03967 0F2D           50                         push	ax
03968                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03969 0F2E           E8         F617            call	_inb
03970 0F31           44                         inc	sp
03971 0F32           44                         inc	sp
03972                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
03973 0F33           3C                     FA  cmp	al,#$FA
03974 0F35           74           09            je  	.C6
03975                       00000F37            .C7:
03976                                           ! 1103         keyboard_panic(996);
03977                                           ! Debug: list int = const $3E4 (used reg = )
03978 0F37           B8                   03E4  mov	ax,#$3E4
03979 0F3A           50                         push	ax
03980                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03981 0F3B           E8         0014            call	_keyboard_panic
03982 0F3E           44                         inc	sp
03983 0F3F           44                         inc	sp
03984                                           !BCC_EOS
03985                                           ! 1104     }
03986                                           ! 1105     outb(0x80, 0x77);
03987                       00000F40            .C6:
03988                                           ! Debug: list int = const $77 (used reg = )
03989 0F40           B8                   0077  mov	ax,*$77
03990 0F43           50                         push	ax
03991                                           ! Debug: list int = const $80 (used reg = )
03992 0F44           B8                   0080  mov	ax,#$80
03993 0F47           50                         push	ax
03994                                           ! Debug: func () void = outb+0 (used reg = )
03995 0F48           E8         F613            call	_outb
03996 0F4B           83C4                   04  add	sp,*4
03997                                           !BCC_EOS
03998                                           ! 1106 }
03999 0F4E           89EC                       mov	sp,bp
04000 0F50           5D                         pop	bp
04001 0F51           C3                         ret
04002                                           ! 1107   void
04003                                           ! 1108 keyboard_panic(status)
04004                                           ! 1109   Bit16u status;
04005                                           export	_keyboard_panic
04006                       00000F52            _keyboard_panic:
04007                                           !BCC_EOS
04008                                           ! 1110 {
04009                                           ! 1111   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04010 0F52           55                         push	bp
04011 0F53           89E5                       mov	bp,sp
04012                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04013 0F55           FF76         04            push	4[bp]
04014                                           ! Debug: list * char = .C8+0 (used reg = )
04015 0F58           BB                   DCE1  mov	bx,#.C8
04016 0F5B           53                         push	bx
04017                                           ! Debug: list int = const 7 (used reg = )
04018 0F5C           B8                   0007  mov	ax,*7
04019 0F5F           50                         push	ax
04020                                           ! Debug: func () void = bios_printf+0 (used reg = )
04021 0F60           E8         F946            call	_bios_printf
04022 0F63           89EC                       mov	sp,bp
04023                                           !BCC_EOS
04024                                           ! 1112 }
04025 0F65           5D                         pop	bp
04026 0F66           C3                         ret
04027                                           ! 1113   void
04028                                           ! Register BX used in function keyboard_panic
04029                                           ! 1114 machine_reset()
04030                                           ! 1115 {
04031                                           export	_machine_reset
04032                       00000F67            _machine_reset:
04033                                           ! 1116 #asm
04034                                           !BCC_ASM
04035                                           ;we must check whether 0xFE is set or not
04036                                           ;if it is s3 resume, just jmp back to normal Post Entry
04037                                           ;below port io will prevent s3 resume
04038 0F67           B0                     0F    mov al, #0x0f
04039 0F69           E6                     70    out 0x70, al
04040 0F6B           E4                     71    in al, 0x71
04041 0F6D           3C                     FE    cmp al, #0xFE
04042 0F6F   7503    E9         D0E7              jz post
04043                                           ! 1125 endasm
04044                                           !BCC_ENDASM
04045                                           ! 1126   outb(0x64, 0x60);
04046 0F74           55                         push	bp
04047 0F75           89E5                       mov	bp,sp
04048                                           ! Debug: list int = const $60 (used reg = )
04049 0F77           B8                   0060  mov	ax,*$60
04050 0F7A           50                         push	ax
04051                                           ! Debug: list int = const $64 (used reg = )
04052 0F7B           B8                   0064  mov	ax,*$64
04053 0F7E           50                         push	ax
04054                                           ! Debug: func () void = outb+0 (used reg = )
04055 0F7F           E8         F5DC            call	_outb
04056 0F82           89EC                       mov	sp,bp
04057                                           !BCC_EOS
04058                                           ! 1127   outb(0x60, 0x14);
04059                                           ! Debug: list int = const $14 (used reg = )
04060 0F84           B8                   0014  mov	ax,*$14
04061 0F87           50                         push	ax
04062                                           ! Debug: list int = const $60 (used reg = )
04063 0F88           B8                   0060  mov	ax,*$60
04064 0F8B           50                         push	ax
04065                                           ! Debug: func () void = outb+0 (used reg = )
04066 0F8C           E8         F5CF            call	_outb
04067 0F8F           89EC                       mov	sp,bp
04068                                           !BCC_EOS
04069                                           ! 1128   outb(0x64, 0xfe);
04070                                           ! Debug: list int = const $FE (used reg = )
04071 0F91           B8                   00FE  mov	ax,#$FE
04072 0F94           50                         push	ax
04073                                           ! Debug: list int = const $64 (used reg = )
04074 0F95           B8                   0064  mov	ax,*$64
04075 0F98           50                         push	ax
04076                                           ! Debug: func () void = outb+0 (used reg = )
04077 0F99           E8         F5C2            call	_outb
04078 0F9C           89EC                       mov	sp,bp
04079                                           !BCC_EOS
04080                                           ! 1129   bios_printf((2 | 4 | 1), "Couldn't reset the machine\n");
04081                                           ! Debug: list * char = .C9+0 (used reg = )
04082 0F9E           BB                   DCC5  mov	bx,#.C9
04083 0FA1           53                         push	bx
04084                                           ! Debug: list int = const 7 (used reg = )
04085 0FA2           B8                   0007  mov	ax,*7
04086 0FA5           50                         push	ax
04087                                           ! Debug: func () void = bios_printf+0 (used reg = )
04088 0FA6           E8         F900            call	_bios_printf
04089 0FA9           89EC                       mov	sp,bp
04090                                           !BCC_EOS
04091                                           ! 1130 }
04092 0FAB           5D                         pop	bp
04093 0FAC           C3                         ret
04094                                           ! 1131   void
04095                                           ! Register BX used in function machine_reset
04096                                           ! 1132 clobber_entry_point()
04097                                           ! 1133 {
04098                                           export	_clobber_entry_point
04099                       00000FAD            _clobber_entry_point:
04100                                           ! 1134     write_word(0xffff, 0x0001, machine_reset);
04101 0FAD           55                         push	bp
04102 0FAE           89E5                       mov	bp,sp
04103                                           ! Debug: cast * () void = const 0 to () void = machine_reset+0 (used reg = )
04104                                           ! Debug: list * () void = machine_reset+0 (used reg = )
04105 0FB0           BB                   0F67  mov	bx,#_machine_reset
04106 0FB3           53                         push	bx
04107                                           ! Debug: list int = const 1 (used reg = )
04108 0FB4           B8                   0001  mov	ax,*1
04109 0FB7           50                         push	ax
04110                                           ! Debug: list unsigned int = const $FFFF (used reg = )
04111 0FB8           B8                   FFFF  mov	ax,#$FFFF
04112 0FBB           50                         push	ax
04113                                           ! Debug: func () void = write_word+0 (used reg = )
04114 0FBC           E8         F67D            call	_write_word
04115 0FBF           89EC                       mov	sp,bp
04116                                           !BCC_EOS
04117                                           ! 1135 }
04118 0FC1           5D                         pop	bp
04119 0FC2           C3                         ret
04120                                           ! 1136   void
04121                                           ! Register BX used in function clobber_entry_point
04122                                           ! 1137 shutdown_status_panic(status)
04123                                           ! 1138   Bit16u status;
04124                                           export	_shutdown_status_panic
04125                       00000FC3            _shutdown_status_panic:
04126                                           !BCC_EOS
04127                                           ! 1139 {
04128                                           ! 1140   bios_printf((2 | 4 | 1), "Unimplemented shutdown status: %02x\n",(Bit8u)status);
04129 0FC3           55                         push	bp
04130 0FC4           89E5                       mov	bp,sp
04131                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04132 0FC6           8A46         04            mov	al,4[bp]
04133 0FC9           30E4                       xor	ah,ah
04134 0FCB           50                         push	ax
04135                                           ! Debug: list * char = .CA+0 (used reg = )
04136 0FCC           BB                   DCA0  mov	bx,#.CA
04137 0FCF           53                         push	bx
04138                                           ! Debug: list int = const 7 (used reg = )
04139 0FD0           B8                   0007  mov	ax,*7
04140 0FD3           50                         push	ax
04141                                           ! Debug: func () void = bios_printf+0 (used reg = )
04142 0FD4           E8         F8D2            call	_bios_printf
04143 0FD7           89EC                       mov	sp,bp
04144                                           !BCC_EOS
04145                                           ! 1141 }
04146 0FD9           5D                         pop	bp
04147 0FDA           C3                         ret
04148                                           ! 1142 void
04149                                           ! Register BX used in function shutdown_status_panic
04150                                           ! 1143 print_bios_banner()
04151                                           ! 1144 {
04152                                           export	_print_bios_banner
04153                       00000FDB            _print_bios_banner:
04154                                           ! 1145   bios_printf(2, "HVMAssist"" BIOS, %d cpu%s, ", 1, 1>1?"s":"");
04155 0FDB           55                         push	bp
04156 0FDC           89E5                       mov	bp,sp
04157                                           ! Debug: list * char = .CD+0 (used reg = )
04158 0FDE           BB                   DC82  mov	bx,#.CD
04159 0FE1           53                         push	bx
04160                                           ! Debug: list int = const 1 (used reg = )
04161 0FE2           B8                   0001  mov	ax,*1
04162 0FE5           50                         push	ax
04163                                           ! Debug: list * char = .CB+0 (used reg = )
04164 0FE6           BB                   DC85  mov	bx,#.CB
04165 0FE9           53                         push	bx
04166                                           ! Debug: list int = const 2 (used reg = )
04167 0FEA           B8                   0002  mov	ax,*2
04168 0FED           50                         push	ax
04169                                           ! Debug: func () void = bios_printf+0 (used reg = )
04170 0FEE           E8         F8B8            call	_bios_printf
04171 0FF1           89EC                       mov	sp,bp
04172                                           !BCC_EOS
04173                                           ! 1146   bios_printf(2, "%s %s\n", bios_cvs_version_string, bios_date_string);
04174                                           ! Debug: list * char = bios_date_string+0 (used reg = )
04175 0FF3           BB                   0177  mov	bx,#_bios_date_string
04176 0FF6           53                         push	bx
04177                                           ! Debug: list * char = bios_cvs_version_string+0 (used reg = )
04178 0FF7           BB                   0164  mov	bx,#_bios_cvs_version_string
04179 0FFA           53                         push	bx
04180                                           ! Debug: list * char = .CE+0 (used reg = )
04181 0FFB           BB                   DC7B  mov	bx,#.CE
04182 0FFE           53                         push	bx
04183                                           ! Debug: list int = const 2 (used reg = )
04184 0FFF           B8                   0002  mov	ax,*2
04185 1002           50                         push	ax
04186                                           ! Debug: func () void = bios_printf+0 (used reg = )
04187 1003           E8         F8A3            call	_bios_printf
04188 1006           89EC                       mov	sp,bp
04189                                           !BCC_EOS
04190                                           ! 1147   bios_printf(2, "TCG-enabled BIOS.\n");
04191                                           ! Debug: list * char = .CF+0 (used reg = )
04192 1008           BB                   DC68  mov	bx,#.CF
04193 100B           53                         push	bx
04194                                           ! Debug: list int = const 2 (used reg = )
04195 100C           B8                   0002  mov	ax,*2
04196 100F           50                         push	ax
04197                                           ! Debug: func () void = bios_printf+0 (used reg = )
04198 1010           E8         F896            call	_bios_printf
04199 1013           89EC                       mov	sp,bp
04200                                           !BCC_EOS
04201                                           ! 1148   bios_printf(2, "\n");
04202                                           ! Debug: list * char = .D0+0 (used reg = )
04203 1015           BB                   DC66  mov	bx,#.D0
04204 1018           53                         push	bx
04205                                           ! Debug: list int = const 2 (used reg = )
04206 1019           B8                   0002  mov	ax,*2
04207 101C           50                         push	ax
04208                                           ! Debug: func () void = bios_printf+0 (used reg = )
04209 101D           E8         F889            call	_bios_printf
04210 1020           89EC                       mov	sp,bp
04211                                           !BCC_EOS
04212                                           ! 1149 }
04213 1022           5D                         pop	bp
04214 1023           C3                         ret
04215                                           ! 1150 struct ipl_entry {
04216                                           ! Register BX used in function print_bios_banner
04217                                           ! 1151   Bit16u type;
04218                                           !BCC_EOS
04219                                           ! 1152   Bit16u flags;
04220                                           !BCC_EOS
04221                                           ! 1153   Bit32u vector;
04222                                           !BCC_EOS
04223                                           ! 1154   Bit32u description;
04224                                           !BCC_EOS
04225                                           ! 1155   Bit32u reserved;
04226                                           !BCC_EOS
04227                                           ! 1156 };
04228                                           !BCC_EOS
04229                                           ! 1157 static void
04230                                           ! 1158 init_boot_vectors()
04231                                           ! 1159 {
04232                       00001024            _init_boot_vectors:
04233                                           ! 1160   struct ipl_entry e;
04234                                           !BCC_EOS
04235                                           ! 1161   Bit16u count = 0;
04236 1024           55                         push	bp
04237 1025           89E5                       mov	bp,sp
04238 1027           83C4                   EE  add	sp,*-$12
04239                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
04240 102A           31C0                       xor	ax,ax
04241 102C           8946         EE            mov	-$12[bp],ax
04242                                           !BCC_EOS
04243                                           ! 1162   Bit16u ss = get_SS();
04244 102F           4C                         dec	sp
04245 1030           4C                         dec	sp
04246                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
04247 1031           E8         F623            call	_get_SS
04248                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
04249 1034           8946         EC            mov	-$14[bp],ax
04250                                           !BCC_EOS
04251                                           ! 1163   memsetb(0x9ff0, 0x0000, 0, 0xff);
04252                                           ! Debug: list int = const $FF (used reg = )
04253 1037           B8                   00FF  mov	ax,#$FF
04254 103A           50                         push	ax
04255                                           ! Debug: list int = const 0 (used reg = )
04256 103B           31C0                       xor	ax,ax
04257 103D           50                         push	ax
04258                                           ! Debug: list int = const 0 (used reg = )
04259 103E           31C0                       xor	ax,ax
04260 1040           50                         push	ax
04261                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04262 1041           B8                   9FF0  mov	ax,#$9FF0
04263 1044           50                         push	ax
04264                                           ! Debug: func () void = memsetb+0 (used reg = )
04265 1045           E8         EFB8            call	_memsetb
04266 1048           83C4                   08  add	sp,*8
04267                                           !BCC_EOS
04268                                           ! 1164   e.type = 1; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04269                                           ! Debug: eq int = const 1 to unsigned short e = [S+$16-$12] (used reg = )
04270 104B           B8                   0001  mov	ax,*1
04271 104E           8946         F0            mov	-$10[bp],ax
04272                                           !BCC_EOS
04273                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04274 1051           31C0                       xor	ax,ax
04275 1053           8946         F2            mov	-$E[bp],ax
04276                                           !BCC_EOS
04277                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04278 1056           31C0                       xor	ax,ax
04279 1058           31DB                       xor	bx,bx
04280 105A           8946         F4            mov	-$C[bp],ax
04281 105D           895E         F6            mov	-$A[bp],bx
04282                                           !BCC_EOS
04283                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04284 1060           31C0                       xor	ax,ax
04285 1062           31DB                       xor	bx,bx
04286 1064           8946         F8            mov	-8[bp],ax
04287 1067           895E         FA            mov	-6[bp],bx
04288                                           !BCC_EOS
04289                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04290 106A           31C0                       xor	ax,ax
04291 106C           31DB                       xor	bx,bx
04292 106E           8946         FC            mov	-4[bp],ax
04293 1071           895E         FE            mov	-2[bp],bx
04294                                           !BCC_EOS
04295                                           ! 1165   memcpyb(0x9ff0, 0x0000 + count * sizeof (e
04296                                           ! 1165 ), ss, &e, sizeof (e));
04297                                           ! Debug: list int = const $10 (used reg = )
04298 1074           B8                   0010  mov	ax,*$10
04299 1077           50                         push	ax
04300                                           ! Debug: list * struct ipl_entry e = S+$18-$12 (used reg = )
04301 1078           8D5E         F0            lea	bx,-$10[bp]
04302 107B           53                         push	bx
04303                                           ! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
04304 107C           FF76         EC            push	-$14[bp]
04305                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
04306 107F           8B46         EE            mov	ax,-$12[bp]
04307 1082           B1                     04  mov	cl,*4
04308 1084           D3E0                       shl	ax,cl
04309                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04310                                           ! Debug: expression subtree swapping
04311                                           ! Debug: list unsigned int = ax+0 (used reg = )
04312 1086           50                         push	ax
04313                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04314 1087           B8                   9FF0  mov	ax,#$9FF0
04315 108A           50                         push	ax
04316                                           ! Debug: func () void = memcpyb+0 (used reg = )
04317 108B           E8         EF97            call	_memcpyb
04318 108E           83C4                   0A  add	sp,*$A
04319                                           !BCC_EOS
04320                                           ! 1166   count++;
04321                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04322 1091           8B46         EE            mov	ax,-$12[bp]
04323 1094           40                         inc	ax
04324 1095           8946         EE            mov	-$12[bp],ax
04325                                           !BCC_EOS
04326                                           ! 1167   e.type = 2; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04327                                           ! Debug: eq int = const 2 to unsigned short e = [S+$16-$12] (used reg = )
04328 1098           B8                   0002  mov	ax,*2
04329 109B           8946         F0            mov	-$10[bp],ax
04330                                           !BCC_EOS
04331                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04332 109E           31C0                       xor	ax,ax
04333 10A0           8946         F2            mov	-$E[bp],ax
04334                                           !BCC_EOS
04335                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04336 10A3           31C0                       xor	ax,ax
04337 10A5           31DB                       xor	bx,bx
04338 10A7           8946         F4            mov	-$C[bp],ax
04339 10AA           895E         F6            mov	-$A[bp],bx
04340                                           !BCC_EOS
04341                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04342 10AD           31C0                       xor	ax,ax
04343 10AF           31DB                       xor	bx,bx
04344 10B1           8946         F8            mov	-8[bp],ax
04345 10B4           895E         FA            mov	-6[bp],bx
04346                                           !BCC_EOS
04347                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04348 10B7           31C0                       xor	ax,ax
04349 10B9           31DB                       xor	bx,bx
04350 10BB           8946         FC            mov	-4[bp],ax
04351 10BE           895E         FE            mov	-2[bp],bx
04352                                           !BCC_EOS
04353                                           ! 1168   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
04354                                           ! Debug: list int = const $10 (used reg = )
04355 10C1           B8                   0010  mov	ax,*$10
04356 10C4           50                         push	ax
04357                                           ! Debug: list * struct ipl_entry e = S+$18-$12 (used reg = )
04358 10C5           8D5E         F0            lea	bx,-$10[bp]
04359 10C8           53                         push	bx
04360                                           ! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
04361 10C9           FF76         EC            push	-$14[bp]
04362                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
04363 10CC           8B46         EE            mov	ax,-$12[bp]
04364 10CF           B1                     04  mov	cl,*4
04365 10D1           D3E0                       shl	ax,cl
04366                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04367                                           ! Debug: expression subtree swapping
04368                                           ! Debug: list unsigned int = ax+0 (used reg = )
04369 10D3           50                         push	ax
04370                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04371 10D4           B8                   9FF0  mov	ax,#$9FF0
04372 10D7           50                         push	ax
04373                                           ! Debug: func () void = memcpyb+0 (used reg = )
04374 10D8           E8         EF4A            call	_memcpyb
04375 10DB           83C4                   0A  add	sp,*$A
04376                                           !BCC_EOS
04377                                           ! 1169   count++;
04378                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04379 10DE           8B46         EE            mov	ax,-$12[bp]
04380 10E1           40                         inc	ax
04381 10E2           8946         EE            mov	-$12[bp],ax
04382                                           !BCC_EOS
04383                                           ! 1170   e.type = 3; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
04384                                           ! Debug: eq int = const 3 to unsigned short e = [S+$16-$12] (used reg = )
04385 10E5           B8                   0003  mov	ax,*3
04386 10E8           8946         F0            mov	-$10[bp],ax
04387                                           !BCC_EOS
04388                                           ! Debug: eq int = const 0 to unsigned short e = [S+$16-$10] (used reg = )
04389 10EB           31C0                       xor	ax,ax
04390 10ED           8946         F2            mov	-$E[bp],ax
04391                                           !BCC_EOS
04392                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$E] (used reg = )
04393 10F0           31C0                       xor	ax,ax
04394 10F2           31DB                       xor	bx,bx
04395 10F4           8946         F4            mov	-$C[bp],ax
04396 10F7           895E         F6            mov	-$A[bp],bx
04397                                           !BCC_EOS
04398                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-$A] (used reg = )
04399 10FA           31C0                       xor	ax,ax
04400 10FC           31DB                       xor	bx,bx
04401 10FE           8946         F8            mov	-8[bp],ax
04402 1101           895E         FA            mov	-6[bp],bx
04403                                           !BCC_EOS
04404                                           ! Debug: eq int = const 0 to unsigned long e = [S+$16-6] (used reg = )
04405 1104           31C0                       xor	ax,ax
04406 1106           31DB                       xor	bx,bx
04407 1108           8946         FC            mov	-4[bp],ax
04408 110B           895E         FE            mov	-2[bp],bx
04409                                           !BCC_EOS
04410                                           ! 1171   memcpyb(0x9ff0, 0x0000 + count * sizeof (e), ss, &e, sizeof (e));
04411                                           ! Debug: list int = const $10 (used reg = )
04412 110E           B8                   0010  mov	ax,*$10
04413 1111           50                         push	ax
04414                                           ! Debug: list * struct ipl_entry e = S+$18-$12 (used reg = )
04415 1112           8D5E         F0            lea	bx,-$10[bp]
04416 1115           53                         push	bx
04417                                           ! Debug: list unsigned short ss = [S+$1A-$16] (used reg = )
04418 1116           FF76         EC            push	-$14[bp]
04419                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1C-$14] (used reg = )
04420 1119           8B46         EE            mov	ax,-$12[bp]
04421 111C           B1                     04  mov	cl,*4
04422 111E           D3E0                       shl	ax,cl
04423                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04424                                           ! Debug: expression subtree swapping
04425                                           ! Debug: list unsigned int = ax+0 (used reg = )
04426 1120           50                         push	ax
04427                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04428 1121           B8                   9FF0  mov	ax,#$9FF0
04429 1124           50                         push	ax
04430                                           ! Debug: func () void = memcpyb+0 (used reg = )
04431 1125           E8         EEFD            call	_memcpyb
04432 1128           83C4                   0A  add	sp,*$A
04433                                           !BCC_EOS
04434                                           ! 1172   count++;
04435                                           ! Debug: postinc unsigned short count = [S+$16-$14] (used reg = )
04436 112B           8B46         EE            mov	ax,-$12[bp]
04437 112E           40                         inc	ax
04438 112F           8946         EE            mov	-$12[bp],ax
04439                                           !BCC_EOS
04440                                           ! 1173   write_word(0x9ff0, 0x0080, count);
04441                                           ! Debug: list unsigned short count = [S+$16-$14] (used reg = )
04442 1132           FF76         EE            push	-$12[bp]
04443                                           ! Debug: list int = const $80 (used reg = )
04444 1135           B8                   0080  mov	ax,#$80
04445 1138           50                         push	ax
04446                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04447 1139           B8                   9FF0  mov	ax,#$9FF0
04448 113C           50                         push	ax
04449                                           ! Debug: func () void = write_word+0 (used reg = )
04450 113D           E8         F4FC            call	_write_word
04451 1140           83C4                   06  add	sp,*6
04452                                           !BCC_EOS
04453                                           ! 1174   write_word(0x9ff0, 0x0082, 0xffff);
04454                                           ! Debug: list unsigned int = const $FFFF (used reg = )
04455 1143           B8                   FFFF  mov	ax,#$FFFF
04456 1146           50                         push	ax
04457                                           ! Debug: list int = const $82 (used reg = )
04458 1147           B8                   0082  mov	ax,#$82
04459 114A           50                         push	ax
04460                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04461 114B           B8                   9FF0  mov	ax,#$9FF0
04462 114E           50                         push	ax
04463                                           ! Debug: func () void = write_word+0 (used reg = )
04464 114F           E8         F4EA            call	_write_word
04465 1152           83C4                   06  add	sp,*6
04466                                           !BCC_EOS
04467                                           ! 1175 }
04468 1155           89EC                       mov	sp,bp
04469 1157           5D                         pop	bp
04470 1158           C3                         ret
04471                                           ! 1176 static Bit8u
04472                                           ! Register BX used in function init_boot_vectors
04473                                           ! 1177 get_boot_vector(i, e)
04474                                           ! 1178 Bit16u i; struct ipl_entry *e;
04475                       00001159            _get_boot_vector:
04476                                           !BCC_EOS
04477                                           !BCC_EOS
04478                                           ! 1179 {
04479                                           ! 1180   Bit16u count;
04480                                           !BCC_EOS
04481                                           ! 1181   Bit16u ss = get_SS();
04482 1159           55                         push	bp
04483 115A           89E5                       mov	bp,sp
04484 115C           83C4                   FC  add	sp,*-4
04485                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
04486 115F           E8         F4F5            call	_get_SS
04487                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
04488 1162           8946         FC            mov	-4[bp],ax
04489                                           !BCC_EOS
04490                                           ! 1182   count = read_word(0x9ff0, 0x0080);
04491                                           ! Debug: list int = const $80 (used reg = )
04492 1165           B8                   0080  mov	ax,#$80
04493 1168           50                         push	ax
04494                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04495 1169           B8                   9FF0  mov	ax,#$9FF0
04496 116C           50                         push	ax
04497                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
04498 116D           E8         F4A1            call	_read_word
04499 1170           83C4                   04  add	sp,*4
04500                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+6-4] (used reg = )
04501 1173           8946         FE            mov	-2[bp],ax
04502                                           !BCC_EOS
04503                                           ! 1183   if (i >= count) return 0;
04504                                           ! Debug: ge unsigned short count = [S+6-4] to unsigned short i = [S+6+2] (used reg = )
04505 1176           8B46         04            mov	ax,4[bp]
04506 1179           3B46         FE            cmp	ax,-2[bp]
04507 117C           72           06            jb  	.D1
04508                       0000117E            .D2:
04509 117E           30C0                       xor	al,al
04510 1180           89EC                       mov	sp,bp
04511 1182           5D                         pop	bp
04512 1183           C3                         ret
04513                                           !BCC_EOS
04514                                           ! 1184   memcpyb(ss, e, 0x9ff0, 0x0000 + i * sizeof (*e), sizeof (*e));
04515                       00001184            .D1:
04516                                           ! Debug: list int = const $10 (used reg = )
04517 1184           B8                   0010  mov	ax,*$10
04518 1187           50                         push	ax
04519                                           ! Debug: mul int = const $10 to unsigned short i = [S+8+2] (used reg = )
04520 1188           8B46         04            mov	ax,4[bp]
04521 118B           B1                     04  mov	cl,*4
04522 118D           D3E0                       shl	ax,cl
04523                                           ! Debug: add unsigned int = ax+0 to int = const 0 (used reg = )
04524                                           ! Debug: expression subtree swapping
04525                                           ! Debug: list unsigned int = ax+0 (used reg = )
04526 118F           50                         push	ax
04527                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
04528 1190           B8                   9FF0  mov	ax,#$9FF0
04529 1193           50                         push	ax
04530                                           ! Debug: list * struct ipl_entry e = [S+$C+4] (used reg = )
04531 1194           FF76         06            push	6[bp]
04532                                           ! Debug: list unsigned short ss = [S+$E-6] (used reg = )
04533 1197           FF76         FC            push	-4[bp]
04534                                           ! Debug: func () void = memcpyb+0 (used reg = )
04535 119A           E8         EE88            call	_memcpyb
04536 119D           83C4                   0A  add	sp,*$A
04537                                           !BCC_EOS
04538                                           ! 1185   return 1;
04539 11A0           B0                     01  mov	al,*1
04540 11A2           89EC                       mov	sp,bp
04541 11A4           5D                         pop	bp
04542 11A5           C3                         ret
04543                                           !BCC_EOS
04544                                           ! 1186 }
04545                                           ! 1187 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
04546                                           
04547                       000011A6            _drivetypes:
04548                       000011A6            .D3:
04549 11A6                        00            .byte	0
04550 11A7                  00000009            .blkb	9
04551                       000011B0            .D4:
04552 11B0                        46            .ascii	"Floppy"
04553 11B6                        00            .byte	0
04554 11B7                  00000003            .blkb	3
04555                       000011BA            .D5:
04556 11BA                        48            .ascii	"Hard Disk"
04557 11C3                        00            .byte	0
04558                       000011C4            .D6:
04559 11C4                        43            .ascii	"CD-Rom"
04560 11CA                        00            .byte	0
04561 11CB                  00000003            .blkb	3
04562                       000011CE            .D7:
04563 11CE                        4E            .ascii	"Network"
04564 11D5                        00            .byte	0
04565 11D6                  00000002            .blkb	2
04566                                           !BCC_EOS
04567                                           ! 1188 void
04568                                           ! 1189 print_boot_device(type)
04569                                           ! 1190   Bit16u type;
04570                                           
04571                                           export	_print_boot_device
04572                       000011D8            _print_boot_device:
04573                                           !BCC_EOS
04574                                           ! 1191 {
04575                                           ! 1192   if (type == 0x80 ) type = 0x4;
04576 11D8           55                         push	bp
04577 11D9           89E5                       mov	bp,sp
04578                                           ! Debug: logeq int = const $80 to unsigned short type = [S+2+2] (used reg = )
04579 11DB           8B46         04            mov	ax,4[bp]
04580 11DE           3D                   0080  cmp	ax,#$80
04581 11E1           75           06            jne 	.D8
04582                       000011E3            .D9:
04583                                           ! Debug: eq int = const 4 to unsigned short type = [S+2+2] (used reg = )
04584 11E3           B8                   0004  mov	ax,*4
04585 11E6           8946         04            mov	4[bp],ax
04586                                           !BCC_EOS
04587                                           ! 1193   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
04588                       000011E9            .D8:
04589                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
04590 11E9           8B46         04            mov	ax,4[bp]
04591 11EC           85C0                       test	ax,ax
04592 11EE           74           08            je  	.DB
04593                       000011F0            .DC:
04594                                           ! Debug: gt int = const 4 to unsigned short type = [S+2+2] (used reg = )
04595 11F0           8B46         04            mov	ax,4[bp]
04596 11F3           3D                   0004  cmp	ax,*4
04597 11F6           76           0D            jbe 	.DA
04598                       000011F8            .DB:
04599                                           ! Debug: list * char = .DD+0 (used reg = )
04600 11F8           BB                   DC56  mov	bx,#.DD
04601 11FB           53                         push	bx
04602                                           ! Debug: list int = const 7 (used reg = )
04603 11FC           B8                   0007  mov	ax,*7
04604 11FF           50                         push	ax
04605                                           ! Debug: func () void = bios_printf+0 (used reg = )
04606 1200           E8         F6A6            call	_bios_printf
04607 1203           89EC                       mov	sp,bp
04608                                           !BCC_EOS
04609                                           ! 1194   bios_printf(2, "Booting from %s...\n", drivetypes[type]);
04610                       00001205            .DA:
04611                                           ! Debug: ptradd unsigned short type = [S+2+2] to [5] [$A] char = drivetypes+0 (used reg = )
04612 1205           8B5E         04            mov	bx,4[bp]
04613 1208           89DA                       mov	dx,bx
04614 120A           D1E3                       shl	bx,*1
04615 120C           D1E3                       shl	bx,*1
04616 120E           01D3                       add	bx,dx
04617 1210           D1E3                       shl	bx,*1
04618                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
04619                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
04620 1212           81C3                 11A6  add	bx,#_drivetypes
04621 1216           53                         push	bx
04622                                           ! Debug: list * char = .DE+0 (used reg = )
04623 1217           BB                   DC42  mov	bx,#.DE
04624 121A           53                         push	bx
04625                                           ! Debug: list int = const 2 (used reg = )
04626 121B           B8                   0002  mov	ax,*2
04627 121E           50                         push	ax
04628                                           ! Debug: func () void = bios_printf+0 (used reg = )
04629 121F           E8         F687            call	_bios_printf
04630 1222           89EC                       mov	sp,bp
04631                                           !BCC_EOS
04632                                           ! 1195 }
04633 1224           5D                         pop	bp
04634 1225           C3                         ret
04635                                           ! 1196   void
04636                                           ! Register BX used in function print_boot_device
04637                                           ! 1197 print_boot_failure(type, reason)
04638                                           ! 1198   Bit16u type; Bit8u reason;
04639                                           export	_print_boot_failure
04640                       00001226            _print_boot_failure:
04641                                           !BCC_EOS
04642                                           !BCC_EOS
04643                                           ! 1199 {
04644                                           ! 1200   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
04645 1226           55                         push	bp
04646 1227           89E5                       mov	bp,sp
04647                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
04648 1229           8B46         04            mov	ax,4[bp]
04649 122C           85C0                       test	ax,ax
04650 122E           74           08            je  	.E0
04651                       00001230            .E1:
04652                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
04653 1230           8B46         04            mov	ax,4[bp]
04654 1233           3D                   0003  cmp	ax,*3
04655 1236           76           0D            jbe 	.DF
04656                       00001238            .E0:
04657                                           ! Debug: list * char = .E2+0 (used reg = )
04658 1238           BB                   DC32  mov	bx,#.E2
04659 123B           53                         push	bx
04660                                           ! Debug: list int = const 7 (used reg = )
04661 123C           B8                   0007  mov	ax,*7
04662 123F           50                         push	ax
04663                                           ! Debug: func () void = bios_printf+0 (used reg = )
04664 1240           E8         F666            call	_bios_printf
04665 1243           89EC                       mov	sp,bp
04666                                           !BCC_EOS
04667                                           ! 1201   bios_printf(2, "Boot from %s failed", drivetypes[type]);
04668                       00001245            .DF:
04669                                           ! Debug: ptradd unsigned short type = [S+2+2] to [5] [$A] char = drivetypes+0 (used reg = )
04670 1245           8B5E         04            mov	bx,4[bp]
04671 1248           89DA                       mov	dx,bx
04672 124A           D1E3                       shl	bx,*1
04673 124C           D1E3                       shl	bx,*1
04674 124E           01D3                       add	bx,dx
04675 1250           D1E3                       shl	bx,*1
04676                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
04677                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
04678 1252           81C3                 11A6  add	bx,#_drivetypes
04679 1256           53                         push	bx
04680                                           ! Debug: list * char = .E3+0 (used reg = )
04681 1257           BB                   DC1E  mov	bx,#.E3
04682 125A           53                         push	bx
04683                                           ! Debug: list int = const 2 (used reg = )
04684 125B           B8                   0002  mov	ax,*2
04685 125E           50                         push	ax
04686                                           ! Debug: func () void = bios_printf+0 (used reg = )
04687 125F           E8         F647            call	_bios_printf
04688 1262           89EC                       mov	sp,bp
04689                                           !BCC_EOS
04690                                           ! 1202   if (type < 4) {
04691                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
04692 1264           8B46         04            mov	ax,4[bp]
04693 1267           3D                   0004  cmp	ax,*4
04694 126A           73           23            jae 	.E4
04695                       0000126C            .E5:
04696                                           ! 1203   if (reason==0)
04697                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
04698 126C           8A46         06            mov	al,6[bp]
04699 126F           84C0                       test	al,al
04700 1271           75           0F            jne 	.E6
04701                       00001273            .E7:
04702                                           ! 1204     bios_printf(2, ": not a bootable disk");
04703                                           ! Debug: list * char = .E8+0 (used reg = )
04704 1273           BB                   DC08  mov	bx,#.E8
04705 1276           53                         push	bx
04706                                           ! Debug: list int = const 2 (used reg = )
04707 1277           B8                   0002  mov	ax,*2
04708 127A           50                         push	ax
04709                                           ! Debug: func () void = bios_printf+0 (used reg = )
04710 127B           E8         F62B            call	_bios_printf
04711 127E           89EC                       mov	sp,bp
04712                                           !BCC_EOS
04713                                           ! 1205   else
04714                                           ! 1206     bios_printf(2, ": could not read the boot disk");
04715 1280           EB           0D            jmp .E9
04716                       00001282            .E6:
04717                                           ! Debug: list * char = .EA+0 (used reg = )
04718 1282           BB                   DBE9  mov	bx,#.EA
04719 1285           53                         push	bx
04720                                           ! Debug: list int = const 2 (used reg = )
04721 1286           B8                   0002  mov	ax,*2
04722 1289           50                         push	ax
04723                                           ! Debug: func () void = bios_printf+0 (used reg = )
04724 128A           E8         F61C            call	_bios_printf
04725 128D           89EC                       mov	sp,bp
04726                                           !BCC_EOS
04727                                           ! 1207   }
04728                       0000128F            .E9:
04729                                           ! 1208   bios_printf(2, "\n");
04730                       0000128F            .E4:
04731                                           ! Debug: list * char = .EB+0 (used reg = )
04732 128F           BB                   DBE7  mov	bx,#.EB
04733 1292           53                         push	bx
04734                                           ! Debug: list int = const 2 (used reg = )
04735 1293           B8                   0002  mov	ax,*2
04736 1296           50                         push	ax
04737                                           ! Debug: func () void = bios_printf+0 (used reg = )
04738 1297           E8         F60F            call	_bios_printf
04739 129A           89EC                       mov	sp,bp
04740                                           !BCC_EOS
04741                                           ! 1209 }
04742 129C           5D                         pop	bp
04743 129D           C3                         ret
04744                                           ! 1210   void
04745                                           ! Register BX used in function print_boot_failure
04746                                           ! 1211 print_cdromboot_failure( code )
04747                                           ! 1212   Bit16u code;
04748                                           export	_print_cdromboot_failure
04749                       0000129E            _print_cdromboot_failure:
04750                                           !BCC_EOS
04751                                           ! 1213 {
04752                                           ! 1214   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
04753 129E           55                         push	bp
04754 129F           89E5                       mov	bp,sp
04755                                           ! Debug: list unsigned short code = [S+2+2] (used reg = )
04756 12A1           FF76         04            push	4[bp]
04757                                           ! Debug: list * char = .EC+0 (used reg = )
04758 12A4           BB                   DBC7  mov	bx,#.EC
04759 12A7           53                         push	bx
04760                                           ! Debug: list int = const 6 (used reg = )
04761 12A8           B8                   0006  mov	ax,*6
04762 12AB           50                         push	ax
04763                                           ! Debug: func () void = bios_printf+0 (used reg = )
04764 12AC           E8         F5FA            call	_bios_printf
04765 12AF           89EC                       mov	sp,bp
04766                                           !BCC_EOS
04767                                           ! 1215   return;
04768 12B1           5D                         pop	bp
04769 12B2           C3                         ret
04770                                           !BCC_EOS
04771                                           ! 1216 }
04772                                           ! 1217 Bit8u check_for_keystroke()
04773                                           ! Register BX used in function print_cdromboot_failure
04774                                           ! 1218 {
04775                                           export	_check_for_keystroke
04776                       000012B3            _check_for_keystroke:
04777                                           ! 1219 #asm
04778                                           !BCC_ASM
04779 12B3           B8                   0100      mov ax, #0x100
04780 12B6           CD                     16      int #0x16
04781 12B8           74           04                jz no_key
04782 12BA           B0                     01      mov al, #1
04783 12BC           EB           02                jmp done
04784                       000012BE            no_key:
04785 12BE           30C0                           xor al, al
04786                       000012C0            done:
04787                                           ! 1228 endasm
04788                                           !BCC_ENDASM
04789                                           ! 1229 }
04790 12C0           C3                         ret
04791                                           ! 1230 Bit8u get_keystroke()
04792                                           ! 1231 {
04793                                           export	_get_keystroke
04794                       000012C1            _get_keystroke:
04795                                           ! 1232 #asm
04796                                           !BCC_ASM
04797 12C1           B8                   0000      mov ax, #0x0
04798 12C4           CD                     16      int #0x16
04799 12C6           86C4                           xchg ah, al
04800                                           ! 1236 endasm
04801                                           !BCC_ENDASM
04802                                           ! 1237 }
04803 12C8           C3                         ret
04804                                           ! 1238 Bit8u wait(ticks, stop_on_key)
04805                                           ! 1239   Bit16u ticks;
04806                                           export	_wait
04807                       000012C9            _wait:
04808                                           !BCC_EOS
04809                                           ! 1240   Bit8u stop_on_key;
04810                                           !BCC_EOS
04811                                           ! 1241 {
04812                                           ! 1242     long ticks_to_wait, delta;
04813                                           !BCC_EOS
04814                                           ! 1243     Bit32u prev_ticks, t;
04815                                           !BCC_EOS
04816                                           ! 1244     Bit8u scan_code = 0;
04817 12C9           55                         push	bp
04818 12CA           89E5                       mov	bp,sp
04819 12CC           83C4                   EF  add	sp,*-$11
04820                                           ! Debug: eq int = const 0 to unsigned char scan_code = [S+$13-$13] (used reg = )
04821 12CF           30C0                       xor	al,al
04822 12D1           8846         EF            mov	-$11[bp],al
04823                                           !BCC_EOS
04824                                           ! 1245     ticks_to_wait = ticks;
04825 12D4           4C                         dec	sp
04826                                           ! Debug: eq unsigned short ticks = [S+$14+2] to long ticks_to_wait = [S+$14-6] (used reg = )
04827 12D5           8B46         04            mov	ax,4[bp]
04828 12D8           31DB                       xor	bx,bx
04829 12DA           8946         FC            mov	-4[bp],ax
04830 12DD           895E         FE            mov	-2[bp],bx
04831                                           !BCC_EOS
04832                                           ! 1246     prev_ticks = read_dword(0x0, 0x46c);
04833                                           ! Debug: list int = const $46C (used reg = )
04834 12E0           B8                   046C  mov	ax,#$46C
04835 12E3           50                         push	ax
04836                                           ! Debug: list int = const 0 (used reg = )
04837 12E4           31C0                       xor	ax,ax
04838 12E6           50                         push	ax
04839                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
04840 12E7           E8         ED6B            call	_read_dword
04841 12EA           89D3                       mov	bx,dx
04842 12EC           83C4                   04  add	sp,*4
04843                                           ! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$14-$E] (used reg = )
04844 12EF           8946         F4            mov	-$C[bp],ax
04845 12F2           895E         F6            mov	-$A[bp],bx
04846                                           !BCC_EOS
04847                                           ! 1247     do
04848                                           ! 1248     {
04849                       000012F5            .EF:
04850                                           ! 1249         t = read_dword(0x0, 0x46c);
04851                                           ! Debug: list int = const $46C (used reg = )
04852 12F5           B8                   046C  mov	ax,#$46C
04853 12F8           50                         push	ax
04854                                           ! Debug: list int = const 0 (used reg = )
04855 12F9           31C0                       xor	ax,ax
04856 12FB           50                         push	ax
04857                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
04858 12FC           E8         ED56            call	_read_dword
04859 12FF           89D3                       mov	bx,dx
04860 1301           83C4                   04  add	sp,*4
04861                                           ! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$14-$12] (used reg = )
04862 1304           8946         F0            mov	-$10[bp],ax
04863 1307           895E         F2            mov	-$E[bp],bx
04864                                           !BCC_EOS
04865                                           ! 1250         if (t > prev_ticks)
04866                                           ! Debug: gt unsigned long prev_ticks = [S+$14-$E] to unsigned long t = [S+$14-$12] (used reg = )
04867 130A           8B46         F4            mov	ax,-$C[bp]
04868 130D           8B5E         F6            mov	bx,-$A[bp]
04869 1310           8D7E         F0            lea	di,-$10[bp]
04870 1313           E8         ED85            call	lcmpul
04871 1316           73           26            jae 	.F0
04872                       00001318            .F1:
04873                                           ! 1251         {
04874                                           ! 1252             delta = t - prev
04875                                           ! 1252 _ticks;
04876                                           ! Debug: sub unsigned long prev_ticks = [S+$14-$E] to unsigned long t = [S+$14-$12] (used reg = )
04877 1318           8B46         F0            mov	ax,-$10[bp]
04878 131B           8B5E         F2            mov	bx,-$E[bp]
04879 131E           8D7E         F4            lea	di,-$C[bp]
04880 1321           E8         ED8D            call	lsubul
04881                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$14-$A] (used reg = )
04882 1324           8946         F8            mov	-8[bp],ax
04883 1327           895E         FA            mov	-6[bp],bx
04884                                           !BCC_EOS
04885                                           ! 1253             ticks_to_wait -= delta;
04886                                           ! Debug: subab long delta = [S+$14-$A] to long ticks_to_wait = [S+$14-6] (used reg = )
04887 132A           8B46         FC            mov	ax,-4[bp]
04888 132D           8B5E         FE            mov	bx,-2[bp]
04889 1330           8D7E         F8            lea	di,-8[bp]
04890 1333           E8         ED7B            call	lsubl
04891 1336           8946         FC            mov	-4[bp],ax
04892 1339           895E         FE            mov	-2[bp],bx
04893                                           !BCC_EOS
04894                                           ! 1254         }
04895                                           ! 1255         else if (t < prev_ticks)
04896 133C           EB           20            jmp .F2
04897                       0000133E            .F0:
04898                                           ! Debug: lt unsigned long prev_ticks = [S+$14-$E] to unsigned long t = [S+$14-$12] (used reg = )
04899 133E           8B46         F4            mov	ax,-$C[bp]
04900 1341           8B5E         F6            mov	bx,-$A[bp]
04901 1344           8D7E         F0            lea	di,-$10[bp]
04902 1347           E8         ED51            call	lcmpul
04903 134A           76           12            jbe 	.F3
04904                       0000134C            .F4:
04905                                           ! 1256             ticks_to_wait -= t;
04906                                           ! Debug: subab unsigned long t = [S+$14-$12] to long ticks_to_wait = [S+$14-6] (used reg = )
04907 134C           8B46         FC            mov	ax,-4[bp]
04908 134F           8B5E         FE            mov	bx,-2[bp]
04909 1352           8D7E         F0            lea	di,-$10[bp]
04910 1355           E8         ED59            call	lsubul
04911 1358           8946         FC            mov	-4[bp],ax
04912 135B           895E         FE            mov	-2[bp],bx
04913                                           !BCC_EOS
04914                                           ! 1257         prev_ticks = t;
04915                       0000135E            .F3:
04916                       0000135E            .F2:
04917                                           ! Debug: eq unsigned long t = [S+$14-$12] to unsigned long prev_ticks = [S+$14-$E] (used reg = )
04918 135E           8B46         F0            mov	ax,-$10[bp]
04919 1361           8B5E         F2            mov	bx,-$E[bp]
04920 1364           8946         F4            mov	-$C[bp],ax
04921 1367           895E         F6            mov	-$A[bp],bx
04922                                           !BCC_EOS
04923                                           ! 1258         if (check_for_keystroke())
04924                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
04925 136A           E8         FF46            call	_check_for_keystroke
04926 136D           84C0                       test	al,al
04927 136F           74           28            je  	.F5
04928                       00001371            .F6:
04929                                           ! 1259         {
04930                                           ! 1260             scan_code = get_keystroke();
04931                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
04932 1371           E8         FF4D            call	_get_keystroke
04933                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$14-$13] (used reg = )
04934 1374           8846         EF            mov	-$11[bp],al
04935                                           !BCC_EOS
04936                                           ! 1261             bios_printf(8, "Key pressed: %x\n", scan_code);
04937                                           ! Debug: list unsigned char scan_code = [S+$14-$13] (used reg = )
04938 1377           8A46         EF            mov	al,-$11[bp]
04939 137A           30E4                       xor	ah,ah
04940 137C           50                         push	ax
04941                                           ! Debug: list * char = .F7+0 (used reg = )
04942 137D           BB                   DBB6  mov	bx,#.F7
04943 1380           53                         push	bx
04944                                           ! Debug: list int = const 8 (used reg = )
04945 1381           B8                   0008  mov	ax,*8
04946 1384           50                         push	ax
04947                                           ! Debug: func () void = bios_printf+0 (used reg = )
04948 1385           E8         F521            call	_bios_printf
04949 1388           83C4                   06  add	sp,*6
04950                                           !BCC_EOS
04951                                           ! 1262             if (stop_on_key)
04952 138B           8A46         06            mov	al,6[bp]
04953 138E           84C0                       test	al,al
04954 1390           74           07            je  	.F8
04955                       00001392            .F9:
04956                                           ! 1263                 return scan_code;
04957 1392           8A46         EF            mov	al,-$11[bp]
04958 1395           89EC                       mov	sp,bp
04959 1397           5D                         pop	bp
04960 1398           C3                         ret
04961                                           !BCC_EOS
04962                                           ! 1264         }
04963                       00001399            .F8:
04964                                           ! 1265     } while (ticks_to_wait > 0);
04965                       00001399            .F5:
04966                       00001399            .EE:
04967                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$14-6] (used reg = )
04968 1399           31C0                       xor	ax,ax
04969 139B           31DB                       xor	bx,bx
04970 139D           8D7E         FC            lea	di,-4[bp]
04971 13A0           E8         ECF8            call	lcmpl
04972 13A3         0F8C         FF4E            blt 	.EF
04973                       000013A7            .FA:
04974                                           !BCC_EOS
04975                                           ! 1266     return scan_code;
04976                       000013A7            .ED:
04977 13A7           8A46         EF            mov	al,-$11[bp]
04978 13AA           89EC                       mov	sp,bp
04979 13AC           5D                         pop	bp
04980 13AD           C3                         ret
04981                                           !BCC_EOS
04982                                           ! 1267 }
04983                                           ! 1268 static void clearscreen() {
04984                                           ! Register BX used in function wait
04985                       000013AE            _clearscreen:
04986                                           ! 1269 #asm
04987                                           !BCC_ASM
04988 13AE           53                                 push bx
04989 13AF           51                                 push cx
04990 13B0           52                                 push dx
04991 13B1           B8                   0100          mov ax, #0x100
04992 13B4           B9                   1000          mov cx, #0x1000
04993 13B7           CD                     10          int #0x10
04994 13B9           B8                   0700          mov ax, #0x700
04995 13BC           B7                     07          mov bh, #7
04996 13BE           31C9                               xor cx, cx
04997 13C0           BA                   184F          mov dx, #0x184f
04998 13C3           CD                     10          int #0x10
04999 13C5           B8                   0200          mov ax, #0x200
05000 13C8           31DB                               xor bx, bx
05001 13CA           31D2                               xor dx, dx
05002 13CC           CD                     10          int #0x10
05003 13CE           5A                                 pop dx
05004 13CF           59                                 pop cx
05005 13D0           5B                                 pop bx
05006                                           ! 1288 endasm
05007                                           !BCC_ENDASM
05008                                           ! 1289 }
05009 13D1           C3                         ret
05010                                           ! 1290 int bootmenu(selected)
05011                                           ! 1291   int selected;
05012                                           export	_bootmenu
05013                       000013D2            _bootmenu:
05014                                           !BCC_EOS
05015                                           ! 1292 {
05016                                           ! 1293     Bit8u scode;
05017                                           !BCC_EOS
05018                                           ! 1294     int max;
05019                                           !BCC_EOS
05020                                           ! 1295     max = read_word(0x9ff0, 0x0080);
05021 13D2           55                         push	bp
05022 13D3           89E5                       mov	bp,sp
05023 13D5           83C4                   FC  add	sp,*-4
05024                                           ! Debug: list int = const $80 (used reg = )
05025 13D8           B8                   0080  mov	ax,#$80
05026 13DB           50                         push	ax
05027                                           ! Debug: list unsigned int = const $9FF0 (used reg = )
05028 13DC           B8                   9FF0  mov	ax,#$9FF0
05029 13DF           50                         push	ax
05030                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05031 13E0           E8         F22E            call	_read_word
05032 13E3           83C4                   04  add	sp,*4
05033                                           ! Debug: eq unsigned short = ax+0 to int max = [S+6-6] (used reg = )
05034 13E6           8946         FC            mov	-4[bp],ax
05035                                           !BCC_EOS
05036                                           ! 1296     for(;;) {
05037                                           !BCC_EOS
05038                                           !BCC_EOS
05039                       000013E9            .FD:
05040                                           ! 1297         if (selected > max || selected < 1) selected = 1;
05041                                           ! Debug: gt int max = [S+6-6] to int selected = [S+6+2] (used reg = )
05042 13E9           8B46         04            mov	ax,4[bp]
05043 13EC           3B46         FC            cmp	ax,-4[bp]
05044 13EF           7F           08            jg  	.FF
05045                       000013F1            .100:
05046                                           ! Debug: lt int = const 1 to int selected = [S+6+2] (used reg = )
05047 13F1           8B46         04            mov	ax,4[bp]
05048 13F4           3D                   0001  cmp	ax,*1
05049 13F7           7D           06            jge 	.FE
05050                       000013F9            .FF:
05051                                           ! Debug: eq int = const 1 to int selected = [S+6+2] (used reg = )
05052 13F9           B8                   0001  mov	ax,*1
05053 13FC           8946         04            mov	4[bp],ax
05054                                           !BCC_EOS
05055                                           ! 1298         clearscreen();
05056                       000013FF            .FE:
05057                                           ! Debug: func () void = clearscreen+0 (used reg = )
05058 13FF           E8         FFAC            call	_clearscreen
05059                                           !BCC_EOS
05060                                           ! 1299         bios_printf(2 | 4, "\n\n\n\n\n\n\n");
05061                                           ! Debug: list * char = .101+0 (used reg = )
05062 1402           BB                   DBAE  mov	bx,#.101
05063 1405           53                         push	bx
05064                                           ! Debug: list int = const 6 (used reg = )
05065 1406           B8                   0006  mov	ax,*6
05066 1409           50                         push	ax
05067                                           ! Debug: func () void = bios_printf+0 (used reg = )
05068 140A           E8         F49C            call	_bios_printf
05069 140D           83C4                   04  add	sp,*4
05070                                           !BCC_EOS
05071                                           ! 1300         bios_printf(2 | 4, "          Select boot device\n\n");
05072                                           ! Debug: list * char = .102+0 (used reg = )
05073 1410           BB                   DB8F  mov	bx,#.102
05074 1413           53                         push	bx
05075                                           ! Debug: list int = const 6 (used reg = )
05076 1414           B8                   0006  mov	ax,*6
05077 1417           50                         push	ax
05078                                           ! Debug: func () void = bios_printf+0 (used reg = )
05079 1418           E8         F48E            call	_bios_printf
05080 141B           83C4                   04  add	sp,*4
05081                                           !BCC_EOS
05082                                           ! 1301         bios_printf(2 | 4, "            1. Floppy\n");
05083                                           ! Debug: list * char = .103+0 (used reg = )
05084 141E           BB                   DB78  mov	bx,#.103
05085 1421           53                         push	bx
05086                                           ! Debug: list int = const 6 (used reg = )
05087 1422           B8                   0006  mov	ax,*6
05088 1425           50                         push	ax
05089                                           ! Debug: func () void = bios_printf+0 (used reg = )
05090 1426           E8         F480            call	_bios_printf
05091 1429           83C4                   04  add	sp,*4
05092                                           !BCC_EOS
05093                                           ! 1302         bios_printf(2 | 4, "            2. Hard drive\n");
05094                                           ! Debug: list * char = .104+0 (used reg = )
05095 142C           BB                   DB5D  mov	bx,#.104
05096 142F           53                         push	bx
05097                                           ! Debug: list int = const 6 (used reg = )
05098 1430           B8                   0006  mov	ax,*6
05099 1433           50                         push	ax
05100                                           ! Debug: func () void = bios_printf+0 (used reg = )
05101 1434           E8         F472            call	_bios_printf
05102 1437           83C4                   04  add	sp,*4
05103                                           !BCC_EOS
05104                                           ! 1303         bios_printf(2 | 4, "            3. CD-ROM\n");
05105                                           ! Debug: list * char = .105+0 (used reg = )
05106 143A           BB                   DB46  mov	bx,#.105
05107 143D           53                         push	bx
05108                                           ! Debug: list int = const 6 (used reg = )
05109 143E           B8                   0006  mov	ax,*6
05110 1441           50                         push	ax
05111                                           ! Debug: func () void = bios_printf+0 (used reg = )
05112 1442           E8         F464            call	_bios_printf
05113 1445           83C4                   04  add	sp,*4
05114                                           !BCC_EOS
05115                                           ! 1304         if (max == 4)
05116                                           ! Debug: logeq int = const 4 to int max = [S+6-6] (used reg = )
05117 1448           8B46         FC            mov	ax,-4[bp]
05118 144B           3D                   0004  cmp	ax,*4
05119 144E           75           0E            jne 	.106
05120                       00001450            .107:
05121                                           ! 1305             bios_printf(2 | 4, "            4. Network\n");
05122                                           ! Debug: list * char = .108+0 (used reg = )
05123 1450           BB                   DB2E  mov	bx,#.108
05124 1453           53                         push	bx
05125                                           ! Debug: list int = const 6 (used reg = )
05126 1454           B8                   0006  mov	ax,*6
05127 1457           50                         push	ax
05128                                           ! Debug: func () void = bios_printf+0 (used reg = )
05129 1458           E8         F44E            call	_bios_printf
05130 145B           83C4                   04  add	sp,*4
05131                                           !BCC_EOS
05132                                           ! 1306         bios_printf(2 | 4, "\n\n          Currently selected: %d\n", selected);
05133                       0000145E            .106:
05134                                           ! Debug: list int selected = [S+6+2] (used reg = )
05135 145E           FF76         04            push	4[bp]
05136                                           ! Debug: list * char = .109+0 (used reg = )
05137 1461           BB                   DB0A  mov	bx,#.109
05138 1464           53                         push	bx
05139                                           ! Debug: list int = const 6 (used reg = )
05140 1465           B8                   0006  mov	ax,*6
05141 1468           50                         push	ax
05142                                           ! Debug: func () void = bios_printf+0 (used reg = )
05143 1469           E8         F43D            call	_bios_printf
05144 146C           83C4                   06  add	sp,*6
05145                                           !BCC_EOS
05146                                           ! 1307         do {
05147                       0000146F            .10C:
05148                                           ! 1308             scode = wait(18, 1);
05149                                           ! Debug: list int = const 1 (used reg = )
05150 146F           B8                   0001  mov	ax,*1
05151 1472           50                         push	ax
05152                                           ! Debug: list int = const $12 (used reg = )
05153 1473           B8                   0012  mov	ax,*$12
05154 1476           50                         push	ax
05155                                           ! Debug: func () unsigned char = wait+0 (used reg = )
05156 1477           E8         FE4F            call	_wait
05157 147A           83C4                   04  add	sp,*4
05158                                           ! Debug: eq unsigned char = al+0 to unsigned char scode = [S+6-3] (used reg = )
05159 147D           8846         FF            mov	-1[bp],al
05160                                           !BCC_EOS
05161                                           ! 1309         } while (scode == 0);
05162                       00001480            .10B:
05163                                           ! Debug: logeq int = const 0 to unsigned char scode = [S+6-3] (used reg = )
05164 1480           8A46         FF            mov	al,-1[bp]
05165 1483           84C0                       test	al,al
05166 1485           74           E8            je 	.10C
05167                       00001487            .10D:
05168                                           !BCC_EOS
05169                                           ! 1310         switch(scode) {
05170                       00001487            .10A:
05171 1487           8A46         FF            mov	al,-1[bp]
05172 148A           EB           68            jmp .110
05173                                           ! 1311         case 0x02:
05174                                           ! 1312         case 0x03:
05175                       0000148C            .111:
05176                                           ! 1313         case 0x04:
05177                       0000148C            .112:
05178                                           ! 1314             selected = scode - 1;
05179                       0000148C            .113:
05180                                           ! Debug: sub int = const 1 to unsigned char scode = [S+6-3] (used reg = )
05181 148C           8A46         FF            mov	al,-1[bp]
05182 148F           30E4                       xor	ah,ah
05183                                           ! Debug: eq unsigned int = ax-1 to int selected = [S+6+2] (used reg = )
05184 1491           48                         dec	ax
05185 1492           8946         04            mov	4[bp],ax
05186                                           !BCC_EOS
05187                                           ! 1315             break;
05188 1495           EB           7B            jmp .10E
05189                                           !BCC_EOS
05190                                           ! 1316         case 0x05:
05191                                           ! 1317             if (max == 4)
05192                       00001497            .114:
05193                                           ! Debug: logeq int = const 4 to int max = [S+6-6] (used reg = )
05194 1497           8B46         FC            mov	ax,-4[bp]
05195 149A           3D                   0004  cmp	ax,*4
05196 149D           75           0B            jne 	.115
05197                       0000149F            .116:
05198                                           ! 1318                 selected = scode -1 ;
05199                                           ! Debug: sub int = const 1 to unsigned char scode = [S+6-3] (used reg = )
05200 149F           8A46         FF            mov	al,-1[bp]
05201 14A2           30E4                       xor	ah,ah
05202                                           ! Debug: eq unsigned int = ax-1 to int selected = [S+6+2] (used reg = )
05203 14A4           48                         dec	ax
05204 14A5           8946         04            mov	4[bp],ax
05205                                           !BCC_EOS
05206                                           ! 1319             else
05207                                           ! 1320                 scode = 0;
05208 14A8           EB           05            jmp .117
05209                       000014AA            .115:
05210                                           ! Debug: eq int = const 0 to unsigned char scode = [S+6-3] (used reg = )
05211 14AA           30C0                       xor	al,al
05212 14AC           8846         FF            mov	-1[bp],al
05213                                           !BCC_EOS
05214                                           ! 1321             break;
05215                       000014AF            .117:
05216 14AF           EB           61            jmp .10E
05217                                           !BCC_EOS
05218                                           ! 1322         case 0x48:
05219                                           ! 1323             selected -= 1;
05220                       000014B1            .118:
05221                                           ! Debug: subab int = const 1 to int selected = [S+6+2] (used reg = )
05222 14B1           8B46         04            mov	ax,4[bp]
05223 14B4           48                         dec	ax
05224 14B5           8946         04            mov	4[bp],ax
05225                                           !BCC_EOS
05226                                           ! 1324             if (selected < 1)
05227                                           ! Debug: lt int = const 1 to int selected = [S+6+2] (used reg = )
05228 14B8           8B46         04            mov	ax,4[bp]
05229 14BB           3D                   0001  cmp	ax,*1
05230 14BE           7D           06            jge 	.119
05231                       000014C0            .11A:
05232                                           ! 1325                 selected = 1;
05233                                           ! Debug: eq int = const 1 to int selected = [S+6+2] (used reg = )
05234 14C0           B8                   0001  mov	ax,*1
05235 14C3           8946         04            mov	4[bp],ax
05236                                           !BCC_EOS
05237                                           ! 1326             scode = 0;
05238                       000014C6            .119:
05239                                           ! Debug: eq int = const 0 to unsigned char scode = [S+6-3] (used reg = )
05240 14C6           30C0                       xor	al,al
05241 14C8           8846         FF            mov	-1[bp],al
05242                                           !BCC_EOS
05243                                           ! 1327             break;
05244 14CB           EB           45            jmp .10E
05245                                           !BCC_EOS
05246                                           ! 1328         case 0x50:
05247                                           ! 1329             selected += 1;
05248                       000014CD            .11B:
05249                                           ! Debug: addab int = const 1 to int selected = [S+6+2] (used reg = )
05250 14CD           8B46         04            mov	ax,4[bp]
05251 14D0           40                         inc	ax
05252 14D1           8946         04            mov	4[bp],ax
05253                                           !BCC_EOS
05254                                           ! 1330             if (selected > max)
05255                                           ! Debug: gt int max = [S+6-6] to int selected = [S+6+2] (used reg = )
05256 14D4           8B46         04            mov	ax,4[bp]
05257 14D7           3B46         FC            cmp	ax,-4[bp]
05258 14DA           7E           06            jle 	.11C
05259                       000014DC            .11D:
05260                                           ! 1331                 sele
05261                                           ! 1331 cted = max;
05262                                           ! Debug: eq int max = [S+6-6] to int selected = [S+6+2] (used reg = )
05263 14DC           8B46         FC            mov	ax,-4[bp]
05264 14DF           8946         04            mov	4[bp],ax
05265                                           !BCC_EOS
05266                                           ! 1332             scode = 0;
05267                       000014E2            .11C:
05268                                           ! Debug: eq int = const 0 to unsigned char scode = [S+6-3] (used reg = )
05269 14E2           30C0                       xor	al,al
05270 14E4           8846         FF            mov	-1[bp],al
05271                                           !BCC_EOS
05272                                           ! 1333             break;
05273 14E7           EB           29            jmp .10E
05274                                           !BCC_EOS
05275                                           ! 1334         case 0x1c:
05276                                           ! 1335             break;
05277                       000014E9            .11E:
05278 14E9           EB           27            jmp .10E
05279                                           !BCC_EOS
05280                                           ! 1336         default:
05281                                           ! 1337             scode = 0;
05282                       000014EB            .11F:
05283                                           ! Debug: eq int = const 0 to unsigned char scode = [S+6-3] (used reg = )
05284 14EB           30C0                       xor	al,al
05285 14ED           8846         FF            mov	-1[bp],al
05286                                           !BCC_EOS
05287                                           ! 1338             break;
05288 14F0           EB           20            jmp .10E
05289                                           !BCC_EOS
05290                                           ! 1339         }
05291                                           ! 1340         if (scode != 0)
05292 14F2           EB           1E            jmp .10E
05293                       000014F4            .110:
05294 14F4           2C                     02  sub	al,*2
05295 14F6           74           94            je 	.111
05296 14F8           2C                     01  sub	al,*1
05297 14FA           74           90            je 	.112
05298 14FC           2C                     01  sub	al,*1
05299 14FE           74           8C            je 	.113
05300 1500           2C                     01  sub	al,*1
05301 1502           74           93            je 	.114
05302 1504           2C                     17  sub	al,*$17
05303 1506           74           E1            je 	.11E
05304 1508           2C                     2C  sub	al,*$2C
05305 150A           74           A5            je 	.118
05306 150C           2C                     08  sub	al,*8
05307 150E           74           BD            je 	.11B
05308 1510           EB           D9            jmp	.11F
05309                       00001512            .10E:
05310                       FFFFFFFA            ..FFFF	=	-6
05311                                           ! Debug: ne int = const 0 to unsigned char scode = [S+6-3] (used reg = )
05312 1512           8A46         FF            mov	al,-1[bp]
05313 1515           84C0                       test	al,al
05314 1517           74           02            je  	.120
05315                       00001519            .121:
05316                                           ! 1341             break;
05317 1519           EB           03            jmp .FB
05318                                           !BCC_EOS
05319                                           ! 1342     }
05320                       0000151B            .120:
05321                                           ! 1343     switch (selected) {
05322                       0000151B            .FC:
05323 151B           E9         FECB            br 	.FD
05324                       0000151E            .FB:
05325 151E           8B46         04            mov	ax,4[bp]
05326 1521           EB           24            jmp .124
05327                                           ! 1344     case 1:
05328                                           ! 1345         return 0x3D;
05329                       00001523            .125:
05330 1523           B8                   003D  mov	ax,*$3D
05331 1526           89EC                       mov	sp,bp
05332 1528           5D                         pop	bp
05333 1529           C3                         ret
05334                                           !BCC_EOS
05335                                           ! 1346     case 2:
05336                                           ! 1347         return 0x3E;
05337                       0000152A            .126:
05338 152A           B8                   003E  mov	ax,*$3E
05339 152D           89EC                       mov	sp,bp
05340 152F           5D                         pop	bp
05341 1530           C3                         ret
05342                                           !BCC_EOS
05343                                           ! 1348     case 3:
05344                                           ! 1349         return 0x3F;
05345                       00001531            .127:
05346 1531           B8                   003F  mov	ax,*$3F
05347 1534           89EC                       mov	sp,bp
05348 1536           5D                         pop	bp
05349 1537           C3                         ret
05350                                           !BCC_EOS
05351                                           ! 1350     case 4:
05352                                           ! 1351         return 0x58;
05353                       00001538            .128:
05354 1538           B8                   0058  mov	ax,*$58
05355 153B           89EC                       mov	sp,bp
05356 153D           5D                         pop	bp
05357 153E           C3                         ret
05358                                           !BCC_EOS
05359                                           ! 1352     default:
05360                                           ! 1353         return 0;
05361                       0000153F            .129:
05362 153F           31C0                       xor	ax,ax
05363 1541           89EC                       mov	sp,bp
05364 1543           5D                         pop	bp
05365 1544           C3                         ret
05366                                           !BCC_EOS
05367                                           ! 1354     }
05368                                           ! 1355 }
05369 1545           EB           16            jmp .122
05370                       00001547            .124:
05371 1547           2D                   0001  sub	ax,*1
05372 154A           74           D7            je 	.125
05373 154C           2D                   0001  sub	ax,*1
05374 154F           74           D9            je 	.126
05375 1551           2D                   0001  sub	ax,*1
05376 1554           74           DB            je 	.127
05377 1556           2D                   0001  sub	ax,*1
05378 1559           74           DD            je 	.128
05379 155B           EB           E2            jmp	.129
05380                       0000155D            .122:
05381                       FFFFFFFA            ..FFFE	=	-6
05382 155D           89EC                       mov	sp,bp
05383 155F           5D                         pop	bp
05384 1560           C3                         ret
05385                                           ! 1356 void interactive_bootkey()
05386                                           ! Register BX used in function bootmenu
05387                                           ! 1357 {
05388                                           export	_interactive_bootkey
05389                       00001561            _interactive_bootkey:
05390                                           ! 1358     Bit16u i;
05391                                           !BCC_EOS
05392                                           ! 1359     Bit8u scan = 0;
05393 1561           55                         push	bp
05394 1562           89E5                       mov	bp,sp
05395 1564           83C4                   FD  add	sp,*-3
05396                                           ! Debug: eq int = const 0 to unsigned char scan = [S+5-5] (used reg = )
05397 1567           30C0                       xor	al,al
05398 1569           8846         FD            mov	-3[bp],al
05399                                           !BCC_EOS
05400                                           ! 1360     bios_printf(2 | 4,
05401 156C           4C                         dec	sp
05402                                           ! 1361                 "\n\nPress F10 to select boot device.\n");
05403                                           ! Debug: list * char = .12A+0 (used reg = )
05404 156D           BB                   DAE6  mov	bx,#.12A
05405 1570           53                         push	bx
05406                                           ! Debug: list int = const 6 (used reg = )
05407 1571           B8                   0006  mov	ax,*6
05408 1574           50                         push	ax
05409                                           ! Debug: func () void = bios_printf+0 (used reg = )
05410 1575           E8         F331            call	_bios_printf
05411 1578           83C4                   04  add	sp,*4
05412                                           !BCC_EOS
05413                                           ! 1362     scan = wait(1, 0);
05414                                           ! Debug: list int = const 0 (used reg = )
05415 157B           31C0                       xor	ax,ax
05416 157D           50                         push	ax
05417                                           ! Debug: list int = const 1 (used reg = )
05418 157E           B8                   0001  mov	ax,*1
05419 1581           50                         push	ax
05420                                           ! Debug: func () unsigned char = wait+0 (used reg = )
05421 1582           E8         FD44            call	_wait
05422 1585           83C4                   04  add	sp,*4
05423                                           ! Debug: eq unsigned char = al+0 to unsigned char scan = [S+6-5] (used reg = )
05424 1588           8846         FD            mov	-3[bp],al
05425                                           !BCC_EOS
05426                                           ! 1363     if (scan == 0x44)
05427                                           ! Debug: logeq int = const $44 to unsigned char scan = [S+6-5] (used reg = )
05428 158B           8A46         FD            mov	al,-3[bp]
05429 158E           3C                     44  cmp	al,*$44
05430 1590           75           16            jne 	.12B
05431                       00001592            .12C:
05432                                           ! 1364         scan = bootmenu(inb_cmos(0x3d) & 0x0f);
05433                                           ! Debug: list int = const $3D (used reg = )
05434 1592           B8                   003D  mov	ax,*$3D
05435 1595           50                         push	ax
05436                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
05437 1596           E8         EFF4            call	_inb_cmos
05438 1599           44                         inc	sp
05439 159A           44                         inc	sp
05440                                           ! Debug: and int = const $F to unsigned char = al+0 (used reg = )
05441 159B           24                     0F  and	al,*$F
05442                                           ! Debug: list unsigned char = al+0 (used reg = )
05443 159D           30E4                       xor	ah,ah
05444 159F           50                         push	ax
05445                                           ! Debug: func () int = bootmenu+0 (used reg = )
05446 15A0           E8         FE2F            call	_bootmenu
05447 15A3           44                         inc	sp
05448 15A4           44                         inc	sp
05449                                           ! Debug: eq int = ax+0 to unsigned char scan = [S+6-5] (used reg = )
05450 15A5           8846         FD            mov	-3[bp],al
05451                                           !BCC_EOS
05452                                           ! 1365     switch(scan) {
05453                       000015A8            .12B:
05454 15A8           8A46         FD            mov	al,-3[bp]
05455 15AB           EB           44            jmp .12F
05456                                           ! 1366     case 0x3D:
05457                                           ! 1367         outb_cmos(0x3d, 0x01);
05458                       000015AD            .130:
05459                                           ! Debug: list int = const 1 (used reg = )
05460 15AD           B8                   0001  mov	ax,*1
05461 15B0           50                         push	ax
05462                                           ! Debug: list int = const $3D (used reg = )
05463 15B1           B8                   003D  mov	ax,*$3D
05464 15B4           50                         push	ax
05465                                           ! Debug: func () void = outb_cmos+0 (used reg = )
05466 15B5           E8         EFC6            call	_outb_cmos
05467 15B8           83C4                   04  add	sp,*4
05468                                           !BCC_EOS
05469                                           ! 1368         break;
05470 15BB           EB           46            jmp .12D
05471                                           !BCC_EOS
05472                                           ! 1369     case 0x3E:
05473                                           ! 1370         outb_cmos(0x3d, 0x02);
05474                       000015BD            .131:
05475                                           ! Debug: list int = const 2 (used reg = )
05476 15BD           B8                   0002  mov	ax,*2
05477 15C0           50                         push	ax
05478                                           ! Debug: list int = const $3D (used reg = )
05479 15C1           B8                   003D  mov	ax,*$3D
05480 15C4           50                         push	ax
05481                                           ! Debug: func () void = outb_cmos+0 (used reg = )
05482 15C5           E8         EFB6            call	_outb_cmos
05483 15C8           83C4                   04  add	sp,*4
05484                                           !BCC_EOS
05485                                           ! 1371         break;
05486 15CB           EB           36            jmp .12D
05487                                           !BCC_EOS
05488                                           ! 1372     case 0x3F:
05489                                           ! 1373         outb_cmos(0x3d, 0x03);
05490                       000015CD            .132:
05491                                           ! Debug: list int = const 3 (used reg = )
05492 15CD           B8                   0003  mov	ax,*3
05493 15D0           50                         push	ax
05494                                           ! Debug: list int = const $3D (used reg = )
05495 15D1           B8                   003D  mov	ax,*$3D
05496 15D4           50                         push	ax
05497                                           ! Debug: func () void = outb_cmos+0 (used reg = )
05498 15D5           E8         EFA6            call	_outb_cmos
05499 15D8           83C4                   04  add	sp,*4
05500                                           !BCC_EOS
05501                                           ! 1374         break;
05502 15DB           EB           26            jmp .12D
05503                                           !BCC_EOS
05504                                           ! 1375     case 0x58:
05505                                           ! 1376         outb_cmos(0x3d, 0x04);
05506                       000015DD            .133:
05507                                           ! Debug: list int = const 4 (used reg = )
05508 15DD           B8                   0004  mov	ax,*4
05509 15E0           50                         push	ax
05510                                           ! Debug: list int = const $3D (used reg = )
05511 15E1           B8                   003D  mov	ax,*$3D
05512 15E4           50                         push	ax
05513                                           ! Debug: func () void = outb_cmos+0 (used reg = )
05514 15E5           E8         EF96            call	_outb_cmos
05515 15E8           83C4                   04  add	sp,*4
05516                                           !BCC_EOS
05517                                           ! 1377         break;
05518 15EB           EB           16            jmp .12D
05519                                           !BCC_EOS
05520                                           ! 1378     default:
05521                                           ! 1379         break;
05522                       000015ED            .134:
05523 15ED           EB           14            jmp .12D
05524                                           !BCC_EOS
05525                                           ! 1380     }
05526                                           ! 1381 }
05527 15EF           EB           12            jmp .12D
05528                       000015F1            .12F:
05529 15F1           2C                     3D  sub	al,*$3D
05530 15F3           74           B8            je 	.130
05531 15F5           2C                     01  sub	al,*1
05532 15F7           74           C4            je 	.131
05533 15F9           2C                     01  sub	al,*1
05534 15FB           74           D0            je 	.132
05535 15FD           2C                     19  sub	al,*$19
05536 15FF           74           DC            je 	.133
05537 1601           EB           EA            jmp	.134
05538                       00001603            .12D:
05539                       FFFFFFFA            ..FFFD	=	-6
05540 1603           89EC                       mov	sp,bp
05541 1605           5D                         pop	bp
05542 1606           C3                         ret
05543                                           ! 1382 void
05544                                           ! Register BX used in function interactive_bootkey
05545                                           ! 1383 nmi_handler_msg()
05546                                           ! 1384 {
05547                                           export	_nmi_handler_msg
05548                       00001607            _nmi_handler_msg:
05549                                           ! 1385   bios_printf((2 | 4 | 1), "NMI Handler called\n");
05550 1607           55                         push	bp
05551 1608           89E5                       mov	bp,sp
05552                                           ! Debug: list * char = .135+0 (used reg = )
05553 160A           BB                   DAD2  mov	bx,#.135
05554 160D           53                         push	bx
05555                                           ! Debug: list int = const 7 (used reg = )
05556 160E           B8                   0007  mov	ax,*7
05557 1611           50                         push	ax
05558                                           ! Debug: func () void = bios_printf+0 (used reg = )
05559 1612           E8         F294            call	_bios_printf
05560 1615           89EC                       mov	sp,bp
05561                                           !BCC_EOS
05562                                           ! 1386 }
05563 1617           5D                         pop	bp
05564 1618           C3                         ret
05565                                           ! 1387 void
05566                                           ! Register BX used in function nmi_handler_msg
05567                                           ! 1388 int18_panic_msg()
05568                                           ! 1389 {
05569                                           export	_int18_panic_msg
05570                       00001619            _int18_panic_msg:
05571                                           ! 1390   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
05572 1619           55                         push	bp
05573 161A           89E5                       mov	bp,sp
05574                                           ! Debug: list * char = .136+0 (used reg = )
05575 161C           BB                   DABD  mov	bx,#.136
05576 161F           53                         push	bx
05577                                           ! Debug: list int = const 7 (used reg = )
05578 1620           B8                   0007  mov	ax,*7
05579 1623           50                         push	ax
05580                                           ! Debug: func () void = bios_printf+0 (used reg = )
05581 1624           E8         F282            call	_bios_printf
05582 1627           89EC                       mov	sp,bp
05583                                           !BCC_EOS
05584                                           ! 1391 }
05585 1629           5D                         pop	bp
05586 162A           C3                         ret
05587                                           ! 1392 void
05588                                           ! Register BX used in function int18_panic_msg
05589                                           ! 1393 log_bios_start()
05590                                           ! 1394 {
05591                                           export	_log_bios_start
05592                       0000162B            _log_bios_start:
05593                                           ! 1395   bios_printf(4, "%s\n", (CVSID + 4));
05594 162B           55                         push	bp
05595 162C           89E5                       mov	bp,sp
05596                                           ! Debug: list * char = CVSID+4 (used reg = )
05597 162E           BB                   0198  mov	bx,#_CVSID+4
05598 1631           53                         push	bx
05599                                           ! Debug: list * char = .137+0 (used reg = )
05600 1632           BB                   DAB9  mov	bx,#.137
05601 1635           53                         push	bx
05602                                           ! Debug: list int = const 4 (used reg = )
05603 1636           B8                   0004  mov	ax,*4
05604 1639           50                         push	ax
05605                                           ! Debug: func () void = bios_printf+0 (used reg = )
05606 163A           E8         F26C            call	_bios_printf
05607 163D           89EC                       mov	sp,bp
05608                                           !BCC_EOS
05609                                           ! 1396 }
05610 163F           5D                         pop	bp
05611 1640           C3                         ret
05612                                           ! 1397   bx_bool
05613                                           ! Register BX used in function log_bios_start
05614                                           ! 1398 set_enable_a20(val)
05615                                           ! 1399   bx_bool val;
05616                                           export	_set_enable_a20
05617                       00001641            _set_enable_a20:
05618                                           !BCC_EOS
05619                                           ! 1400 {
05620                                           ! 1401   Bit8u oldval;
05621                                           !BCC_EOS
05622                                           ! 1402   oldval = inb(0x92);
05623 1641           55                         push	bp
05624 1642           89E5                       mov	bp,sp
05625 1644           4C                         dec	sp
05626 1645           4C                         dec	sp
05627                                           ! Debug: list int = const $92 (used reg = )
05628 1646           B8                   0092  mov	ax,#$92
05629 1649           50                         push	ax
05630                                           ! Debug: func () unsigned char = inb+0 (used reg = )
05631 164A           E8         EEFB            call	_inb
05632 164D           44                         inc	sp
05633 164E           44                         inc	sp
05634                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
05635 164F           8846         FF            mov	-1[bp],al
05636                                           !BCC_EOS
05637                                           ! 1403   if (val)
05638 1652           8B46         04            mov	ax,4[bp]
05639 1655           85C0                       test	ax,ax
05640 1657           74           14            je  	.138
05641                       00001659            .139:
05642                                           ! 1404     outb(0x92, oldval | 0x02);
05643                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
05644 1659           8A46         FF            mov	al,-1[bp]
05645 165C           0C                     02  or	al,*2
05646                                           ! Debug: list unsigned char = al+0 (used reg = )
05647 165E           30E4                       xor	ah,ah
05648 1660           50                         push	ax
05649                                           ! Debug: list int = const $92 (used reg = )
05650 1661           B8                   0092  mov	ax,#$92
05651 1664           50                         push	ax
05652                                           ! Debug: func () void = outb+0 (used reg = )
05653 1665           E8         EEF6            call	_outb
05654 1668           83C4                   04  add	sp,*4
05655                                           !BCC_EOS
05656                                           ! 1405   else
05657                                           ! 1406     outb(0x92, oldval & 0xfd);
05658 166B           EB           12            jmp .13A
05659                       0000166D            .138:
05660                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
05661 166D           8A46         FF            mov	al,-1[bp]
05662 1670           24                     FD  and	al,#$FD
05663                                           ! Debug: list unsigned char = al+0 (used reg = )
05664 1672           30E4                       xor	ah,ah
05665 1674           50                         push	ax
05666                                           ! Debug: list int = const $92 (used reg = )
05667 1675           B8                   0092  mov	ax,#$92
05668 1678           50                         push	ax
05669                                           ! Debug: func () void = outb+0 (used reg = )
05670 1679           E8         EEE2            call	_outb
05671 167C           83C4                   04  add	sp,*4
05672                                           !BCC_EOS
05673                                           ! 1407   return((oldval & 0x02) != 0);
05674                       0000167F            .13A:
05675                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
05676 167F           8A46         FF            mov	al,-1[bp]
05677 1682           24                     02  and	al,*2
05678                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
05679 1684           84C0                       test	al,al
05680 1686           74           04            je 	.13B
05681 1688           B0                     01  mov	al,*1
05682 168A           EB           02            jmp	.13C
05683                       0000168C            .13B:
05684 168C           30C0                       xor	al,al
05685                       0000168E            .13C:
05686                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
05687 168E           30E4                       xor	ah,ah
05688 1690           89EC                       mov	sp,bp
05689 1692           5D                         pop	bp
05690 1693           C3                         ret
05691                                           !BCC_EOS
05692                                           ! 1408 }
05693                                           ! 1409   void
05694                                           ! 1410 debugger_on()
05695                                           ! 1411 {
05696                                           export	_debugger_on
05697                       00001694            _debugger_on:
05698                                           ! 1412   outb(0xfedc, 0x01);
05699 1694           55                         push	bp
05700 1695           89E5                       mov	bp,sp
05701                                           ! Debug: list int = const 1 (used reg = )
05702 1697           B8                   0001  mov	ax,*1
05703 169A           50                         push	ax
05704                                           ! Debug: list unsigned int = const $FEDC (used reg = )
05705 169B           B8                   FEDC  mov	ax,#$FEDC
05706 169E           50                         push	ax
05707                                           ! Debug: func () void = outb+0 (used reg = )
05708 169F           E8         EEBC            call	_outb
05709 16A2           89EC                       mov	sp,bp
05710                                           !BCC_EOS
05711                                           ! 1413 }
05712 16A4           5D                         pop	bp
05713 16A5           C3                         ret
05714                                           ! 1414   void
05715                                           ! 1415 debugger_off()
05716                                           ! 1416 {
05717                                           export	_debugger_off
05718                       000016A6            _debugger_off:
05719                                           ! 1417   outb(0xfedc, 0x00);
05720 16A6           55                         push	bp
05721 16A7           89E5                       mov	bp,sp
05722                                           ! Debug: list int = const 0 (used reg = )
05723 16A9           31C0                       xor	ax,ax
05724 16AB           50                         push	ax
05725                                           ! Debug: list unsigned int = const $FEDC (used reg = )
05726 16AC           B8                   FEDC  mov	ax,#$FEDC
05727 16AF           50                         push	ax
05728                                           ! Debug: func () void = outb+0 (used reg = )
05729 16B0           E8         EEAB            call	_outb
05730 16B3           89EC                       mov	sp,bp
05731                                           !BCC_EOS
05732                                           ! 1418 }
05733 16B5           5D                         pop	bp
05734 16B6           C3                         ret
05735                                           ! 1419 void
05736                                           ! 1420 s3_resume()
05737                                           ! 1421 {
05738                                           export	_s3_resume
05739                       000016B7            _s3_resume:
05740                                           ! 1422     Bit32u s3_wakeup_vector;
05741                                           !BCC_EOS
05742                                           ! 1423     Bit16u s3_wakeup_ip, s3_wakeup_cs;
05743                                           !BCC_EOS
05744                                           ! 1424     Bit8u cmos_shutdown_status;
05745                                           !BCC_EOS
05746                                           ! 1425 #asm
05747 16B7           55                         push	bp
05748 16B8           89E5                       mov	bp,sp
05749 16BA           83C4                   F6  add	sp,*-$A
05750                                           !BCC_EOS
05751                                           !BCC_ASM
05752                       00000001            _s3_resume.cmos_shutdown_status	set	1
05753                       FFFFFFF7            .s3_resume.cmos_shutdown_status	set	-9
05754                       00000004            _s3_resume.s3_wakeup_ip	set	4
05755                       FFFFFFFA            .s3_resume.s3_wakeup_ip	set	-6
05756                       00000006            _s3_resume.s3_wakeup_vector	set	6
05757                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
05758                       00000002            _s3_resume.s3_wakeup_cs	set	2
05759                       FFFFFFF8            .s3_resume.s3_wakeup_cs	set	-8
05760 16BD           1E                             push ds
05761 16BE           50                             push ax
05762 16BF           B8                   9FC0      mov ax, #0x9FC0
05763 16C2           8ED8                           mov ds, ax
05764 16C4           A0         0001                mov al, [1]
05765 16C7           8846         F7                mov .s3_resume.cmos_shutdown_status[bp], al
05766 16CA           58                             pop ax
05767 16CB           1F                             pop ds
05768                                           ! 1434 endasm
05769                                           !BCC_ENDASM
05770                                           !BCC_EOS
05771                                           ! 1435     if (cmos_shutdown_status != 0xFE)
05772                                           ! Debug: ne int = const $FE to unsigned char cmos_shutdown_status = [S+$C-$B] (used reg = )
05773 16CC           8A46         F7            mov	al,-9[bp]
05774 16CF           3C                     FE  cmp	al,#$FE
05775 16D1           74           04            je  	.13D
05776                       000016D3            .13E:
05777                                           ! 1436         return;
05778 16D3           89EC                       mov	sp,bp
05779 16D5           5D                         pop	bp
05780 16D6           C3                         ret
05781                                           !BCC_EOS
05782                                           ! 1437     s3_wakeup_vector = get_s3_waking_vector();
05783                       000016D7            .13D:
05784                                           ! Debug: func () unsigned long = get_s3_waking_vector+0 (used reg = )
05785 16D7           E8         9360            call	_get_s3_waking_vector
05786 16DA           89D3                       mov	bx,dx
05787                                           ! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
05788 16DC           8946         FC            mov	-4[bp],ax
05789 16DF           895E         FE            mov	-2[bp],bx
05790                                           !BCC_EOS
05791                                           ! 1438     if (!s3_wakeup_vector)
05792 16E2           8B46         FC            mov	ax,-4[bp]
05793 16E5           8B5E         FE            mov	bx,-2[bp]
05794 16E8           E8         E9F9            call	ltstl
05795 16EB           75           04            jne 	.13F
05796                       000016ED            .140:
05797                                           ! 1439         return;
05798 16ED           89EC                       mov	sp,bp
05799 16EF           5D                         pop	bp
05800 16F0           C3                         ret
05801                                           !BCC_EOS
05802                                           ! 1440     s3_wakeup_ip = s3_wakeup_vector & 0xF;
05803                       000016F1            .13F:
05804                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
05805                                           ! Debug: expression subtree swapping
05806 16F1           B8                   000F  mov	ax,*$F
05807 16F4           31DB                       xor	bx,bx
05808 16F6           8D7E         FC            lea	di,-4[bp]
05809 16F9           E8         E98F            call	landul
05810                                           ! Debug: eq unsigned long = bx+0 to unsigned short s3_wakeup_ip = [S+$C-8] (used reg = )
05811 16FC           8946         FA            mov	-6[bp],ax
05812                                           !BCC_EOS
05813                                           ! 1441     s3_wakeup_cs = s3_wakeup_vector >> 4;
05814                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+$C-6] (used reg = )
05815 16FF           8B46         FC            mov	ax,-4[bp]
05816 1702           8B5E         FE            mov	bx,-2[bp]
05817 1705           BF                   0004  mov	di,*4
05818 1708           E8         E9EE            call	lsrul
05819                                           ! Debug: eq unsigned long = bx+0 to unsigned short s3_wakeup_cs = [S+$C-$A] (used reg = )
05820 170B           8946         F8            mov	-8[bp],ax
05821                                           !BCC_EOS
05822                                           ! 1442 #asm
05823                                           !BCC_EOS
05824                                           !BCC_ASM
05825                       00000001            _s3_resume.cmos_shutdown_status	set	1
05826                       FFFFFFF7            .s3_resume.cmos_shutdown_status	set	-9
05827                       00000004            _s3_resume.s3_wakeup_ip	set	4
05828                       FFFFFFFA            .s3_resume.s3_wakeup_ip	set	-6
05829                       00000006            _s3_resume.s3_wakeup_vector	set	6
05830                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
05831                       00000002            _s3_resume.s3_wakeup_cs	set	2
05832                       FFFFFFF8            .s3_resume.s3_wakeup_cs	set	-8
05833 170E           FF76         F8                push .s3_resume.s3_wakeup_cs[bp]
05834 1711           FF76         FA                push .s3_resume.s3_wakeup_ip[bp]
05835 1714           CB                             retf
05836                                           ! 1446 endasm
05837                                           !BCC_ENDASM
05838                                           !BCC_EOS
05839                                           ! 1447 }
05840 1715           89EC                       mov	sp,bp
05841 1717           5D                         pop	bp
05842 1718           C3                         ret
05843                                           ! 1448 void ata_init( )
05844                                           ! Register BX used in function s3_resume
05845                                           ! 1449 {
05846                                           export	_ata_init
05847                       00001719            _ata_init:
05848                                           ! 1450   Bit16u ebda_seg=read_word(0x0040,0x000E);
05849 1719           55                         push	bp
05850 171A           89E5                       mov	bp,sp
05851 171C           4C                         dec	sp
05852 171D           4C                         dec	sp
05853                                           ! Debug: list int = const $E (used reg = )
05854 171E           B8                   000E  mov	ax,*$E
05855 1721           50                         push	ax
05856                                           ! Debug: list int = const $40 (used reg = )
05857 1722           B8                   0040  mov	ax,*$40
05858 1725           50                         push	ax
05859                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05860 1726           E8         EEE8            call	_read_word
05861 1729           83C4                   04  add	sp,*4
05862                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
05863 172C           8946         FE            mov	-2[bp],ax
05864                                           !BCC_EOS
05865                                           ! 1451   Bit8u channel, device;
05866                                           !BCC_EOS
05867                                           ! 1452   for (channel=0; channel<4; channel++) {
05868 172F           4C                         dec	sp
05869 1730           4C                         dec	sp
05870                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
05871 1731           30C0                       xor	al,al
05872 1733           8846         FD            mov	-3[bp],al
05873                                           !BCC_EOS
05874                                           !BCC_EOS
05875 1736           E9         0077            br 	.143
05876                       00001739            .144:
05877                                           ! 1453     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
05878                                           ! Debug: list int = const 0 (used reg = )
05879 1739           31C0                       xor	ax,ax
05880 173B           50                         push	ax
05881                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
05882 173C           8A46         FD            mov	al,-3[bp]
05883 173F           30E4                       xor	ah,ah
05884 1741           B1                     03  mov	cl,*3
05885 1743           D3E0                       shl	ax,cl
05886 1745           89C3                       mov	bx,ax
05887                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
05888                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
05889 1747           81C3                 0122  add	bx,#$122
05890 174B           53                         push	bx
05891                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
05892 174C           FF76         FE            push	-2[bp]
05893                                           ! Debug: func () void = write_byte+0 (used reg = )
05894 174F           E8         EED2            call	_write_byte
05895 1752           83C4                   06  add	sp,*6
05896                                           !BCC_EOS
05897                                           ! 1454     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1,0x0);
05898                                           ! Debug: list int = const 0 (used reg = )
05899 1755           31C0                       xor	ax,ax
05900 1757           50                         push	ax
05901                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
05902 1758           8A46         FD            mov	al,-3[bp]
05903 175B           30E4                       xor	ah,ah
05904 175D           B1                     03  mov	cl,*3
05905 175F           D3E0                       shl	ax,cl
05906 1761           89C3                       mov	bx,ax
05907                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
05908                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
05909 1763           81C3                 0124  add	bx,#$124
05910 1767           53                         push	bx
05911                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
05912 1768           FF76         FE            push	-2[bp]
05913                                           ! Debug: func () void = write_word+0 (used reg = )
05914 176B           E8         EECE            call	_write_word
05915 176E           83C4                   06  add	sp,*6
05916                                           !BCC_EOS
05917                                           ! 1455     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
05918                                           ! Debug: list int = const 0 (used reg = )
05919 1771           31C0                       xor	ax,ax
05920 1773           50                         push	ax
05921                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
05922 1774           8A46         FD            mov	al,-3[bp]
05923 1777           30E4                       xor	ah,ah
05924 1779           B1                     03  mov	cl,*3
05925 177B           D3E0                       shl	ax,cl
05926 177D           89C3                       mov	bx,ax
05927                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
05928                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
05929 177F           81C3                 0126  add	bx,#$126
05930 1783           53                         push	bx
05931                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
05932 1784           FF76         FE            push	-2[bp]
05933                                           ! Debug: func () void = write_word+0 (used reg = )
05934 1787           E8         EEB2            call	_write_word
05935 178A           83C4                   06  add	sp,*6
05936                                           !BCC_EOS
05937                                           ! 1456     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
05938                                           ! Debug: list int = const 0 (used reg = )
05939 178D           31C0                       xor	ax,ax
05940 178F           50                         push	ax
05941                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
05942 1790           8A46         FD            mov	al,-3[bp]
05943 1793           30E4                       xor	ah,ah
05944 1795           B1                     03  mov	cl,*3
05945 1797           D3E0                       shl	ax,cl
05946 1799           89C3                       mov	bx,ax
05947                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
05948                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
05949 179B           81C3                 0128  add	bx,#$128
05950 179F           53                         push	bx
05951                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
05952 17A0           FF76         FE            push	-2[bp]
05953                                           ! Debug: func () void = write_byte+0 (used reg = )
05954 17A3           E8         EE7E            call	_write_byte
05955 17A6           83C4                   06  add	sp,*6
05956                                           !BCC_EOS
05957                                           ! 1457     }
05958                                           ! 1458   for (device=0; device<(4*2); device++) {
05959                       000017A9            .142:
05960                                           ! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
05961 17A9           8A46         FD            mov	al,-3[bp]
05962 17AC           40                         inc	ax
05963 17AD           8846         FD            mov	-3[bp],al
05964                       000017B0            .143:
05965                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
05966 17B0           8A46         FD            mov	al,-3[bp]
05967 17B3           3C                     04  cmp	al,*4
05968 17B5           72           82            jb 	.144
05969                       000017B7            .145:
05970                       000017B7            .141:
05971                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
05972 17B7           30C0                       xor	al,al
05973 17B9           8846         FC            mov	-4[bp],al
05974                                           !BCC_EOS
05975                                           !BCC_EOS
05976 17BC           E9         01A0            br 	.148
05977                       000017BF            .149:
05978                                           ! 1459     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
05979                                           ! Debug: list int = const 0 (used reg = )
05980 17BF           31C0                       xor	ax,ax
05981 17C1           50                         push	ax
05982                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
05983 17C2           8A46         FC            mov	al,-4[bp]
05984 17C5           30E4                       xor	ah,ah
05985 17C7           B9                   001A  mov	cx,*$1A
05986 17CA           F7E9                       imul	cx
05987 17CC           89C3                       mov	bx,ax
05988                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
05989                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
05990 17CE           81C3                 0142  add	bx,#$142
05991 17D2           53                         push	bx
05992                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
05993 17D3           FF76         FE            push	-2[bp]
05994                                           ! Debug: func () void = write_byte+0 (used reg = )
05995 17D6           E8         EE4B            call	_write_byte
05996 17D9           83C4                   06  add	sp,*6
05997                                           !BCC_EOS
05998                                           ! 1460     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
05999                                           ! Debug: list int = const 0 (used reg = )
06000 17DC           31C0                       xor	ax,ax
06001 17DE           50                         push	ax
06002                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06003 17DF           8A46         FC            mov	al,-4[bp]
06004 17E2           30E4                       xor	ah,ah
06005 17E4           B9                   001A  mov	cx,*$1A
06006 17E7           F7E9                       imul	cx
06007 17E9           89C3                       mov	bx,ax
06008                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06009                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
06010 17EB           81C3                 0143  add	bx,#$143
06011 17EF           53                         push	bx
06012                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06013 17F0           FF76         FE            push	-2[bp]
06014                                           ! Debug: func () void = write_byte+0 (used reg = )
06015 17F3           E8         EE2E            call	_write_byte
06016 17F6           83C4                   06  add	sp,*6
06017                                           !BCC_EOS
06018                                           ! 1461     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
06019                                           ! Debug: list int = const 0 (used reg = )
06020 17F9           31C0                       xor	ax,ax
06021 17FB           50                         push	ax
06022                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06023 17FC           8A46         FC            mov	al,-4[bp]
06024 17FF           30E4                       xor	ah,ah
06025 1801           B9                   001A  mov	cx,*$1A
06026 1804           F7E9                       imul	cx
06027 1806           89C3                       mov	bx,ax
06028                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06029                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
06030 1808           81C3                 0144  add	bx,#$144
06031 180C           53                         push	bx
06032                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06033 180D           FF76         FE            push	-2[bp]
06034                                           ! Debug: func () void = write_byte+0 (used reg = )
06035 1810           E8         EE11            call	_write_byte
06036 1813           83C4                   06  add	sp,*6
06037                                           !BCC_EOS
06038                                           ! 1462     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
06039                                           ! Debug: list int = const 0 (used reg = )
06040 1816           31C0                       xor	ax,ax
06041 1818           50                         push	ax
06042                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06043 1819           8A46         FC            mov	al,-4[bp]
06044 181C           30E4                       xor	ah,ah
06045 181E           B9                   001A  mov	cx,*$1A
06046 1821           F7E9                       imul	cx
06047 1823           89C3                       mov	bx,ax
06048                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06049                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
06050 1825           81C3                 0145  add	bx,#$145
06051 1829           53                         push	bx
06052                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06053 182A           FF76         FE            push	-2[bp]
06054                                           ! Debug: func () void = write_byte+0 (used reg = )
06055 182D           E8         EDF4            call	_write_byte
06056 1830           83C4                   06  add	sp,*6
06057                                           !BCC_EOS
06058                                           ! 1463     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
06059                                           ! Debug: list int = const 0 (used reg = )
06060 1833           31C0                       xor	ax,ax
06061 1835           50                         push	ax
06062                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06063 1836           8A46         FC            mov	al,-4[bp]
06064 1839           30E4                       xor	ah,ah
06065 183B           B9                   001A  mov	cx,*$1A
06066 183E           F7E9                       imul	cx
06067 1840           89C3                       mov	bx,ax
06068                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06069                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
06070 1842           81C3                 0146  add	bx,#$146
06071 1846           53                         push	bx
06072                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06073 1847           FF76         FE            push	-2[bp]
06074                                           ! Debug: func () void = write_byte+0 (used reg = )
06075 184A           E8         EDD7            call	_write_byte
06076 184D           83C4                   06  add	sp,*6
06077                                           !BCC_EOS
06078                                           ! 1464     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
06079                                           ! Debug: list int = const 0 (used reg = )
06080 1850           31C0                       xor	ax,ax
06081 1852           50                         push	ax
06082                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06083 1853           8A46         FC            mov	al,-4[bp]
06084 1856           30E4                       xor	ah,ah
06085 1858           B9                   001A  mov	cx,*$1A
06086 185B           F7E9                       imul	cx
06087 185D           89C3                       mov	bx,ax
06088                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06089                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
06090 185F           81C3                 0148  add	bx,#$148
06091 1863           53                         push	bx
06092                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06093 1864           FF76         FE            push	-2[bp]
06094                                           ! Debug: func () void = write_word+0 (used reg = )
06095 1867           E8         EDD2            call	_write_word
06096 186A           83C4                   06  add	sp,*6
06097                                           !BCC_EOS
06098                                           ! 1465     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
06099                                           ! Debug: list int = const 0 (used reg = )
06100 186D           31C0                       xor	ax,ax
06101 186F           50                         push	ax
06102                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06103 1870           8A46         FC            mov	al,-4[bp]
06104 1873           30E4                       xor	ah,ah
06105 1875           B9                   001A  mov	cx,*$1A
06106 1878           F7E9                       imul	cx
06107 187A           89C3                       mov	bx,ax
06108                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06109                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
06110 187C           81C3                 014A  add	bx,#$14A
06111 1880           53                         push	bx
06112                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06113 1881           FF76         FE            push	-2[bp]
06114                                           ! Debug: func () void = write_byte+0 (used reg = )
06115 1884           E8         ED9D            call	_write_byte
06116 1887           83C4                   06  add	sp,*6
06117                                           !BCC_EOS
06118                                           ! 1466     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
06119                                           ! Debug: list int = const 0 (used reg = )
06120 188A           31C0                       xor	ax,ax
06121 188C           50                         push	ax
06122                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06123 188D           8A46         FC            mov	al,-4[bp]
06124 1890           30E4                       xor	ah,ah
06125 1892           B9                   001A  mov	cx,*$1A
06126 1895           F7E9                       imul	cx
06127 1897           89C3                       mov	bx,ax
06128                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06129                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
06130 1899           81C3                 014C  add	bx,#$14C
06131 189D           53                         push	bx
06132                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06133 189E           FF76         FE            push	-2[bp]
06134                                           ! Debug: func () void = write_word+0 (used reg = )
06135 18A1           E8         ED98            call	_write_word
06136 18A4           83C4                   06  add	sp,*6
06137                                           !BCC_EOS
06138                                           ! 1467     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders,0);
06139                                           ! Debug: list int = const 0 (used reg = )
06140 18A7           31C0                       xor	ax,ax
06141 18A9           50                         push	ax
06142                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06143 18AA           8A46         FC            mov	al,-4[bp]
06144 18AD           30E4                       xor	ah,ah
06145 18AF           B9                   001A  mov	cx,*$1A
06146 18B2           F7E9                       imul	cx
06147 18B4           89C3                       mov	bx,ax
06148                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06149                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
06150 18B6           81C3                 014E  add	bx,#$14E
06151 18BA           53                         push	bx
06152                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06153 18BB           FF76         FE            push	-2[bp]
06154                                           ! Debug: func () void = write_word+0 (used reg = )
06155 18BE           E8         ED7B            call	_write_word
06156 18C1           83C4                   06  add	sp,*6
06157                                           !BCC_EOS
06158                                           ! 1468     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
06159                                           ! Debug: list int = const 0 (used reg = )
06160 18C4           31C0                       xor	ax,ax
06161 18C6           50                         push	ax
06162                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06163 18C7           8A46         FC            mov	al,-4[bp]
06164 18CA           30E4                       xor	ah,ah
06165 18CC           B9                   001A  mov	cx,*$1A
06166 18CF           F7E9                       imul	cx
06167 18D1           89C3                       mov	bx,ax
06168                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06169                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
06170 18D3           81C3                 0150  add	bx,#$150
06171 18D7           53                         push	bx
06172                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06173 18D8           FF76         FE            push	-2[bp]
06174                                           ! Debug: func () void = write_word+0 (used reg = )
06175 18DB           E8         ED5E            call	_write_word
06176 18DE           83C4                   06  add	sp,*6
06177                                           !BCC_EOS
06178                                           ! 1469     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads,0);
06179                                           ! Debug: list int = const 0 (used reg = )
06180 18E1           31C0                       xor	ax,ax
06181 18E3           50                         push	ax
06182                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06183 18E4           8A46         FC            mov	al,-4[bp]
06184 18E7           30E4                       xor	ah,ah
06185 18E9           B9                   001A  mov	cx,*$1A
06186 18EC           F7E9                       imul	cx
06187 18EE           89C3                       mov	bx,ax
06188                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06189                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
06190 18F0           81C3                 0152  add	bx,#$152
06191 18F4           53                         push	bx
06192                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06193 18F5           FF76         FE            push	-2[bp]
06194                                           ! Debug: func () void = write_word+0 (used reg = )
06195 18F8           E8         ED41            call	_write_word
06196 18FB           83C4                   06  add	sp,*6
06197                                           !BCC_EOS
06198                                           ! 1470     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
06199                                           ! Debug: list int = const 0 (used reg = )
06200 18FE           31C0                       xor	ax,ax
06201 1900           50                         push	ax
06202                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06203 1901           8A46         FC            mov	al,-4[bp]
06204 1904           30E4                       xor	ah,ah
06205 1906           B9                   001A  mov	cx,*$1A
06206 1909           F7E9                       imul	cx
06207 190B           89C3                       mov	bx,ax
06208                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06209                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
06210 190D           81C3                 0154  add	bx,#$154
06211 1911           53                         push	bx
06212                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06213 1912           FF76         FE            push	-2[bp]
06214                                           ! Debug: func () void = write_word+0 (used reg = )
06215 1915           E8         ED24            call	_write_word
06216 1918           83C4                   06  add	sp,*6
06217                                           !BCC_EOS
06218                                           ! 1471     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
06219                                           ! Debug: list int = const 0 (used reg = )
06220 191B           31C0                       xor	ax,ax
06221 191D           50                         push	ax
06222                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06223 191E           8A46         FC            mov	al,-4[bp]
06224 1921           30E4                       xor	ah,ah
06225 1923           B9                   001A  mov	cx,*$1A
06226 1926           F7E9                       imul	cx
06227 1928           89C3                       mov	bx,ax
06228                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06229                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
06230 192A           81C3                 0156  add	bx,#$156
06231 192E           53                         push	bx
06232                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06233 192F           FF76         FE            push	-2[bp]
06234                                           ! Debug: func () void = write_word+0 (used reg = )
06235 1932           E8         ED07            call	_write_word
06236 1935           83C4                   06  add	sp,*6
06237                                           !BCC_EOS
06238                                           ! 1472     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors,0L);
06239                                           ! Debug: list long = const 0 (used reg = )
06240 1938           31C0                       xor	ax,ax
06241 193A           31DB                       xor	bx,bx
06242 193C           53                         push	bx
06243 193D           50                         push	ax
06244                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06245 193E           8A46         FC            mov	al,-4[bp]
06246 1941           30E4                       xor	ah,ah
06247 1943           B9                   001A  mov	cx,*$1A
06248 1946           F7E9                       imul	cx
06249 1948           89C3                       mov	bx,ax
06250                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06251                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
06252 194A           81C3                 0158  add	bx,#$158
06253 194E           53                         push	bx
06254                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06255 194F           FF76         FE            push	-2[bp]
06256                                           ! Debug: func () void = write_dword+0 (used reg = )
06257 1952           E8         E717            call	_write_dword
06258 1955           83C4                   08  add	sp,*8
06259                                           !BCC_EOS
06260                                           ! 1473     }
06261                                           ! 1474   for (device=0; device<(4*2); device++) {
06262                       00001958            .147:
06263                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06264 1958           8A46         FC            mov	al,-4[bp]
06265 195B           40                         inc	ax
06266 195C           8846         FC            mov	-4[bp],al
06267                       0000195F            .148:
06268                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06269 195F           8A46         FC            mov	al,-4[bp]
06270 1962           3C                     08  cmp	al,*8
06271 1964         0F82         FE57            blo 	.149
06272                       00001968            .14A:
06273                       00001968            .146:
06274                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06275 1968           30C0                       xor	al,al
06276 196A           8846         FC            mov	-4[bp],al
06277                                           !BCC_EOS
06278                                           !BCC_EOS
06279 196D           EB           39            jmp .14D
06280                       0000196F            .14E:
06281                                           ! 1475     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
06282                                           ! Debug: list int = const 8 (used reg = )
06283 196F           B8                   0008  mov	ax,*8
06284 1972           50                         push	ax
06285                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $213 (used reg = )
06286 1973           8A46         FC            mov	al,-4[bp]
06287 1976           30E4                       xor	ah,ah
06288 1978           89C3                       mov	bx,ax
06289                                           ! Debug: address unsigned char = [bx+$213] (used reg = )
06290                                           ! Debug: list * unsigned char = bx+$213 (used reg = )
06291 197A           81C3                 0213  add	bx,#$213
06292 197E           53                         push	bx
06293                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06294 197F           FF76         FE            push	-2[bp]
06295                                           ! Debug: func () void = write_byte+0 (used reg = )
06296 1982           E8         EC9F            call	_write_byte
06297 1985           83C4                   06  add	sp,*6
06298                                           !BCC_EOS
06299                                           ! 1476     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
06300                                           ! Debug: list int = const 8 (used reg = )
06301 1988           B8                   0008  mov	ax,*8
06302 198B           50                         push	ax
06303                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $21C (used reg = )
06304 198C           8A46         FC            mov	al,-4[bp]
06305 198F           30E4                       xor	ah,ah
06306 1991           89C3                       mov	bx,ax
06307                                           ! Debug: address unsigned char = [bx+$21C] (used reg = )
06308                                           ! Debug: list * unsigned char = bx+$21C (used reg = )
06309 1993           81C3                 021C  add	bx,#$21C
06310 1997           53                         push	bx
06311                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06312 1998           FF76         FE            push	-2[bp]
06313                                           ! Debug: func () void = write_byte+0 (used reg = )
06314 199B           E8         EC86            call	_write_byte
06315 199E           83C4                   06  add	sp,*6
06316                                           !BCC_EOS
06317                                           ! 1477     }
06318                                           ! 1478   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
06319                       000019A1            .14C:
06320                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06321 19A1           8A46         FC            mov	al,-4[bp]
06322 19A4           40                         inc	ax
06323 19A5           8846         FC            mov	-4[bp],al
06324                       000019A8            .14D:
06325                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06326 19A8           8A46         FC            mov	al,-4[bp]
06327 19AB           3C                     08  cmp	al,*8
06328 19AD           72           C0            jb 	.14E
06329                       000019AF            .14F:
06330                       000019AF            .14B:
06331                                           ! Debug: list int = const 0 (used reg = )
06332 19AF           31C0                       xor	ax,ax
06333 19B1           50                         push	ax
06334                                           ! Debug: list * unsigned char = const $212 (used reg = )
06335 19B2           B8                   0212  mov	ax,#$212
06336 19B5           50                         push	ax
06337                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06338 19B6           FF76         FE            push	-2[bp]
06339                                           ! Debug: func () void = write_byte+0 (used reg = )
06340 19B9           E8         EC68            call	_write_byte
06341 19BC           83C4                   06  add	sp,*6
06342                                           !BCC_EOS
06343                                           ! 1479   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
06344                                           ! Debug: list int = const 0 (used reg = )
06345 19BF           31C0                       xor	ax,ax
06346 19C1           50                         push	ax
06347                                           ! Debug: list * unsigned char = const $21B (used reg = )
06348 19C2           B8                   021B  mov	ax,#$21B
06349 19C5           50                         push	ax
06350                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06351 19C6           FF76         FE            push	-2[bp]
06352                                           ! Debug: func () void = write_byte+0 (used reg = )
06353 19C9           E8         EC58            call	_write_byte
06354 19CC           83C4                   06  add	sp,*6
06355                                           !BCC_EOS
06356                                           ! 1480 }
06357 19CF           89EC                       mov	sp,bp
06358 19D1           5D                         pop	bp
06359 19D2           C3                         ret
06360                                           ! 1481 void ata_detect( )
06361                                           ! Register BX used in function ata_init
06362                                           ! 1482 {
06363                                           export	_ata_detect
06364                       000019D3            _ata_detect:
06365                                           ! 1483   Bit16u ebda_seg=read_word(0x0040,0x000E);
06366 19D3           55                         push	bp
06367 19D4           89E5                       mov	bp,sp
06368 19D6           4C                         dec	sp
06369 19D7           4C                         dec	sp
06370                                           ! Debug: list int = const $E (used reg = )
06371 19D8           B8                   000E  mov	ax,*$E
06372 19DB           50                         push	ax
06373                                           ! Debug: list int = const $40 (used reg = )
06374 19DC           B8                   0040  mov	ax,*$40
06375 19DF           50                         push	ax
06376                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
06377 19E0           E8         EC2E            call	_read_word
06378 19E3           83C4                   04  add	sp,*4
06379                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
06380 19E6           8946         FE            mov	-2[bp],ax
06381                                           !BCC_EOS
06382                                           ! 1484   Bit8u hdcount, cdco
06383                                           ! 1484 unt, device, type;
06384                                           !BCC_EOS
06385                                           ! 1485   Bit8u buffer[0x0200];
06386                                           !BCC_EOS
06387                                           ! 1486   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
06388 19E9           81C4                 FDFC  add	sp,#-$204
06389                                           ! Debug: list int = const 0 (used reg = )
06390 19ED           31C0                       xor	ax,ax
06391 19EF           50                         push	ax
06392                                           ! Debug: list * unsigned char = const $122 (used reg = )
06393 19F0           B8                   0122  mov	ax,#$122
06394 19F3           50                         push	ax
06395                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06396 19F4           FF76         FE            push	-2[bp]
06397                                           ! Debug: func () void = write_byte+0 (used reg = )
06398 19F7           E8         EC2A            call	_write_byte
06399 19FA           83C4                   06  add	sp,*6
06400                                           !BCC_EOS
06401                                           ! 1487   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
06402                                           ! Debug: list int = const $1F0 (used reg = )
06403 19FD           B8                   01F0  mov	ax,#$1F0
06404 1A00           50                         push	ax
06405                                           ! Debug: list * unsigned short = const $124 (used reg = )
06406 1A01           B8                   0124  mov	ax,#$124
06407 1A04           50                         push	ax
06408                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06409 1A05           FF76         FE            push	-2[bp]
06410                                           ! Debug: func () void = write_word+0 (used reg = )
06411 1A08           E8         EC31            call	_write_word
06412 1A0B           83C4                   06  add	sp,*6
06413                                           !BCC_EOS
06414                                           ! 1488   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase2,0x3f0);
06415                                           ! Debug: list int = const $3F0 (used reg = )
06416 1A0E           B8                   03F0  mov	ax,#$3F0
06417 1A11           50                         push	ax
06418                                           ! Debug: list * unsigned short = const $126 (used reg = )
06419 1A12           B8                   0126  mov	ax,#$126
06420 1A15           50                         push	ax
06421                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06422 1A16           FF76         FE            push	-2[bp]
06423                                           ! Debug: func () void = write_word+0 (used reg = )
06424 1A19           E8         EC20            call	_write_word
06425 1A1C           83C4                   06  add	sp,*6
06426                                           !BCC_EOS
06427                                           ! 1489   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
06428                                           ! Debug: list int = const $E (used reg = )
06429 1A1F           B8                   000E  mov	ax,*$E
06430 1A22           50                         push	ax
06431                                           ! Debug: list * unsigned char = const $128 (used reg = )
06432 1A23           B8                   0128  mov	ax,#$128
06433 1A26           50                         push	ax
06434                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06435 1A27           FF76         FE            push	-2[bp]
06436                                           ! Debug: func () void = write_byte+0 (used reg = )
06437 1A2A           E8         EBF7            call	_write_byte
06438 1A2D           83C4                   06  add	sp,*6
06439                                           !BCC_EOS
06440                                           ! 1490   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iface,0x00);
06441                                           ! Debug: list int = const 0 (used reg = )
06442 1A30           31C0                       xor	ax,ax
06443 1A32           50                         push	ax
06444                                           ! Debug: list * unsigned char = const $12A (used reg = )
06445 1A33           B8                   012A  mov	ax,#$12A
06446 1A36           50                         push	ax
06447                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06448 1A37           FF76         FE            push	-2[bp]
06449                                           ! Debug: func () void = write_byte+0 (used reg = )
06450 1A3A           E8         EBE7            call	_write_byte
06451 1A3D           83C4                   06  add	sp,*6
06452                                           !BCC_EOS
06453                                           ! 1491   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
06454                                           ! Debug: list int = const $170 (used reg = )
06455 1A40           B8                   0170  mov	ax,#$170
06456 1A43           50                         push	ax
06457                                           ! Debug: list * unsigned short = const $12C (used reg = )
06458 1A44           B8                   012C  mov	ax,#$12C
06459 1A47           50                         push	ax
06460                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06461 1A48           FF76         FE            push	-2[bp]
06462                                           ! Debug: func () void = write_word+0 (used reg = )
06463 1A4B           E8         EBEE            call	_write_word
06464 1A4E           83C4                   06  add	sp,*6
06465                                           !BCC_EOS
06466                                           ! 1492   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
06467                                           ! Debug: list int = const $370 (used reg = )
06468 1A51           B8                   0370  mov	ax,#$370
06469 1A54           50                         push	ax
06470                                           ! Debug: list * unsigned short = const $12E (used reg = )
06471 1A55           B8                   012E  mov	ax,#$12E
06472 1A58           50                         push	ax
06473                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06474 1A59           FF76         FE            push	-2[bp]
06475                                           ! Debug: func () void = write_word+0 (used reg = )
06476 1A5C           E8         EBDD            call	_write_word
06477 1A5F           83C4                   06  add	sp,*6
06478                                           !BCC_EOS
06479                                           ! 1493   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
06480                                           ! Debug: list int = const $F (used reg = )
06481 1A62           B8                   000F  mov	ax,*$F
06482 1A65           50                         push	ax
06483                                           ! Debug: list * unsigned char = const $130 (used reg = )
06484 1A66           B8                   0130  mov	ax,#$130
06485 1A69           50                         push	ax
06486                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06487 1A6A           FF76         FE            push	-2[bp]
06488                                           ! Debug: func () void = write_byte+0 (used reg = )
06489 1A6D           E8         EBB4            call	_write_byte
06490 1A70           83C4                   06  add	sp,*6
06491                                           !BCC_EOS
06492                                           ! 1494   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
06493                                           ! Debug: list int = const 0 (used reg = )
06494 1A73           31C0                       xor	ax,ax
06495 1A75           50                         push	ax
06496                                           ! Debug: list * unsigned char = const $132 (used reg = )
06497 1A76           B8                   0132  mov	ax,#$132
06498 1A79           50                         push	ax
06499                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06500 1A7A           FF76         FE            push	-2[bp]
06501                                           ! Debug: func () void = write_byte+0 (used reg = )
06502 1A7D           E8         EBA4            call	_write_byte
06503 1A80           83C4                   06  add	sp,*6
06504                                           !BCC_EOS
06505                                           ! 1495   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
06506                                           ! Debug: list int = const $1E8 (used reg = )
06507 1A83           B8                   01E8  mov	ax,#$1E8
06508 1A86           50                         push	ax
06509                                           ! Debug: list * unsigned short = const $134 (used reg = )
06510 1A87           B8                   0134  mov	ax,#$134
06511 1A8A           50                         push	ax
06512                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06513 1A8B           FF76         FE            push	-2[bp]
06514                                           ! Debug: func () void = write_word+0 (used reg = )
06515 1A8E           E8         EBAB            call	_write_word
06516 1A91           83C4                   06  add	sp,*6
06517                                           !BCC_EOS
06518                                           ! 1496   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
06519                                           ! Debug: list int = const $3E0 (used reg = )
06520 1A94           B8                   03E0  mov	ax,#$3E0
06521 1A97           50                         push	ax
06522                                           ! Debug: list * unsigned short = const $136 (used reg = )
06523 1A98           B8                   0136  mov	ax,#$136
06524 1A9B           50                         push	ax
06525                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06526 1A9C           FF76         FE            push	-2[bp]
06527                                           ! Debug: func () void = write_word+0 (used reg = )
06528 1A9F           E8         EB9A            call	_write_word
06529 1AA2           83C4                   06  add	sp,*6
06530                                           !BCC_EOS
06531                                           ! 1497   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
06532                                           ! Debug: list int = const $C (used reg = )
06533 1AA5           B8                   000C  mov	ax,*$C
06534 1AA8           50                         push	ax
06535                                           ! Debug: list * unsigned char = const $138 (used reg = )
06536 1AA9           B8                   0138  mov	ax,#$138
06537 1AAC           50                         push	ax
06538                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06539 1AAD           FF76         FE            push	-2[bp]
06540                                           ! Debug: func () void = write_byte+0 (used reg = )
06541 1AB0           E8         EB71            call	_write_byte
06542 1AB3           83C4                   06  add	sp,*6
06543                                           !BCC_EOS
06544                                           ! 1498   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
06545                                           ! Debug: list int = const 0 (used reg = )
06546 1AB6           31C0                       xor	ax,ax
06547 1AB8           50                         push	ax
06548                                           ! Debug: list * unsigned char = const $13A (used reg = )
06549 1AB9           B8                   013A  mov	ax,#$13A
06550 1ABC           50                         push	ax
06551                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06552 1ABD           FF76         FE            push	-2[bp]
06553                                           ! Debug: func () void = write_byte+0 (used reg = )
06554 1AC0           E8         EB61            call	_write_byte
06555 1AC3           83C4                   06  add	sp,*6
06556                                           !BCC_EOS
06557                                           ! 1499   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
06558                                           ! Debug: list int = const $168 (used reg = )
06559 1AC6           B8                   0168  mov	ax,#$168
06560 1AC9           50                         push	ax
06561                                           ! Debug: list * unsigned short = const $13C (used reg = )
06562 1ACA           B8                   013C  mov	ax,#$13C
06563 1ACD           50                         push	ax
06564                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06565 1ACE           FF76         FE            push	-2[bp]
06566                                           ! Debug: func () void = write_word+0 (used reg = )
06567 1AD1           E8         EB68            call	_write_word
06568 1AD4           83C4                   06  add	sp,*6
06569                                           !BCC_EOS
06570                                           ! 1500   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
06571                                           ! Debug: list int = const $360 (used reg = )
06572 1AD7           B8                   0360  mov	ax,#$360
06573 1ADA           50                         push	ax
06574                                           ! Debug: list * unsigned short = const $13E (used reg = )
06575 1ADB           B8                   013E  mov	ax,#$13E
06576 1ADE           50                         push	ax
06577                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06578 1ADF           FF76         FE            push	-2[bp]
06579                                           ! Debug: func () void = write_word+0 (used reg = )
06580 1AE2           E8         EB57            call	_write_word
06581 1AE5           83C4                   06  add	sp,*6
06582                                           !BCC_EOS
06583                                           ! 1501   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
06584                                           ! Debug: list int = const $B (used reg = )
06585 1AE8           B8                   000B  mov	ax,*$B
06586 1AEB           50                         push	ax
06587                                           ! Debug: list * unsigned char = const $140 (used reg = )
06588 1AEC           B8                   0140  mov	ax,#$140
06589 1AEF           50                         push	ax
06590                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
06591 1AF0           FF76         FE            push	-2[bp]
06592                                           ! Debug: func () void = write_byte+0 (used reg = )
06593 1AF3           E8         EB2E            call	_write_byte
06594 1AF6           83C4                   06  add	sp,*6
06595                                           !BCC_EOS
06596                                           ! 1502   hdcount=cdcount=0;
06597                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
06598 1AF9           30C0                       xor	al,al
06599 1AFB           8846         FC            mov	-4[bp],al
06600                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
06601 1AFE           8846         FD            mov	-3[bp],al
06602                                           !BCC_EOS
06603                                           ! 1503   for(device=0; device<(4*2); device++) {
06604                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
06605 1B01           30C0                       xor	al,al
06606 1B03           8846         FB            mov	-5[bp],al
06607                                           !BCC_EOS
06608                                           !BCC_EOS
06609 1B06           E9         0C90            br 	.152
06610                       00001B09            .153:
06611                                           ! 1504     Bit16u iobase1, iobase2;
06612                                           !BCC_EOS
06613                                           ! 1505     Bit8u channel, slave, shift;
06614                                           !BCC_EOS
06615                                           ! 1506     Bit8u sc, sn, cl, ch, st;
06616                                           !BCC_EOS
06617                                           ! 1507     channel = device / 2;
06618 1B09           83C4                   F4  add	sp,*-$C
06619                                           ! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
06620 1B0C           8A46         FB            mov	al,-5[bp]
06621 1B0F           30E4                       xor	ah,ah
06622 1B11           D1E8                       shr	ax,*1
06623                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
06624 1B13           8886       FDF5            mov	-$20B[bp],al
06625                                           !BCC_EOS
06626                                           ! 1508     slave = device % 2;
06627                                           ! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
06628 1B17           8A46         FB            mov	al,-5[bp]
06629 1B1A           30E4                       xor	ah,ah
06630 1B1C           24                     01  and	al,*1
06631                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
06632 1B1E           8886       FDF4            mov	-$20C[bp],al
06633                                           !BCC_EOS
06634                                           ! 1509     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
06635                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
06636 1B22           8A86       FDF5            mov	al,-$20B[bp]
06637 1B26           30E4                       xor	ah,ah
06638 1B28           B1                     03  mov	cl,*3
06639 1B2A           D3E0                       shl	ax,cl
06640 1B2C           89C3                       mov	bx,ax
06641                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06642                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
06643 1B2E           81C3                 0124  add	bx,#$124
06644 1B32           53                         push	bx
06645                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
06646 1B33           FF76         FE            push	-2[bp]
06647                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
06648 1B36           E8         EAD8            call	_read_word
06649 1B39           83C4                   04  add	sp,*4
06650                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
06651 1B3C           8986       FDF8            mov	-$208[bp],ax
06652                                           !BCC_EOS
06653                                           ! 1510     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
06654                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
06655 1B40           8A86       FDF5            mov	al,-$20B[bp]
06656 1B44           30E4                       xor	ah,ah
06657 1B46           B1                     03  mov	cl,*3
06658 1B48           D3E0                       shl	ax,cl
06659 1B4A           89C3                       mov	bx,ax
06660                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06661                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
06662 1B4C           81C3                 0126  add	bx,#$126
06663 1B50           53                         push	bx
06664                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
06665 1B51           FF76         FE            push	-2[bp]
06666                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
06667 1B54           E8         EABA            call	_read_word
06668 1B57           83C4                   04  add	sp,*4
06669                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
06670 1B5A           8986       FDF6            mov	-$20A[bp],ax
06671                                           !BCC_EOS
06672                                           ! 1511     outb(iobase2+6, 0x08 | 0x02);
06673                                           ! Debug: list int = const $A (used reg = )
06674 1B5E           B8                   000A  mov	ax,*$A
06675 1B61           50                         push	ax
06676                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
06677 1B62           8B86       FDF6            mov	ax,-$20A[bp]
06678                                           ! Debug: list unsigned int = ax+6 (used reg = )
06679 1B66           05                   0006  add	ax,*6
06680 1B69           50                         push	ax
06681                                           ! Debug: func () void = outb+0 (used reg = )
06682 1B6A           E8         E9F1            call	_outb
06683 1B6D           83C4                   04  add	sp,*4
06684                                           !BCC_EOS
06685                                           ! 1512     outb(iobase1+6, slave ? 0xb0 : 0xa0);
06686 1B70           8A86       FDF4            mov	al,-$20C[bp]
06687 1B74           84C0                       test	al,al
06688 1B76           74           04            je  	.154
06689                       00001B78            .155:
06690 1B78           B0                     B0  mov	al,#$B0
06691 1B7A           EB           02            jmp .156
06692                       00001B7C            .154:
06693 1B7C           B0                     A0  mov	al,#$A0
06694                       00001B7E            .156:
06695                                           ! Debug: list char = al+0 (used reg = )
06696 1B7E           30E4                       xor	ah,ah
06697 1B80           50                         push	ax
06698                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
06699 1B81           8B86       FDF8            mov	ax,-$208[bp]
06700                                           ! Debug: list unsigned int = ax+6 (used reg = )
06701 1B85           05                   0006  add	ax,*6
06702 1B88           50                         push	ax
06703                                           ! Debug: func () void = outb+0 (used reg = )
06704 1B89           E8         E9D2            call	_outb
06705 1B8C           83C4                   04  add	sp,*4
06706                                           !BCC_EOS
06707                                           ! 1513     outb(iobase1+2, 0x55);
06708                                           ! Debug: list int = const $55 (used reg = )
06709 1B8F           B8                   0055  mov	ax,*$55
06710 1B92           50                         push	ax
06711                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
06712 1B93           8B86       FDF8            mov	ax,-$208[bp]
06713                                           ! Debug: list unsigned int = ax+2 (used reg = )
06714 1B97           40                         inc	ax
06715 1B98           40                         inc	ax
06716 1B99           50                         push	ax
06717                                           ! Debug: func () void = outb+0 (used reg = )
06718 1B9A           E8         E9C1            call	_outb
06719 1B9D           83C4                   04  add	sp,*4
06720                                           !BCC_EOS
06721                                           ! 1514     outb(iobase1+3, 0xaa);
06722                                           ! Debug: list int = const $AA (used reg = )
06723 1BA0           B8                   00AA  mov	ax,#$AA
06724 1BA3           50                         push	ax
06725                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
06726 1BA4           8B86       FDF8            mov	ax,-$208[bp]
06727                                           ! Debug: list unsigned int = ax+3 (used reg = )
06728 1BA8           05                   0003  add	ax,*3
06729 1BAB           50                         push	ax
06730                                           ! Debug: func () void = outb+0 (used reg = )
06731 1BAC           E8         E9AF            call	_outb
06732 1BAF           83C4                   04  add	sp,*4
06733                                           !BCC_EOS
06734                                           ! 1515     outb(iobase1+2, 0xaa);
06735                                           ! Debug: list int = const $AA (used reg = )
06736 1BB2           B8                   00AA  mov	ax,#$AA
06737 1BB5           50                         push	ax
06738                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
06739 1BB6           8B86       FDF8            mov	ax,-$208[bp]
06740                                           ! Debug: list unsigned int = ax+2 (used reg = )
06741 1BBA           40                         inc	ax
06742 1BBB           40                         inc	ax
06743 1BBC           50                         push	ax
06744                                           ! Debug: func () void = outb+0 (used reg = )
06745 1BBD           E8         E99E            call	_outb
06746 1BC0           83C4                   04  add	sp,*4
06747                                           !BCC_EOS
06748                                           ! 1516     outb(iobase1+3, 0x55);
06749                                           ! Debug: list int = const $55 (used reg = )
06750 1BC3           B8                   0055  mov	ax,*$55
06751 1BC6           50                         push	ax
06752                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
06753 1BC7           8B86       FDF8            mov	ax,-$208[bp]
06754                                           ! Debug: list unsigned int = ax+3 (used reg = )
06755 1BCB           05                   0003  add	ax,*3
06756 1BCE           50                         push	ax
06757                                           ! Debug: func () void = outb+0 (used reg = )
06758 1BCF           E8         E98C            call	_outb
06759 1BD2           83C4                   04  add	sp,*4
06760                                           !BCC_EOS
06761                                           ! 1517     outb(iobase1+2, 0x55);
06762                                           ! Debug: list int = const $55 (used reg = )
06763 1BD5           B8                   0055  mov	ax,*$55
06764 1BD8           50                         push	ax
06765                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
06766 1BD9           8B86       FDF8            mov	ax,-$208[bp]
06767                                           ! Debug: list unsigned int = ax+2 (used reg = )
06768 1BDD           40                         inc	ax
06769 1BDE           40                         inc	ax
06770 1BDF           50                         push	ax
06771                                           ! Debug: func () void = outb+0 (used reg = )
06772 1BE0           E8         E97B            call	_outb
06773 1BE3           83C4                   04  add	sp,*4
06774                                           !BCC_EOS
06775                                           ! 1518     outb(iobase1+3, 0xaa);
06776                                           ! Debug: list int = const $AA (used reg = )
06777 1BE6           B8                   00AA  mov	ax,#$AA
06778 1BE9           50                         push	ax
06779                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
06780 1BEA           8B86       FDF8            mov	ax,-$208[bp]
06781                                           ! Debug: list unsigned int = ax+3 (used reg = )
06782 1BEE           05                   0003  add	ax,*3
06783 1BF1           50                         push	ax
06784                                           ! Debug: func () void = outb+0 (used reg = )
06785 1BF2           E8         E969            call	_outb
06786 1BF5           83C4                   04  add	sp,*4
06787                                           !BCC_EOS
06788                                           ! 1519     sc = inb(iobase1+2);
06789                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
06790 1BF8           8B86       FDF8            mov	ax,-$208[bp]
06791                                           ! Debug: list unsigned int = ax+2 (used reg = )
06792 1BFC           40                         inc	ax
06793 1BFD           40                         inc	ax
06794 1BFE           50                         push	ax
06795                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06796 1BFF           E8         E946            call	_inb
06797 1C02           44                         inc	sp
06798 1C03           44                         inc	sp
06799                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
06800 1C04           8886       FDF2            mov	-$20E[bp],al
06801                                           !BCC_EOS
06802                                           ! 1520     sn = inb(iobase1+3);
06803                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
06804 1C08           8B86       FDF8            mov	ax,-$208[bp]
06805                                           ! Debug: list unsigned int = ax+3 (used reg = )
06806 1C0C           05                   0003  add	ax,*3
06807 1C0F           50                         push	ax
06808                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06809 1C10           E8         E935            call	_inb
06810 1C13           44                         inc	sp
06811 1C14           44                         inc	sp
06812                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
06813 1C15           8886       FDF1            mov	-$20F[bp],al
06814                                           !BCC_EOS
06815                                           ! 1521     if ( (sc == 0x55) && (sn == 0xaa) ) {
06816                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
06817 1C19           8A86       FDF2            mov	al,-$20E[bp]
06818 1C1D           3C                     55  cmp	al,*$55
06819 1C1F         0F85         0120            bne 	.157
06820                       00001C23            .159:
06821                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
06822 1C23           8A86       FDF1            mov	al,-$20F[bp]
06823 1C27           3C                     AA  cmp	al,#$AA
06824 1C29         0F85         0116            bne 	.157
06825                       00001C2D            .158:
06826                                           ! 1522       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
06827                                           ! Debug: list int = const 1 (used reg = )
06828 1C2D           B8                   0001  mov	ax,*1
06829 1C30           50                         push	ax
06830                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
06831 1C31           8A46         FB            mov	al,-5[bp]
06832 1C34           30E4                       xor	ah,ah
06833 1C36           B9                   001A  mov	cx,*$1A
06834 1C39           F7E9                       imul	cx
06835 1C3B           89C3                       mov	bx,ax
06836                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06837                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
06838 1C3D           81C3                 0142  add	bx,#$142
06839 1C41           53                         push	bx
06840                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
06841 1C42           FF76         FE            push	-2[bp]
06842                                           ! Debug: func () void = write_byte+0 (used reg = )
06843 1C45           E8         E9DC            call	_write_byte
06844 1C48           83C4                   06  add	sp,*6
06845                                           !BCC_EOS
06846                                           ! 1523       ata_reset (device);
06847                                           ! Debug: list unsigned char device = [S+$214-7] (used reg = )
06848 1C4B           8A46         FB            mov	al,-5[bp]
06849 1C4E           30E4                       xor	ah,ah
06850 1C50           50                         push	ax
06851                                           ! Debug: func () void = ata_reset+0 (used reg = )
06852 1C51           E8         0B9A            call	_ata_reset
06853 1C54           44                         inc	sp
06854 1C55           44                         inc	sp
06855                                           !BCC_EOS
06856                                           ! 1524       outb(iobas
06857                                           ! 1524 e1+6, slave ? 0xb0 : 0xa0);
06858 1C56           8A86       FDF4            mov	al,-$20C[bp]
06859 1C5A           84C0                       test	al,al
06860 1C5C           74           04            je  	.15A
06861                       00001C5E            .15B:
06862 1C5E           B0                     B0  mov	al,#$B0
06863 1C60           EB           02            jmp .15C
06864                       00001C62            .15A:
06865 1C62           B0                     A0  mov	al,#$A0
06866                       00001C64            .15C:
06867                                           ! Debug: list char = al+0 (used reg = )
06868 1C64           30E4                       xor	ah,ah
06869 1C66           50                         push	ax
06870                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
06871 1C67           8B86       FDF8            mov	ax,-$208[bp]
06872                                           ! Debug: list unsigned int = ax+6 (used reg = )
06873 1C6B           05                   0006  add	ax,*6
06874 1C6E           50                         push	ax
06875                                           ! Debug: func () void = outb+0 (used reg = )
06876 1C6F           E8         E8EC            call	_outb
06877 1C72           83C4                   04  add	sp,*4
06878                                           !BCC_EOS
06879                                           ! 1525       sc = inb(iobase1+2);
06880                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
06881 1C75           8B86       FDF8            mov	ax,-$208[bp]
06882                                           ! Debug: list unsigned int = ax+2 (used reg = )
06883 1C79           40                         inc	ax
06884 1C7A           40                         inc	ax
06885 1C7B           50                         push	ax
06886                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06887 1C7C           E8         E8C9            call	_inb
06888 1C7F           44                         inc	sp
06889 1C80           44                         inc	sp
06890                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
06891 1C81           8886       FDF2            mov	-$20E[bp],al
06892                                           !BCC_EOS
06893                                           ! 1526       sn = inb(iobase1+3);
06894                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
06895 1C85           8B86       FDF8            mov	ax,-$208[bp]
06896                                           ! Debug: list unsigned int = ax+3 (used reg = )
06897 1C89           05                   0003  add	ax,*3
06898 1C8C           50                         push	ax
06899                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06900 1C8D           E8         E8B8            call	_inb
06901 1C90           44                         inc	sp
06902 1C91           44                         inc	sp
06903                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
06904 1C92           8886       FDF1            mov	-$20F[bp],al
06905                                           !BCC_EOS
06906                                           ! 1527       if ( (sc==0x01) && (sn==0x01) ) {
06907                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
06908 1C96           8A86       FDF2            mov	al,-$20E[bp]
06909 1C9A           3C                     01  cmp	al,*1
06910 1C9C         0F85         00A3            bne 	.15D
06911                       00001CA0            .15F:
06912                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
06913 1CA0           8A86       FDF1            mov	al,-$20F[bp]
06914 1CA4           3C                     01  cmp	al,*1
06915 1CA6         0F85         0099            bne 	.15D
06916                       00001CAA            .15E:
06917                                           ! 1528         cl = inb(iobase1+4);
06918                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
06919 1CAA           8B86       FDF8            mov	ax,-$208[bp]
06920                                           ! Debug: list unsigned int = ax+4 (used reg = )
06921 1CAE           05                   0004  add	ax,*4
06922 1CB1           50                         push	ax
06923                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06924 1CB2           E8         E893            call	_inb
06925 1CB5           44                         inc	sp
06926 1CB6           44                         inc	sp
06927                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
06928 1CB7           8886       FDF0            mov	-$210[bp],al
06929                                           !BCC_EOS
06930                                           ! 1529         ch = inb(iobase1+5);
06931                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
06932 1CBB           8B86       FDF8            mov	ax,-$208[bp]
06933                                           ! Debug: list unsigned int = ax+5 (used reg = )
06934 1CBF           05                   0005  add	ax,*5
06935 1CC2           50                         push	ax
06936                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06937 1CC3           E8         E882            call	_inb
06938 1CC6           44                         inc	sp
06939 1CC7           44                         inc	sp
06940                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
06941 1CC8           8886       FDEF            mov	-$211[bp],al
06942                                           !BCC_EOS
06943                                           ! 1530         st = inb(iobase1+7);
06944                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
06945 1CCC           8B86       FDF8            mov	ax,-$208[bp]
06946                                           ! Debug: list unsigned int = ax+7 (used reg = )
06947 1CD0           05                   0007  add	ax,*7
06948 1CD3           50                         push	ax
06949                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06950 1CD4           E8         E871            call	_inb
06951 1CD7           44                         inc	sp
06952 1CD8           44                         inc	sp
06953                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
06954 1CD9           8886       FDEE            mov	-$212[bp],al
06955                                           !BCC_EOS
06956                                           ! 1531         if ( (cl==0x14) && (ch==0xeb) ) {
06957                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
06958 1CDD           8A86       FDF0            mov	al,-$210[bp]
06959 1CE1           3C                     14  cmp	al,*$14
06960 1CE3           75           28            jne 	.160
06961                       00001CE5            .162:
06962                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
06963 1CE5           8A86       FDEF            mov	al,-$211[bp]
06964 1CE9           3C                     EB  cmp	al,#$EB
06965 1CEB           75           20            jne 	.160
06966                       00001CED            .161:
06967                                           ! 1532           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
06968                                           ! Debug: list int = const 3 (used reg = )
06969 1CED           B8                   0003  mov	ax,*3
06970 1CF0           50                         push	ax
06971                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
06972 1CF1           8A46         FB            mov	al,-5[bp]
06973 1CF4           30E4                       xor	ah,ah
06974 1CF6           B9                   001A  mov	cx,*$1A
06975 1CF9           F7E9                       imul	cx
06976 1CFB           89C3                       mov	bx,ax
06977                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06978                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
06979 1CFD           81C3                 0142  add	bx,#$142
06980 1D01           53                         push	bx
06981                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
06982 1D02           FF76         FE            push	-2[bp]
06983                                           ! Debug: func () void = write_byte+0 (used reg = )
06984 1D05           E8         E91C            call	_write_byte
06985 1D08           83C4                   06  add	sp,*6
06986                                           !BCC_EOS
06987                                           ! 1533           }
06988                                           ! 1534         else if ( (cl==0x00) && (ch==0x00) && (st!=0x00) ) {
06989 1D0B           EB           36            jmp .163
06990                       00001D0D            .160:
06991                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
06992 1D0D           8A86       FDF0            mov	al,-$210[bp]
06993 1D11           84C0                       test	al,al
06994 1D13           75           2E            jne 	.164
06995                       00001D15            .167:
06996                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
06997 1D15           8A86       FDEF            mov	al,-$211[bp]
06998 1D19           84C0                       test	al,al
06999 1D1B           75           26            jne 	.164
07000                       00001D1D            .166:
07001                                           ! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
07002 1D1D           8A86       FDEE            mov	al,-$212[bp]
07003 1D21           84C0                       test	al,al
07004 1D23           74           1E            je  	.164
07005                       00001D25            .165:
07006                                           ! 1535           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
07007                                           ! Debug: list int = const 2 (used reg = )
07008 1D25           B8                   0002  mov	ax,*2
07009 1D28           50                         push	ax
07010                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07011 1D29           8A46         FB            mov	al,-5[bp]
07012 1D2C           30E4                       xor	ah,ah
07013 1D2E           B9                   001A  mov	cx,*$1A
07014 1D31           F7E9                       imul	cx
07015 1D33           89C3                       mov	bx,ax
07016                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07017                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07018 1D35           81C3                 0142  add	bx,#$142
07019 1D39           53                         push	bx
07020                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07021 1D3A           FF76         FE            push	-2[bp]
07022                                           ! Debug: func () void = write_byte+0 (used reg = )
07023 1D3D           E8         E8E4            call	_write_byte
07024 1D40           83C4                   06  add	sp,*6
07025                                           !BCC_EOS
07026                                           ! 1536           }
07027                                           ! 1537         }
07028                       00001D43            .164:
07029                       00001D43            .163:
07030                                           ! 1538       }
07031                       00001D43            .15D:
07032                                           ! 1539     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
07033                       00001D43            .157:
07034                                           ! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
07035 1D43           8A46         FB            mov	al,-5[bp]
07036 1D46           30E4                       xor	ah,ah
07037 1D48           B9                   001A  mov	cx,*$1A
07038 1D4B           F7E9                       imul	cx
07039 1D4D           89C3                       mov	bx,ax
07040                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07041                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07042 1D4F           81C3                 0142  add	bx,#$142
07043 1D53           53                         push	bx
07044                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07045 1D54           FF76         FE            push	-2[bp]
07046                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07047 1D57           E8         E8A4            call	_read_byte
07048 1D5A           83C4                   04  add	sp,*4
07049                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
07050 1D5D           8846         FA            mov	-6[bp],al
07051                                           !BCC_EOS
07052                                           ! 1540     if(type == 0x02) {
07053                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
07054 1D60           8A46         FA            mov	al,-6[bp]
07055 1D63           3C                     02  cmp	al,*2
07056 1D65         0F85         0530            bne 	.168
07057                       00001D69            .169:
07058                                           ! 1541       Bit32u sectors;
07059                                           !BCC_EOS
07060                                           ! 1542       Bit16u cylinders, heads, spt, blksize;
07061                                           !BCC_EOS
07062                                           ! 1543       Bit8u translation, removable, mode;
07063                                           !BCC_EOS
07064                                           ! 1544       mode = 0x00;
07065 1D69           83C4                   F0  add	sp,*-$10
07066                                           ! Debug: eq int = const 0 to unsigned char mode = [S+$224-$223] (used reg = )
07067 1D6C           30C0                       xor	al,al
07068 1D6E           8886       FDDF            mov	-$221[bp],al
07069                                           !BCC_EOS
07070                                           ! 1545       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
07071                                           ! Debug: list int = const $FF (used reg = )
07072 1D72           B8                   00FF  mov	ax,#$FF
07073 1D75           50                         push	ax
07074                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07075 1D76           8A46         FB            mov	al,-5[bp]
07076 1D79           30E4                       xor	ah,ah
07077 1D7B           B9                   001A  mov	cx,*$1A
07078 1D7E           F7E9                       imul	cx
07079 1D80           89C3                       mov	bx,ax
07080                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07081                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
07082 1D82           81C3                 0143  add	bx,#$143
07083 1D86           53                         push	bx
07084                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07085 1D87           FF76         FE            push	-2[bp]
07086                                           ! Debug: func () void = write_byte+0 (used reg = )
07087 1D8A           E8         E897            call	_write_byte
07088 1D8D           83C4                   06  add	sp,*6
07089                                           !BCC_EOS
07090                                           ! 1546       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
07091                                           ! Debug: list int = const 0 (used reg = )
07092 1D90           31C0                       xor	ax,ax
07093 1D92           50                         push	ax
07094                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07095 1D93           8A46         FB            mov	al,-5[bp]
07096 1D96           30E4                       xor	ah,ah
07097 1D98           B9                   001A  mov	cx,*$1A
07098 1D9B           F7E9                       imul	cx
07099 1D9D           89C3                       mov	bx,ax
07100                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07101                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
07102 1D9F           81C3                 0146  add	bx,#$146
07103 1DA3           53                         push	bx
07104                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07105 1DA4           FF76         FE            push	-2[bp]
07106                                           ! Debug: func () void = write_byte+0 (used reg = )
07107 1DA7           E8         E87A            call	_write_byte
07108 1DAA           83C4                   06  add	sp,*6
07109                                           !BCC_EOS
07110                                           ! 1547       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, get_SS(),buffer) !=0 )
07111                                           ! Debug: list * unsigned char buffer = S+$224-$208 (used reg = )
07112 1DAD           8D9E       FDFA            lea	bx,-$206[bp]
07113 1DB1           53                         push	bx
07114                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07115 1DB2           E8         E8A2            call	_get_SS
07116                                           ! Debug: list unsigned short = ax+0 (used reg = )
07117 1DB5           50                         push	ax
07118                                           ! Debug: list long = const 0 (used reg = )
07119 1DB6           31C0                       xor	ax,ax
07120 1DB8           31DB                       xor	bx,bx
07121 1DBA           53                         push	bx
07122 1DBB           50                         push	ax
07123                                           ! Debug: list int = const 0 (used reg = )
07124 1DBC           31C0                       xor	ax,ax
07125 1DBE           50                         push	ax
07126                                           ! Debug: list int = const 0 (used reg = )
07127 1DBF           31C0                       xor	ax,ax
07128 1DC1           50                         push	ax
07129                                           ! Debug: list int = const 0 (used reg = )
07130 1DC2           31C0                       xor	ax,ax
07131 1DC4           50                         push	ax
07132                                           ! Debug: list int = const 1 (used reg = )
07133 1DC5           B8                   0001  mov	ax,*1
07134 1DC8           50                         push	ax
07135                                           ! Debug: list int = const $EC (used reg = )
07136 1DC9           B8                   00EC  mov	ax,#$EC
07137 1DCC           50                         push	ax
07138                                           ! Debug: list unsigned char device = [S+$236-7] (used reg = )
07139 1DCD           8A46         FB            mov	al,-5[bp]
07140 1DD0           30E4                       xor	ah,ah
07141 1DD2           50                         push	ax
07142                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
07143 1DD3           E8         0BB4            call	_ata_cmd_data_in
07144 1DD6           83C4                   14  add	sp,*$14
07145                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
07146 1DD9           85C0                       test	ax,ax
07147 1DDB           74           0E            je  	.16A
07148                       00001DDD            .16B:
07149                                           ! 1548         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
07150                                           ! Debug: list * char = .16C+0 (used reg = )
07151 1DDD           BB                   DA90  mov	bx,#.16C
07152 1DE0           53                         push	bx
07153                                           ! Debug: list int = const 7 (used reg = )
07154 1DE1           B8                   0007  mov	ax,*7
07155 1DE4           50                         push	ax
07156                                           ! Debug: func () void = bios_printf+0 (used reg = )
07157 1DE5           E8         EAC1            call	_bios_printf
07158 1DE8           83C4                   04  add	sp,*4
07159                                           !BCC_EOS
07160                                           ! 1549       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
07161                       00001DEB            .16A:
07162                                           ! Debug: list * unsigned char buffer = S+$224-$208 (used reg = )
07163 1DEB           8D9E       FDFA            lea	bx,-$206[bp]
07164 1DEF           53                         push	bx
07165                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07166 1DF0           E8         E864            call	_get_SS
07167                                           ! Debug: list unsigned short = ax+0 (used reg = )
07168 1DF3           50                         push	ax
07169                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07170 1DF4           E8         E807            call	_read_byte
07171 1DF7           83C4                   04  add	sp,*4
07172                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
07173 1DFA           24                     80  and	al,#$80
07174 1DFC           84C0                       test	al,al
07175 1DFE           74           04            je  	.16D
07176                       00001E00            .16E:
07177 1E00           B0                     01  mov	al,*1
07178 1E02           EB           02            jmp .16F
07179                       00001E04            .16D:
07180 1E04           30C0                       xor	al,al
07181                       00001E06            .16F:
07182                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$224-$222] (used reg = )
07183 1E06           8886       FDE0            mov	-$220[bp],al
07184                                           !BCC_EOS
07185                                           ! 1550       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
07186                                           ! Debug: list * unsigned char buffer = S+$224-$1A8 (used reg = )
07187 1E0A           8D9E       FE5A            lea	bx,-$1A6[bp]
07188 1E0E           53                         push	bx
07189                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07190 1E0F           E8         E845            call	_get_SS
07191                                           ! Debug: list unsigned short = ax+0 (used reg = )
07192 1E12           50                         push	ax
07193                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07194 1E13           E8         E7E8            call	_read_byte
07195 1E16           83C4                   04  add	sp,*4
07196 1E19           84C0                       test	al,al
07197 1E1B           74           04            je  	.170
07198                       00001E1D            .171:
07199 1E1D           B0                     01  mov	al,*1
07200 1E1F           EB           02            jmp .172
07201                       00001E21            .170:
07202 1E21           30C0                       xor	al,al
07203                       00001E23            .172:
07204                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$224-$223] (used reg = )
07205 1E23           8886       FDDF            mov	-$221[bp],al
07206                                           !BCC_EOS
07207                                           ! 1551       blksize = read_word(get_SS(),buffer+10);
07208                                           ! Debug: list * unsigned char buffer = S+$224-$1FE (used reg = )
07209 1E27           8D9E       FE04            lea	bx,-$1FC[bp]
07210 1E2B           53                         push	bx
07211                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07212 1E2C           E8         E828            call	_get_SS
07213                                           ! Debug: list unsigned short = ax+0 (used reg = )
07214 1E2F           50                         push	ax
07215                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07216 1E30           E8         E7DE            call	_read_word
07217 1E33           83C4                   04  add	sp,*4
07218                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$224-$220] (used reg = )
07219 1E36           8986       FDE2            mov	-$21E[bp],ax
07220                                           !BCC_EOS
07221                                           ! 1552       cylinders = read_word(get_SS(),buffer+(1*2));
07222                                           ! Debug: list * unsigned char buffer = S+$224-$206 (used reg = )
07223 1E3A           8D9E       FDFC            lea	bx,-$204[bp]
07224 1E3E           53                         push	bx
07225                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07226 1E3F           E8         E815            call	_get_SS
07227                                           ! Debug: list unsigned short = ax+0 (used reg = )
07228 1E42           50                         push	ax
07229                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07230 1E43           E8         E7CB            call	_read_word
07231 1E46           83C4                   04  add	sp,*4
07232                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$224-$21A] (used reg = )
07233 1E49           8986       FDE8            mov	-$218[bp],ax
07234                                           !BCC_EOS
07235                                           ! 1553       heads = read_word(get_SS(),buffer+(3*2));
07236                                           ! Debug: list * unsigned char buffer = S+$224-$202 (used reg = )
07237 1E4D           8D9E       FE00            lea	bx,-$200[bp]
07238 1E51           53                         push	bx
07239                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07240 1E52           E8         E802            call	_get_SS
07241                                           ! Debug: list unsigned short = ax+0 (used reg = )
07242 1E55           50                         push	ax
07243                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07244 1E56           E8         E7B8            call	_read_word
07245 1E59           83C4                   04  add	sp,*4
07246                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$224-$21C] (used reg = )
07247 1E5C           8986       FDE6            mov	-$21A[bp],ax
07248                                           !BCC_EOS
07249                                           ! 1554       spt = read_word(get_SS(),buffer+(6*2));
07250                                           ! Debug: list * unsigned char buffer = S+$224-$1FC (used reg = )
07251 1E60           8D9E       FE06            lea	bx,-$1FA[bp]
07252 1E64           53                         push	bx
07253                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07254 1E65           E8         E7EF            call	_get_SS
07255                                           ! Debug: list unsigned short = ax+0 (used reg = )
07256 1E68           50                         push	ax
07257                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07258 1E69           E8         E7A5            call	_read_word
07259 1E6C           83C4                   04  add	sp,*4
07260                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$224-$21E] (used reg = )
07261 1E6F           8986       FDE4            mov	-$21C[bp],ax
07262                                           !BCC_EOS
07263                                           ! 1555       sectors = read_dword(get_SS(),buffer+(60*2));
07264                                           ! Debug: list * unsigned char buffer = S+$224-$190 (used reg = )
07265 1E73           8D9E       FE72            lea	bx,-$18E[bp]
07266 1E77           53                         push	bx
07267                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
07268 1E78           E8         E7DC            call	_get_SS
07269                                           ! Debug: list unsigned short = ax+0 (used reg = )
07270 1E7B           50                         push	ax
07271                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
07272 1E7C           E8         E1D6            call	_read_dword
07273 1E7F           89D3                       mov	bx,dx
07274 1E81           83C4                   04  add	sp,*4
07275                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$224-$218] (used reg = )
07276 1E84           8986       FDEA            mov	-$216[bp],ax
07277 1E88           899E       FDEC            mov	-$214[bp],bx
07278                                           !BCC_EOS
07279                                           ! 1556       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
07280                                           ! Debug: list int = const $FF (used reg = )
07281 1E8C           B8                   00FF  mov	ax,#$FF
07282 1E8F           50                         push	ax
07283                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07284 1E90           8A46         FB            mov	al,-5[bp]
07285 1E93           30E4                       xor	ah,ah
07286 1E95           B9                   001A  mov	cx,*$1A
07287 1E98           F7E9                       imul	cx
07288 1E9A           89C3                       mov	bx,ax
07289                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07290                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
07291 1E9C           81C3                 0143  add	bx,#$143
07292 1EA0           53                         push	bx
07293                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07294 1EA1           FF76         FE            push	-2[bp]
07295                                           ! Debug: func () void = write_byte+0 (used reg = )
07296 1EA4           E8         E77D            call	_write_byte
07297 1EA7           83C4                   06  add	sp,*6
07298                                           !BCC_EOS
07299                                           ! 1557       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
07300                                           ! Debug: list unsigned char removable = [S+$224-$222] (used reg = )
07301 1EAA           8A86       FDE0            mov	al,-$220[bp]
07302 1EAE           30E4                       xor	ah,ah
07303 1EB0           50                         push	ax
07304                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07305 1EB1           8A46         FB            mov	al,-5[bp]
07306 1EB4           30E4                       xor	ah,ah
07307 1EB6           B9                   001A  mov	cx,*$1A
07308 1EB9           F7E9                       imul	cx
07309 1EBB           89C3                       mov	bx,ax
07310                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
07311                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
07312 1EBD           81C3                 0144  add	bx,#$144
07313 1EC1           53                         push	bx
07314                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07315 1EC2           FF76         FE            push	-2[bp]
07316                                           ! Debug: func () void = write_byte+0 (used reg = )
07317 1EC5           E8         E75C            call	_write_byte
07318 1EC8           83C4                   06  add	sp,*6
07319                                           !BCC_EOS
07320                                           ! 1558       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
07321                                           ! Debug: list unsigned char mode = [S+$224-$223] (used reg = )
07322 1ECB           8A86       FDDF            mov	al,-$221[bp]
07323 1ECF           30E4                       xor	ah,ah
07324 1ED1           50                         push	ax
07325                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07326 1ED2           8A46         FB            mov	al,-5[bp]
07327 1ED5           30E4                       xor	ah,ah
07328 1ED7           B9                   001A  mov	cx,*$1A
07329 1EDA           F7E9                       imul	cx
07330 1EDC           89C3                       mov	bx,ax
07331                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
07332                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
07333 1EDE           81C3                 0146  add	bx,#$146
07334 1EE2           53                         push	bx
07335                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07336 1EE3           FF76         FE            push	-2[bp]
07337                                           ! Debug: func () void = write_byte+0 (used reg = )
07338 1EE6           E8         E73B            call	_write_byte
07339 1EE9           83C4                   06  add	sp,*6
07340                                           !BCC_EOS
07341                                           ! 1559       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
07342                                           ! Debug: list unsigned short blksize = [S+$224-$220] (used reg = )
07343 1EEC           FFB6       FDE2            push	-$21E[bp]
07344                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07345 1EF0           8A46         FB            mov	al,-5[bp]
07346 1EF3           30E4                       xor	ah,ah
07347 1EF5           B9                   001A  mov	cx,*$1A
07348 1EF8           F7E9                       imul	cx
07349 1EFA           89C3                       mov	bx,ax
07350                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
07351                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
07352 1EFC           81C3                 0148  add	bx,#$148
07353 1F00           53                         push	bx
07354                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07355 1F01           FF76         FE            push	-2[bp]
07356                                           ! Debug: func () void = write_word+0 (used reg = )
07357 1F04           E8         E735            call	_write_word
07358 1F07           83C4                   06  add	sp,*6
07359                                           !BCC_EOS
07360                                           ! 1560       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
07361                                           ! Debug: list unsigned short heads = [S+$224-$21C] (used reg = )
07362 1F0A           FFB6       FDE6            push	-$21A[bp]
07363                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07364 1F0E           8A46         FB            mov	al,-5[bp]
07365 1F11           30E4                       xor	ah,ah
07366 1F13           B9                   001A  mov	cx,*$1A
07367 1F16           F7E9                       imul	cx
07368 1F18           89C3                       mov	bx,ax
07369                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
07370                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
07371 1F1A           81C3                 0152  add	bx,#$152
07372 1F1E           53                         push	bx
07373                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07374 1F1F           FF76         FE            push	-2[bp]
07375                                           ! Debug: func () void = write_word+0 (used reg = )
07376 1F22           E8         E717            call	_write_word
07377 1F25           83C4                   06  add	sp,*6
07378                                           !BCC_EOS
07379                                           ! 1561       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders, cylinders);
07380                                           ! Debug: list unsigned short cylinders = [S+$224-$21A] (used reg = )
07381 1F28           FFB6       FDE8            push	-$218[bp]
07382                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07383 1F2C           8A46         FB            mov	al,-5[bp]
07384 1F2F           30E4                       xor	ah,ah
07385 1F31           B9                   001A  mov	cx,*$1A
07386 1F34           F7E9                       imul	cx
07387 1F36           89C3                       mov	bx,ax
07388                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
07389                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
07390 1F38           81C3                 0154  add	bx,#$154
07391 1F3C           53                         push	bx
07392                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07393 1F3D           FF76         FE            push	-2[bp]
07394                                           ! Debug: func () void = write_word+0 (used reg = )
07395 1F40           E8         E6F9            call	_write_word
07396 1F43           83C4                   06  add	sp,*6
07397                                           !BCC_EOS
07398                                           ! 1562       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
07399                                           ! Debug: list unsigned short spt = [S+$224-$21E] (used reg = )
07400 1F46           FFB6       FDE4            push	-$21C[bp]
07401                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07402 1F4A           8A46         FB            mov	al,-5[bp]
07403 1F4D           30E4                       xor	ah,ah
07404 1F4F           B9                   001A  mov	cx,*$1A
07405 1F52           F7E9                       imul	cx
07406 1F54           89C3                       mov	bx,ax
07407                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
07408                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
07409 1F56           81C3                 0156  add	bx,#$156
07410 1F5A           53                         push	bx
07411                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07412 1F5B           FF76         FE            push	-2[bp]
07413                                           ! Debug: func () void = write_word+0 (used reg = )
07414 1F5E           E8         E6DB            call	_write_word
07415 1F61           83C4                   06  add	sp,*6
07416                                           !BCC_EOS
07417                                           ! 1563  
07418                                           ! 1563      write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors, sectors);
07419                                           ! Debug: list unsigned long sectors = [S+$224-$218] (used reg = )
07420 1F64           FFB6       FDEC            push	-$214[bp]
07421 1F68           FFB6       FDEA            push	-$216[bp]
07422                                           ! Debug: ptradd unsigned char device = [S+$228-7] to [8] struct  = const $142 (used reg = )
07423 1F6C           8A46         FB            mov	al,-5[bp]
07424 1F6F           30E4                       xor	ah,ah
07425 1F71           B9                   001A  mov	cx,*$1A
07426 1F74           F7E9                       imul	cx
07427 1F76           89C3                       mov	bx,ax
07428                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
07429                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
07430 1F78           81C3                 0158  add	bx,#$158
07431 1F7C           53                         push	bx
07432                                           ! Debug: list unsigned short ebda_seg = [S+$22A-4] (used reg = )
07433 1F7D           FF76         FE            push	-2[bp]
07434                                           ! Debug: func () void = write_dword+0 (used reg = )
07435 1F80           E8         E0E9            call	_write_dword
07436 1F83           83C4                   08  add	sp,*8
07437                                           !BCC_EOS
07438                                           ! 1564       bios_printf(4, "ata%d-%d: PCHS=%u/%d/%d translation=", channel, slave,cylinders, heads, spt);
07439                                           ! Debug: list unsigned short spt = [S+$224-$21E] (used reg = )
07440 1F86           FFB6       FDE4            push	-$21C[bp]
07441                                           ! Debug: list unsigned short heads = [S+$226-$21C] (used reg = )
07442 1F8A           FFB6       FDE6            push	-$21A[bp]
07443                                           ! Debug: list unsigned short cylinders = [S+$228-$21A] (used reg = )
07444 1F8E           FFB6       FDE8            push	-$218[bp]
07445                                           ! Debug: list unsigned char slave = [S+$22A-$20E] (used reg = )
07446 1F92           8A86       FDF4            mov	al,-$20C[bp]
07447 1F96           30E4                       xor	ah,ah
07448 1F98           50                         push	ax
07449                                           ! Debug: list unsigned char channel = [S+$22C-$20D] (used reg = )
07450 1F99           8A86       FDF5            mov	al,-$20B[bp]
07451 1F9D           30E4                       xor	ah,ah
07452 1F9F           50                         push	ax
07453                                           ! Debug: list * char = .173+0 (used reg = )
07454 1FA0           BB                   DA6B  mov	bx,#.173
07455 1FA3           53                         push	bx
07456                                           ! Debug: list int = const 4 (used reg = )
07457 1FA4           B8                   0004  mov	ax,*4
07458 1FA7           50                         push	ax
07459                                           ! Debug: func () void = bios_printf+0 (used reg = )
07460 1FA8           E8         E8FE            call	_bios_printf
07461 1FAB           83C4                   0E  add	sp,*$E
07462                                           !BCC_EOS
07463                                           ! 1565       translation = inb_cmos(0x39 + channel/2);
07464                                           ! Debug: div int = const 2 to unsigned char channel = [S+$224-$20D] (used reg = )
07465 1FAE           8A86       FDF5            mov	al,-$20B[bp]
07466 1FB2           30E4                       xor	ah,ah
07467 1FB4           D1E8                       shr	ax,*1
07468                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
07469                                           ! Debug: expression subtree swapping
07470                                           ! Debug: list unsigned int = ax+$39 (used reg = )
07471 1FB6           05                   0039  add	ax,*$39
07472 1FB9           50                         push	ax
07473                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
07474 1FBA           E8         E5D0            call	_inb_cmos
07475 1FBD           44                         inc	sp
07476 1FBE           44                         inc	sp
07477                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$224-$221] (used reg = )
07478 1FBF           8886       FDE1            mov	-$21F[bp],al
07479                                           !BCC_EOS
07480                                           ! 1566       for (shift=device%4; shift>0; shift--) translation >>= 2;
07481                                           ! Debug: mod int = const 4 to unsigned char device = [S+$224-7] (used reg = )
07482 1FC3           8A46         FB            mov	al,-5[bp]
07483 1FC6           30E4                       xor	ah,ah
07484 1FC8           24                     03  and	al,*3
07485                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$224-$20F] (used reg = )
07486 1FCA           8886       FDF3            mov	-$20D[bp],al
07487                                           !BCC_EOS
07488                                           !BCC_EOS
07489 1FCE           EB           17            jmp .176
07490                       00001FD0            .177:
07491                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$224-$221] (used reg = )
07492 1FD0           8A86       FDE1            mov	al,-$21F[bp]
07493 1FD4           30E4                       xor	ah,ah
07494 1FD6           D1E8                       shr	ax,*1
07495 1FD8           D1E8                       shr	ax,*1
07496 1FDA           8886       FDE1            mov	-$21F[bp],al
07497                                           !BCC_EOS
07498                                           ! 1567       translation &= 0x03;
07499                       00001FDE            .175:
07500                                           ! Debug: postdec unsigned char shift = [S+$224-$20F] (used reg = )
07501 1FDE           8A86       FDF3            mov	al,-$20D[bp]
07502 1FE2           48                         dec	ax
07503 1FE3           8886       FDF3            mov	-$20D[bp],al
07504                       00001FE7            .176:
07505                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$224-$20F] (used reg = )
07506 1FE7           8A86       FDF3            mov	al,-$20D[bp]
07507 1FEB           84C0                       test	al,al
07508 1FED           75           E1            jne	.177
07509                       00001FEF            .178:
07510                       00001FEF            .174:
07511                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$224-$221] (used reg = )
07512 1FEF           8A86       FDE1            mov	al,-$21F[bp]
07513 1FF3           24                     03  and	al,*3
07514 1FF5           8886       FDE1            mov	-$21F[bp],al
07515                                           !BCC_EOS
07516                                           ! 1568       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
07517                                           ! Debug: list unsigned char translation = [S+$224-$221] (used reg = )
07518 1FF9           8A86       FDE1            mov	al,-$21F[bp]
07519 1FFD           30E4                       xor	ah,ah
07520 1FFF           50                         push	ax
07521                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07522 2000           8A46         FB            mov	al,-5[bp]
07523 2003           30E4                       xor	ah,ah
07524 2005           B9                   001A  mov	cx,*$1A
07525 2008           F7E9                       imul	cx
07526 200A           89C3                       mov	bx,ax
07527                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
07528                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
07529 200C           81C3                 014A  add	bx,#$14A
07530 2010           53                         push	bx
07531                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07532 2011           FF76         FE            push	-2[bp]
07533                                           ! Debug: func () void = write_byte+0 (used reg = )
07534 2014           E8         E60D            call	_write_byte
07535 2017           83C4                   06  add	sp,*6
07536                                           !BCC_EOS
07537                                           ! 1569       switch (translation) {
07538 201A           8A86       FDE1            mov	al,-$21F[bp]
07539 201E           EB           42            jmp .17B
07540                                           ! 1570         case 0:
07541                                           ! 1571           bios_printf(4, "none");
07542                       00002020            .17C:
07543                                           ! Debug: list * char = .17D+0 (used reg = )
07544 2020           BB                   DA66  mov	bx,#.17D
07545 2023           53                         push	bx
07546                                           ! Debug: list int = const 4 (used reg = )
07547 2024           B8                   0004  mov	ax,*4
07548 2027           50                         push	ax
07549                                           ! Debug: func () void = bios_printf+0 (used reg = )
07550 2028           E8         E87E            call	_bios_printf
07551 202B           83C4                   04  add	sp,*4
07552                                           !BCC_EOS
07553                                           ! 1572           break;
07554 202E           EB           42            jmp .179
07555                                           !BCC_EOS
07556                                           ! 1573         case 1:
07557                                           ! 1574           bios_printf(4, "lba");
07558                       00002030            .17E:
07559                                           ! Debug: list * char = .17F+0 (used reg = )
07560 2030           BB                   DA62  mov	bx,#.17F
07561 2033           53                         push	bx
07562                                           ! Debug: list int = const 4 (used reg = )
07563 2034           B8                   0004  mov	ax,*4
07564 2037           50                         push	ax
07565                                           ! Debug: func () void = bios_printf+0 (used reg = )
07566 2038           E8         E86E            call	_bios_printf
07567 203B           83C4                   04  add	sp,*4
07568                                           !BCC_EOS
07569                                           ! 1575           break;
07570 203E           EB           32            jmp .179
07571                                           !BCC_EOS
07572                                           ! 1576         case 2:
07573                                           ! 1577           bios_printf(4, "large");
07574                       00002040            .180:
07575                                           ! Debug: list * char = .181+0 (used reg = )
07576 2040           BB                   DA5C  mov	bx,#.181
07577 2043           53                         push	bx
07578                                           ! Debug: list int = const 4 (used reg = )
07579 2044           B8                   0004  mov	ax,*4
07580 2047           50                         push	ax
07581                                           ! Debug: func () void = bios_printf+0 (used reg = )
07582 2048           E8         E85E            call	_bios_printf
07583 204B           83C4                   04  add	sp,*4
07584                                           !BCC_EOS
07585                                           ! 1578           break;
07586 204E           EB           22            jmp .179
07587                                           !BCC_EOS
07588                                           ! 1579         case 3:
07589                                           ! 1580           bios_printf(4, "r-echs");
07590                       00002050            .182:
07591                                           ! Debug: list * char = .183+0 (used reg = )
07592 2050           BB                   DA55  mov	bx,#.183
07593 2053           53                         push	bx
07594                                           ! Debug: list int = const 4 (used reg = )
07595 2054           B8                   0004  mov	ax,*4
07596 2057           50                         push	ax
07597                                           ! Debug: func () void = bios_printf+0 (used reg = )
07598 2058           E8         E84E            call	_bios_printf
07599 205B           83C4                   04  add	sp,*4
07600                                           !BCC_EOS
07601                                           ! 1581           break;
07602 205E           EB           12            jmp .179
07603                                           !BCC_EOS
07604                                           ! 1582         }
07605                                           ! 1583       switch (translation) {
07606 2060           EB           10            jmp .179
07607                       00002062            .17B:
07608 2062           2C                     00  sub	al,*0
07609 2064           74           BA            je 	.17C
07610 2066           2C                     01  sub	al,*1
07611 2068           74           C6            je 	.17E
07612 206A           2C                     01  sub	al,*1
07613 206C           74           D2            je 	.180
07614 206E           2C                     01  sub	al,*1
07615 2070           74           DE            je 	.182
07616                       00002072            .179:
07617                       FFFFFDDC            ..FFFC	=	-$224
07618 2072           8A86       FDE1            mov	al,-$21F[bp]
07619 2076           E9         0161            br 	.186
07620                                           ! 1584         case 0:
07621                                           ! 1585           break;
07622                       00002079            .187:
07623 2079           E9         0174            br 	.184
07624                                           !BCC_EOS
07625                                           ! 1586         case 1:
07626                                           ! 1587           spt = 63;
07627                       0000207C            .188:
07628                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$224-$21E] (used reg = )
07629 207C           B8                   003F  mov	ax,*$3F
07630 207F           8986       FDE4            mov	-$21C[bp],ax
07631                                           !BCC_EOS
07632                                           ! 1588           sectors /= 63;
07633                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors = [S+$224-$218] (used reg = )
07634 2083           B8                   003F  mov	ax,*$3F
07635 2086           31DB                       xor	bx,bx
07636 2088           53                         push	bx
07637 2089           50                         push	ax
07638 208A           8B86       FDEA            mov	ax,-$216[bp]
07639 208E           8B9E       FDEC            mov	bx,-$214[bp]
07640 2092           8DBE       FDDA            lea	di,-2+..FFFB[bp]
07641 2096           E8         E0A5            call	ldivul
07642 2099           8986       FDEA            mov	-$216[bp],ax
07643 209D           899E       FDEC            mov	-$214[bp],bx
07644 20A1           83C4                   04  add	sp,*4
07645                                           !BCC_EOS
07646                                           ! 1589           heads = sectors / 1024;
07647                                           ! Debug: div unsigned long = const $400 to unsigned long sectors = [S+$224-$218] (used reg = )
07648 20A4           B8                   0400  mov	ax,#$400
07649 20A7           31DB                       xor	bx,bx
07650 20A9           53                         push	bx
07651 20AA           50                         push	ax
07652 20AB           8B86       FDEA            mov	ax,-$216[bp]
07653 20AF           8B9E       FDEC            mov	bx,-$214[bp]
07654 20B3           8DBE       FDDA            lea	di,-2+..FFFB[bp]
07655 20B7           E8         E084            call	ldivul
07656 20BA           83C4                   04  add	sp,*4
07657                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$224-$21C] (used reg = )
07658 20BD           8986       FDE6            mov	-$21A[bp],ax
07659                                           !BCC_EOS
07660                                           ! 1590           if (heads>128) heads = 255;
07661                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$224-$21C] (used reg = )
07662 20C1           8B86       FDE6            mov	ax,-$21A[bp]
07663 20C5           3D                   0080  cmp	ax,#$80
07664 20C8           76           09            jbe 	.189
07665                       000020CA            .18A:
07666                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$224-$21C] (used reg = )
07667 20CA           B8                   00FF  mov	ax,#$FF
07668 20CD           8986       FDE6            mov	-$21A[bp],ax
07669                                           !BCC_EOS
07670                                           ! 1591           else if (heads>64) heads = 128;
07671 20D1           EB           3D            jmp .18B
07672                       000020D3            .189:
07673                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$224-$21C] (used reg = )
07674 20D3           8B86       FDE6            mov	ax,-$21A[bp]
07675 20D7           3D                   0040  cmp	ax,*$40
07676 20DA           76           09            jbe 	.18C
07677                       000020DC            .18D:
07678                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$224-$21C] (used reg = )
07679 20DC           B8                   0080  mov	ax,#$80
07680 20DF           8986       FDE6            mov	-$21A[bp],ax
07681                                           !BCC_EOS
07682                                           ! 1592           else if (heads>32) heads = 64;
07683 20E3           EB           2B            jmp .18E
07684                       000020E5            .18C:
07685                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$224-$21C] (used reg = )
07686 20E5           8B86       FDE6            mov	ax,-$21A[bp]
07687 20E9           3D                   0020  cmp	ax,*$20
07688 20EC           76           09            jbe 	.18F
07689                       000020EE            .190:
07690                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$224-$21C] (used reg = )
07691 20EE           B8                   0040  mov	ax,*$40
07692 20F1           8986       FDE6            mov	-$21A[bp],ax
07693                                           !BCC_EOS
07694                                           ! 1593           else if (heads>16) heads = 32;
07695 20F5           EB           19            jmp .191
07696                       000020F7            .18F:
07697                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$224-$21C] (used reg = )
07698 20F7           8B86       FDE6            mov	ax,-$21A[bp]
07699 20FB           3D                   0010  cmp	ax,*$10
07700 20FE           76           09            jbe 	.192
07701                       00002100            .193:
07702                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$224-$21C] (used reg = )
07703 2100           B8                   0020  mov	ax,*$20
07704 2103           8986       FDE6            mov	-$21A[bp],ax
07705                                           !BCC_EOS
07706                                           ! 1594           else heads=16;
07707 2107           EB           07            jmp .194
07708                       00002109            .192:
07709                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$224-$21C] (used reg = )
07710 2109           B8                   0010  mov	ax,*$10
07711 210C           8986       FDE6            mov	-$21A[bp],ax
07712                                           !BCC_EOS
07713                                           ! 1595           cylinders = sectors / heads;
07714                       00002110            .194:
07715                       00002110            .191:
07716                       00002110            .18E:
07717                       00002110            .18B:
07718                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$224-$21C] (used reg = )
07719 2110           8B86       FDE6            mov	ax,-$21A[bp]
07720 2114           31DB                       xor	bx,bx
07721                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors = [S+$224-$218] (used reg = )
07722 2116           53                         push	bx
07723 2117           50                         push	ax
07724 2118           8B86       FDEA            mov	ax,-$216[bp]
07725 211C           8B9E       FDEC            mov	bx,-$214[bp]
07726 2120           8DBE       FDDA            lea	di,-2+..FFFB[bp]
07727 2124           E8         E017            call	ldivul
07728 2127           83C4                   04  add	sp,*4
07729                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$224-$21A] (used reg = )
07730 212A           8986       FDE8            mov	-$218[bp],ax
07731                                           !BCC_EOS
07732                                           ! 1596           break;
07733 212E           E9         00BF            br 	.184
07734                                           !BCC_EOS
07735                                           ! 1597         case 3:
07736                                           ! 1598           if (heads==16) {
07737                       00002131            .195:
07738                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$224-$21C] (used reg = )
07739 2131           8B86       FDE6            mov	ax,-$21A[bp]
07740 2135           3D                   0010  cmp	ax,*$10
07741 2138           75           72            jne 	.196
07742                       0000213A            .197:
07743                                           ! 1599             if(cylinders>61439) cylinders=61439;
07744                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$224-$21A] (used reg = )
07745 213A           8B86       FDE8            mov	ax,-$218[bp]
07746 213E           31DB                       xor	bx,bx
07747                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
07748 2140           53                         push	bx
07749 2141           50                         push	ax
07750 2142           B8                   EFFF  mov	ax,#$EFFF
07751 2145           31DB                       xor	bx,bx
07752 2147           53                         push	bx
07753 2148           50                         push	ax
07754 2149           8B86       FDDA            mov	ax,-2+..FFFB[bp]
07755 214D           8B9E       FDDC            mov	bx,0+..FFFB[bp]
07756 2151           8DBE       FDD6            lea	di,-6+..FFFB[bp]
07757 2155           E8         DF43            call	lcmpul
07758 2158           8DA6       FDDE            lea	sp,2+..FFFB[bp]
07759 215C           76           07            jbe 	.198
07760                       0000215E            .199:
07761                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$224-$21A] (used reg = )
07762 215E           B8                   EFFF  mov	ax,#$EFFF
07763 2161           8986       FDE8            mov	-$218[bp],ax
07764                                           !BCC_EOS
07765                                           ! 1600             heads=15;
07766                       00002165            .198:
07767                                           ! Debug: eq int = const $F to unsigned short heads = [S+$224-$21C] (used reg = )
07768 2165           B8                   000F  mov	ax,*$F
07769 2168           8986       FDE6            mov	-$21A[bp],ax
07770                                           !BCC_EOS
07771                                           ! 1601             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
07772                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$224-$21A] (used reg = )
07773 216C           8B86       FDE8            mov	ax,-$218[bp]
07774 2170           31DB                       xor	bx,bx
07775                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
07776 2172           53                         push	bx
07777 2173           50                         push	ax
07778 2174           B8                   0010  mov	ax,*$10
07779 2177           31DB                       xor	bx,bx
07780 2179           53                         push	bx
07781 217A           50                         push	ax
07782 217B           8B86       FDDA            mov	ax,-2+..FFFB[bp]
07783 217F           8B9E       FDDC            mov	bx,0+..FFFB[bp]
07784 2183           8DBE       FDD6            lea	di,-6+..FFFB[bp]
07785 2187           E8         DF2F            call	lmulul
07786 218A           83C4                   08  add	sp,*8
07787                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
07788 218D           53                         push	bx
07789 218E           50                         push	ax
07790 218F           B8                   000F  mov	ax,*$F
07791 2192           31DB                       xor	bx,bx
07792 2194           53                         push	bx
07793 2195           50                         push	ax
07794 2196           8B86       FDDA            mov	ax,-2+..FFFB[bp]
07795 219A           8B9E       FDDC            mov	bx,0+..FFFB[bp]
07796 219E           8DBE       FDD6            lea	di,-6+..FFFB[bp]
07797 21A2           E8         DF99            call	ldivul
07798 21A5           83C4                   08  add	sp,*8
07799                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
07800                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$224-$21A] (used reg = )
07801 21A8           8986       FDE8            mov	-$218[bp],ax
07802                                           !BCC_EOS
07803                                           ! 1602             }
07804                                           ! 1603         case 2:
07805                       000021AC            .196:
07806                                           ! 1604           while(cylinders > 1024) {
07807                       000021AC            .19A:
07808 21AC           EB           1F            jmp .19C
07809                       000021AE            .19D:
07810                                           ! 1605             cylinders >>= 1;
07811                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$224-$21A] (used reg = )
07812 21AE           8B86       FDE8            mov	ax,-$218[bp]
07813 21B2           D1E8                       shr	ax,*1
07814 21B4           8986       FDE8            mov	-$218[bp],ax
07815                                           !BCC_EOS
07816                                           ! 1606             heads <<= 1;
07817                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$224-$21C] (used reg = )
07818 21B8           8B86       FDE6            mov	ax,-$21A[bp]
07819 21BC           D1E0                       shl	ax,*1
07820 21BE           8986       FDE6            mov	-$21A[bp],ax
07821                                           !BCC_EOS
07822                                           ! 1607             if (heads > 127) break;
07823                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$224-$21C] (used reg = )
07824 21C2           8B86       FDE6            mov	ax,-$21A[bp]
07825 21C6           3D                   007F  cmp	ax,*$7F
07826 21C9           76           02            jbe 	.19E
07827                       000021CB            .19F:
07828 21CB           EB           09            jmp .19B
07829                                           !BCC_EOS
07830                                           ! 1608           }
07831                       000021CD            .19E:
07832                                           ! 1609           break;
07833                       000021CD            .19C:
07834                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$224-$21A] (used reg = )
07835 21CD           8B86       FDE8            mov	ax,-$218[bp]
07836 21D1           3D                   0400  cmp	ax,#$400
07837 21D4           77           D8            ja 	.19D
07838                       000021D6            .1A0:
07839                       000021D6            .19B:
07840 21D6           EB           18            jmp .184
07841                                           !BCC_EOS
07842                                           ! 1610         }
07843                                           ! 1611       if (cylinders > 1024) cylinders=1024;
07844 21D8           EB           16            jmp .184
07845                       000021DA            .186:
07846 21DA           2C                     00  sub	al,*0
07847 21DC         0F84         FE99            beq 	.187
07848 21E0           2C                     01  sub	al,*1
07849 21E2         0F84         FE96            beq 	.188
07850 21E6           2C                     01  sub	al,*1
07851 21E8           74           C2            je 	.19A
07852 21EA           2C                     01  sub	al,*1
07853 21EC         0F84         FF41            beq 	.195
07854                       000021F0            .184:
07855                       FFFFFDDC            ..FFFB	=	-$224
07856                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$224-$21A] (used reg = )
07857 21F0           8B86       FDE8            mov	ax,-$218[bp]
07858 21F4           3D                   0400  cmp	ax,#$400
07859 21F7           76           07            jbe 	.1A1
07860                       000021F9            .1A2:
07861                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$224-$21A] (used reg = )
07862 21F9           B8                   0400  mov	ax,#$400
07863 21FC           8986       FDE8            mov	-$218[bp],ax
07864                                           !BCC_EOS
07865                                           ! 1612       bios_printf(4, " LCHS=%d/%d/%d\n", cylinders, heads, spt);
07866                       00002200            .1A1:
07867                                           ! Debug: list unsigned short spt = [S+$224-$21E] (used reg = )
07868 2200           FFB6       FDE4            push	-$21C[bp]
07869                                           ! Debug: list unsigned short heads = [S+$226-$21C] (used reg = )
07870 2204           FFB6       FDE6            push	-$21A[bp]
07871                                           ! Debug: list unsigned short cylinders = [S+$228-$21A] (used reg = )
07872 2208           FFB6       FDE8            push	-$218[bp]
07873                                           ! Debug: list * char = .1A3+0 (used reg = )
07874 220C           BB                   DA45  mov	bx,#.1A3
07875 220F           53                         push	bx
07876                                           ! Debug: list int = const 4 (used reg = )
07877 2210           B8                   0004  mov	ax,*4
07878 2213           50                         push	ax
07879                                           ! Debug: func () void = bios_printf+0 (used reg = )
07880 2214           E8         E692            call	_bios_printf
07881 2217           83C4                   0A  add	sp,*$A
07882                                           !BCC_EOS
07883                                           ! 1613       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
07884                                           ! Debug: list unsigned short heads = [S+$224-$21C] (used reg = )
07885 221A           FFB6       FDE6            push	-$21A[bp]
07886                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07887 221E           8A46         FB            mov	al,-5[bp]
07888 2221           30E4                       xor	ah,ah
07889 2223           B9                   001A  mov	cx,*$1A
07890 2226           F7E9                       imul	cx
07891 2228           89C3                       mov	bx,ax
07892                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
07893                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
07894 222A           81C3                 014C  add	bx,#$14C
07895 222E           53                         push	bx
07896                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07897 222F           FF76         FE            push	-2[bp]
07898                                           ! Debug: func () void = write_word+0 (used reg = )
07899 2232           E8         E407            call	_write_word
07900 2235           83C4                   06  add	sp,*6
07901                                           !BCC_EOS
07902                                           ! 1614       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
07903                                           ! Debug: list unsigned short cylinders = [S+$224-$21A] (used reg = )
07904 2238           FFB6       FDE8            push	-$218[bp]
07905                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07906 223C           8A46         FB            mov	al,-5[bp]
07907 223F           30E4                       xor	ah,ah
07908 2241           B9                   001A  mov	cx,*$1A
07909 2244           F7E9                       imul	cx
07910 2246           89C3                       mov	bx,ax
07911                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
07912                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
07913 2248           81C3                 014E  add	bx,#$14E
07914 224C           53                         push	bx
07915                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07916 224D           FF76         FE            push	-2[bp]
07917                                           ! Debug: func () void = write_word+0 (used reg = )
07918 2250           E8         E3E9            call	_write_word
07919 2253           83C4                   06  add	sp,*6
07920                                           !BCC_EOS
07921                                           ! 1615       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
07922                                           ! Debug: list unsigned short spt = [S+$224-$21E] (used reg = )
07923 2256           FFB6       FDE4            push	-$21C[bp]
07924                                           ! Debug: ptradd unsigned char device = [S+$226-7] to [8] struct  = const $142 (used reg = )
07925 225A           8A46         FB            mov	al,-5[bp]
07926 225D           30E4                       xor	ah,ah
07927 225F           B9                   001A  mov	cx,*$1A
07928 2262           F7E9                       imul	cx
07929 2264           89C3                       mov	bx,ax
07930                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
07931                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
07932 2266           81C3                 0150  add	bx,#$150
07933 226A           53                         push	bx
07934                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07935 226B           FF76         FE            push	-2[bp]
07936                                           ! Debug: func () void = write_word+0 (used reg = )
07937 226E           E8         E3CB            call	_write_word
07938 2271           83C4                   06  add	sp,*6
07939                                           !BCC_EOS
07940                                           ! 1616       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
07941                                           ! Debug: list unsigned char device = [S+$224-7] (used reg = )
07942 2274           8A46         FB            mov	al,-5[bp]
07943 2277           30E4                       xor	ah,ah
07944 2279           50                         push	ax
07945                                           ! Debug: ptradd unsigned char hdcount = [S+$226-5] to [8] unsigned char = const $213 (used reg = )
07946 227A           8A46         FD            mov	al,-3[bp]
07947 227D           30E4                       xor	ah,ah
07948 227F           89C3                       mov	bx,ax
07949                                           ! Debug: address unsigned char = [bx+$213] (used reg = )
07950                                           ! Debug: list * unsigned char = bx+$213 (used reg = )
07951 2281           81C3                 0213  add	bx,#$213
07952 2285           53                         push	bx
07953                                           ! Debug: list unsigned short ebda_seg = [S+$228-4] (used reg = )
07954 2286           FF76         FE            push	-2[bp]
07955                                           ! Debug: func () void = write_byte+0 (used reg = )
07956 2289           E8         E398            call	_write_byte
07957 228C           83C4                   06  add	sp,*6
07958                                           !BCC_EOS
07959                                           ! 1617       hdcount++;
07960                                           ! Debug: postinc unsigned char hdcount = [S+$224-5] (used reg = )
07961 228F           8A46         FD            mov	al,-3[bp]
07962 2292           40                         inc	ax
07963 2293           8846         FD            mov	-3[bp],al
07964                                           !BCC_EOS
07965                                           ! 1618       }
07966 2296           83C4                   10  add	sp,*$10
07967                                           ! 1619     if(type == 0x03) {
07968                       00002299            .168:
07969                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
07970 2299           8A46         FA            mov	al,-6[bp]
07971 229C           3C                     03  cmp	al,*3
07972 229E         0F85         0180            bne 	.1A4
07973                       000022A2            .1A5:
07974                                           ! 1620       Bit8u type, removable, mode;
07975                                           !BCC_EOS
07976                                           ! 1621       Bit
07977                                           ! 1621 16u blksize;
07978                                           !BCC_EOS
07979                                           ! 1622       mode = 0x00;
07980 22A2           83C4                   FA  add	sp,*-6
07981                                           ! Debug: eq int = const 0 to unsigned char mode = [S+$21A-$217] (used reg = )
07982 22A5           30C0                       xor	al,al
07983 22A7           8886       FDEB            mov	-$215[bp],al
07984                                           !BCC_EOS
07985                                           ! 1623       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
07986                                           ! Debug: list int = const 5 (used reg = )
07987 22AB           B8                   0005  mov	ax,*5
07988 22AE           50                         push	ax
07989                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
07990 22AF           8A46         FB            mov	al,-5[bp]
07991 22B2           30E4                       xor	ah,ah
07992 22B4           B9                   001A  mov	cx,*$1A
07993 22B7           F7E9                       imul	cx
07994 22B9           89C3                       mov	bx,ax
07995                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
07996                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
07997 22BB           81C3                 0143  add	bx,#$143
07998 22BF           53                         push	bx
07999                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08000 22C0           FF76         FE            push	-2[bp]
08001                                           ! Debug: func () void = write_byte+0 (used reg = )
08002 22C3           E8         E35E            call	_write_byte
08003 22C6           83C4                   06  add	sp,*6
08004                                           !BCC_EOS
08005                                           ! 1624       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
08006                                           ! Debug: list int = const 0 (used reg = )
08007 22C9           31C0                       xor	ax,ax
08008 22CB           50                         push	ax
08009                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08010 22CC           8A46         FB            mov	al,-5[bp]
08011 22CF           30E4                       xor	ah,ah
08012 22D1           B9                   001A  mov	cx,*$1A
08013 22D4           F7E9                       imul	cx
08014 22D6           89C3                       mov	bx,ax
08015                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08016                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08017 22D8           81C3                 0146  add	bx,#$146
08018 22DC           53                         push	bx
08019                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08020 22DD           FF76         FE            push	-2[bp]
08021                                           ! Debug: func () void = write_byte+0 (used reg = )
08022 22E0           E8         E341            call	_write_byte
08023 22E3           83C4                   06  add	sp,*6
08024                                           !BCC_EOS
08025                                           ! 1625       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, get_SS(),buffer) != 0)
08026                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
08027 22E6           8D9E       FDFA            lea	bx,-$206[bp]
08028 22EA           53                         push	bx
08029                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08030 22EB           E8         E369            call	_get_SS
08031                                           ! Debug: list unsigned short = ax+0 (used reg = )
08032 22EE           50                         push	ax
08033                                           ! Debug: list long = const 0 (used reg = )
08034 22EF           31C0                       xor	ax,ax
08035 22F1           31DB                       xor	bx,bx
08036 22F3           53                         push	bx
08037 22F4           50                         push	ax
08038                                           ! Debug: list int = const 0 (used reg = )
08039 22F5           31C0                       xor	ax,ax
08040 22F7           50                         push	ax
08041                                           ! Debug: list int = const 0 (used reg = )
08042 22F8           31C0                       xor	ax,ax
08043 22FA           50                         push	ax
08044                                           ! Debug: list int = const 0 (used reg = )
08045 22FB           31C0                       xor	ax,ax
08046 22FD           50                         push	ax
08047                                           ! Debug: list int = const 1 (used reg = )
08048 22FE           B8                   0001  mov	ax,*1
08049 2301           50                         push	ax
08050                                           ! Debug: list int = const $A1 (used reg = )
08051 2302           B8                   00A1  mov	ax,#$A1
08052 2305           50                         push	ax
08053                                           ! Debug: list unsigned char device = [S+$22C-7] (used reg = )
08054 2306           8A46         FB            mov	al,-5[bp]
08055 2309           30E4                       xor	ah,ah
08056 230B           50                         push	ax
08057                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
08058 230C           E8         067B            call	_ata_cmd_data_in
08059 230F           83C4                   14  add	sp,*$14
08060                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08061 2312           85C0                       test	ax,ax
08062 2314           74           0E            je  	.1A6
08063                       00002316            .1A7:
08064                                           ! 1626         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
08065                                           ! Debug: list * char = .1A8+0 (used reg = )
08066 2316           BB                   DA1A  mov	bx,#.1A8
08067 2319           53                         push	bx
08068                                           ! Debug: list int = const 7 (used reg = )
08069 231A           B8                   0007  mov	ax,*7
08070 231D           50                         push	ax
08071                                           ! Debug: func () void = bios_printf+0 (used reg = )
08072 231E           E8         E588            call	_bios_printf
08073 2321           83C4                   04  add	sp,*4
08074                                           !BCC_EOS
08075                                           ! 1627       type = read_byte(get_SS(),buffer+1) & 0x1f;
08076                       00002324            .1A6:
08077                                           ! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
08078 2324           8D9E       FDFB            lea	bx,-$205[bp]
08079 2328           53                         push	bx
08080                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08081 2329           E8         E32B            call	_get_SS
08082                                           ! Debug: list unsigned short = ax+0 (used reg = )
08083 232C           50                         push	ax
08084                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08085 232D           E8         E2CE            call	_read_byte
08086 2330           83C4                   04  add	sp,*4
08087                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
08088 2333           24                     1F  and	al,*$1F
08089                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
08090 2335           8886       FDED            mov	-$213[bp],al
08091                                           !BCC_EOS
08092                                           ! 1628       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
08093                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
08094 2339           8D9E       FDFA            lea	bx,-$206[bp]
08095 233D           53                         push	bx
08096                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08097 233E           E8         E316            call	_get_SS
08098                                           ! Debug: list unsigned short = ax+0 (used reg = )
08099 2341           50                         push	ax
08100                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08101 2342           E8         E2B9            call	_read_byte
08102 2345           83C4                   04  add	sp,*4
08103                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08104 2348           24                     80  and	al,#$80
08105 234A           84C0                       test	al,al
08106 234C           74           04            je  	.1A9
08107                       0000234E            .1AA:
08108 234E           B0                     01  mov	al,*1
08109 2350           EB           02            jmp .1AB
08110                       00002352            .1A9:
08111 2352           30C0                       xor	al,al
08112                       00002354            .1AB:
08113                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
08114 2354           8886       FDEC            mov	-$214[bp],al
08115                                           !BCC_EOS
08116                                           ! 1629       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
08117                                           ! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
08118 2358           8D9E       FE5A            lea	bx,-$1A6[bp]
08119 235C           53                         push	bx
08120                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08121 235D           E8         E2F7            call	_get_SS
08122                                           ! Debug: list unsigned short = ax+0 (used reg = )
08123 2360           50                         push	ax
08124                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08125 2361           E8         E29A            call	_read_byte
08126 2364           83C4                   04  add	sp,*4
08127 2367           84C0                       test	al,al
08128 2369           74           04            je  	.1AC
08129                       0000236B            .1AD:
08130 236B           B0                     01  mov	al,*1
08131 236D           EB           02            jmp .1AE
08132                       0000236F            .1AC:
08133 236F           30C0                       xor	al,al
08134                       00002371            .1AE:
08135                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
08136 2371           8886       FDEB            mov	-$215[bp],al
08137                                           !BCC_EOS
08138                                           ! 1630       blksize = 2048;
08139                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
08140 2375           B8                   0800  mov	ax,#$800
08141 2378           8986       FDE8            mov	-$218[bp],ax
08142                                           !BCC_EOS
08143                                           ! 1631       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
08144                                           ! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
08145 237C           8A86       FDED            mov	al,-$213[bp]
08146 2380           30E4                       xor	ah,ah
08147 2382           50                         push	ax
08148                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08149 2383           8A46         FB            mov	al,-5[bp]
08150 2386           30E4                       xor	ah,ah
08151 2388           B9                   001A  mov	cx,*$1A
08152 238B           F7E9                       imul	cx
08153 238D           89C3                       mov	bx,ax
08154                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08155                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08156 238F           81C3                 0143  add	bx,#$143
08157 2393           53                         push	bx
08158                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08159 2394           FF76         FE            push	-2[bp]
08160                                           ! Debug: func () void = write_byte+0 (used reg = )
08161 2397           E8         E28A            call	_write_byte
08162 239A           83C4                   06  add	sp,*6
08163                                           !BCC_EOS
08164                                           ! 1632       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
08165                                           ! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
08166 239D           8A86       FDEC            mov	al,-$214[bp]
08167 23A1           30E4                       xor	ah,ah
08168 23A3           50                         push	ax
08169                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08170 23A4           8A46         FB            mov	al,-5[bp]
08171 23A7           30E4                       xor	ah,ah
08172 23A9           B9                   001A  mov	cx,*$1A
08173 23AC           F7E9                       imul	cx
08174 23AE           89C3                       mov	bx,ax
08175                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08176                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
08177 23B0           81C3                 0144  add	bx,#$144
08178 23B4           53                         push	bx
08179                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08180 23B5           FF76         FE            push	-2[bp]
08181                                           ! Debug: func () void = write_byte+0 (used reg = )
08182 23B8           E8         E269            call	_write_byte
08183 23BB           83C4                   06  add	sp,*6
08184                                           !BCC_EOS
08185                                           ! 1633       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
08186                                           ! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
08187 23BE           8A86       FDEB            mov	al,-$215[bp]
08188 23C2           30E4                       xor	ah,ah
08189 23C4           50                         push	ax
08190                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08191 23C5           8A46         FB            mov	al,-5[bp]
08192 23C8           30E4                       xor	ah,ah
08193 23CA           B9                   001A  mov	cx,*$1A
08194 23CD           F7E9                       imul	cx
08195 23CF           89C3                       mov	bx,ax
08196                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08197                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08198 23D1           81C3                 0146  add	bx,#$146
08199 23D5           53                         push	bx
08200                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08201 23D6           FF76         FE            push	-2[bp]
08202                                           ! Debug: func () void = write_byte+0 (used reg = )
08203 23D9           E8         E248            call	_write_byte
08204 23DC           83C4                   06  add	sp,*6
08205                                           !BCC_EOS
08206                                           ! 1634       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
08207                                           ! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
08208 23DF           FFB6       FDE8            push	-$218[bp]
08209                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08210 23E3           8A46         FB            mov	al,-5[bp]
08211 23E6           30E4                       xor	ah,ah
08212 23E8           B9                   001A  mov	cx,*$1A
08213 23EB           F7E9                       imul	cx
08214 23ED           89C3                       mov	bx,ax
08215                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08216                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
08217 23EF           81C3                 0148  add	bx,#$148
08218 23F3           53                         push	bx
08219                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08220 23F4           FF76         FE            push	-2[bp]
08221                                           ! Debug: func () void = write_word+0 (used reg = )
08222 23F7           E8         E242            call	_write_word
08223 23FA           83C4                   06  add	sp,*6
08224                                           !BCC_EOS
08225                                           ! 1635       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
08226                                           ! Debug: list unsigned char device = [S+$21A-7] (used reg = )
08227 23FD           8A46         FB            mov	al,-5[bp]
08228 2400           30E4                       xor	ah,ah
08229 2402           50                         push	ax
08230                                           ! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $21C (used reg = )
08231 2403           8A46         FC            mov	al,-4[bp]
08232 2406           30E4                       xor	ah,ah
08233 2408           89C3                       mov	bx,ax
08234                                           ! Debug: address unsigned char = [bx+$21C] (used reg = )
08235                                           ! Debug: list * unsigned char = bx+$21C (used reg = )
08236 240A           81C3                 021C  add	bx,#$21C
08237 240E           53                         push	bx
08238                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08239 240F           FF76         FE            push	-2[bp]
08240                                           ! Debug: func () void = write_byte+0 (used reg = )
08241 2412           E8         E20F            call	_write_byte
08242 2415           83C4                   06  add	sp,*6
08243                                           !BCC_EOS
08244                                           ! 1636       cdcount++;
08245                                           ! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
08246 2418           8A46         FC            mov	al,-4[bp]
08247 241B           40                         inc	ax
08248 241C           8846         FC            mov	-4[bp],al
08249                                           !BCC_EOS
08250                                           ! 1637       }
08251 241F           83C4                   06  add	sp,*6
08252                                           ! 1638       {
08253                       00002422            .1A4:
08254                                           ! 1639       Bit32u sizeinmb;
08255                                           !BCC_EOS
08256                                           ! 1640       Bit16u ataversion;
08257                                           !BCC_EOS
08258                                           ! 1641       Bit8u c, i, version, model[41];
08259                                           !BCC_EOS
08260                                           ! 1642       switch (type) {
08261 2422           83C4                   CE  add	sp,*-$32
08262 2425           8A46         FA            mov	al,-6[bp]
08263 2428           E9         019D            br 	.1B1
08264                                           ! 1643         case 0x02:
08265                                           ! 1644           sizeinmb = read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors);
08266                       0000242B            .1B2:
08267                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
08268 242B           8A46         FB            mov	al,-5[bp]
08269 242E           30E4                       xor	ah,ah
08270 2430           B9                   001A  mov	cx,*$1A
08271 2433           F7E9                       imul	cx
08272 2435           89C3                       mov	bx,ax
08273                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08274                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
08275 2437           81C3                 0158  add	bx,#$158
08276 243B           53                         push	bx
08277                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
08278 243C           FF76         FE            push	-2[bp]
08279                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08280 243F           E8         DC13            call	_read_dword
08281 2442           89D3                       mov	bx,dx
08282 2444           83C4                   04  add	sp,*4
08283                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
08284 2447           8986       FDEA            mov	-$216[bp],ax
08285 244B           899E       FDEC            mov	-$214[bp],bx
08286                                           !BCC_EOS
08287                                           ! 1645           sizeinmb >>= 11;
08288                                           ! Debug: srab int = const $B to unsigned long sizeinmb = [S+$246-$218] (used reg = )
08289 244F           8B86       FDEA            mov	ax,-$216[bp]
08290 2453           8B9E       FDEC            mov	bx,-$214[bp]
08291 2457           88E0                       mov	al,ah
08292 2459           88DC                       mov	ah,bl
08293 245B           88FB                       mov	bl,bh
08294 245D           28FF                       sub	bh,bh
08295 245F           BF                   0003  mov	di,*3
08296 2462           E8         DC94            call	lsrul
08297 2465           8986       FDEA            mov	-$216[bp],ax
08298 2469           899E       FDEC            mov	-$214[bp],bx
08299                                           !BCC_EOS
08300                                           ! 1646         case 0x03:
08301                                           ! 1647           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
08302                       0000246D            .1B3:
08303                                           ! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
08304 246D           8D9E       FE9A            lea	bx,-$166[bp]
08305 2471           53                         push	bx
08306                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08307 2472           E8         E1E2            call	_get_SS
08308                                           ! Debug: list unsigned short = ax+0 (used reg = )
08309 2475           50                         push	ax
08310                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08311 2476           E8         E185            call	_read_byte
08312 2479           83C4                   04  add	sp,*4
08313 247C           50                         push	ax
08314                                           ! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
08315 247D           8D9E       FE9B            lea	bx,-$165[bp]
08316 2481           53                         push	bx
08317                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08318 2482           E8         E1D2            call	_get_SS
08319                                           ! Debug: list unsigned short = ax+0 (used reg = )
08320 2485           50                         push	ax
08321                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08322 2486           E8         E175            call	_read_byte
08323 2489           83C4                   04  add	sp,*4
08324                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
08325 248C           30E4                       xor	ah,ah
08326                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
08327 248E           88C4                       mov	ah,al
08328 2490           30C0                       xor	al,al
08329                                           ! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
08330 2492           0A86       FDBA            or	al,0+..FFFA[bp]
08331 2496           44                         inc	sp
08332 2497           44                         inc	sp
08333                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
08334 2498           8986       FDE8            mov	-$218[bp],ax
08335                                           !BCC_EOS
08336                                           ! 1648           for(version=15;version>0;version--) {
08337                                           ! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
08338 249C           B0                     0F  mov	al,*$F
08339 249E           8886       FDE5            mov	-$21B[bp],al
08340                                           !BCC_EOS
08341                                           !BCC_EOS
08342 24A2           EB           22            jmp .1B6
08343                       000024A4            .1B7:
08344                                           ! 1649             if((ataversion&(1<<version))!=0)
08345                                           ! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
08346 24A4           8A86       FDE5            mov	al,-$21B[bp]
08347 24A8           30E4                       xor	ah,ah
08348 24AA           89C3                       mov	bx,ax
08349 24AC           B8                   0001  mov	ax,*1
08350 24AF           89D9                       mov	cx,bx
08351 24B1           D3E0                       shl	ax,cl
08352                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
08353                                           ! Debug: expression subtree swapping
08354 24B3           2386       FDE8            and	ax,-$218[bp]
08355                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
08356 24B7           85C0                       test	ax,ax
08357 24B9           74           02            je  	.1B8
08358                       000024BB            .1B9:
08359                                           ! 1650             break;
08360 24BB           EB           11            jmp .1B4
08361                                           !BCC_EOS
08362                                           ! 1651             }
08363                       000024BD            .1B8:
08364                                           ! 1652           for(i=0;i<20;i++){
08365                       000024BD            .1B5:
08366                                           ! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
08367 24BD           8A86       FDE5            mov	al,-$21B[bp]
08368 24C1           48                         dec	ax
08369 24C2           8886       FDE5            mov	-$21B[bp],al
08370                       000024C6            .1B6:
08371                                           ! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
08372 24C6           8A86       FDE5            mov	al,-$21B[bp]
08373 24CA           84C0                       test	al,al
08374 24CC           75           D6            jne	.1B7
08375                       000024CE            .1BA:
08376                       000024CE            .1B4:
08377                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
08378 24CE           30C0                       xor	al,al
08379 24D0           8886       FDE6            mov	-$21A[bp],al
08380                                           !BCC_EOS
08381                                           !BCC_EOS
08382 24D4           E9         007B            br 	.1BD
08383                       000024D7            .1BE:
08384                                           ! 1653             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
08385                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
08386 24D7           8A86       FDE6            mov	al,-$21A[bp]
08387 24DB           30E4                       xor	ah,ah
08388 24DD           D1E0                       shl	ax,*1
08389                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
08390 24DF           89EB                       mov	bx,bp
08391 24E1           01C3                       add	bx,ax
08392                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
08393                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
08394                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
08395                                           ! Debug: list * unsigned char = bx-$1CF (used reg = )
08396 24E3           81C3                 FE31  add	bx,#-$1CF
08397 24E7           53                         push	bx
08398                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08399 24E8           E8         E16C            call	_get_SS
08400                                           ! Debug: list unsigned short = ax+0 (used reg = )
08401 24EB           50                         push	ax
08402                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08403 24EC           E8         E10F            call	_read_byte
08404 24EF           83C4                   04  add	sp,*4
08405                                           ! Debug: list unsigned char = al+0 (used reg = )
08406 24F2           30E4                       xor	ah,ah
08407 24F4           50                         push	ax
08408                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
08409 24F5           8A86       FDE6            mov	al,-$21A[bp]
08410 24F9           30E4                       xor	ah,ah
08411 24FB           D1E0                       shl	ax,*1
08412                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
08413 24FD           89EB                       mov	bx,bp
08414 24FF           01C3                       add	bx,ax
08415                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
08416                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
08417 2501           81C3                 FDBC  add	bx,#-$244
08418 2505           53                         push	bx
08419                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08420 2506           E8         E14E            call	_get_SS
08421                                           ! Debug: list unsigned short = ax+0 (used reg = )
08422 2509           50                         push	ax
08423                                           ! Debug: func () void = write_byte+0 (used reg = )
08424 250A           E8         E117            call	_write_byte
08425 250D           83C4                   06  add	sp,*6
08426                                           !BCC_EOS
08427                                           ! 1654             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
08428                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
08429 2510           8A86       FDE6            mov	al,-$21A[bp]
08430 2514           30E4                       xor	ah,ah
08431 2516           D1E0                       shl	ax,*1
08432                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
08433 2518           89EB                       mov	bx,bp
08434 251A           01C3                       add	bx,ax
08435                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
08436                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
08437                                           ! Debug: list * unsigned char = bx-$1D0 (used reg = )
08438 251C           81C3                 FE30  add	bx,#-$1D0
08439 2520           53                         push	bx
08440                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08441 2521           E8         E133            call	_get_SS
08442                                           ! Debug: list unsigned short = ax+0 (used reg = )
08443 2524           50                         push	ax
08444                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08445 2525           E8         E0D6            call	_read_byte
08446 2528           83C4                   04  add	sp,*4
08447                                           ! Debug: list unsigned char = al+0 (used reg = )
08448 252B           30E4                       xor	ah,ah
08449 252D           50                         push	ax
08450                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
08451 252E           8A86       FDE6            mov	al,-$21A[bp]
08452 2532           30E4                       xor	ah,ah
08453 2534           D1E0                       shl	ax,*1
08454                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
08455 2536           89EB                       mov	bx,bp
08456 2538           01C3                       add	bx,ax
08457                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
08458                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
08459                                           ! Debug: list * unsigned char = bx-$243 (used reg = )
08460 253A           81C3                 FDBD  add	bx,#-$243
08461 253E           53                         push	bx
08462                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08463 253F           E8         E115            call	_get_SS
08464                                           ! Debug: list unsigned short = ax+0 (used reg = )
08465 2542           50                         push	ax
08466                                           ! Debug: func () void = write_byte+0 (used reg = )
08467 2543           E8         E0DE            call	_write_byte
08468 2546           83C4                   06  add	sp,*6
08469                                           !BCC_EOS
08470                                           ! 1655             }
08471                                           ! 1656           write_byte(get_SS(),model+40,0x00);
08472                       00002549            .1BC:
08473                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
08474 2549           8A86       FDE6            mov	al,-$21A[bp]
08475 254D           40                         inc	ax
08476 254E           8886       FDE6            mov	-$21A[bp],al
08477                       00002552            .1BD:
08478                                           ! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
08479 2552           8A86       FDE6            mov	al,-$21A[bp]
08480 2556           3C                     14  cmp	al,*$14
08481 2558         0F82         FF7B            blo 	.1BE
08482                       0000255C            .1BF:
08483                       0000255C            .1BB:
08484                                           ! Debug: list int = const 0 (used reg = )
08485 255C           31C0                       xor	ax,ax
08486 255E           50                         push	ax
08487                                           ! Debug: list * unsigned char model = S+$248-$21E (used reg = )
08488 255F           8D9E       FDE4            lea	bx,-$21C[bp]
08489 2563           53                         push	bx
08490                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08491 2564           E8         E0F0            call	_get_SS
08492                                           ! Debug: list unsigned short = ax+0 (used reg = )
08493 2567           50                         push	ax
08494                                           ! Debug: func () void = write_byte+0 (used reg = )
08495 2568           E8         E0B9            call	_write_byte
08496 256B           83C4                   06  add	sp,*6
08497                                           !BCC_EOS
08498                                           ! 1657           for(i=39;i>0;i--){
08499                                           ! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
08500 256E           B0                     27  mov	al,*$27
08501 2570           8886       FDE6            mov	-$21A[bp],al
08502                                           !BCC_EOS
08503                                           !BCC_EOS
08504 2574           EB           46            jmp .1C2
08505                       00002576            .1C3:
08506                                           ! 1658             if(read_byte(get_SS(),model+i)==0x20)
08507                                           ! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
08508 2576           8A86       FDE6            mov	al,-$21A[bp]
08509 257A           30E4                       xor	ah,ah
08510 257C           89EB                       mov	bx,bp
08511 257E           01C3                       add	bx,ax
08512                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
08513                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
08514 2580           81C3                 FDBC  add	bx,#-$244
08515 2584           53                         push	bx
08516                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08517 2585           E8         E0CF            call	_get_SS
08518                                           ! Debug: list unsigned short = ax+0 (used reg = )
08519 2588           50                         push	ax
08520                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08521 2589           E8         E072            call	_read_byte
08522 258C           83C4                   04  add	sp,*4
08523                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
08524 258F           3C                     20  cmp	al,*$20
08525 2591           75           1E            jne 	.1C4
08526                       00002593            .1C5:
08527                                           ! 1659               write_byte(get_SS(),model+i,0x00);
08528                                           ! Debug: list int = const 0 (used reg = )
08529 2593           31C0                       xor	ax,ax
08530 2595           50                         push	ax
08531                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
08532 2596           8A86       FDE6            mov	al,-$21A[bp]
08533 259A           30E4                       xor	ah,ah
08534 259C           89EB                       mov	bx,bp
08535 259E           01C3                       add	bx,ax
08536                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
08537                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
08538 25A0           81C3                 FDBC  add	bx,#-$244
08539 25A4           53                         push	bx
08540                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08541 25A5           E8         E0AF            call	_get_SS
08542                                           ! Debug: list unsigned short = ax+0 (used reg = )
08543 25A8           50                         push	ax
08544                                           ! Debug: func () void = write_byte+0 (used reg = )
08545 25A9           E8         E078            call	_write_byte
08546 25AC           83C4                   06  add	sp,*6
08547                                           !BCC_EOS
08548                                           ! 1660             else break;
08549 25AF           EB           02            jmp .1C6
08550                       000025B1            .1C4:
08551 25B1           EB           11            jmp .1C0
08552                                           !BCC_EOS
08553                                           ! 1661             }
08554                       000025B3            .1C6:
08555                                           ! 1662           break;
08556                       000025B3            .1C1:
08557                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
08558 25B3           8A86       FDE6            mov	al,-$21A[bp]
08559 25B7           48                         dec	ax
08560 25B8           8886       FDE6            mov	-$21A[bp],al
08561                       000025BC            .1C2:
08562                                           ! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
08563 25BC           8A86       FDE6            mov	al,-$21A[bp]
08564 25C0           84C0                       test	al,al
08565 25C2           75           B2            jne	.1C3
08566                       000025C4            .1C7:
08567                       000025C4            .1C0:
08568 25C4           EB           0E            jmp .1AF
08569                                           !BCC_EOS
08570                                           ! 1663         }
08571                                           ! 1664       switch (type) {
08572 25C6           EB           0C            jmp .1AF
08573                       000025C8            .1B1:
08574 25C8           2C                     02  sub	al,*2
08575 25CA         0F84         FE5D            beq 	.1B2
08576 25CE           2C                     01  sub	al,*1
08577 25D0         0F84         FE99            beq 	.1B3
08578                       000025D4            .1AF:
08579                       FFFFFDBA            ..FFFA	=	-$246
08580 25D4           8A46         FA            mov	al,-6[bp]
08581 25D7           E9         01A2            br 	.1CA
08582                                           ! 1665         case 0x02:
08583                                           ! 1666           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"m
08584                       000025DA            .1CB:
08585                                           ! 1666 aster");
08586 25DA           8A86       FDF4            mov	al,-$20C[bp]
08587 25DE           84C0                       test	al,al
08588 25E0           74           05            je  	.1CF
08589                       000025E2            .1D0:
08590 25E2           BB                   DA08  mov	bx,#.1CD
08591 25E5           EB           03            jmp .1D1
08592                       000025E7            .1CF:
08593 25E7           BB                   DA01  mov	bx,#.1CE
08594                       000025EA            .1D1:
08595                                           ! Debug: list * char = bx+0 (used reg = )
08596 25EA           53                         push	bx
08597                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
08598 25EB           8A86       FDF5            mov	al,-$20B[bp]
08599 25EF           30E4                       xor	ah,ah
08600 25F1           50                         push	ax
08601                                           ! Debug: list * char = .1CC+0 (used reg = )
08602 25F2           BB                   DA0F  mov	bx,#.1CC
08603 25F5           53                         push	bx
08604                                           ! Debug: list int = const 2 (used reg = )
08605 25F6           B8                   0002  mov	ax,*2
08606 25F9           50                         push	ax
08607                                           ! Debug: func () void = bios_printf+0 (used reg = )
08608 25FA           E8         E2AC            call	_bios_printf
08609 25FD           83C4                   08  add	sp,*8
08610                                           !BCC_EOS
08611                                           ! 1667           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
08612                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
08613 2600           30C0                       xor	al,al
08614 2602           8886       FDE6            mov	-$21A[bp],al
08615                                           !BCC_EOS
08616 2606           EB           15            jmp .1D3
08617                       00002608            .1D4:
08618                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
08619 2608           8A86       FDE7            mov	al,-$219[bp]
08620 260C           30E4                       xor	ah,ah
08621 260E           50                         push	ax
08622                                           ! Debug: list * char = .1D5+0 (used reg = )
08623 260F           BB                   D9FE  mov	bx,#.1D5
08624 2612           53                         push	bx
08625                                           ! Debug: list int = const 2 (used reg = )
08626 2613           B8                   0002  mov	ax,*2
08627 2616           50                         push	ax
08628                                           ! Debug: func () void = bios_printf+0 (used reg = )
08629 2617           E8         E28F            call	_bios_printf
08630 261A           83C4                   06  add	sp,*6
08631                                           !BCC_EOS
08632                                           ! 1668           if (sizeinmb < 1UL<<16)
08633                       0000261D            .1D3:
08634                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
08635 261D           8A86       FDE6            mov	al,-$21A[bp]
08636 2621           40                         inc	ax
08637 2622           8886       FDE6            mov	-$21A[bp],al
08638                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
08639 2626           48                         dec	ax
08640 2627           30E4                       xor	ah,ah
08641 2629           89EB                       mov	bx,bp
08642 262B           01C3                       add	bx,ax
08643                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
08644                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
08645 262D           81C3                 FDBC  add	bx,#-$244
08646 2631           53                         push	bx
08647                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08648 2632           E8         E022            call	_get_SS
08649                                           ! Debug: list unsigned short = ax+0 (used reg = )
08650 2635           50                         push	ax
08651                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08652 2636           E8         DFC5            call	_read_byte
08653 2639           83C4                   04  add	sp,*4
08654                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
08655 263C           8886       FDE7            mov	-$219[bp],al
08656 2640           84C0                       test	al,al
08657 2642           75           C4            jne	.1D4
08658                       00002644            .1D6:
08659                       00002644            .1D2:
08660                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
08661 2644           31C0                       xor	ax,ax
08662 2646           BB                   0001  mov	bx,*1
08663 2649           8DBE       FDEA            lea	di,-$216[bp]
08664 264D           E8         DA4B            call	lcmpul
08665 2650           76           1B            jbe 	.1D7
08666                       00002652            .1D8:
08667                                           ! 1669             bios_printf(2, " ATA-%d Hard-Disk (%04u MBytes)\n",version,(Bit16u)sizeinmb);
08668                                           ! Debug: list unsigned short sizeinmb = [S+$246-$218] (used reg = )
08669 2652           FFB6       FDEA            push	-$216[bp]
08670                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
08671 2656           8A86       FDE5            mov	al,-$21B[bp]
08672 265A           30E4                       xor	ah,ah
08673 265C           50                         push	ax
08674                                           ! Debug: list * char = .1D9+0 (used reg = )
08675 265D           BB                   D9DD  mov	bx,#.1D9
08676 2660           53                         push	bx
08677                                           ! Debug: list int = const 2 (used reg = )
08678 2661           B8                   0002  mov	ax,*2
08679 2664           50                         push	ax
08680                                           ! Debug: func () void = bios_printf+0 (used reg = )
08681 2665           E8         E241            call	_bios_printf
08682 2668           83C4                   08  add	sp,*8
08683                                           !BCC_EOS
08684                                           ! 1670           else
08685                                           ! 1671             bios_printf(2, " ATA-%d Hard-Disk (%04u GBytes)\n",version,(Bit16u)(sizeinmb>>10));
08686 266B           EB           2C            jmp .1DA
08687                       0000266D            .1D7:
08688                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
08689 266D           8B86       FDEA            mov	ax,-$216[bp]
08690 2671           8B9E       FDEC            mov	bx,-$214[bp]
08691 2675           88E0                       mov	al,ah
08692 2677           88DC                       mov	ah,bl
08693 2679           88FB                       mov	bl,bh
08694 267B           28FF                       sub	bh,bh
08695 267D           BF                   0002  mov	di,*2
08696 2680           E8         DA76            call	lsrul
08697                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08698                                           ! Debug: list unsigned short = ax+0 (used reg = )
08699 2683           50                         push	ax
08700                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
08701 2684           8A86       FDE5            mov	al,-$21B[bp]
08702 2688           30E4                       xor	ah,ah
08703 268A           50                         push	ax
08704                                           ! Debug: list * char = .1DB+0 (used reg = )
08705 268B           BB                   D9BC  mov	bx,#.1DB
08706 268E           53                         push	bx
08707                                           ! Debug: list int = const 2 (used reg = )
08708 268F           B8                   0002  mov	ax,*2
08709 2692           50                         push	ax
08710                                           ! Debug: func () void = bios_printf+0 (used reg = )
08711 2693           E8         E213            call	_bios_printf
08712 2696           83C4                   08  add	sp,*8
08713                                           !BCC_EOS
08714                                           ! 1672           break;
08715                       00002699            .1DA:
08716 2699           E9         00F0            br 	.1C8
08717                                           !BCC_EOS
08718                                           ! 1673         case 0x03:
08719                                           ! 1674           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
08720                       0000269C            .1DC:
08721 269C           8A86       FDF4            mov	al,-$20C[bp]
08722 26A0           84C0                       test	al,al
08723 26A2           74           05            je  	.1E0
08724                       000026A4            .1E1:
08725 26A4           BB                   D9AA  mov	bx,#.1DE
08726 26A7           EB           03            jmp .1E2
08727                       000026A9            .1E0:
08728 26A9           BB                   D9A3  mov	bx,#.1DF
08729                       000026AC            .1E2:
08730                                           ! Debug: list * char = bx+0 (used reg = )
08731 26AC           53                         push	bx
08732                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
08733 26AD           8A86       FDF5            mov	al,-$20B[bp]
08734 26B1           30E4                       xor	ah,ah
08735 26B3           50                         push	ax
08736                                           ! Debug: list * char = .1DD+0 (used reg = )
08737 26B4           BB                   D9B1  mov	bx,#.1DD
08738 26B7           53                         push	bx
08739                                           ! Debug: list int = const 2 (used reg = )
08740 26B8           B8                   0002  mov	ax,*2
08741 26BB           50                         push	ax
08742                                           ! Debug: func () void = bios_printf+0 (used reg = )
08743 26BC           E8         E1EA            call	_bios_printf
08744 26BF           83C4                   08  add	sp,*8
08745                                           !BCC_EOS
08746                                           ! 1675           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
08747                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
08748 26C2           30C0                       xor	al,al
08749 26C4           8886       FDE6            mov	-$21A[bp],al
08750                                           !BCC_EOS
08751 26C8           EB           15            jmp .1E4
08752                       000026CA            .1E5:
08753                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
08754 26CA           8A86       FDE7            mov	al,-$219[bp]
08755 26CE           30E4                       xor	ah,ah
08756 26D0           50                         push	ax
08757                                           ! Debug: list * char = .1E6+0 (used reg = )
08758 26D1           BB                   D9A0  mov	bx,#.1E6
08759 26D4           53                         push	bx
08760                                           ! Debug: list int = const 2 (used reg = )
08761 26D5           B8                   0002  mov	ax,*2
08762 26D8           50                         push	ax
08763                                           ! Debug: func () void = bios_printf+0 (used reg = )
08764 26D9           E8         E1CD            call	_bios_printf
08765 26DC           83C4                   06  add	sp,*6
08766                                           !BCC_EOS
08767                                           ! 1676           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device)==0x05)
08768                       000026DF            .1E4:
08769                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
08770 26DF           8A86       FDE6            mov	al,-$21A[bp]
08771 26E3           40                         inc	ax
08772 26E4           8886       FDE6            mov	-$21A[bp],al
08773                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
08774 26E8           48                         dec	ax
08775 26E9           30E4                       xor	ah,ah
08776 26EB           89EB                       mov	bx,bp
08777 26ED           01C3                       add	bx,ax
08778                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
08779                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
08780 26EF           81C3                 FDBC  add	bx,#-$244
08781 26F3           53                         push	bx
08782                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08783 26F4           E8         DF60            call	_get_SS
08784                                           ! Debug: list unsigned short = ax+0 (used reg = )
08785 26F7           50                         push	ax
08786                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08787 26F8           E8         DF03            call	_read_byte
08788 26FB           83C4                   04  add	sp,*4
08789                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
08790 26FE           8886       FDE7            mov	-$219[bp],al
08791 2702           84C0                       test	al,al
08792 2704           75           C4            jne	.1E5
08793                       00002706            .1E7:
08794                       00002706            .1E3:
08795                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
08796 2706           8A46         FB            mov	al,-5[bp]
08797 2709           30E4                       xor	ah,ah
08798 270B           B9                   001A  mov	cx,*$1A
08799 270E           F7E9                       imul	cx
08800 2710           89C3                       mov	bx,ax
08801                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08802                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08803 2712           81C3                 0143  add	bx,#$143
08804 2716           53                         push	bx
08805                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
08806 2717           FF76         FE            push	-2[bp]
08807                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08808 271A           E8         DEE1            call	_read_byte
08809 271D           83C4                   04  add	sp,*4
08810                                           ! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
08811 2720           3C                     05  cmp	al,*5
08812 2722           75           17            jne 	.1E8
08813                       00002724            .1E9:
08814                                           ! 1677             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
08815                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
08816 2724           8A86       FDE5            mov	al,-$21B[bp]
08817 2728           30E4                       xor	ah,ah
08818 272A           50                         push	ax
08819                                           ! Debug: list * char = .1EA+0 (used reg = )
08820 272B           BB                   D986  mov	bx,#.1EA
08821 272E           53                         push	bx
08822                                           ! Debug: list int = const 2 (used reg = )
08823 272F           B8                   0002  mov	ax,*2
08824 2732           50                         push	ax
08825                                           ! Debug: func () void = bios_printf+0 (used reg = )
08826 2733           E8         E173            call	_bios_printf
08827 2736           83C4                   06  add	sp,*6
08828                                           !BCC_EOS
08829                                           ! 1678           else
08830                                           ! 1679             bios_printf(2, " ATAPI-%d Device\n",version);
08831 2739           EB           15            jmp .1EB
08832                       0000273B            .1E8:
08833                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
08834 273B           8A86       FDE5            mov	al,-$21B[bp]
08835 273F           30E4                       xor	ah,ah
08836 2741           50                         push	ax
08837                                           ! Debug: list * char = .1EC+0 (used reg = )
08838 2742           BB                   D974  mov	bx,#.1EC
08839 2745           53                         push	bx
08840                                           ! Debug: list int = const 2 (used reg = )
08841 2746           B8                   0002  mov	ax,*2
08842 2749           50                         push	ax
08843                                           ! Debug: func () void = bios_printf+0 (used reg = )
08844 274A           E8         E15C            call	_bios_printf
08845 274D           83C4                   06  add	sp,*6
08846                                           !BCC_EOS
08847                                           ! 1680           break;
08848                       00002750            .1EB:
08849 2750           EB           3A            jmp .1C8
08850                                           !BCC_EOS
08851                                           ! 1681         case 0x01:
08852                                           ! 1682           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
08853                       00002752            .1ED:
08854 2752           8A86       FDF4            mov	al,-$20C[bp]
08855 2756           84C0                       test	al,al
08856 2758           74           05            je  	.1F1
08857                       0000275A            .1F2:
08858 275A           BB                   D953  mov	bx,#.1EF
08859 275D           EB           03            jmp .1F3
08860                       0000275F            .1F1:
08861 275F           BB                   D94C  mov	bx,#.1F0
08862                       00002762            .1F3:
08863                                           ! Debug: list * char = bx+0 (used reg = )
08864 2762           53                         push	bx
08865                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
08866 2763           8A86       FDF5            mov	al,-$20B[bp]
08867 2767           30E4                       xor	ah,ah
08868 2769           50                         push	ax
08869                                           ! Debug: list * char = .1EE+0 (used reg = )
08870 276A           BB                   D95A  mov	bx,#.1EE
08871 276D           53                         push	bx
08872                                           ! Debug: list int = const 2 (used reg = )
08873 276E           B8                   0002  mov	ax,*2
08874 2771           50                         push	ax
08875                                           ! Debug: func () void = bios_printf+0 (used reg = )
08876 2772           E8         E134            call	_bios_printf
08877 2775           83C4                   08  add	sp,*8
08878                                           !BCC_EOS
08879                                           ! 1683           break;
08880 2778           EB           12            jmp .1C8
08881                                           !BCC_EOS
08882                                           ! 1684         }
08883                                           ! 1685       }
08884 277A           EB           10            jmp .1C8
08885                       0000277C            .1CA:
08886 277C           2C                     01  sub	al,*1
08887 277E           74           D2            je 	.1ED
08888 2780           2C                     01  sub	al,*1
08889 2782         0F84         FE54            beq 	.1CB
08890 2786           2C                     01  sub	al,*1
08891 2788         0F84         FF10            beq 	.1DC
08892                       0000278C            .1C8:
08893                       FFFFFDBA            ..FFF9	=	-$246
08894 278C           83C4                   32  add	sp,*$32
08895                                           ! 1686     }
08896 278F           83C4                   0C  add	sp,*$C
08897                                           ! 1687   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
08898                       00002792            .151:
08899                                           ! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
08900 2792           8A46         FB            mov	al,-5[bp]
08901 2795           40                         inc	ax
08902 2796           8846         FB            mov	-5[bp],al
08903                       00002799            .152:
08904                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
08905 2799           8A46         FB            mov	al,-5[bp]
08906 279C           3C                     08  cmp	al,*8
08907 279E         0F82         F367            blo 	.153
08908                       000027A2            .1F4:
08909                       000027A2            .150:
08910                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
08911 27A2           8A46         FD            mov	al,-3[bp]
08912 27A5           30E4                       xor	ah,ah
08913 27A7           50                         push	ax
08914                                           ! Debug: list * unsigned char = const $212 (used reg = )
08915 27A8           B8                   0212  mov	ax,#$212
08916 27AB           50                         push	ax
08917                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
08918 27AC           FF76         FE            push	-2[bp]
08919                                           ! Debug: func () void = write_byte+0 (used reg = )
08920 27AF           E8         DE72            call	_write_byte
08921 27B2           83C4                   06  add	sp,*6
08922                                           !BCC_EOS
08923                                           ! 1688   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
08924                                           ! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
08925 27B5           8A46         FC            mov	al,-4[bp]
08926 27B8           30E4                       xor	ah,ah
08927 27BA           50                         push	ax
08928                                           ! Debug: list * unsigned char = const $21B (used reg = )
08929 27BB           B8                   021B  mov	ax,#$21B
08930 27BE           50                         push	ax
08931                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
08932 27BF           FF76         FE            push	-2[bp]
08933                                           ! Debug: func () void = write_byte+0 (used reg = )
08934 27C2           E8         DE5F            call	_write_byte
08935 27C5           83C4                   06  add	sp,*6
08936                                           !BCC_EOS
08937                                           ! 1689   write_byte(0x40,0x75, hdcount);
08938                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
08939 27C8           8A46         FD            mov	al,-3[bp]
08940 27CB           30E4                       xor	ah,ah
08941 27CD           50                         push	ax
08942                                           ! Debug: list int = const $75 (used reg = )
08943 27CE           B8                   0075  mov	ax,*$75
08944 27D1           50                         push	ax
08945                                           ! Debug: list int = const $40 (used reg = )
08946 27D2           B8                   0040  mov	ax,*$40
08947 27D5           50                         push	ax
08948                                           ! Debug: func () void = write_byte+0 (used reg = )
08949 27D6           E8         DE4B            call	_write_byte
08950 27D9           83C4                   06  add	sp,*6
08951                                           !BCC_EOS
08952                                           ! 1690   bios_printf(2, "\n");
08953                                           ! Debug: list * char = .1F5+0 (used reg = )
08954 27DC           BB                   D94A  mov	bx,#.1F5
08955 27DF           53                         push	bx
08956                                           ! Debug: list int = const 2 (used reg = )
08957 27E0           B8                   0002  mov	ax,*2
08958 27E3           50                         push	ax
08959                                           ! Debug: func () void = bios_printf+0 (used reg = )
08960 27E4           E8         E0C2            call	_bios_printf
08961 27E7           83C4                   04  add	sp,*4
08962                                           !BCC_EOS
08963                                           ! 1691 }
08964 27EA           89EC                       mov	sp,bp
08965 27EC           5D                         pop	bp
08966 27ED           C3                         ret
08967                                           ! 1692 void ata_reset(device)
08968                                           ! Register BX used in function ata_detect
08969                                           ! 1693 Bit16u device;
08970                                           export	_ata_reset
08971                       000027EE            _ata_reset:
08972                                           !BCC_EOS
08973                                           ! 1694 {
08974                                           ! 1695   Bit16u ebda_seg=read_word(0x0040,0x000E);
08975 27EE           55                         push	bp
08976 27EF           89E5                       mov	bp,sp
08977 27F1           4C                         dec	sp
08978 27F2           4C                         dec	sp
08979                                           ! Debug: list int = const $E (used reg = )
08980 27F3           B8                   000E  mov	ax,*$E
08981 27F6           50                         push	ax
08982                                           ! Debug: list int = const $40 (used reg = )
08983 27F7           B8                   0040  mov	ax,*$40
08984 27FA           50                         push	ax
08985                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08986 27FB           E8         DE13            call	_read_word
08987 27FE           83C4                   04  add	sp,*4
08988                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
08989 2801           8946         FE            mov	-2[bp],ax
08990                                           !BCC_EOS
08991                                           ! 1696   Bit16u iobase1, iobase2;
08992                                           !BCC_EOS
08993                                           ! 1697   Bit8u channel, slave, sn, sc;
08994                                           !BCC_EOS
08995                                           ! 1698   Bit16u max;
08996                                           !BCC_EOS
08997                                           ! 1699   channel = device / 2;
08998 2804           83C4                   F6  add	sp,*-$A
08999                                           ! Debug: div int = const 2 to unsigned short device = [S+$E+2] (used reg = )
09000 2807           8B46         04            mov	ax,4[bp]
09001 280A           D1E8                       shr	ax,*1
09002                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$E-9] (used reg = )
09003 280C           8846         F9            mov	-7[bp],al
09004                                           !BCC_EOS
09005                                           ! 1700   slave = device % 2;
09006                                           ! Debug: mod int = const 2 to unsigned short device = [S+$E+2] (used reg = )
09007 280F           8B46         04            mov	ax,4[bp]
09008 2812           24                     01  and	al,*1
09009                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$E-$A] (used reg = )
09010 2814           8846         F8            mov	-8[bp],al
09011                                           !BCC_EOS
09012                                           ! 1701   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
09013                                           ! Debug: ptradd unsigned char channel = [S+$E-9] to [4] struct  = const $122 (used reg = )
09014 2817           8A46         F9            mov	al,-7[bp]
09015 281A           30E4                       xor	ah,ah
09016 281C           B1                     03  mov	cl,*3
09017 281E           D3E0                       shl	ax,cl
09018 2820           89C3                       mov	bx,ax
09019                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09020                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
09021 2822           81C3                 0124  add	bx,#$124
09022 2826           53                         push	bx
09023                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
09024 2827           FF76         FE            push	-2[bp]
09025                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09026 282A           E8         DDE4            call	_read_word
09027 282D           83C4                   04  add	sp,*4
09028                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$E-6] (used reg = )
09029 2830           8946         FC            mov	-4[bp],ax
09030                                           !BCC_EOS
09031                                           ! 1702   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
09032                                           ! Debug: ptradd unsigned char channel = [S+$E-9] to [4] struct  = const $122 (used reg = )
09033 2833           8A46         F9            mov	al,-7[bp]
09034 2836           30E4                       xor	ah,ah
09035 2838           B1                     03  mov	cl,*3
09036 283A           D3E0                       shl	ax,cl
09037 283C           89C3                       mov	bx,ax
09038                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09039                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
09040 283E           81C3                 0126  add	bx,#$126
09041 2842           53                         push	bx
09042                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
09043 2843           FF76         FE            push	-2[bp]
09044                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09045 2846           E8         DDC8            call	_read_word
09046 2849           83C4                   04  add	sp,*4
09047                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$E-8] (used reg = )
09048 284C           8946         FA            mov	-6[bp],ax
09049                                           !BCC_EOS
09050                                           ! 1703   outb(iobase2+6, 0x08 | 0x02 | 0x04);
09051                                           ! Debug: list int = const $E (used reg = )
09052 284F           B8                   000E  mov	ax,*$E
09053 2852           50                         push	ax
09054                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-8] (used reg = )
09055 2853           8B46         FA            mov	ax,-6[bp]
09056                                           ! Debug: list unsigned int = ax+6 (used reg = )
09057 2856           05                   0006  add	ax,*6
09058 2859           50                         push	ax
09059                                           ! Debug: func () void = outb+0 (used reg = )
09060 285A           E8         DD01            call	_outb
09061 285D           83C4                   04  add	sp,*4
09062                                           !BCC_EOS
09063                                           ! 1704   max=0xff;
09064                                           ! Debug: eq int = const $FF to unsigned short max = [S+$E-$E] (used reg = )
09065 2860           B8                   00FF  mov	ax,#$FF
09066 2863           8946         F4            mov	-$C[bp],ax
09067                                           !BCC_EOS
09068                                           ! 1705   while(--max>0) {
09069 2866           EB           20            jmp .1F7
09070                       00002868            .1F8:
09071                                           ! 1706     Bit8u status = inb(iobase1+7);
09072 2868           4C                         dec	sp
09073                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$F-6] (used reg = )
09074 2869           8B46         FC            mov	ax,-4[bp]
09075                                           ! Debug: list unsigned int = ax+7 (used reg = )
09076 286C           05                   0007  add	ax,*7
09077 286F           50                         push	ax
09078                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09079 2870           E8         DCD5            call	_inb
09080 2873           44                         inc	sp
09081 2874           44                         inc	sp
09082                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$F-$F] (used reg = )
09083 2875           8846         F3            mov	-$D[bp],al
09084                                           !BCC_EOS
09085                                           ! 1707     if ((status & 0x80) != 0) break;
09086 2878           4C                         dec	sp
09087                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$F] (used reg = )
09088 2879           8A46         F3            mov	al,-$D[bp]
09089 287C           24                     80  and	al,#$80
09090                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
09091 287E           84C0                       test	al,al
09092 2880           74           04            je  	.1F9
09093                       00002882            .1FA:
09094 2882           44                         inc	sp
09095 2883           44                         inc	sp
09096 2884           EB           0D            jmp .1F6
09097                                           !BCC_EOS
09098                                           ! 1708   }
09099                       00002886            .1F9:
09100 2886           44                         inc	sp
09101 2887           44                         inc	sp
09102                                           ! 1709   outb(iobase2+6, 0x08 | 0x02);
09103                       00002888            .1F7:
09104                                           ! Debug: predec unsigned short max = [S+$E-$E] (used reg = )
09105 2888           8B46         F4            mov	ax,-$C[bp]
09106 288B           48                         dec	ax
09107 288C           8946         F4            mov	-$C[bp],ax
09108                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
09109 288F           85C0                       test	ax,ax
09110 2891           75           D5            jne	.1F8
09111                       00002893            .1FB:
09112                       00002893            .1F6:
09113                                           ! Debug: list int = const $A (used reg = )
09114 2893           B8                   000A  mov	ax,*$A
09115 2896           50                         push	ax
09116                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-8] (used reg = )
09117 2897           8B46         FA            mov	ax,-6[bp]
09118                                           ! Debug: list unsigned int = ax+6 (used reg = )
09119 289A           05                   0006  add	ax,*6
09120 289D           50                         push	ax
09121                                           ! Debug: func () void = outb+0 (used reg = )
09122 289E           E8         DCBD            call	_outb
09123 28A1           83C4                   04  add	sp,*4
09124                                           !BCC_EOS
09125                                           ! 1710   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x00) {
09126                                           ! Debug: ptradd unsigned short device = [S+$E+2] to [8] struct  = const $142 (used reg = )
09127 28A4           8B46         04            mov	ax,4[bp]
09128 28A7           B9                   001A  mov	cx,*$1A
09129 28AA           F7E9                       imul	cx
09130 28AC           89C3                       mov	bx,ax
09131                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
09132                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
09133 28AE           81C3                 0142  add	bx,#$142
09134 28B2           53                         push	bx
09135                                           ! Debug: list unsigned short ebda_seg = [S+$10-4] (used reg = )
09136 28B3           FF76         FE            push	-2[bp]
09137                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09138 28B6           E8         DD45            call	_read_byte
09139 28B9           83C4                   04  add	sp,*4
09140                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
09141 28BC           84C0                       test	al,al
09142 28BE           74           7B            je  	.1FC
09143                       000028C0            .1FD:
09144                                           ! 1711     outb(iobase1+6, slave?0xb0:0xa0);
09145 28C0           8A46         F8            mov	al,-8[bp]
09146 28C3           84C0                       test	al,al
09147 28C5           74           04            je  	.1FE
09148                       000028C7            .1FF:
09149 28C7           B0                     B0  mov	al,#$B0
09150 28C9           EB           02            jmp .200
09151                       000028CB            .1FE:
09152 28CB           B0                     A0  mov	al,#$A0
09153                       000028CD            .200:
09154                                           ! Debug: list char = al+0 (used reg = )
09155 28CD           30E4                       xor	ah,ah
09156 28CF           50                         push	ax
09157                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$10-6] (used reg = )
09158 28D0           8B46         FC            mov	ax,-4[bp]
09159                                           ! Debug: list unsigned int = ax+6 (used reg = )
09160 28D3           05                   0006  add	ax,*6
09161 28D6           50                         push	ax
09162                                           ! Debug: func () void = outb+0 (used reg = )
09163 28D7           E8         DC84            call	_outb
09164 28DA           83C4                   04  add	sp,*4
09165                                           !BCC_EOS
09166                                           ! 1712     sc = inb(iobase1+2);
09167                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$E-6] (used reg = )
09168 28DD           8B46         FC            mov	ax,-4[bp]
09169                                           ! Debug: list unsigned int = ax+2 (used reg = )
09170 28E0           40                         inc	ax
09171 28E1           40                         inc	ax
09172 28E2           50                         push	ax
09173                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09174 28E3           E8         DC62            call	_inb
09175 28E6           44                         inc	sp
09176 28E7           44                         inc	sp
09177                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$E-$C] (used reg = )
09178 28E8           8846         F6            mov	-$A[bp],al
09179                                           !BCC_EOS
09180                                           ! 1713     sn = inb(iobase1+3);
09181                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$E-6] (used reg = )
09182 28EB           8B46         FC            mov	ax,-4[bp]
09183                                           ! Debug: list unsigned int = ax+3 (used reg = )
09184 28EE           05                   0003  add	ax,*3
09185 28F1           50                         push	ax
09186                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09187 28F2           E8         DC53            call	_inb
09188 28F5           44                         inc	sp
09189 28F6           44                         inc	sp
09190                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$E-$B] (used reg = )
09191 28F7           8846         F7            mov	-9[bp],al
09192                                           !BCC_EOS
09193                                           ! 1714     if ( (sc==0x01) && (sn==0x01) ) {
09194                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$E-$C] (used reg = )
09195 28FA           8A46         F6            mov	al,-$A[bp]
09196 28FD           3C                     01  cmp	al,*1
09197 28FF           75           3A            jne 	.201
09198                       00002901            .203:
09199                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$E-$B] (used reg = )
09200 2901           8A46         F7            mov	al,-9[bp]
09201 2904           3C                     01  cmp	al,*1
09202 2906           75           33            jne 	.201
09203                       00002908            .202:
09204                                           ! 1715       max=0xff;
09205                                           ! Debug: eq int = const $FF to unsigned short max = [S+$E-$E] (used reg = )
09206 2908           B8                   00FF  mov	ax,#$FF
09207 290B           8946         F4            mov	-$C[bp],ax
09208                                           !BCC_EOS
09209                                           ! 1716       while(--max>0) {
09210 290E           EB           20            jmp .205
09211                       00002910            .206:
09212                                           ! 1717         Bit8u status = inb(iobase1+7);
09213 2910           4C                         dec	sp
09214                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$F-6] (used reg = )
09215 2911           8B46         FC            mov	ax,-4[bp]
09216                                           ! Debug: list unsigned int = ax+7 (used reg = )
09217 2914           05                   0007  add	ax,*7
09218 2917           50                         push	ax
09219                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09220 2918           E8         DC2D            call	_inb
09221 291B           44                         inc	sp
09222 291C           44                         inc	sp
09223                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$F-$F] (used reg = )
09224 291D           8846         F3            mov	-$D[bp],al
09225                                           !BCC_EOS
09226                                           ! 1718         if ((status & 0x80) == 0) break;
09227 2920           4C                         dec	sp
09228                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$F] (used reg = )
09229 2921           8A46         F3            mov	al,-$D[bp]
09230 2924           24                     80  and	al,#$80
09231                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
09232 2926           84C0                       test	al,al
09233 2928           75           04            jne 	.207
09234                       0000292A            .208:
09235 292A           44                         inc	sp
09236 292B           44                         inc	sp
09237 292C           EB           0D            jmp .204
09238                                           !BCC_EOS
09239                                           ! 1719         }
09240                       0000292E            .207:
09241 292E           44                         inc	sp
09242 292F           44                         inc	sp
09243                                           ! 1720       }
09244                       00002930            .205:
09245                                           ! Debug: predec unsigned short max = [S+$E-$E] (used reg = )
09246 2930           8B46         F4            mov	ax,-$C[bp]
09247 2933           48                         dec	ax
09248 2934           8946         F4            mov	-$C[bp],ax
09249                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
09250 2937           85C0                       test	ax,ax
09251 2939           75           D5            jne	.206
09252                       0000293B            .209:
09253                       0000293B            .204:
09254                                           ! 1721     }
09255                       0000293B            .201:
09256                                           ! 1722   max=0xfff;
09257                       0000293B            .1FC:
09258                                           ! Debug: eq int = const $FFF to unsigned short max = [S+$E-$E] (used reg = )
09259 293B           B8                   0FFF  mov	ax,#$FFF
09260 293E           8946         F4            mov	-$C[bp],ax
09261                                           !BCC_EOS
09262                                           ! 1723   while(--max>0) {
09263 2941           EB           20            jmp .20B
09264                       00002943            .20C:
09265                                           ! 1724     Bit8u statu
09266                                           ! 1724 s = inb(iobase1+7);
09267 2943           4C                         dec	sp
09268                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$F-6] (used reg = )
09269 2944           8B46         FC            mov	ax,-4[bp]
09270                                           ! Debug: list unsigned int = ax+7 (used reg = )
09271 2947           05                   0007  add	ax,*7
09272 294A           50                         push	ax
09273                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09274 294B           E8         DBFA            call	_inb
09275 294E           44                         inc	sp
09276 294F           44                         inc	sp
09277                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$F-$F] (used reg = )
09278 2950           8846         F3            mov	-$D[bp],al
09279                                           !BCC_EOS
09280                                           ! 1725       if ((status & 0x40) != 0) break;
09281 2953           4C                         dec	sp
09282                                           ! Debug: and int = const $40 to unsigned char status = [S+$10-$F] (used reg = )
09283 2954           8A46         F3            mov	al,-$D[bp]
09284 2957           24                     40  and	al,*$40
09285                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
09286 2959           84C0                       test	al,al
09287 295B           74           04            je  	.20D
09288                       0000295D            .20E:
09289 295D           44                         inc	sp
09290 295E           44                         inc	sp
09291 295F           EB           0D            jmp .20A
09292                                           !BCC_EOS
09293                                           ! 1726   }
09294                       00002961            .20D:
09295 2961           44                         inc	sp
09296 2962           44                         inc	sp
09297                                           ! 1727   outb(iobase2+6, 0x08);
09298                       00002963            .20B:
09299                                           ! Debug: predec unsigned short max = [S+$E-$E] (used reg = )
09300 2963           8B46         F4            mov	ax,-$C[bp]
09301 2966           48                         dec	ax
09302 2967           8946         F4            mov	-$C[bp],ax
09303                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
09304 296A           85C0                       test	ax,ax
09305 296C           75           D5            jne	.20C
09306                       0000296E            .20F:
09307                       0000296E            .20A:
09308                                           ! Debug: list int = const 8 (used reg = )
09309 296E           B8                   0008  mov	ax,*8
09310 2971           50                         push	ax
09311                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$10-8] (used reg = )
09312 2972           8B46         FA            mov	ax,-6[bp]
09313                                           ! Debug: list unsigned int = ax+6 (used reg = )
09314 2975           05                   0006  add	ax,*6
09315 2978           50                         push	ax
09316                                           ! Debug: func () void = outb+0 (used reg = )
09317 2979           E8         DBE2            call	_outb
09318 297C           83C4                   04  add	sp,*4
09319                                           !BCC_EOS
09320                                           ! 1728 }
09321 297F           89EC                       mov	sp,bp
09322 2981           5D                         pop	bp
09323 2982           C3                         ret
09324                                           ! 1729 Bit16u ata_cmd_non_data()
09325                                           ! Register BX used in function ata_reset
09326                                           ! 1730 {return 0;}
09327                                           export	_ata_cmd_non_data
09328                       00002983            _ata_cmd_non_data:
09329 2983           55                         push	bp
09330 2984           89E5                       mov	bp,sp
09331 2986           31C0                       xor	ax,ax
09332 2988           5D                         pop	bp
09333 2989           C3                         ret
09334                                           !BCC_EOS
09335                                           ! 1731 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba, segment, offset)
09336                                           ! 1732 Bit16u device, command, count, cylinder, head, sector, segment, offset;
09337                                           export	_ata_cmd_data_in
09338                       0000298A            _ata_cmd_data_in:
09339                                           !BCC_EOS
09340                                           ! 1733 Bit32u lba;
09341                                           !BCC_EOS
09342                                           ! 1734 {
09343                                           ! 1735   Bit16u ebda_seg=read_word(0x0040,0x000E);
09344 298A           55                         push	bp
09345 298B           89E5                       mov	bp,sp
09346 298D           4C                         dec	sp
09347 298E           4C                         dec	sp
09348                                           ! Debug: list int = const $E (used reg = )
09349 298F           B8                   000E  mov	ax,*$E
09350 2992           50                         push	ax
09351                                           ! Debug: list int = const $40 (used reg = )
09352 2993           B8                   0040  mov	ax,*$40
09353 2996           50                         push	ax
09354                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09355 2997           E8         DC77            call	_read_word
09356 299A           83C4                   04  add	sp,*4
09357                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
09358 299D           8946         FE            mov	-2[bp],ax
09359                                           !BCC_EOS
09360                                           ! 1736   Bit16u iobase1, iobase2, blksize;
09361                                           !BCC_EOS
09362                                           ! 1737   Bit8u channel, slave;
09363                                           !BCC_EOS
09364                                           ! 1738   Bit8u status, current, mode;
09365                                           !BCC_EOS
09366                                           ! 1739   channel = device / 2;
09367 29A0           83C4                   F4  add	sp,*-$C
09368                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
09369 29A3           8B46         04            mov	ax,4[bp]
09370 29A6           D1E8                       shr	ax,*1
09371                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
09372 29A8           8846         F7            mov	-9[bp],al
09373                                           !BCC_EOS
09374                                           ! 1740   slave = device % 2;
09375                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
09376 29AB           8B46         04            mov	ax,4[bp]
09377 29AE           24                     01  and	al,*1
09378                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
09379 29B0           8846         F6            mov	-$A[bp],al
09380                                           !BCC_EOS
09381                                           ! 1741   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
09382                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
09383 29B3           8A46         F7            mov	al,-9[bp]
09384 29B6           30E4                       xor	ah,ah
09385 29B8           B1                     03  mov	cl,*3
09386 29BA           D3E0                       shl	ax,cl
09387 29BC           89C3                       mov	bx,ax
09388                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
09389                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
09390 29BE           81C3                 0124  add	bx,#$124
09391 29C2           53                         push	bx
09392                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
09393 29C3           FF76         FE            push	-2[bp]
09394                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09395 29C6           E8         DC48            call	_read_word
09396 29C9           83C4                   04  add	sp,*4
09397                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
09398 29CC           8946         FC            mov	-4[bp],ax
09399                                           !BCC_EOS
09400                                           ! 1742   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
09401                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
09402 29CF           8A46         F7            mov	al,-9[bp]
09403 29D2           30E4                       xor	ah,ah
09404 29D4           B1                     03  mov	cl,*3
09405 29D6           D3E0                       shl	ax,cl
09406 29D8           89C3                       mov	bx,ax
09407                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
09408                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
09409 29DA           81C3                 0126  add	bx,#$126
09410 29DE           53                         push	bx
09411                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
09412 29DF           FF76         FE            push	-2[bp]
09413                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
09414 29E2           E8         DC2C            call	_read_word
09415 29E5           83C4                   04  add	sp,*4
09416                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
09417 29E8           8946         FA            mov	-6[bp],ax
09418                                           !BCC_EOS
09419                                           ! 1743   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
09420                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
09421 29EB           8B46         04            mov	ax,4[bp]
09422 29EE           B9                   001A  mov	cx,*$1A
09423 29F1           F7E9                       imul	cx
09424 29F3           89C3                       mov	bx,ax
09425                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09426                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
09427 29F5           81C3                 0146  add	bx,#$146
09428 29F9           53                         push	bx
09429                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
09430 29FA           FF76         FE            push	-2[bp]
09431                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09432 29FD           E8         DBFE            call	_read_byte
09433 2A00           83C4                   04  add	sp,*4
09434                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
09435 2A03           8846         F3            mov	-$D[bp],al
09436                                           !BCC_EOS
09437                                           ! 1744   blksize = 0x200;
09438                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
09439 2A06           B8                   0200  mov	ax,#$200
09440 2A09           8946         F8            mov	-8[bp],ax
09441                                           !BCC_EOS
09442                                           ! 1745   if (mode == 0x01) blksize>>=2;
09443                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
09444 2A0C           8A46         F3            mov	al,-$D[bp]
09445 2A0F           3C                     01  cmp	al,*1
09446 2A11           75           0C            jne 	.210
09447                       00002A13            .211:
09448                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
09449 2A13           8B46         F8            mov	ax,-8[bp]
09450 2A16           D1E8                       shr	ax,*1
09451 2A18           D1E8                       shr	ax,*1
09452 2A1A           8946         F8            mov	-8[bp],ax
09453                                           !BCC_EOS
09454                                           ! 1746   else blksize>>=1;
09455 2A1D           EB           08            jmp .212
09456                       00002A1F            .210:
09457                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
09458 2A1F           8B46         F8            mov	ax,-8[bp]
09459 2A22           D1E8                       shr	ax,*1
09460 2A24           8946         F8            mov	-8[bp],ax
09461                                           !BCC_EOS
09462                                           ! 1747   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
09463                       00002A27            .212:
09464                                           ! Debug: list int = const 0 (used reg = )
09465 2A27           31C0                       xor	ax,ax
09466 2A29           50                         push	ax
09467                                           ! Debug: list * unsigned short = const $234 (used reg = )
09468 2A2A           B8                   0234  mov	ax,#$234
09469 2A2D           50                         push	ax
09470                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
09471 2A2E           FF76         FE            push	-2[bp]
09472                                           ! Debug: func () void = write_word+0 (used reg = )
09473 2A31           E8         DC08            call	_write_word
09474 2A34           83C4                   06  add	sp,*6
09475                                           !BCC_EOS
09476                                           ! 1748   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
09477                                           ! Debug: list long = const 0 (used reg = )
09478 2A37           31C0                       xor	ax,ax
09479 2A39           31DB                       xor	bx,bx
09480 2A3B           53                         push	bx
09481 2A3C           50                         push	ax
09482                                           ! Debug: list * unsigned long = const $236 (used reg = )
09483 2A3D           B8                   0236  mov	ax,#$236
09484 2A40           50                         push	ax
09485                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
09486 2A41           FF76         FE            push	-2[bp]
09487                                           ! Debug: func () void = write_dword+0 (used reg = )
09488 2A44           E8         D625            call	_write_dword
09489 2A47           83C4                   08  add	sp,*8
09490                                           !BCC_EOS
09491                                           ! 1749   current = 0;
09492                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
09493 2A4A           30C0                       xor	al,al
09494 2A4C           8846         F4            mov	-$C[bp],al
09495                                           !BCC_EOS
09496                                           ! 1750   status = inb(iobase1 + 7);
09497                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
09498 2A4F           8B46         FC            mov	ax,-4[bp]
09499                                           ! Debug: list unsigned int = ax+7 (used reg = )
09500 2A52           05                   0007  add	ax,*7
09501 2A55           50                         push	ax
09502                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09503 2A56           E8         DAEF            call	_inb
09504 2A59           44                         inc	sp
09505 2A5A           44                         inc	sp
09506                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
09507 2A5B           8846         F5            mov	-$B[bp],al
09508                                           !BCC_EOS
09509                                           ! 1751   if (status & 0x80) return 1;
09510                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
09511 2A5E           8A46         F5            mov	al,-$B[bp]
09512 2A61           24                     80  and	al,#$80
09513 2A63           84C0                       test	al,al
09514 2A65           74           07            je  	.213
09515                       00002A67            .214:
09516 2A67           B8                   0001  mov	ax,*1
09517 2A6A           89EC                       mov	sp,bp
09518 2A6C           5D                         pop	bp
09519 2A6D           C3                         ret
09520                                           !BCC_EOS
09521                                           ! 1752   outb(iobase2 + 6, 0x08 | 0x02);
09522                       00002A6E            .213:
09523                                           ! Debug: list int = const $A (used reg = )
09524 2A6E           B8                   000A  mov	ax,*$A
09525 2A71           50                         push	ax
09526                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
09527 2A72           8B46         FA            mov	ax,-6[bp]
09528                                           ! Debug: list unsigned int = ax+6 (used reg = )
09529 2A75           05                   0006  add	ax,*6
09530 2A78           50                         push	ax
09531                                           ! Debug: func () void = outb+0 (used reg = )
09532 2A79           E8         DAE2            call	_outb
09533 2A7C           83C4                   04  add	sp,*4
09534                                           !BCC_EOS
09535                                           ! 1753   if (sector == 0) {
09536                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
09537 2A7F           8B46         0E            mov	ax,$E[bp]
09538 2A82           85C0                       test	ax,ax
09539 2A84         0F85         0123            bne 	.215
09540                       00002A88            .216:
09541                                           ! 1754     if ((count >= 1 << 8) || (lba + count >= 1UL << 28)) {
09542                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
09543 2A88           8B46         08            mov	ax,8[bp]
09544 2A8B           3D                   0100  cmp	ax,#$100
09545 2A8E           73           27            jae 	.218
09546                       00002A90            .219:
09547                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
09548 2A90           8B46         08            mov	ax,8[bp]
09549 2A93           31DB                       xor	bx,bx
09550                                           ! Debug: add unsigned long = bx+0 to unsigned long lba = [S+$10+$E] (used reg = )
09551                                           ! Debug: expression subtree swapping
09552 2A95           8D7E         10            lea	di,$10[bp]
09553 2A98           E8         D5F8            call	laddul
09554                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
09555 2A9B           53                         push	bx
09556 2A9C           50                         push	ax
09557 2A9D           31C0                       xor	ax,ax
09558 2A9F           BB                   1000  mov	bx,#$1000
09559 2AA2           53                         push	bx
09560 2AA3           50                         push	ax
09561 2AA4           8B46         EE            mov	ax,-$12[bp]
09562 2AA7           8B5E         F0            mov	bx,-$10[bp]
09563 2AAA           8D7E         EA            lea	di,-$16[bp]
09564 2AAD           E8         D5EB            call	lcmpul
09565 2AB0           8D66         F2            lea	sp,-$E[bp]
09566 2AB3         0F82         00A5            blo 	.217
09567                       00002AB7            .218:
09568                                           ! 1755       outb(iobase1 + 1, 0x00);
09569                                           ! Debug: list int = const 0 (used reg = )
09570 2AB7           31C0                       xor	ax,ax
09571 2AB9           50                         push	ax
09572                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
09573 2ABA           8B46         FC            mov	ax,-4[bp]
09574                                           ! Debug: list unsigned int = ax+1 (used reg = )
09575 2ABD           40                         inc	ax
09576 2ABE           50                         push	ax
09577                                           ! Debug: func () void = outb+0 (used reg = )
09578 2ABF           E8         DA9C            call	_outb
09579 2AC2           83C4                   04  add	sp,*4
09580                                           !BCC_EOS
09581                                           ! 1756       outb(iobase1 + 2, (count >> 8) & 0xff);
09582                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
09583 2AC5           8B46         08            mov	ax,8[bp]
09584 2AC8           88E0                       mov	al,ah
09585 2ACA           30E4                       xor	ah,ah
09586                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
09587                                           ! Debug: list unsigned char = al+0 (used reg = )
09588 2ACC           30E4                       xor	ah,ah
09589 2ACE           50                         push	ax
09590                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
09591 2ACF           8B46         FC            mov	ax,-4[bp]
09592                                           ! Debug: list unsigned int = ax+2 (used reg = )
09593 2AD2           40                         inc	ax
09594 2AD3           40                         inc	ax
09595 2AD4           50                         push	ax
09596                                           ! Debug: func () void = outb+0 (used reg = )
09597 2AD5           E8         DA86            call	_outb
09598 2AD8           83C4                   04  add	sp,*4
09599                                           !BCC_EOS
09600                                           ! 1757       outb(iobase1 + 3, lba >> 24);
09601                                           ! Debug: sr int = const $18 to unsigned long lba = [S+$10+$E] (used reg = )
09602 2ADB           8B46         10            mov	ax,$10[bp]
09603 2ADE           8B5E         12            mov	bx,$12[bp]
09604 2AE1           93                         xchg	bx,ax
09605 2AE2           88E0                       mov	al,ah
09606 2AE4           30E4                       xor	ah,ah
09607 2AE6           31DB                       xor	bx,bx
09608                                           ! Debug: list unsigned long = bx+0 (used reg = )
09609 2AE8           53                         push	bx
09610 2AE9           50                         push	ax
09611                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
09612 2AEA           8B46         FC            mov	ax,-4[bp]
09613                                           ! Debug: list unsigned int = ax+3 (used reg = )
09614 2AED           05                   0003  add	ax,*3
09615 2AF0           50                         push	ax
09616                                           ! Debug: func () void = outb+0 (used reg = )
09617 2AF1           E8         DA6A            call	_outb
09618 2AF4           83C4                   06  add	sp,*6
09619                                           !BCC_EOS
09620                                           ! 1758       outb(iobase1 + 4, 0);
09621                                           ! Debug: list int = const 0 (used reg = )
09622 2AF7           31C0                       xor	ax,ax
09623 2AF9           50                         push	ax
09624                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
09625 2AFA           8B46         FC            mov	ax,-4[bp]
09626                                           ! Debug: list unsigned int = ax+4 (used reg = )
09627 2AFD           05                   0004  add	ax,*4
09628 2B00           50                         push	ax
09629                                           ! Debug: func () void = outb+0 (used reg = )
09630 2B01           E8         DA5A            call	_outb
09631 2B04           83C4                   04  add	sp,*4
09632                                           !BCC_EOS
09633                                           ! 1759       outb(iobase1 + 5, 0);
09634                                           ! Debug: list int = const 0 (used reg = )
09635 2B07           31C0                       xor	ax,ax
09636 2B09           50                         push	ax
09637                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
09638 2B0A           8B46         FC            mov	ax,-4[bp]
09639                                           ! Debug: list unsigned int = ax+5 (used reg = )
09640 2B0D           05                   0005  add	ax,*5
09641 2B10           50                         push	ax
09642                                           ! Debug: func () void = outb+0 (used reg = )
09643 2B11           E8         DA4A            call	_outb
09644 2B14           83C4                   04  add	sp,*4
09645                                           !BCC_EOS
09646                                           ! 1760       command |= 0x04;
09647                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
09648 2B17           8B46         06            mov	ax,6[bp]
09649 2B1A           0C                     04  or	al,*4
09650 2B1C           8946         06            mov	6[bp],ax
09651                                           !BCC_EOS
09652                                           ! 1761       count &= (1UL << 8) - 1;
09653                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
09654 2B1F           8B46         08            mov	ax,8[bp]
09655 2B22           31DB                       xor	bx,bx
09656 2B24           53                         push	bx
09657 2B25           50                         push	ax
09658 2B26           B8                   00FF  mov	ax,#$FF
09659 2B29           31DB                       xor	bx,bx
09660 2B2B           53                         push	bx
09661 2B2C           50                         push	ax
09662 2B2D           8B46         EE            mov	ax,-$12[bp]
09663 2B30           8B5E         F0            mov	bx,-$10[bp]
09664 2B33           8D7E         EA            lea	di,-$16[bp]
09665 2B36           E8         D552            call	landul
09666 2B39           8946         08            mov	8[bp],ax
09667 2B3C           83C4                   08  add	sp,*8
09668                                           !BCC_EOS
09669                                           ! 1762       lba &= (1UL << 24) - 1;
09670                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba = [S+$10+$E] (used reg = )
09671 2B3F           B8                   FFFF  mov	ax,#$FFFF
09672 2B42           BB                   00FF  mov	bx,#$FF
09673 2B45           53                         push	bx
09674 2B46           50                         push	ax
09675 2B47           8B46         10            mov	ax,$10[bp]
09676 2B4A           8B5E         12            mov	bx,$12[bp]
09677 2B4D           8D7E         EE            lea	di,-$12[bp]
09678 2B50           E8         D538            call	landul
09679 2B53           8946         10            mov	$10[bp],ax
09680 2B56           895E         12            mov	$12[bp],bx
09681 2B59           83C4                   04  add	sp,*4
09682                                           !BCC_EOS
09683                                           ! 1763       }
09684                                           ! 1764     sector = (Bit16u) (lba & 0x000000ffL);
09685                       00002B5C            .217:
09686                                           ! Debug: and long = const $FF to unsigned long lba = [S+$10+$E] (used reg = )
09687                                           ! Debug: expression subtree swapping
09688 2B5C           B8                   00FF  mov	ax,#$FF
09689 2B5F           31DB                       xor	bx,bx
09690 2B61           8D7E         10            lea	di,$10[bp]
09691 2B64           E8         D524            call	landul
09692                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09693                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
09694 2B67           8946         0E            mov	$E[bp],ax
09695                                           !BCC_EOS
09696                                           ! 1765     lba >>= 8;
09697                                           ! Debug: srab int = const 8 to unsigned long lba = [S+$10+$E] (used reg = )
09698 2B6A           8B46         10            mov	ax,$10[bp]
09699 2B6D           8B5E         12            mov	bx,$12[bp]
09700 2B70           88E0                       mov	al,ah
09701 2B72           88DC                       mov	ah,bl
09702 2B74           88FB                       mov	bl,bh
09703 2B76           28FF                       sub	bh,bh
09704 2B78           8946         10            mov	$10[bp],ax
09705 2B7B           895E         12            mov	$12[bp],bx
09706                                           !BCC_EOS
09707                                           ! 1766     cylinder = (Bit16u) (lba & 0x0000ffffL);
09708                                           ! Debug: and long = const $FFFF to unsigned long lba = [S+$10+$E] (used reg = )
09709                                           ! Debug: expression subtree swapping
09710 2B7E           B8                   FFFF  mov	ax,#$FFFF
09711 2B81           31DB                       xor	bx,bx
09712 2B83           8D7E         10            lea	di,$10[bp]
09713 2B86           E8         D502            call	landul
09714                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09715                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
09716 2B89           8946         0A            mov	$A[bp],ax
09717                                           !BCC_EOS
09718                                           ! 1767     lba >>= 16;
09719                                           ! Debug: srab int = const $10 to unsigned long lba = [S+$10+$E] (used reg = )
09720 2B8C           8B46         10            mov	ax,$10[bp]
09721 2B8F           8B5E         12            mov	bx,$12[bp]
09722 2B92           93                         xchg	bx,ax
09723 2B93           31DB                       xor	bx,bx
09724 2B95           8946         10            mov	$10[bp],ax
09725 2B98           895E         12            mov	$12[bp],bx
09726                                           !BCC_EOS
09727                                           ! 1768     head = ((Bit16u) (lba & 0x0000000fL)) | 0x40;
09728                                           ! Debug: and long = const $F to unsigned long lba = [S+$10+$E] (used reg = )
09729                                           ! Debug: expression subtree swapping
09730 2B9B           B8                   000F  mov	ax,*$F
09731 2B9E           31DB                       xor	bx,bx
09732 2BA0           8D7E         10            lea	di,$10[bp]
09733 2BA3           E8         D4E5            call	landul
09734                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09735                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
09736 2BA6           0C                     40  or	al,*$40
09737                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
09738 2BA8           8946         0C            mov	$C[bp],ax
09739                                           !BCC_EOS
09740                                           ! 1769     }
09741                                           ! 1770   outb(iobase1 + 1, 0x00);
09742                       00002BAB            .215:
09743                                           ! Debug: list int = const 0 (used reg = )
09744 2BAB           31C0                       xor	ax,ax
09745 2BAD           50                         push	ax
09746                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
09747 2BAE           8B46         FC            mov	ax,-4[bp]
09748                                           ! Debug: list unsigned int = ax+1 (used reg = )
09749 2BB1           40                         inc	ax
09750 2BB2           50                         push	ax
09751                                           ! Debug: func () void = outb+0 (used reg = )
09752 2BB3           E8         D9A8            call	_outb
09753 2BB6           83C4                   04  add	sp,*4
09754                                           !BCC_EOS
09755                                           ! 1771   outb(iobase1 + 2, count);
09756                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
09757 2BB9           FF76         08            push	8[bp]
09758                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
09759 2BBC           8B46         FC            mov	ax,-4[bp]
09760                                           ! Debug: list unsigned int = ax+2 (used reg = )
09761 2BBF           40                         inc	ax
09762 2BC0           40                         inc	ax
09763 2BC1           50                         push	ax
09764                                           ! Debug: func () void = outb+0 (used reg = )
09765 2BC2           E8         D999            call	_outb
09766 2BC5           83C4                   04  add	sp,*4
09767                                           !BCC_EOS
09768                                           ! 1772   outb(iobase1 + 3, sector);
09769                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
09770 2BC8           FF76         0E            push	$E[bp]
09771                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
09772 2BCB           8B46         FC            mov	ax,-4[bp]
09773                                           ! Debug: list unsigned int = ax+3 (used reg = )
09774 2BCE           05                   0003  add	ax,*3
09775 2BD1           50                         push	ax
09776                                           ! Debug: func () void = outb+0 (used reg = )
09777 2BD2           E8         D989            call	_outb
09778 2BD5           83C4                   04  add	sp,*4
09779                                           !BCC_EOS
09780                                           ! 1773   outb(iobase1 + 4, cylinder & 0x00ff);
09781                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
09782 2BD8           8A46         0A            mov	al,$A[bp]
09783                                           ! Debug: list unsigned char = al+0 (used reg = )
09784 2BDB           30E4                       xor	ah,ah
09785 2BDD           50                         push	ax
09786                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
09787 2BDE           8B46         FC            mov	ax,-4[bp]
09788                                           ! Debug: list unsigned int = ax+4 (used reg = )
09789 2BE1           05                   0004  add	ax,*4
09790 2BE4           50                         push	ax
09791                                           ! Debug: func () void = outb+0 (used reg = )
09792 2BE5           E8         D976            call	_outb
09793 2BE8           83C4                   04  add	sp,*4
09794                                           !BCC_EOS
09795                                           ! 1774   outb(iobase1 + 5, cylinder >> 8);
09796                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
09797 2BEB           8B46         0A            mov	ax,$A[bp]
09798 2BEE           88E0                       mov	al,ah
09799 2BF0           30E4                       xor	ah,ah
09800                                           ! Debug: list unsigned int = ax+0 (used reg = )
09801 2BF2           50                         push	ax
09802                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
09803 2BF3           8B46         FC            mov	ax,-4[bp]
09804                                           ! Debug: list unsigned int = ax+5 (used reg = )
09805 2BF6           05                   0005  add	ax,*5
09806 2BF9           50                         push	ax
09807                                           ! Debug: func () void = outb+0 (used reg = )
09808 2BFA           E8         D961            call	_outb
09809 2BFD           83C4                   04  add	sp,*4
09810                                           !BCC_EOS
09811                                           ! 1775   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
09812 2C00           8A46         F6            mov	al,-$A[bp]
09813 2C03           84C0                       test	al,al
09814 2C05           74           04            je  	.21A
09815                       00002C07            .21B:
09816 2C07           B0                     B0  mov	al,#$B0
09817 2C09           EB           02            jmp .21C
09818                       00002C0B            .21A:
09819 2C0B           B0                     A0  mov	al,#$A0
09820                       00002C0D            .21C:
09821                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
09822 2C0D           0A46         0C            or	al,$C[bp]
09823                                           ! Debug: list unsigned char = al+0 (used reg = )
09824 2C10           30E4                       xor	ah,ah
09825 2C12           50                         push	ax
09826                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
09827 2C13           8B46         FC            mov	ax,-4[bp]
09828                                           ! Debug: list unsigned int = ax+6 (used reg = )
09829 2C16           05                   0006  add	ax,*6
09830 2C19           50                         push	ax
09831                                           ! Debug: func () void = outb+0 (used reg = )
09832 2C1A           E8         D941            call	_outb
09833 2C1D           83C4                   04  add	sp,*4
09834                                           !BCC_EOS
09835                                           ! 1776   outb(iobase1 + 7, command);
09836                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
09837 2C20           FF76         06            push	6[bp]
09838                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
09839 2C23           8B46         FC            mov	ax,-4[bp]
09840                                           ! Debug: list unsigned int = ax+7 (used reg = )
09841 2C26           05                   0007  add	ax,*7
09842 2C29           50                         push	ax
09843                                           ! Debug: func () void = outb+0 (used reg = )
09844 2C2A           E8         D931            call	_outb
09845 2C2D           83C4                   04  add	sp,*4
09846                                           !BCC_EOS
09847                                           ! 1777   while (1) {
09848                       00002C30            .21F:
09849                                           ! 1778     status = inb(iobase1 + 7);
09850                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
09851 2C30           8B46         FC            mov	ax,-4[bp]
09852                                           ! Debug: list unsigned int = ax+7 (used reg = )
09853 2C33           05                   0007  add	ax,*7
09854 2C36           50                         push	ax
09855                                           ! Debug: func () unsigned char = inb+0 (used reg = )
09856 2C37           E8         D90E            call	_inb
09857 2C3A           44                         inc	sp
09858 2C3B           44                         inc	sp
09859                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
09860 2C3C           8846         F5            mov	-$B[bp],al
09861                                           !BCC_EOS
09862                                           ! 1779     if ( !(status & 0x80) ) break;
09863                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
09864 2C3F           8A46         F5            mov	al,-$B[bp]
09865 2C42           24                     80  and	al,#$80
09866 2C44           84C0                       test	al,al
09867 2C46           75           02            jne 	.220
09868                       00002C48            .221:
09869 2C48           EB           02            jmp .21D
09870                                           !BCC_EOS
09871                                           ! 1780     }
09872                       00002C4A            .220:
09873                                           ! 1781   if (status & 0x01) {
09874                       00002C4A            .21E:
09875 2C4A           EB           E4            jmp	.21F
09876                       00002C4C            .222:
09877                       00002C4C            .21D:
09878                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
09879 2C4C           8A46         F5            mov	al,-$B[bp]
09880 2C4F           24                     01  and	al,*1
09881 2C51           84C0                       test	al,al
09882 2C53           74           09            je  	.223
09883                       00002C55            .224:
09884                                           ! 1782     ;
09885                                           !BCC_EOS
09886                                           ! 1783     return 2;
09887 2C55           B8                   0002  mov	ax,*2
09888 2C58           89EC                       mov	sp,bp
09889 2C5A           5D                         pop	bp
09890 2C5B           C3                         ret
09891                                           !BCC_EOS
09892                                           ! 1784     } else if ( !(status & 0x08) ) {
09893 2C5C           EB           10            jmp .225
09894                       00002C5E            .223:
09895                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
09896 2C5E           8A46         F5            mov	al,-$B[bp]
09897 2C61           24                     08  and	al,*8
09898 2C63           84C0                       test	al,al
09899 2C65           75           07            jne 	.226
09900                       00002C67            .227:
09901                                           ! 1785     ;
09902                                           !BCC_EOS
09903                                           ! 1786     return 3;
09904 2C67           B8                   0003  mov	ax,*3
09905 2C6A           89EC                       mov	sp,bp
09906 2C6C           5D                         pop	bp
09907 2C6D           C3                         ret
09908                                           !BCC_EOS
09909                                           ! 1787   }
09910                                           ! 1788 #asm
09911                       00002C6E            .226:
09912                       00002C6E            .225:
09913                                           !BCC_EOS
09914                                           !BCC_ASM
09915                       00000016            _ata_cmd_data_in.count	set	$16
09916                       00000008            .ata_cmd_data_in.count	set	8
09917                       00000022            _ata_cmd_data_in.segment	set	$22
09918                       00000014            .ata_cmd_data_in.segment	set	$14
09919                       0000000A            _ata_cmd_data_in.iobase1	set	$A
09920                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
09921                       00000005            _ata_cmd_data_in.channel	set	5
09922                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
09923                       0000001C            _ata_cmd_data_in.sector	set	$1C
09924                       0000000E            .ata_cmd_data_in.sector	set	$E
09925                       00000006            _ata_cmd_data_in.blksize	set	6
09926                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
09927                       0000001A            _ata_cmd_data_in.head	set	$1A
09928                       0000000C            .ata_cmd_data_in.head	set	$C
09929                       00000018            _ata_cmd_data_in.cylinder	set	$18
09930                       0000000A            .ata_cmd_data_in.cylinder	set	$A
09931                       00000012            _ata_cmd_data_in.device	set	$12
09932                       00000004            .ata_cmd_data_in.device	set	4
09933                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
09934                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
09935                       00000003            _ata_cmd_data_in.status	set	3
09936                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
09937                       0000001E            _ata_cmd_data_in.lba	set	$1E
09938                       00000010            .ata_cmd_data_in.lba	set	$10
09939                       00000002            _ata_cmd_data_in.current	set	2
09940                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
09941                       00000014            _ata_cmd_data_in.command	set	$14
09942                       00000006            .ata_cmd_data_in.command	set	6
09943                       00000001            _ata_cmd_data_in.mode	set	1
09944                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
09945                       00000008            _ata_cmd_data_in.iobase2	set	8
09946                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
09947                       00000024            _ata_cmd_data_in.offset	set	$24
09948                       00000016            .ata_cmd_data_in.offset	set	$16
09949                       00000004            _ata_cmd_data_in.slave	set	4
09950                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
09951 2C6E           FB                                 sti ;; enable higher priority interrupts
09952                                           ! 1790 endasm
09953                                           !BCC_ENDASM
09954                                           !BCC_EOS
09955                                           ! 1791   while (1) {
09956                       00002C6F            .22A:
09957                                           ! 1792 #asm
09958                                           !BCC_EOS
09959                                           !BCC_ASM
09960                       00000016            _ata_cmd_data_in.count	set	$16
09961                       00000008            .ata_cmd_data_in.count	set	8
09962                       00000022            _ata_cmd_data_in.segment	set	$22
09963                       00000014            .ata_cmd_data_in.segment	set	$14
09964                       0000000A            _ata_cmd_data_in.iobase1	set	$A
09965                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
09966                       00000005            _ata_cmd_data_in.channel	set	5
09967                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
09968                       0000001C            _ata_cmd_data_in.sector	set	$1C
09969                       0000000E            .ata_cmd_data_in.sector	set	$E
09970                       00000006            _ata_cmd_data_in.blksize	set	6
09971                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
09972                       0000001A            _ata_cmd_data_in.head	set	$1A
09973                       0000000C            .ata_cmd_data_in.head	set	$C
09974                       00000018            _ata_cmd_data_in.cylinder	set	$18
09975                       0000000A            .ata_cmd_data_in.cylinder	set	$A
09976                       00000012            _ata_cmd_data_in.device	set	$12
09977                       00000004            .ata_cmd_data_in.device	set	4
09978                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
09979                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
09980                       00000003            _ata_cmd_data_in.status	set	3
09981                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
09982                       0000001E            _ata_cmd_data_in.lba	set	$1E
09983                       00000010            .ata_cmd_data_in.lba	set	$10
09984                       00000002            _ata_cmd_data_in.current	set	2
09985                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
09986                       00000014            _ata_cmd_data_in.command	set	$14
09987                       00000006            .ata_cmd_data_in.command	set	6
09988                       00000001            _ata_cmd_data_in.mode	set	1
09989                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
09990                       00000008            _ata_cmd_data_in.iobase2	set	8
09991                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
09992                       00000024            _ata_cmd_data_in.offset	set	$24
09993                       00000016            .ata_cmd_data_in.offset	set	$16
09994                       00000004            _ata_cmd_data_in.slave	set	4
09995                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
09996 2C6F           55                                 push bp
09997 2C70           89E5                               mov bp, sp
09998 2C72           8B7E         26                    mov di, _ata_cmd_data_in.offset + 2[bp]
09999 2C75           8B46         24                    mov ax, _ata_cmd_data_in.segment + 2[bp]
10000 2C78           8B4E         08                    mov cx, _ata_cmd_data_in.blksize + 2[bp]
10001                                                   ;; adjust if there will be an overrun. 2K max sector size
10002 2C7B           81FF                 F800          cmp di, #0xf800 ;;
10003 2C7F           76           07                    jbe ata_in_no_adjust
10004                       00002C81            ata_in_adjust:
10005 2C81           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
10006 2C85           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10007                       00002C88            ata_in_no_adjust:
10008 2C88           8EC0                               mov es, ax ;; segment in es
10009 2C8A           8B56         0C                    mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
10010 2C8D           8A66         03                    mov ah, _ata_cmd_data_in.mode + 2[bp]
10011 2C90           80FC                   01          cmp ah, #0x01
10012 2C93           74           04                    je ata_in_32
10013                       00002C95            ata_in_16:
10014 2C95           F3                                 rep
10015 2C96           6D                                   insw ;; CX words transfered from port(DX) to ES:[DI]
10016 2C97           EB           03                    jmp ata_in_done
10017                       00002C99            ata_in_32:
10018 2C99           F3                                 rep
10019 2C9A     66    6D                                   insd ;; CX dwords transfered from port(DX) to ES:[DI]
10020                       00002C9C            ata_in_done:
10021 2C9C           897E         26                    mov _ata_cmd_data_in.offset + 2[bp], di
10022 2C9F           8C46         24                    mov _ata_cmd_data_in.segment + 2[bp], es
10023 2CA2           5D                                 pop bp
10024                                           ! 1821 endasm
10025                                           !BCC_ENDASM
10026                                           !BCC_EOS
10027                                           ! 1822     current++;
10028                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
10029 2CA3           8A46         F4            mov	al,-$C[bp]
10030 2CA6           40                         inc	ax
10031 2CA7           8846         F4            mov	-$C[bp],al
10032                                           !BCC_EOS
10033                                           ! 1823     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
10034                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
10035 2CAA           8A46         F4            mov	al,-$C[bp]
10036 2CAD           30E4                       xor	ah,ah
10037 2CAF           50                         push	ax
10038                                           ! Debug: list * unsigned short = const $234 (used reg = )
10039 2CB0           B8                   0234  mov	ax,#$234
10040 2CB3           50                         push	ax
10041                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10042 2CB4           FF76         FE            push	-2[bp]
10043                                           ! Debug: func () void = write_word+0 (used reg = )
10044 2CB7           E8         D982            call	_write_word
10045 2CBA           83C4                   06  add	sp,*6
10046                                           !BCC_EOS
10047                                           ! 1824     count--;
10048                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
10049 2CBD           8B46         08            mov	ax,8[bp]
10050 2CC0           48                         dec	ax
10051 2CC1           8946         08            mov	8[bp],ax
10052                                           !BCC_EOS
10053                                           ! 1825     status = inb(iobase1 + 7);
10054                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10055 2CC4           8B46         FC            mov	ax,-4[bp]
10056                                           ! Debug: list unsigned int = ax+7 (used reg = )
10057 2CC7           05                   0007  add	ax,*7
10058 2CCA           50                         push	ax
10059                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10060 2CCB           E8         D87A            call	_inb
10061 2CCE           44                         inc	sp
10062 2CCF           44                         inc	sp
10063                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10064 2CD0           8846         F5            mov	-$B[bp],al
10065                                           !BCC_EOS
10066                                           ! 1826     if (count == 0) {
10067                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
10068 2CD3           8B46         08            mov	ax,8[bp]
10069 2CD6           85C0                       test	ax,ax
10070 2CD8           75           14            jne 	.22B
10071                       00002CDA            .22C:
10072                                           ! 1827       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10073                                           ! 1828           != 0x40 ) {
10074                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
10075 2CDA           8A46         F5            mov	al,-$B[bp]
10076 2CDD           24                     C9  and	al,#$C9
10077                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10078 2CDF           3C                     40  cmp	al,*$40
10079 2CE1           74           07            je  	.22D
10080                       00002CE3            .22E:
10081                                           ! 1829         ;
10082                                           !BCC_EOS
10083                                           ! 1830         return 4;
10084 2CE3           B8                   0004  mov	ax,*4
10085 2CE6           89EC                       mov	sp,bp
10086 2CE8           5D                         pop	bp
10087 2CE9           C3                         ret
10088                                           !BCC_EOS
10089                                           ! 1831         }
10090                                           ! 1832       break;
10091                       00002CEA            .22D:
10092 2CEA           EB           17            jmp .228
10093                                           !BCC_EOS
10094                                           ! 1833       }
10095                                           ! 1834     else {
10096 2CEC           EB           12            jmp .22F
10097                       00002CEE            .22B:
10098                                           ! 1835       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10099                                           ! 1836           != (0x40 | 0x08) ) {
10100                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
10101 2CEE           8A46         F5            mov	al,-$B[bp]
10102 2CF1           24                     C9  and	al,#$C9
10103                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10104 2CF3           3C                     48  cmp	al,*$48
10105 2CF5           74           07            je  	.230
10106                       00002CF7            .231:
10107                                           ! 1837         ;
10108                                           !BCC_EOS
10109                                           ! 1838         return 5;
10110 2CF7           B8                   0005  mov	ax,*5
10111 2CFA           89EC                       mov	sp,bp
10112 2CFC           5D                         pop	bp
10113 2CFD           C3                         ret
10114                                           !BCC_EOS
10115                                           ! 1839       }
10116                                           ! 1840       continue;
10117                       00002CFE            .230:
10118 2CFE           EB           00            jmp .229
10119                                           !BCC_EOS
10120                                           ! 1841     }
10121                                           ! 1842   }
10122                       00002D00            .22F:
10123                                           ! 1843   outb(iobase2+6, 0x08);
10124                       00002D00            .229:
10125 2D00           E9         FF6C            jmp	.22A
10126                       00002D03            .232:
10127                       00002D03            .228:
10128                                           ! Debug: list int = const 8 (used reg = )
10129 2D03           B8                   0008  mov	ax,*8
10130 2D06           50                         push	ax
10131                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10132 2D07           8B46         FA            mov	ax,-6[bp]
10133                                           ! Debug: list unsigned int = ax+6 (used reg = )
10134 2D0A           05                   0006  add	ax,*6
10135 2D0D           50                         push	ax
10136                                           ! Debug: func () void = outb+0 (used reg = )
10137 2D0E           E8         D84D            call	_outb
10138 2D11           83C4                   04  add	sp,*4
10139                                           !BCC_EOS
10140                                           ! 1844   return 0;
10141 2D14           31C0                       xor	ax,ax
10142 2D16           89EC                       mov	sp,bp
10143 2D18           5D                         pop	bp
10144 2D19           C3                         ret
10145                                           !BCC_EOS
10146                                           ! 1845 }
10147                                           ! 1846 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba, segment, offset)
10148                                           ! Register BX used in function ata_cmd_data_in
10149                                           ! 1847 Bit16u device, command, count, cylinder, head, sector, segment, offset;
10150                                           export	_ata_cmd_data_out
10151                       00002D1A            _ata_cmd_data_out:
10152                                           !BCC_EOS
10153                                           ! 1848 Bit32u lba;
10154                                           !BCC_EOS
10155                                           ! 1849 {
10156                                           ! 1850   Bit16u ebda_seg=read_word(0x0040,0x000E);
10157 2D1A           55                         push	bp
10158 2D1B           89E5                       mov	bp,sp
10159 2D1D           4C                         dec	sp
10160 2D1E           4C                         dec	sp
10161                                           ! Debug: list int = const $E (used reg = )
10162 2D1F           B8                   000E  mov	ax,*$E
10163 2D22           50                         push	ax
10164                                           ! Debug: list int = const $40 (used reg = )
10165 2D23           B8                   0040  mov	ax,*$40
10166 2D26           50                         push	ax
10167                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10168 2D27           E8         D8E7            call	_read_word
10169 2D2A           83C4                   04  add	sp,*4
10170                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10171 2D2D           8946         FE            mov	-2[bp],ax
10172                                           !BCC_EOS
10173                                           ! 1851   Bit16u iobase1, iobase2, blksize;
10174                                           !BCC_EOS
10175                                           ! 1852   Bit8u channel, slave;
10176                                           !BCC_EOS
10177                                           ! 1853   Bit8u status, current, mode;
10178                                           !BCC_EOS
10179                                           ! 1854   channel = device / 2;
10180 2D30           83C4                   F4  add	sp,*-$C
10181                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10182 2D33           8B46         04            mov	ax,4[bp]
10183 2D36           D1E8                       shr	ax,*1
10184                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
10185 2D38           8846         F7            mov	-9[bp],al
10186                                           !BCC_EOS
10187                                           ! 1855   slave = device % 2;
10188                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10189 2D3B           8B46         04            mov	ax,4[bp]
10190 2D3E           24                     01  and	al,*1
10191                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
10192 2D40           8846         F6            mov	-$A[bp],al
10193                                           !BCC_EOS
10194                                           ! 1856   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
10195                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10196 2D43           8A46         F7            mov	al,-9[bp]
10197 2D46           30E4                       xor	ah,ah
10198 2D48           B1                     03  mov	cl,*3
10199 2D4A           D3E0                       shl	ax,cl
10200 2D4C           89C3                       mov	bx,ax
10201                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10202                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
10203 2D4E           81C3                 0124  add	bx,#$124
10204 2D52           53                         push	bx
10205                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10206 2D53           FF76         FE            push	-2[bp]
10207                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10208 2D56           E8         D8B8            call	_read_word
10209 2D59           83C4                   04  add	sp,*4
10210                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
10211 2D5C           8946         FC            mov	-4[bp],ax
10212                                           !BCC_EOS
10213                                           ! 1857   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
10214                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10215 2D5F           8A46         F7            mov	al,-9[bp]
10216 2D62           30E4                       xor	ah,ah
10217 2D64           B1                     03  mov	cl,*3
10218 2D66           D3E0                       shl	ax,cl
10219 2D68           89C3                       mov	bx,ax
10220                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10221                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
10222 2D6A           81C3                 0126  add	bx,#$126
10223 2D6E           53                         push	bx
10224                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10225 2D6F           FF76         FE            push	-2[bp]
10226                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10227 2D72           E8         D89C            call	_read_word
10228 2D75           83C4                   04  add	sp,*4
10229                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
10230 2D78           8946         FA            mov	-6[bp],ax
10231                                           !BCC_EOS
10232                                           ! 1858   mode = read_byte(ebda_seg, &((
10233                                           ! 1858 ebda_data_t *) 0)->ata.devices[device].mode);
10234                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10235 2D7B           8B46         04            mov	ax,4[bp]
10236 2D7E           B9                   001A  mov	cx,*$1A
10237 2D81           F7E9                       imul	cx
10238 2D83           89C3                       mov	bx,ax
10239                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10240                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
10241 2D85           81C3                 0146  add	bx,#$146
10242 2D89           53                         push	bx
10243                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10244 2D8A           FF76         FE            push	-2[bp]
10245                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10246 2D8D           E8         D86E            call	_read_byte
10247 2D90           83C4                   04  add	sp,*4
10248                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
10249 2D93           8846         F3            mov	-$D[bp],al
10250                                           !BCC_EOS
10251                                           ! 1859   blksize = 0x200;
10252                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
10253 2D96           B8                   0200  mov	ax,#$200
10254 2D99           8946         F8            mov	-8[bp],ax
10255                                           !BCC_EOS
10256                                           ! 1860   if (mode == 0x01) blksize>>=2;
10257                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
10258 2D9C           8A46         F3            mov	al,-$D[bp]
10259 2D9F           3C                     01  cmp	al,*1
10260 2DA1           75           0C            jne 	.233
10261                       00002DA3            .234:
10262                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
10263 2DA3           8B46         F8            mov	ax,-8[bp]
10264 2DA6           D1E8                       shr	ax,*1
10265 2DA8           D1E8                       shr	ax,*1
10266 2DAA           8946         F8            mov	-8[bp],ax
10267                                           !BCC_EOS
10268                                           ! 1861   else blksize>>=1;
10269 2DAD           EB           08            jmp .235
10270                       00002DAF            .233:
10271                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
10272 2DAF           8B46         F8            mov	ax,-8[bp]
10273 2DB2           D1E8                       shr	ax,*1
10274 2DB4           8946         F8            mov	-8[bp],ax
10275                                           !BCC_EOS
10276                                           ! 1862   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
10277                       00002DB7            .235:
10278                                           ! Debug: list int = const 0 (used reg = )
10279 2DB7           31C0                       xor	ax,ax
10280 2DB9           50                         push	ax
10281                                           ! Debug: list * unsigned short = const $234 (used reg = )
10282 2DBA           B8                   0234  mov	ax,#$234
10283 2DBD           50                         push	ax
10284                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10285 2DBE           FF76         FE            push	-2[bp]
10286                                           ! Debug: func () void = write_word+0 (used reg = )
10287 2DC1           E8         D878            call	_write_word
10288 2DC4           83C4                   06  add	sp,*6
10289                                           !BCC_EOS
10290                                           ! 1863   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
10291                                           ! Debug: list long = const 0 (used reg = )
10292 2DC7           31C0                       xor	ax,ax
10293 2DC9           31DB                       xor	bx,bx
10294 2DCB           53                         push	bx
10295 2DCC           50                         push	ax
10296                                           ! Debug: list * unsigned long = const $236 (used reg = )
10297 2DCD           B8                   0236  mov	ax,#$236
10298 2DD0           50                         push	ax
10299                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
10300 2DD1           FF76         FE            push	-2[bp]
10301                                           ! Debug: func () void = write_dword+0 (used reg = )
10302 2DD4           E8         D295            call	_write_dword
10303 2DD7           83C4                   08  add	sp,*8
10304                                           !BCC_EOS
10305                                           ! 1864   current = 0;
10306                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
10307 2DDA           30C0                       xor	al,al
10308 2DDC           8846         F4            mov	-$C[bp],al
10309                                           !BCC_EOS
10310                                           ! 1865   status = inb(iobase1 + 7);
10311                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10312 2DDF           8B46         FC            mov	ax,-4[bp]
10313                                           ! Debug: list unsigned int = ax+7 (used reg = )
10314 2DE2           05                   0007  add	ax,*7
10315 2DE5           50                         push	ax
10316                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10317 2DE6           E8         D75F            call	_inb
10318 2DE9           44                         inc	sp
10319 2DEA           44                         inc	sp
10320                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10321 2DEB           8846         F5            mov	-$B[bp],al
10322                                           !BCC_EOS
10323                                           ! 1866   if (status & 0x80) return 1;
10324                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
10325 2DEE           8A46         F5            mov	al,-$B[bp]
10326 2DF1           24                     80  and	al,#$80
10327 2DF3           84C0                       test	al,al
10328 2DF5           74           07            je  	.236
10329                       00002DF7            .237:
10330 2DF7           B8                   0001  mov	ax,*1
10331 2DFA           89EC                       mov	sp,bp
10332 2DFC           5D                         pop	bp
10333 2DFD           C3                         ret
10334                                           !BCC_EOS
10335                                           ! 1867   outb(iobase2 + 6, 0x08 | 0x02);
10336                       00002DFE            .236:
10337                                           ! Debug: list int = const $A (used reg = )
10338 2DFE           B8                   000A  mov	ax,*$A
10339 2E01           50                         push	ax
10340                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10341 2E02           8B46         FA            mov	ax,-6[bp]
10342                                           ! Debug: list unsigned int = ax+6 (used reg = )
10343 2E05           05                   0006  add	ax,*6
10344 2E08           50                         push	ax
10345                                           ! Debug: func () void = outb+0 (used reg = )
10346 2E09           E8         D752            call	_outb
10347 2E0C           83C4                   04  add	sp,*4
10348                                           !BCC_EOS
10349                                           ! 1868   if (sector == 0) {
10350                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
10351 2E0F           8B46         0E            mov	ax,$E[bp]
10352 2E12           85C0                       test	ax,ax
10353 2E14         0F85         0123            bne 	.238
10354                       00002E18            .239:
10355                                           ! 1869     if ((count >= 1 << 8) || (lba + count >= 1UL << 28)) {
10356                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
10357 2E18           8B46         08            mov	ax,8[bp]
10358 2E1B           3D                   0100  cmp	ax,#$100
10359 2E1E           73           27            jae 	.23B
10360                       00002E20            .23C:
10361                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
10362 2E20           8B46         08            mov	ax,8[bp]
10363 2E23           31DB                       xor	bx,bx
10364                                           ! Debug: add unsigned long = bx+0 to unsigned long lba = [S+$10+$E] (used reg = )
10365                                           ! Debug: expression subtree swapping
10366 2E25           8D7E         10            lea	di,$10[bp]
10367 2E28           E8         D268            call	laddul
10368                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
10369 2E2B           53                         push	bx
10370 2E2C           50                         push	ax
10371 2E2D           31C0                       xor	ax,ax
10372 2E2F           BB                   1000  mov	bx,#$1000
10373 2E32           53                         push	bx
10374 2E33           50                         push	ax
10375 2E34           8B46         EE            mov	ax,-$12[bp]
10376 2E37           8B5E         F0            mov	bx,-$10[bp]
10377 2E3A           8D7E         EA            lea	di,-$16[bp]
10378 2E3D           E8         D25B            call	lcmpul
10379 2E40           8D66         F2            lea	sp,-$E[bp]
10380 2E43         0F82         00A5            blo 	.23A
10381                       00002E47            .23B:
10382                                           ! 1870       outb(iobase1 + 1, 0x00);
10383                                           ! Debug: list int = const 0 (used reg = )
10384 2E47           31C0                       xor	ax,ax
10385 2E49           50                         push	ax
10386                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10387 2E4A           8B46         FC            mov	ax,-4[bp]
10388                                           ! Debug: list unsigned int = ax+1 (used reg = )
10389 2E4D           40                         inc	ax
10390 2E4E           50                         push	ax
10391                                           ! Debug: func () void = outb+0 (used reg = )
10392 2E4F           E8         D70C            call	_outb
10393 2E52           83C4                   04  add	sp,*4
10394                                           !BCC_EOS
10395                                           ! 1871       outb(iobase1 + 2, (count >> 8) & 0xff);
10396                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
10397 2E55           8B46         08            mov	ax,8[bp]
10398 2E58           88E0                       mov	al,ah
10399 2E5A           30E4                       xor	ah,ah
10400                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
10401                                           ! Debug: list unsigned char = al+0 (used reg = )
10402 2E5C           30E4                       xor	ah,ah
10403 2E5E           50                         push	ax
10404                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10405 2E5F           8B46         FC            mov	ax,-4[bp]
10406                                           ! Debug: list unsigned int = ax+2 (used reg = )
10407 2E62           40                         inc	ax
10408 2E63           40                         inc	ax
10409 2E64           50                         push	ax
10410                                           ! Debug: func () void = outb+0 (used reg = )
10411 2E65           E8         D6F6            call	_outb
10412 2E68           83C4                   04  add	sp,*4
10413                                           !BCC_EOS
10414                                           ! 1872       outb(iobase1 + 3, lba >> 24);
10415                                           ! Debug: sr int = const $18 to unsigned long lba = [S+$10+$E] (used reg = )
10416 2E6B           8B46         10            mov	ax,$10[bp]
10417 2E6E           8B5E         12            mov	bx,$12[bp]
10418 2E71           93                         xchg	bx,ax
10419 2E72           88E0                       mov	al,ah
10420 2E74           30E4                       xor	ah,ah
10421 2E76           31DB                       xor	bx,bx
10422                                           ! Debug: list unsigned long = bx+0 (used reg = )
10423 2E78           53                         push	bx
10424 2E79           50                         push	ax
10425                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
10426 2E7A           8B46         FC            mov	ax,-4[bp]
10427                                           ! Debug: list unsigned int = ax+3 (used reg = )
10428 2E7D           05                   0003  add	ax,*3
10429 2E80           50                         push	ax
10430                                           ! Debug: func () void = outb+0 (used reg = )
10431 2E81           E8         D6DA            call	_outb
10432 2E84           83C4                   06  add	sp,*6
10433                                           !BCC_EOS
10434                                           ! 1873       outb(iobase1 + 4, 0);
10435                                           ! Debug: list int = const 0 (used reg = )
10436 2E87           31C0                       xor	ax,ax
10437 2E89           50                         push	ax
10438                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
10439 2E8A           8B46         FC            mov	ax,-4[bp]
10440                                           ! Debug: list unsigned int = ax+4 (used reg = )
10441 2E8D           05                   0004  add	ax,*4
10442 2E90           50                         push	ax
10443                                           ! Debug: func () void = outb+0 (used reg = )
10444 2E91           E8         D6CA            call	_outb
10445 2E94           83C4                   04  add	sp,*4
10446                                           !BCC_EOS
10447                                           ! 1874       outb(iobase1 + 5, 0);
10448                                           ! Debug: list int = const 0 (used reg = )
10449 2E97           31C0                       xor	ax,ax
10450 2E99           50                         push	ax
10451                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
10452 2E9A           8B46         FC            mov	ax,-4[bp]
10453                                           ! Debug: list unsigned int = ax+5 (used reg = )
10454 2E9D           05                   0005  add	ax,*5
10455 2EA0           50                         push	ax
10456                                           ! Debug: func () void = outb+0 (used reg = )
10457 2EA1           E8         D6BA            call	_outb
10458 2EA4           83C4                   04  add	sp,*4
10459                                           !BCC_EOS
10460                                           ! 1875       command |= 0x04;
10461                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
10462 2EA7           8B46         06            mov	ax,6[bp]
10463 2EAA           0C                     04  or	al,*4
10464 2EAC           8946         06            mov	6[bp],ax
10465                                           !BCC_EOS
10466                                           ! 1876       count &= (1UL << 8) - 1;
10467                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
10468 2EAF           8B46         08            mov	ax,8[bp]
10469 2EB2           31DB                       xor	bx,bx
10470 2EB4           53                         push	bx
10471 2EB5           50                         push	ax
10472 2EB6           B8                   00FF  mov	ax,#$FF
10473 2EB9           31DB                       xor	bx,bx
10474 2EBB           53                         push	bx
10475 2EBC           50                         push	ax
10476 2EBD           8B46         EE            mov	ax,-$12[bp]
10477 2EC0           8B5E         F0            mov	bx,-$10[bp]
10478 2EC3           8D7E         EA            lea	di,-$16[bp]
10479 2EC6           E8         D1C2            call	landul
10480 2EC9           8946         08            mov	8[bp],ax
10481 2ECC           83C4                   08  add	sp,*8
10482                                           !BCC_EOS
10483                                           ! 1877       lba &= (1UL << 24) - 1;
10484                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba = [S+$10+$E] (used reg = )
10485 2ECF           B8                   FFFF  mov	ax,#$FFFF
10486 2ED2           BB                   00FF  mov	bx,#$FF
10487 2ED5           53                         push	bx
10488 2ED6           50                         push	ax
10489 2ED7           8B46         10            mov	ax,$10[bp]
10490 2EDA           8B5E         12            mov	bx,$12[bp]
10491 2EDD           8D7E         EE            lea	di,-$12[bp]
10492 2EE0           E8         D1A8            call	landul
10493 2EE3           8946         10            mov	$10[bp],ax
10494 2EE6           895E         12            mov	$12[bp],bx
10495 2EE9           83C4                   04  add	sp,*4
10496                                           !BCC_EOS
10497                                           ! 1878       }
10498                                           ! 1879     sector = (Bit16u) (lba & 0x000000ffL);
10499                       00002EEC            .23A:
10500                                           ! Debug: and long = const $FF to unsigned long lba = [S+$10+$E] (used reg = )
10501                                           ! Debug: expression subtree swapping
10502 2EEC           B8                   00FF  mov	ax,#$FF
10503 2EEF           31DB                       xor	bx,bx
10504 2EF1           8D7E         10            lea	di,$10[bp]
10505 2EF4           E8         D194            call	landul
10506                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10507                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
10508 2EF7           8946         0E            mov	$E[bp],ax
10509                                           !BCC_EOS
10510                                           ! 1880     lba >>= 8;
10511                                           ! Debug: srab int = const 8 to unsigned long lba = [S+$10+$E] (used reg = )
10512 2EFA           8B46         10            mov	ax,$10[bp]
10513 2EFD           8B5E         12            mov	bx,$12[bp]
10514 2F00           88E0                       mov	al,ah
10515 2F02           88DC                       mov	ah,bl
10516 2F04           88FB                       mov	bl,bh
10517 2F06           28FF                       sub	bh,bh
10518 2F08           8946         10            mov	$10[bp],ax
10519 2F0B           895E         12            mov	$12[bp],bx
10520                                           !BCC_EOS
10521                                           ! 1881     cylinder = (Bit16u) (lba & 0x0000ffffL);
10522                                           ! Debug: and long = const $FFFF to unsigned long lba = [S+$10+$E] (used reg = )
10523                                           ! Debug: expression subtree swapping
10524 2F0E           B8                   FFFF  mov	ax,#$FFFF
10525 2F11           31DB                       xor	bx,bx
10526 2F13           8D7E         10            lea	di,$10[bp]
10527 2F16           E8         D172            call	landul
10528                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10529                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
10530 2F19           8946         0A            mov	$A[bp],ax
10531                                           !BCC_EOS
10532                                           ! 1882     lba >>= 16;
10533                                           ! Debug: srab int = const $10 to unsigned long lba = [S+$10+$E] (used reg = )
10534 2F1C           8B46         10            mov	ax,$10[bp]
10535 2F1F           8B5E         12            mov	bx,$12[bp]
10536 2F22           93                         xchg	bx,ax
10537 2F23           31DB                       xor	bx,bx
10538 2F25           8946         10            mov	$10[bp],ax
10539 2F28           895E         12            mov	$12[bp],bx
10540                                           !BCC_EOS
10541                                           ! 1883     head = ((Bit16u) (lba & 0x0000000fL)) | 0x40;
10542                                           ! Debug: and long = const $F to unsigned long lba = [S+$10+$E] (used reg = )
10543                                           ! Debug: expression subtree swapping
10544 2F2B           B8                   000F  mov	ax,*$F
10545 2F2E           31DB                       xor	bx,bx
10546 2F30           8D7E         10            lea	di,$10[bp]
10547 2F33           E8         D155            call	landul
10548                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10549                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
10550 2F36           0C                     40  or	al,*$40
10551                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
10552 2F38           8946         0C            mov	$C[bp],ax
10553                                           !BCC_EOS
10554                                           ! 1884     }
10555                                           ! 1885   outb(iobase1 + 1, 0x00);
10556                       00002F3B            .238:
10557                                           ! Debug: list int = const 0 (used reg = )
10558 2F3B           31C0                       xor	ax,ax
10559 2F3D           50                         push	ax
10560                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10561 2F3E           8B46         FC            mov	ax,-4[bp]
10562                                           ! Debug: list unsigned int = ax+1 (used reg = )
10563 2F41           40                         inc	ax
10564 2F42           50                         push	ax
10565                                           ! Debug: func () void = outb+0 (used reg = )
10566 2F43           E8         D618            call	_outb
10567 2F46           83C4                   04  add	sp,*4
10568                                           !BCC_EOS
10569                                           ! 1886   outb(iobase1 + 2, count);
10570                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
10571 2F49           FF76         08            push	8[bp]
10572                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10573 2F4C           8B46         FC            mov	ax,-4[bp]
10574                                           ! Debug: list unsigned int = ax+2 (used reg = )
10575 2F4F           40                         inc	ax
10576 2F50           40                         inc	ax
10577 2F51           50                         push	ax
10578                                           ! Debug: func () void = outb+0 (used reg = )
10579 2F52           E8         D609            call	_outb
10580 2F55           83C4                   04  add	sp,*4
10581                                           !BCC_EOS
10582                                           ! 1887   outb(iobase1 + 3, sector);
10583                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
10584 2F58           FF76         0E            push	$E[bp]
10585                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
10586 2F5B           8B46         FC            mov	ax,-4[bp]
10587                                           ! Debug: list unsigned int = ax+3 (used reg = )
10588 2F5E           05                   0003  add	ax,*3
10589 2F61           50                         push	ax
10590                                           ! Debug: func () void = outb+0 (used reg = )
10591 2F62           E8         D5F9            call	_outb
10592 2F65           83C4                   04  add	sp,*4
10593                                           !BCC_EOS
10594                                           ! 1888   outb(iobase1 + 4, cylinder & 0x00ff);
10595                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
10596 2F68           8A46         0A            mov	al,$A[bp]
10597                                           ! Debug: list unsigned char = al+0 (used reg = )
10598 2F6B           30E4                       xor	ah,ah
10599 2F6D           50                         push	ax
10600                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
10601 2F6E           8B46         FC            mov	ax,-4[bp]
10602                                           ! Debug: list unsigned int = ax+4 (used reg = )
10603 2F71           05                   0004  add	ax,*4
10604 2F74           50                         push	ax
10605                                           ! Debug: func () void = outb+0 (used reg = )
10606 2F75           E8         D5E6            call	_outb
10607 2F78           83C4                   04  add	sp,*4
10608                                           !BCC_EOS
10609                                           ! 1889   outb(iobase1 + 5, cylinder >> 8);
10610                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
10611 2F7B           8B46         0A            mov	ax,$A[bp]
10612 2F7E           88E0                       mov	al,ah
10613 2F80           30E4                       xor	ah,ah
10614                                           ! Debug: list unsigned int = ax+0 (used reg = )
10615 2F82           50                         push	ax
10616                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
10617 2F83           8B46         FC            mov	ax,-4[bp]
10618                                           ! Debug: list unsigned int = ax+5 (used reg = )
10619 2F86           05                   0005  add	ax,*5
10620 2F89           50                         push	ax
10621                                           ! Debug: func () void = outb+0 (used reg = )
10622 2F8A           E8         D5D1            call	_outb
10623 2F8D           83C4                   04  add	sp,*4
10624                                           !BCC_EOS
10625                                           ! 1890   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10626 2F90           8A46         F6            mov	al,-$A[bp]
10627 2F93           84C0                       test	al,al
10628 2F95           74           04            je  	.23D
10629                       00002F97            .23E:
10630 2F97           B0                     B0  mov	al,#$B0
10631 2F99           EB           02            jmp .23F
10632                       00002F9B            .23D:
10633 2F9B           B0                     A0  mov	al,#$A0
10634                       00002F9D            .23F:
10635                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
10636 2F9D           0A46         0C            or	al,$C[bp]
10637                                           ! Debug: list unsigned char = al+0 (used reg = )
10638 2FA0           30E4                       xor	ah,ah
10639 2FA2           50                         push	ax
10640                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10641 2FA3           8B46         FC            mov	ax,-4[bp]
10642                                           ! Debug: list unsigned int = ax+6 (used reg = )
10643 2FA6           05                   0006  add	ax,*6
10644 2FA9           50                         push	ax
10645                                           ! Debug: func () void = outb+0 (used reg = )
10646 2FAA           E8         D5B1            call	_outb
10647 2FAD           83C4                   04  add	sp,*4
10648                                           !BCC_EOS
10649                                           ! 1891   outb(iobase1 + 7, command);
10650                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
10651 2FB0           FF76         06            push	6[bp]
10652                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
10653 2FB3           8B46         FC            mov	ax,-4[bp]
10654                                           ! Debug: list unsigned int = ax+7 (used reg = )
10655 2FB6           05                   0007  add	ax,*7
10656 2FB9           50                         push	ax
10657                                           ! Debug: func () void = outb+0 (used reg = )
10658 2FBA           E8         D5A1            call	_outb
10659 2FBD           83C4                   04  add	sp,*4
10660                                           !BCC_EOS
10661                                           ! 1892   while (1) {
10662                       00002FC0            .242:
10663                                           ! 1893     status = inb(iobase1 + 7);
10664                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10665 2FC0           8B46         FC            mov	ax,-4[bp]
10666                                           ! Debug: list unsigned int = ax+7 (used reg = )
10667 2FC3           05                   0007  add	ax,*7
10668 2FC6           50                         push	ax
10669                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10670 2FC7           E8         D57E            call	_inb
10671 2FCA           44                         inc	sp
10672 2FCB           44                         inc	sp
10673                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10674 2FCC           8846         F5            mov	-$B[bp],al
10675                                           !BCC_EOS
10676                                           ! 1894     if ( !(status & 0x80) ) break;
10677                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
10678 2FCF           8A46         F5            mov	al,-$B[bp]
10679 2FD2           24                     80  and	al,#$80
10680 2FD4           84C0                       test	al,al
10681 2FD6           75           02            jne 	.243
10682                       00002FD8            .244:
10683 2FD8           EB           02            jmp .240
10684                                           !BCC_EOS
10685                                           ! 1895     }
10686                       00002FDA            .243:
10687                                           ! 1896   if (status & 0x01) {
10688                       00002FDA            .241:
10689 2FDA           EB           E4            jmp	.242
10690                       00002FDC            .245:
10691                       00002FDC            .240:
10692                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
10693 2FDC           8A46         F5            mov	al,-$B[bp]
10694 2FDF           24                     01  and	al,*1
10695 2FE1           84C0                       test	al,al
10696 2FE3           74           09            je  	.246
10697                       00002FE5            .247:
10698                                           ! 1897     ;
10699                                           !BCC_EOS
10700                                           ! 1898     return 2;
10701 2FE5           B8                   0002  mov	ax,*2
10702 2FE8           89EC                       mov	sp,bp
10703 2FEA           5D                         pop	bp
10704 2FEB           C3                         ret
10705                                           !BCC_EOS
10706                                           ! 1899     } else if ( !(status & 0x08) ) {
10707 2FEC           EB           10            jmp .248
10708                       00002FEE            .246:
10709                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
10710 2FEE           8A46         F5            mov	al,-$B[bp]
10711 2FF1           24                     08  and	al,*8
10712 2FF3           84C0                       test	al,al
10713 2FF5           75           07            jne 	.249
10714                       00002FF7            .24A:
10715                                           ! 1900     ;
10716                                           !BCC_EOS
10717                                           ! 1901     return 3;
10718 2FF7           B8                   0003  mov	ax,*3
10719 2FFA           89EC                       mov	sp,bp
10720 2FFC           5D                         pop	bp
10721 2FFD           C3                         ret
10722                                           !BCC_EOS
10723                                           ! 1902     }
10724                                           ! 1903 #asm
10725                       00002FFE            .249:
10726                       00002FFE            .248:
10727                                           !BCC_EOS
10728                                           !BCC_ASM
10729                       00000016            _ata_cmd_data_out.count	set	$16
10730                       00000008            .ata_cmd_data_out.count	set	8
10731                       00000022            _ata_cmd_data_out.segment	set	$22
10732                       00000014            .ata_cmd_data_out.segment	set	$14
10733                       0000000A            _ata_cmd_data_out.iobase1	set	$A
10734                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
10735                       00000005            _ata_cmd_data_out.channel	set	5
10736                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
10737                       0000001C            _ata_cmd_data_out.sector	set	$1C
10738                       0000000E            .ata_cmd_data_out.sector	set	$E
10739                       00000006            _ata_cmd_data_out.blksize	set	6
10740                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
10741                       0000001A            _ata_cmd_data_out.head	set	$1A
10742                       0000000C            .ata_cmd_data_out.head	set	$C
10743                       00000018            _ata_cmd_data_out.cylinder	set	$18
10744                       0000000A            .ata_cmd_data_out.cylinder	set	$A
10745                       00000012            _ata_cmd_data_out.device	set	$12
10746                       00000004            .ata_cmd_data_out.device	set	4
10747                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
10748                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
10749                       00000003            _ata_cmd_data_out.status	set	3
10750                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
10751                       0000001E            _ata_cmd_data_out.lba	set	$1E
10752                       00000010            .ata_cmd_data_out.lba	set	$10
10753                       00000002            _ata_cmd_data_out.current	set	2
10754                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
10755                       00000014            _ata_cmd_data_out.command	set	$14
10756                       00000006            .ata_cmd_data_out.command	set	6
10757                       00000001            _ata_cmd_data_out.mode	set	1
10758                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
10759                       00000008            _ata_cmd_data_out.iobase2	set	8
10760                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
10761                       00000024            _ata_cmd_data_out.offset	set	$24
10762                       00000016            .ata_cmd_data_out.offset	set	$16
10763                       00000004            _ata_cmd_data_out.slave	set	4
10764                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
10765 2FFE           FB                                 sti ;; enable higher priority interrupts
10766                                           ! 1905 endasm
10767                                           !BCC_ENDASM
10768                                           !BCC_EOS
10769                                           ! 1906   while (1) {
10770                       00002FFF            .24D:
10771                                           ! 1907 #asm
10772                                           !BCC_EOS
10773                                           !BCC_ASM
10774                       00000016            _ata_cmd_data_out.count	set	$16
10775                       00000008            .ata_cmd_data_out.count	set	8
10776                       00000022            _ata_cmd_data_out.segment	set	$22
10777                       00000014            .ata_cmd_data_out.segment	set	$14
10778                       0000000A            _ata_cmd_data_out.iobase1	set	$A
10779                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
10780                       00000005            _ata_cmd_data_out.channel	set	5
10781                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
10782                       0000001C            _ata_cmd_data_out.sector	set	$1C
10783                       0000000E            .ata_cmd_data_out.sector	set	$E
10784                       00000006            _ata_cmd_data_out.blksize	set	6
10785                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
10786                       0000001A            _ata_cmd_data_out.head	set	$1A
10787                       0000000C            .ata_cmd_data_out.head	set	$C
10788                       00000018            _ata_cmd_data_out.cylinder	set	$18
10789                       0000000A            .ata_cmd_data_out.cylinder	set	$A
10790                       00000012            _ata_cmd_data_out.device	set	$12
10791                       00000004            .ata_cmd_data_out.device	set	4
10792                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
10793                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
10794                       00000003            _ata_cmd_data_out.status	set	3
10795                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
10796                       0000001E            _ata_cmd_data_out.lba	set	$1E
10797                       00000010            .ata_cmd_data_out.lba	set	$10
10798                       00000002            _ata_cmd_data_out.current	set	2
10799                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
10800                       00000014            _ata_cmd_data_out.command	set	$14
10801                       00000006            .ata_cmd_data_out.command	set	6
10802                       00000001            _ata_cmd_data_out.mode	set	1
10803                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
10804                       00000008            _ata_cmd_data_out.iobase2	set	8
10805                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
10806                       00000024            _ata_cmd_data_out.offset	set	$24
10807                       00000016            .ata_cmd_data_out.offset	set	$16
10808                       00000004            _ata_cmd_data_out.slave	set	4
10809                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
10810 2FFF           55                                 push bp
10811 3000           89E5                               mov bp, sp
10812 3002           8B76         26                    mov si, _ata_cmd_data_out.offset + 2[bp]
10813 3005           8B46         24                    mov ax, _ata_cmd_data_out.segment + 2[bp]
10814 3008           8B4E         08                    mov cx, _ata_cmd_data_out.blksize + 2[bp]
10815                                                   ;; adjust if there will be an overrun. 2K max sector size
10816 300B           81FE                 F800          cmp si, #0xf800 ;;
10817 300F           76           07                    jbe ata_out_no_adjust
10818                       00003011            ata_out_adjust:
10819 3011           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
10820 3015           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10821                       00003018            ata_out_no_adjust:
10822 3018           8EC0                               mov es, ax ;; segment in es
10823 301A           8B56         0C                    mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
10824 301D           8A66         03                    mov ah, _ata_cmd_data_out.mode + 2[bp]
10825 3020           80FC                   01          cmp ah, #0x01
10826 3023           74           05                    je ata_out_32
10827                       00003025            ata_out_16:
10828 3025           26                                 seg ES
10829 3026           F3                                 rep
10830 3027           6F                                   outsw ;; CX words transfered from port(DX) to ES:[SI]
10831 3028           EB           04                    jmp ata_out_done
10832                       0000302A            ata_out_32:
10833 302A           26                                 seg ES
10834 302B           F3                                 rep
10835 302C     66    6F                                   outsd ;; CX dwords transfered from port(DX) to ES:[SI]
10836                       0000302E            ata_out_done:
10837 302E           8976         26                    mov _ata_cmd_data_out.offset + 2[bp], si
10838 3031           8C46         24                    mov _ata_cmd_data_out.segment + 2[bp], es
10839 3034           5D                                 pop bp
10840                                           ! 1938 endasm
10841                                           !BCC_ENDASM
10842                                           !BCC_EOS
10843                                           ! 1939     current++;
10844                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
10845 3035           8A46         F4            mov	al,-$C[bp]
10846 3038           40                         inc	ax
10847 3039           8846         F4            mov	-$C[bp],al
10848                                           !BCC_EOS
10849                                           ! 1940     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
10850                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
10851 303C           8A46         F4            mov	al,-$C[bp]
10852 303F           30E4                       xor	ah,ah
10853 3041           50                         push	ax
10854                                           ! Debug: list * unsigned short = const $234 (used reg = )
10855 3042           B8                   0234  mov	ax,#$234
10856 3045           50                         push	ax
10857                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10858 3046           FF76         FE            push	-2[bp]
10859                                           ! Debug: func () void = write_word+0 (used reg = )
10860 3049           E8         D5F0            call	_write_word
10861 304C           83C4                   06  add	sp,*6
10862                                           !BCC_EOS
10863                                           ! 1941     count--;
10864                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
10865 304F           8B46         08            mov	ax,8[bp]
10866 3052           48                         dec	ax
10867 3053           8946         08            mov	8[bp],ax
10868                                           !BCC_EOS
10869                                           ! 1942     status = inb(iobase1 + 7);
10870                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10871 3056           8B46         FC            mov	ax,-4[bp]
10872                                           ! Debug: list unsigned int = ax+7 (used reg = )
10873 3059           05                   0007  add	ax,*7
10874 305C           50                         push	ax
10875                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10876 305D           E8         D4E8            call	_inb
10877 3060           44                         inc	sp
10878 3061           44                         inc	sp
10879                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10880 3062           8846         F5            mov	-$B[bp],al
10881                                           !BCC_EOS
10882                                           ! 1943     if (count == 0) {
10883                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
10884 3065           8B46         08            mov	ax,8[bp]
10885 3068           85C0                       test	ax,ax
10886 306A           75           14            jne 	.24E
10887                       0000306C            .24F:
10888                                           ! 1944       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
10889                                           ! 1945           != 0x40 ) {
10890                                           ! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
10891 306C           8A46         F5            mov	al,-$B[bp]
10892 306F           24                     E9  and	al,#$E9
10893                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
10894 3071           3C                     40  cmp	al,*$40
10895 3073           74           07            je  	.250
10896                       00003075            .251:
10897                                           ! 1946         ;
10898                                           !BCC_EOS
10899                                           ! 1947         return 6;
10900 3075           B8                   0006  mov	ax,*6
10901 3078           89EC                       mov	sp,bp
10902 307A           5D                         pop	bp
10903 307B           C3                         ret
10904                                           !BCC_EOS
10905                                           ! 1948         }
10906                                           ! 1949       break;
10907                       0000307C            .250:
10908 307C           EB           17            jmp .24B
10909                                           !BCC_EOS
10910                                           ! 1950       }
10911                                           ! 1951     else {
10912 307E           EB           12            jmp .252
10913                       00003080            .24E:
10914                                           ! 1952       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
10915                                           ! 1953           != (0x40 | 0x08) ) {
10916                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
10917 3080           8A46         F5            mov	al,-$B[bp]
10918 3083           24                     C9  and	al,#$C9
10919                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
10920 3085           3C                     48  cmp	al,*$48
10921 3087           74           07            je  	.253
10922                       00003089            .254:
10923                                           ! 1954         ;
10924                                           !BCC_EOS
10925                                           ! 1955         return 7;
10926 3089           B8                   0007  mov	ax,*7
10927 308C           89EC                       mov	sp,bp
10928 308E           5D                         pop	bp
10929 308F           C3                         ret
10930                                           !BCC_EOS
10931                                           ! 1956       }
10932                                           ! 1957       continue;
10933                       00003090            .253:
10934 3090           EB           00            jmp .24C
10935                                           !BCC_EOS
10936                                           ! 1958     }
10937                                           ! 1959   }
10938                       00003092            .252:
10939                                           ! 1960   outb(iobase2+6, 0x08);
10940                       00003092            .24C:
10941 3092           E9         FF6A            jmp	.24D
10942                       00003095            .255:
10943                       00003095            .24B:
10944                                           ! Debug: list int = const 8 (used reg = )
10945 3095           B8                   0008  mov	ax,*8
10946 3098           50                         push	ax
10947                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10948 3099           8B46         FA            mov	ax,-6[bp]
10949                                           ! Debug: list unsigned int = ax+6 (used reg = )
10950 309C           05                   0006  add	ax,*6
10951 309F           50                         push	ax
10952                                           ! Debug: func () void = outb+0 (used reg = )
10953 30A0           E8         D4BB            call	_outb
10954 30A3           83C4                   04  add	sp,*4
10955                                           !BCC_EOS
10956                                           ! 1961   return 0;
10957 30A6           31C0                       xor	ax,ax
10958 30A8           89EC                       mov	sp,bp
10959 30AA           5D                         pop	bp
10960 30AB           C3                         ret
10961                                           !BCC_EOS
10962                                           ! 1962 }
10963                                           ! 1963 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
10964                                           ! Register BX used in function ata_cmd_data_out
10965                                           ! 1964 Bit8u cmdlen,inout;
10966                                           export	_ata_cmd_packet
10967                       000030AC            _ata_cmd_packet:
10968                                           !BCC_EOS
10969                                           ! 1965 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
10970                                           !BCC_EOS
10971                                           ! 1966 Bit16u header;
10972                                           !BCC_EOS
10973                                           ! 1967 Bit32u length;
10974                                           !BCC_EOS
10975                                           ! 1968 {
10976                                           ! 1969   Bit16u ebda_seg=read_word(0x0040,0x000E);
10977 30AC           55                         push	bp
10978 30AD           89E5                       mov	bp,sp
10979 30AF           4C                         dec	sp
10980 30B0           4C                         dec	sp
10981                                           ! Debug: list int = const $E (used reg = )
10982 30B1           B8                   000E  mov	ax,*$E
10983 30B4           50                         push	ax
10984                                           ! Debug: list int = const $40 (used reg = )
10985 30B5           B8                   0040  mov	ax,*$40
10986 30B8           50                         push	ax
10987                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10988 30B9           E8         D555            call	_read_word
10989 30BC           83C4                   04  add	sp,*4
10990                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10991 30BF           8946         FE            mov	-2[bp],ax
10992                                           !BCC_EOS
10993                                           ! 1970   Bit16u iobase1, iobase2;
10994                                           !BCC_EOS
10995                                           ! 1971   Bit16u lcount, lbefore, lafter, count;
10996                                           !BCC_EOS
10997                                           ! 1972   Bit8u channel, slave;
10998                                           !BCC_EOS
10999                                           ! 1973   Bit8u status, mode, lmode;
11000                                           !BCC_EOS
11001                                           ! 1974   Bit32u total, transfer;
11002                                           !BCC_EOS
11003                                           ! 1975   channel = device / 2;
11004 30C2           83C4                   E6  add	sp,*-$1A
11005                                           ! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
11006 30C5           8B46         04            mov	ax,4[bp]
11007 30C8           D1E8                       shr	ax,*1
11008                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
11009 30CA           8846         F1            mov	-$F[bp],al
11010                                           !BCC_EOS
11011                                           ! 1976   slave = device % 2;
11012                                           ! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
11013 30CD           8B46         04            mov	ax,4[bp]
11014 30D0           24                     01  and	al,*1
11015                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
11016 30D2           8846         F0            mov	-$10[bp],al
11017                                           !BCC_EOS
11018                                           ! 1977   if (inout == 0x02) {
11019                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
11020 30D5           8A46         12            mov	al,$12[bp]
11021 30D8           3C                     02  cmp	al,*2
11022 30DA           75           15            jne 	.256
11023                       000030DC            .257:
11024                                           ! 1978     bios_printf(4, "ata_cmd_packet: DATA_OUT not supported yet\n");
11025                                           ! Debug: list * char = .258+0 (used reg = )
11026 30DC           BB                   D91E  mov	bx,#.258
11027 30DF           53                         push	bx
11028                                           ! Debug: list int = const 4 (used reg = )
11029 30E0           B8                   0004  mov	ax,*4
11030 30E3           50                         push	ax
11031                                           ! Debug: func () void = bios_printf+0 (used reg = )
11032 30E4           E8         D7C2            call	_bios_printf
11033 30E7           83C4                   04  add	sp,*4
11034                                           !BCC_EOS
11035                                           ! 1979     return 1;
11036 30EA           B8                   0001  mov	ax,*1
11037 30ED           89EC                       mov	sp,bp
11038 30EF           5D                         pop	bp
11039 30F0           C3                         ret
11040                                           !BCC_EOS
11041                                           ! 1980     }
11042                                           ! 1981   if (header & 1) {
11043                       000030F1            .256:
11044                                           ! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
11045 30F1           8A46         0C            mov	al,$C[bp]
11046 30F4           24                     01  and	al,*1
11047 30F6           84C0                       test	al,al
11048 30F8           74           07            je  	.259
11049                       000030FA            .25A:
11050                                           ! 1982     ;
11051                                           !BCC_EOS
11052                                           ! 1983     return 1;
11053 30FA           B8                   0001  mov	ax,*1
11054 30FD           89EC                       mov	sp,bp
11055 30FF           5D                         pop	bp
11056 3100           C3                         ret
11057                                           !BCC_EOS
11058                                           ! 1984     }
11059                                           ! 1985   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
11060                       00003101            .259:
11061                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
11062 3101           8A46         F1            mov	al,-$F[bp]
11063 3104           30E4                       xor	ah,ah
11064 3106           B1                     03  mov	cl,*3
11065 3108           D3E0                       shl	ax,cl
11066 310A           89C3                       mov	bx,ax
11067                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
11068                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
11069 310C           81C3                 0124  add	bx,#$124
11070 3110           53                         push	bx
11071                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
11072 3111           FF76         FE            push	-2[bp]
11073                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11074 3114           E8         D4FA            call	_read_word
11075 3117           83C4                   04  add	sp,*4
11076                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
11077 311A           8946         FC            mov	-4[bp],ax
11078                                           !BCC_EOS
11079                                           ! 1986   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
11080                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
11081 311D           8A46         F1            mov	al,-$F[bp]
11082 3120           30E4                       xor	ah,ah
11083 3122           B1                     03  mov	cl,*3
11084 3124           D3E0                       shl	ax,cl
11085 3126           89C3                       mov	bx,ax
11086                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
11087                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
11088 3128           81C3                 0126  add	bx,#$126
11089 312C           53                         push	bx
11090                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
11091 312D           FF76         FE            push	-2[bp]
11092                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11093 3130           E8         D4DE            call	_read_word
11094 3133           83C4                   04  add	sp,*4
11095                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
11096 3136           8946         FA            mov	-6[bp],ax
11097                                           !BCC_EOS
11098                                           ! 1987   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
11099                                           ! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
11100 3139           8B46         04            mov	ax,4[bp]
11101 313C           B9                   001A  mov	cx,*$1A
11102 313F           F7E9                       imul	cx
11103 3141           89C3                       mov	bx,ax
11104                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
11105                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
11106 3143           81C3                 0146  add	bx,#$146
11107 3147           53                         push	bx
11108                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
11109 3148           FF76         FE            push	-2[bp]
11110                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
11111 314B           E8         D4B0            call	_read_byte
11112 314E           83C4                   04  add	sp,*4
11113                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
11114 3151           8846         EE            mov	-$12[bp],al
11115                                           !BCC_EOS
11116                                           ! 1988   transfer= 0L;
11117                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
11118 3154           31C0                       xor	ax,ax
11119 3156           31DB                       xor	bx,bx
11120 3158           8946         E4            mov	-$1C[bp],ax
11121 315B           895E         E6            mov	-$1A[bp],bx
11122                                           !BCC_EOS
11123                                           ! 1989   if (cmdlen < 12) cmdlen=12;
11124                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
11125 315E           8A46         06            mov	al,6[bp]
11126 3161           3C                     0C  cmp	al,*$C
11127 3163           73           05            jae 	.25B
11128                       00003165            .25C:
11129                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
11130 3165           B0                     0C  mov	al,*$C
11131 3167           8846         06            mov	6[bp],al
11132                                           !BCC_EOS
11133                                           ! 1990   if (cmdlen > 12) cmdlen=16;
11134                       0000316A            .25B:
11135                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
11136 316A           8A46         06            mov	al,6[bp]
11137 316D           3C                     0C  cmp	al,*$C
11138 316F           76           05            jbe 	.25D
11139                       00003171            .25E:
11140                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
11141 3171           B0                     10  mov	al,*$10
11142 3173           8846         06            mov	6[bp],al
11143                                           !BCC_EOS
11144                                           ! 1991   cmdlen>>=1;
11145                       00003176            .25D:
11146                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
11147 3176           8A46         06            mov	al,6[bp]
11148 3179           30E4                       xor	ah,ah
11149 317B           D1E8                       shr	ax,*1
11150 317D           8846         06            mov	6[bp],al
11151                                           !BCC_EOS
11152                                           ! 1992   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
11153                                           ! Debug: list int = const 0 (used reg = )
11154 3180           31C0                       xor	ax,ax
11155 3182           50                         push	ax
11156                                           ! Debug: list * unsigned short = const $234 (used reg = )
11157 3183           B8                   0234  mov	ax,#$234
11158 3186           50                         push	ax
11159                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
11160 3187           FF76         FE            push	-2[bp]
11161                                           ! Debug: func () void = write_word+0 (used reg = )
11162 318A           E8         D4AF            call	_write_word
11163 318D           83C4                   06  add	sp,*6
11164                                           !BCC_EOS
11165                                           ! 1993   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
11166                                           ! Debug: list long = const 0 (used reg = )
11167 3190           31C0                       xor	ax,ax
11168 3192           31DB                       xor	bx,bx
11169 3194           53                         push	bx
11170 3195           50                         push	ax
11171                                           ! Debug: list * unsigned long = const $236 (used reg = )
11172 3196           B8                   0236  mov	ax,#$236
11173 3199           50                         push	ax
11174                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
11175 319A           FF76         FE            push	-2[bp]
11176                                           ! Debug: func () void = write_dword+0 (used reg = )
11177 319D           E8         CECC            call	_write_dword
11178 31A0           83C4                   08  add	sp,*8
11179                                           !BCC_EOS
11180                                           ! 1994   status = inb(iobase1 + 7);
11181                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
11182 31A3           8B46         FC            mov	ax,-4[bp]
11183                                           ! Debug: list unsigned int = ax+7 (used reg = )
11184 31A6           05                   0007  add	ax,*7
11185 31A9           50                         push	ax
11186                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11187 31AA           E8         D39B            call	_inb
11188 31AD           44                         inc	sp
11189 31AE           44                         inc	sp
11190                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
11191 31AF           8846         EF            mov	-$11[bp],al
11192                                           !BCC_EOS
11193                                           ! 1995   if (status & 0x80) return 2;
11194                                           ! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
11195 31B2           8A46         EF            mov	al,-$11[bp]
11196 31B5           24                     80  and	al,#$80
11197 31B7           84C0                       test	al,al
11198 31B9           74           07            je  	.25F
11199                       000031BB            .260:
11200 31BB           B8                   0002  mov	ax,*2
11201 31BE           89EC                       mov	sp,bp
11202 31C0           5D                         pop	bp
11203 31C1           C3                         ret
11204                                           !BCC_EOS
11205                                           ! 1996   outb(iobase2 + 6, 0x08 | 0x02);
11206                       000031C2            .25F:
11207                                           ! Debug: list int = const $A (used reg = )
11208 31C2           B8                   000A  mov	ax,*$A
11209 31C5           50                         push	ax
11210                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
11211 31C6           8B46         FA            mov	ax,-6[bp]
11212                                           ! Debug: list unsigned int = ax+6 (used reg = )
11213 31C9           05                   0006  add	ax,*6
11214 31CC           50                         push	ax
11215                                           ! Debug: func () void = outb+0 (used reg = )
11216 31CD           E8         D38E            call	_outb
11217 31D0           83C4                   04  add	sp,*4
11218                                           !BCC_EOS
11219                                           ! 1997   outb(iobase1 + 4, 0xfff0 & 0x00ff);
11220                                           ! Debug: list unsigned int = const $F0 (used reg = )
11221 31D3           B8                   00F0  mov	ax,#$F0
11222 31D6           50                         push	ax
11223                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
11224 31D7           8B46         FC            mov	ax,-4[bp]
11225                                           ! Debug: list unsigned int = ax+4 (used reg = )
11226 31DA           05                   0004  add	ax,*4
11227 31DD           50                         push	ax
11228                                           ! Debug: func () void = outb+0 (used reg = )
11229 31DE           E8         D37D            call	_outb
11230 31E1           83C4                   04  add	sp,*4
11231                                           !BCC_EOS
11232                                           ! 1998   outb(iobase
11233                                           ! 1998 1 + 5, 0xfff0 >> 8);
11234                                           ! Debug: list unsigned int = const $FF (used reg = )
11235 31E4           B8                   00FF  mov	ax,#$FF
11236 31E7           50                         push	ax
11237                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
11238 31E8           8B46         FC            mov	ax,-4[bp]
11239                                           ! Debug: list unsigned int = ax+5 (used reg = )
11240 31EB           05                   0005  add	ax,*5
11241 31EE           50                         push	ax
11242                                           ! Debug: func () void = outb+0 (used reg = )
11243 31EF           E8         D36C            call	_outb
11244 31F2           83C4                   04  add	sp,*4
11245                                           !BCC_EOS
11246                                           ! 1999   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
11247 31F5           8A46         F0            mov	al,-$10[bp]
11248 31F8           84C0                       test	al,al
11249 31FA           74           04            je  	.261
11250                       000031FC            .262:
11251 31FC           B0                     B0  mov	al,#$B0
11252 31FE           EB           02            jmp .263
11253                       00003200            .261:
11254 3200           B0                     A0  mov	al,#$A0
11255                       00003202            .263:
11256                                           ! Debug: list char = al+0 (used reg = )
11257 3202           30E4                       xor	ah,ah
11258 3204           50                         push	ax
11259                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
11260 3205           8B46         FC            mov	ax,-4[bp]
11261                                           ! Debug: list unsigned int = ax+6 (used reg = )
11262 3208           05                   0006  add	ax,*6
11263 320B           50                         push	ax
11264                                           ! Debug: func () void = outb+0 (used reg = )
11265 320C           E8         D34F            call	_outb
11266 320F           83C4                   04  add	sp,*4
11267                                           !BCC_EOS
11268                                           ! 2000   outb(iobase1 + 7, 0xA0);
11269                                           ! Debug: list int = const $A0 (used reg = )
11270 3212           B8                   00A0  mov	ax,#$A0
11271 3215           50                         push	ax
11272                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
11273 3216           8B46         FC            mov	ax,-4[bp]
11274                                           ! Debug: list unsigned int = ax+7 (used reg = )
11275 3219           05                   0007  add	ax,*7
11276 321C           50                         push	ax
11277                                           ! Debug: func () void = outb+0 (used reg = )
11278 321D           E8         D33E            call	_outb
11279 3220           83C4                   04  add	sp,*4
11280                                           !BCC_EOS
11281                                           ! 2001   while (1) {
11282                       00003223            .266:
11283                                           ! 2002     status = inb(iobase1 + 7);
11284                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
11285 3223           8B46         FC            mov	ax,-4[bp]
11286                                           ! Debug: list unsigned int = ax+7 (used reg = )
11287 3226           05                   0007  add	ax,*7
11288 3229           50                         push	ax
11289                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11290 322A           E8         D31B            call	_inb
11291 322D           44                         inc	sp
11292 322E           44                         inc	sp
11293                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
11294 322F           8846         EF            mov	-$11[bp],al
11295                                           !BCC_EOS
11296                                           ! 2003     if ( !(status & 0x80) ) break;
11297                                           ! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
11298 3232           8A46         EF            mov	al,-$11[bp]
11299 3235           24                     80  and	al,#$80
11300 3237           84C0                       test	al,al
11301 3239           75           02            jne 	.267
11302                       0000323B            .268:
11303 323B           EB           02            jmp .264
11304                                           !BCC_EOS
11305                                           ! 2004     }
11306                       0000323D            .267:
11307                                           ! 2005   if (status & 0x01) {
11308                       0000323D            .265:
11309 323D           EB           E4            jmp	.266
11310                       0000323F            .269:
11311                       0000323F            .264:
11312                                           ! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
11313 323F           8A46         EF            mov	al,-$11[bp]
11314 3242           24                     01  and	al,*1
11315 3244           84C0                       test	al,al
11316 3246           74           09            je  	.26A
11317                       00003248            .26B:
11318                                           ! 2006     ;
11319                                           !BCC_EOS
11320                                           ! 2007     return 3;
11321 3248           B8                   0003  mov	ax,*3
11322 324B           89EC                       mov	sp,bp
11323 324D           5D                         pop	bp
11324 324E           C3                         ret
11325                                           !BCC_EOS
11326                                           ! 2008     } else if ( !(status & 0x08) ) {
11327 324F           EB           10            jmp .26C
11328                       00003251            .26A:
11329                                           ! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
11330 3251           8A46         EF            mov	al,-$11[bp]
11331 3254           24                     08  and	al,*8
11332 3256           84C0                       test	al,al
11333 3258           75           07            jne 	.26D
11334                       0000325A            .26E:
11335                                           ! 2009     ;
11336                                           !BCC_EOS
11337                                           ! 2010     return 4;
11338 325A           B8                   0004  mov	ax,*4
11339 325D           89EC                       mov	sp,bp
11340 325F           5D                         pop	bp
11341 3260           C3                         ret
11342                                           !BCC_EOS
11343                                           ! 2011     }
11344                                           ! 2012   cmdseg += (cmdoff / 16);
11345                       00003261            .26D:
11346                       00003261            .26C:
11347                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
11348 3261           8B46         0A            mov	ax,$A[bp]
11349 3264           B1                     04  mov	cl,*4
11350 3266           D3E8                       shr	ax,cl
11351                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
11352 3268           0346         08            add	ax,8[bp]
11353 326B           8946         08            mov	8[bp],ax
11354                                           !BCC_EOS
11355                                           ! 2013   cmdoff %= 16;
11356                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
11357 326E           8B46         0A            mov	ax,$A[bp]
11358 3271           24                     0F  and	al,*$F
11359 3273           30E4                       xor	ah,ah
11360 3275           8946         0A            mov	$A[bp],ax
11361                                           !BCC_EOS
11362                                           ! 2014 #asm
11363                                           !BCC_EOS
11364                                           !BCC_ASM
11365                       00000026            _ata_cmd_packet.cmdoff	set	$26
11366                       0000000A            .ata_cmd_packet.cmdoff	set	$A
11367                       00000028            _ata_cmd_packet.header	set	$28
11368                       0000000C            .ata_cmd_packet.header	set	$C
11369                       0000000E            _ata_cmd_packet.count	set	$E
11370                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
11371                       00000010            _ata_cmd_packet.lafter	set	$10
11372                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
11373                       00000018            _ata_cmd_packet.iobase1	set	$18
11374                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
11375                       0000000D            _ata_cmd_packet.channel	set	$D
11376                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
11377                       00000024            _ata_cmd_packet.cmdseg	set	$24
11378                       00000008            .ata_cmd_packet.cmdseg	set	8
11379                       00000022            _ata_cmd_packet.cmdlen	set	$22
11380                       00000006            .ata_cmd_packet.cmdlen	set	6
11381                       00000009            _ata_cmd_packet.lmode	set	9
11382                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
11383                       00000020            _ata_cmd_packet.device	set	$20
11384                       00000004            .ata_cmd_packet.device	set	4
11385                       0000001A            _ata_cmd_packet.ebda_seg	set	$1A
11386                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
11387                       00000014            _ata_cmd_packet.lcount	set	$14
11388                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
11389                       00000004            _ata_cmd_packet.total	set	4
11390                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
11391                       0000000B            _ata_cmd_packet.status	set	$B
11392                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
11393                       0000000A            _ata_cmd_packet.mode	set	$A
11394                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
11395                       00000032            _ata_cmd_packet.bufoff	set	$32
11396                       00000016            .ata_cmd_packet.bufoff	set	$16
11397                       00000000            _ata_cmd_packet.transfer	set	0
11398                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
11399                       00000016            _ata_cmd_packet.iobase2	set	$16
11400                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
11401                       00000012            _ata_cmd_packet.lbefore	set	$12
11402                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
11403                       00000030            _ata_cmd_packet.bufseg	set	$30
11404                       00000014            .ata_cmd_packet.bufseg	set	$14
11405                       0000000C            _ata_cmd_packet.slave	set	$C
11406                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
11407                       0000002E            _ata_cmd_packet.inout	set	$2E
11408                       00000012            .ata_cmd_packet.inout	set	$12
11409                       0000002A            _ata_cmd_packet.length	set	$2A
11410                       0000000E            .ata_cmd_packet.length	set	$E
11411 3278           FB                               sti ;; enable higher priority interrupts
11412 3279           55                               push bp
11413 327A           89E5                             mov bp, sp
11414 327C           8B76         28                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
11415 327F           8B46         26                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
11416 3282           8B4E         24                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
11417 3285           8EC0                             mov es, ax ;; segment in es
11418 3287           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
11419 328A           26                               seg ES
11420 328B           F3                               rep
11421 328C           6F                                 outsw ;; CX words transfered from port(DX) to ES:[SI]
11422 328D           5D                               pop bp
11423                                           ! 2027 endasm
11424                                           !BCC_ENDASM
11425                                           !BCC_EOS
11426                                           ! 2028   if (inout == 0x00) {
11427                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
11428 328E           8A46         12            mov	al,$12[bp]
11429 3291           84C0                       test	al,al
11430 3293           75           12            jne 	.26F
11431                       00003295            .270:
11432                                           ! 2029     status = inb(iobase1 + 7);
11433                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
11434 3295           8B46         FC            mov	ax,-4[bp]
11435                                           ! Debug: list unsigned int = ax+7 (used reg = )
11436 3298           05                   0007  add	ax,*7
11437 329B           50                         push	ax
11438                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11439 329C           E8         D2A9            call	_inb
11440 329F           44                         inc	sp
11441 32A0           44                         inc	sp
11442                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
11443 32A1           8846         EF            mov	-$11[bp],al
11444                                           !BCC_EOS
11445                                           ! 2030     }
11446                                           ! 2031   else {
11447 32A4           E9         021F            br 	.271
11448                       000032A7            .26F:
11449                                           ! 2032   while (1) {
11450                       000032A7            .274:
11451                                           ! 2033       status = inb(iobase1 + 7);
11452                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
11453 32A7           8B46         FC            mov	ax,-4[bp]
11454                                           ! Debug: list unsigned int = ax+7 (used reg = )
11455 32AA           05                   0007  add	ax,*7
11456 32AD           50                         push	ax
11457                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11458 32AE           E8         D297            call	_inb
11459 32B1           44                         inc	sp
11460 32B2           44                         inc	sp
11461                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
11462 32B3           8846         EF            mov	-$11[bp],al
11463                                           !BCC_EOS
11464                                           ! 2034       if ( (status & (0x80 | 0x08) ) ==0 ) break;
11465                                           ! Debug: and int = const $88 to unsigned char status = [S+$1E-$13] (used reg = )
11466 32B6           8A46         EF            mov	al,-$11[bp]
11467 32B9           24                     88  and	al,#$88
11468                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
11469 32BB           84C0                       test	al,al
11470 32BD           75           03            jne 	.275
11471                       000032BF            .276:
11472 32BF           E9         0204            br 	.272
11473                                           !BCC_EOS
11474                                           ! 2035       if (status & 0x01) {
11475                       000032C2            .275:
11476                                           ! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
11477 32C2           8A46         EF            mov	al,-$11[bp]
11478 32C5           24                     01  and	al,*1
11479 32C7           84C0                       test	al,al
11480 32C9           74           07            je  	.277
11481                       000032CB            .278:
11482                                           ! 2036         ;
11483                                           !BCC_EOS
11484                                           ! 2037         return 3;
11485 32CB           B8                   0003  mov	ax,*3
11486 32CE           89EC                       mov	sp,bp
11487 32D0           5D                         pop	bp
11488 32D1           C3                         ret
11489                                           !BCC_EOS
11490                                           ! 2038       }
11491                                           ! 2039       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11492                       000032D2            .277:
11493                                           ! 2040             != (0x40 | 0x08) ) {
11494                                           ! Debug: and int = const $C9 to unsigned char status = [S+$1E-$13] (used reg = )
11495 32D2           8A46         EF            mov	al,-$11[bp]
11496 32D5           24                     C9  and	al,#$C9
11497                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
11498 32D7           3C                     48  cmp	al,*$48
11499 32D9           74           07            je  	.279
11500                       000032DB            .27A:
11501                                           ! 2041         ;
11502                                           !BCC_EOS
11503                                           ! 2042         return 4;
11504 32DB           B8                   0004  mov	ax,*4
11505 32DE           89EC                       mov	sp,bp
11506 32E0           5D                         pop	bp
11507 32E1           C3                         ret
11508                                           !BCC_EOS
11509                                           ! 2043         }
11510                                           ! 2044       bufseg += (bufoff / 16);
11511                       000032E2            .279:
11512                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$1E+$14] (used reg = )
11513 32E2           8B46         16            mov	ax,$16[bp]
11514 32E5           B1                     04  mov	cl,*4
11515 32E7           D3E8                       shr	ax,cl
11516                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$1E+$12] (used reg = )
11517 32E9           0346         14            add	ax,$14[bp]
11518 32EC           8946         14            mov	$14[bp],ax
11519                                           !BCC_EOS
11520                                           ! 2045       bufoff %= 16;
11521                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$1E+$14] (used reg = )
11522 32EF           8B46         16            mov	ax,$16[bp]
11523 32F2           24                     0F  and	al,*$F
11524 32F4           30E4                       xor	ah,ah
11525 32F6           8946         16            mov	$16[bp],ax
11526                                           !BCC_EOS
11527                                           ! 2046       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
11528                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$1E-6] (used reg = )
11529 32F9           8B46         FC            mov	ax,-4[bp]
11530                                           ! Debug: list unsigned int = ax+4 (used reg = )
11531 32FC           05                   0004  add	ax,*4
11532 32FF           50                         push	ax
11533                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11534 3300           E8         D245            call	_inb
11535 3303           44                         inc	sp
11536 3304           44                         inc	sp
11537 3305           50                         push	ax
11538                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
11539 3306           8B46         FC            mov	ax,-4[bp]
11540                                           ! Debug: list unsigned int = ax+5 (used reg = )
11541 3309           05                   0005  add	ax,*5
11542 330C           50                         push	ax
11543                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11544 330D           E8         D238            call	_inb
11545 3310           44                         inc	sp
11546 3311           44                         inc	sp
11547                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
11548 3312           30E4                       xor	ah,ah
11549                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
11550 3314           88C4                       mov	ah,al
11551 3316           30C0                       xor	al,al
11552                                           ! Debug: add unsigned char (temp) = [S+$20-$20] to unsigned int = ax+0 (used reg = )
11553 3318           0246         E2            add	al,-$1E[bp]
11554 331B           80D4                   00  adc	ah,*0
11555 331E           44                         inc	sp
11556 331F           44                         inc	sp
11557                                           ! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$1E-$A] (used reg = )
11558 3320           8946         F8            mov	-8[bp],ax
11559                                           !BCC_EOS
11560                                           ! 2047       if(header>lcount) {
11561                                           ! Debug: gt unsigned short lcount = [S+$1E-$A] to unsigned short header = [S+$1E+$A] (used reg = )
11562 3323           8B46         0C            mov	ax,$C[bp]
11563 3326           3B46         F8            cmp	ax,-8[bp]
11564 3329           76           16            jbe 	.27B
11565                       0000332B            .27C:
11566                                           ! 2048          lbefore=lcount;
11567                                           ! Debug: eq unsigned short lcount = [S+$1E-$A] to unsigned short lbefore = [S+$1E-$C] (used reg = )
11568 332B           8B46         F8            mov	ax,-8[bp]
11569 332E           8946         F6            mov	-$A[bp],ax
11570                                           !BCC_EOS
11571                                           ! 2049          header-=lcount;
11572                                           ! Debug: subab unsigned short lcount = [S+$1E-$A] to unsigned short header = [S+$1E+$A] (used reg = )
11573 3331           8B46         0C            mov	ax,$C[bp]
11574 3334           2B46         F8            sub	ax,-8[bp]
11575 3337           8946         0C            mov	$C[bp],ax
11576                                           !BCC_EOS
11577                                           ! 2050          lcount=0;
11578                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$1E-$A] (used reg = )
11579 333A           31C0                       xor	ax,ax
11580 333C           8946         F8            mov	-8[bp],ax
11581                                           !BCC_EOS
11582                                           ! 2051          }
11583                                           ! 2052       else {
11584 333F           EB           14            jmp .27D
11585                       00003341            .27B:
11586                                           ! 2053         lbefore=header;
11587                                           ! Debug: eq unsigned short header = [S+$1E+$A] to unsigned short lbefore = [S+$1E-$C] (used reg = )
11588 3341           8B46         0C            mov	ax,$C[bp]
11589 3344           8946         F6            mov	-$A[bp],ax
11590                                           !BCC_EOS
11591                                           ! 2054         header=0;
11592                                           ! Debug: eq int = const 0 to unsigned short header = [S+$1E+$A] (used reg = )
11593 3347           31C0                       xor	ax,ax
11594 3349           8946         0C            mov	$C[bp],ax
11595                                           !BCC_EOS
11596                                           ! 2055         lcount-=lbefore;
11597                                           ! Debug: subab unsigned short lbefore = [S+$1E-$C] to unsigned short lcount = [S+$1E-$A] (used reg = )
11598 334C           8B46         F8            mov	ax,-8[bp]
11599 334F           2B46         F6            sub	ax,-$A[bp]
11600 3352           8946         F8            mov	-8[bp],ax
11601                                           !BCC_EOS
11602                                           ! 2056         }
11603                                           ! 2057       if(lcount>length) {
11604                       00003355            .27D:
11605                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$1E-$A] (used reg = )
11606 3355           8B46         F8            mov	ax,-8[bp]
11607 3358           31DB                       xor	bx,bx
11608                                           ! Debug: gt unsigned long length = [S+$1E+$C] to unsigned long = bx+0 (used reg = )
11609 335A           8D7E         0E            lea	di,$E[bp]
11610 335D           E8         CD3B            call	lcmpul
11611 3360           76           20            jbe 	.27E
11612                       00003362            .27F:
11613                                           ! 2058         lafter=lcount-length;
11614                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$1E-$A] (used reg = )
11615 3362           8B46         F8            mov	ax,-8[bp]
11616 3365           31DB                       xor	bx,bx
11617                                           ! Debug: sub unsigned long length = [S+$1E+$C] to unsigned long = bx+0 (used reg = )
11618 3367           8D7E         0E            lea	di,$E[bp]
11619 336A           E8         CD44            call	lsubul
11620                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$1E-$E] (used reg = )
11621 336D           8946         F4            mov	-$C[bp],ax
11622                                           !BCC_EOS
11623                                           ! 2059         lcount=length;
11624                                           ! Debug: eq unsigned long length = [S+$1E+$C] to unsigned short lcount = [S+$1E-$A] (used reg = )
11625 3370           8B46         0E            mov	ax,$E[bp]
11626 3373           8946         F8            mov	-8[bp],ax
11627                                           !BCC_EOS
11628                                           ! 2060         length=0;
11629                                           ! Debug: eq int = const 0 to unsigned long length = [S+$1E+$C] (used reg = )
11630 3376           31C0                       xor	ax,ax
11631 3378           31DB                       xor	bx,bx
11632 337A           8946         0E            mov	$E[bp],ax
11633 337D           895E         10            mov	$10[bp],bx
11634                                           !BCC_EOS
11635                                           ! 2061         }
11636                                           ! 2062       else {
11637 3380           EB           21            jmp .280
11638                       00003382            .27E:
11639                                           ! 2063         lafter=0;
11640                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$1E-$E] (used reg = )
11641 3382           31C0                       xor	ax,ax
11642 3384           8946         F4            mov	-$C[bp],ax
11643                                           !BCC_EOS
11644                                           ! 2064         length-=lcount;
11645                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$1E-$A] (used reg = )
11646 3387           8B46         F8            mov	ax,-8[bp]
11647 338A           31DB                       xor	bx,bx
11648                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$1E+$C] (used reg = )
11649 338C           53                         push	bx
11650 338D           50                         push	ax
11651 338E           8B46         0E            mov	ax,$E[bp]
11652 3391           8B5E         10            mov	bx,$10[bp]
11653 3394           8D7E         E0            lea	di,-$20[bp]
11654 3397           E8         CD17            call	lsubul
11655 339A           8946         0E            mov	$E[bp],ax
11656 339D           895E         10            mov	$10[bp],bx
11657 33A0           83C4                   04  add	sp,*4
11658                                           !BCC_EOS
11659                                           ! 2065         }
11660                                           ! 2066       count = lcount;
11661                       000033A3            .280:
11662                                           ! Debug: eq unsigned short lcount = [S+$1E-$A] to unsigned short count = [S+$1E-$10] (used reg = )
11663 33A3           8B46         F8            mov	ax,-8[bp]
11664 33A6           8946         F2            mov	-$E[bp],ax
11665                                           !BCC_EOS
11666                                           ! 2067       ;
11667                                           !BCC_EOS
11668                                           ! 2068       ;
11669                                           !BCC_EOS
11670                                           ! 2069       lmode = mode;
11671                                           ! Debug: eq unsigned char mode = [S+$1E-$14] to unsigned char lmode = [S+$1E-$15] (used reg = )
11672 33A9           8A46         EE            mov	al,-$12[bp]
11673 33AC           8846         ED            mov	-$13[bp],al
11674                                           !BCC_EOS
11675                                           ! 2070       if (lbefore & 0x03) lmode=0x00;
11676                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$1E-$C] (used reg = )
11677 33AF           8A46         F6            mov	al,-$A[bp]
11678 33B2           24                     03  and	al,*3
11679 33B4           84C0                       test	al,al
11680 33B6           74           05            je  	.281
11681                       000033B8            .282:
11682                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$1E-$15] (used reg = )
11683 33B8           30C0                       xor	al,al
11684 33BA           8846         ED            mov	-$13[bp],al
11685                                           !BCC_EOS
11686                                           ! 2071       if (lcount & 0x03) lmode=0x00;
11687                       000033BD            .281:
11688                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$1E-$A] (used reg = )
11689 33BD           8A46         F8            mov	al,-8[bp]
11690 33C0           24                     03  and	al,*3
11691 33C2           84C0                       test	al,al
11692 33C4           74           05            je  	.283
11693                       000033C6            .284:
11694                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$1E-$15] (used reg = )
11695 33C6           30C0                       xor	al,al
11696 33C8           8846         ED            mov	-$13[bp],al
11697                                           !BCC_EOS
11698                                           ! 2072       if (lafter & 0x03) lmode=0x00;
11699                       000033CB            .283:
11700                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$1E-$E] (used reg = )
11701 33CB           8A46         F4            mov	al,-$C[bp]
11702 33CE           24                     03  and	al,*3
11703 33D0           84C0                       test	al,al
11704 33D2           74           05            je  	.285
11705                       000033D4            .286:
11706                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$1E-$15] (used reg = )
11707 33D4           30C0                       xor	al,al
11708 33D6           8846         ED            mov	-$13[bp],al
11709                                           !BCC_EOS
11710                                           ! 2073       if (lcount & 0x01) {
11711                       000033D9            .285:
11712                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$1E-$A] (used reg = )
11713 33D9           8A46         F8            mov	al,-8[bp]
11714 33DC           24                     01  and	al,*1
11715 33DE           84C0                       test	al,al
11716 33E0           74           1E            je  	.287
11717                       000033E2            .288:
11718                                           ! 2074         lcount+=1;
11719                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$1E-$A] (used reg = )
11720 33E2           8B46         F8            mov	ax,-8[bp]
11721 33E5           40                         inc	ax
11722 33E6           8946         F8            mov	-8[bp],ax
11723                                           !BCC_EOS
11724                                           ! 2075         if ((lafter > 0) && (lafter & 0x01)) {
11725                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$1E-$E] (used reg = )
11726 33E9           8B46         F4            mov	ax,-$C[bp]
11727 33EC           85C0                       test	ax,ax
11728 33EE           74           10            je  	.289
11729                       000033F0            .28B:
11730                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$1E-$E] (used reg = )
11731 33F0           8A46         F4            mov	al,-$C[bp]
11732 33F3           24                     01  and	al,*1
11733 33F5           84C0                       test	al,al
11734 33F7           74           07            je  	.289
11735                       000033F9            .28A:
11736                                           ! 2076           lafter-=1;
11737                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$1E-$E] (used reg = )
11738 33F9           8B46         F4            mov	ax,-$C[bp]
11739 33FC           48                         dec	ax
11740 33FD           8946         F4            mov	-$C[bp],ax
11741                                           !BCC_EOS
11742                                           ! 2077           }
11743                                           ! 2078         }
11744                       00003400            .289:
11745                                           ! 2079       if (lmode == 0x01) {
11746                       00003400            .287:
11747                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$1E-$15] (used reg = )
11748 3400           8A46         ED            mov	al,-$13[bp]
11749 3403           3C                     01  cmp	al,*1
11750 3405           75           20            jne 	.28C
11751                       00003407            .28D:
11752                                           ! 2080         lcount>>=2; lbefore>>=2; lafter>>=2;
11753                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$1E-$A] (used reg = )
11754 3407           8B46         F8            mov	ax,-8[bp]
11755 340A           D1E8                       shr	ax,*1
11756 340C           D1E8                       shr	ax,*1
11757 340E           8946         F8            mov	-8[bp],ax
11758                                           !BCC_EOS
11759                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$1E-$C] (used reg = )
11760 3411           8B46         F6            mov	ax,-$A[bp]
11761 3414           D1E8                       shr	ax,*1
11762 3416           D1E8                       shr	ax,*1
11763 3418           8946         F6            mov	-$A[bp],ax
11764                                           !BCC_EOS
11765                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$1E-$E] (used reg = )
11766 341B           8B46         F4            mov	ax,-$C[bp]
11767 341E           D1E8                       shr	ax,*1
11768 3420           D1E8                       shr	ax,*1
11769 3422           8946         F4            mov	-$C[bp],ax
11770                                           !BCC_EOS
11771                                           ! 2081         }
11772                                           ! 2082       else {
11773 3425           EB           18            jmp .28E
11774                       00003427            .28C:
11775                                           ! 2083         lcount>>=1; lbefore>>=1; lafter>>=1;
11776                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$1E-$A] (used reg = )
11777 3427           8B46         F8            mov	ax,-8[bp]
11778 342A           D1E8                       shr	ax,*1
11779 342C           8946         F8            mov	-8[bp],ax
11780                                           !BCC_EOS
11781                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$1E-$C] (used reg = )
11782 342F           8B46         F6            mov	ax,-$A[bp]
11783 3432           D1E8                       shr	ax,*1
11784 3434           8946         F6            mov	-$A[bp],ax
11785                                           !BCC_EOS
11786                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$1E-$E] (used reg = )
11787 3437           8B46         F4            mov	ax,-$C[bp]
11788 343A           D1E8                       shr	ax,*1
11789 343C           8946         F4            mov	-$C[bp],ax
11790                                           !BCC_EOS
11791                                           ! 2084         }
11792                                           ! 2085      
11793                                           ! 2085   ;
11794                       0000343F            .28E:
11795                                           !BCC_EOS
11796                                           ! 2086 #asm
11797                                           !BCC_EOS
11798                                           !BCC_ASM
11799                       00000026            _ata_cmd_packet.cmdoff	set	$26
11800                       0000000A            .ata_cmd_packet.cmdoff	set	$A
11801                       00000028            _ata_cmd_packet.header	set	$28
11802                       0000000C            .ata_cmd_packet.header	set	$C
11803                       0000000E            _ata_cmd_packet.count	set	$E
11804                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
11805                       00000010            _ata_cmd_packet.lafter	set	$10
11806                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
11807                       00000018            _ata_cmd_packet.iobase1	set	$18
11808                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
11809                       0000000D            _ata_cmd_packet.channel	set	$D
11810                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
11811                       00000024            _ata_cmd_packet.cmdseg	set	$24
11812                       00000008            .ata_cmd_packet.cmdseg	set	8
11813                       00000022            _ata_cmd_packet.cmdlen	set	$22
11814                       00000006            .ata_cmd_packet.cmdlen	set	6
11815                       00000009            _ata_cmd_packet.lmode	set	9
11816                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
11817                       00000020            _ata_cmd_packet.device	set	$20
11818                       00000004            .ata_cmd_packet.device	set	4
11819                       0000001A            _ata_cmd_packet.ebda_seg	set	$1A
11820                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
11821                       00000014            _ata_cmd_packet.lcount	set	$14
11822                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
11823                       00000004            _ata_cmd_packet.total	set	4
11824                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
11825                       0000000B            _ata_cmd_packet.status	set	$B
11826                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
11827                       0000000A            _ata_cmd_packet.mode	set	$A
11828                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
11829                       00000032            _ata_cmd_packet.bufoff	set	$32
11830                       00000016            .ata_cmd_packet.bufoff	set	$16
11831                       00000000            _ata_cmd_packet.transfer	set	0
11832                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
11833                       00000016            _ata_cmd_packet.iobase2	set	$16
11834                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
11835                       00000012            _ata_cmd_packet.lbefore	set	$12
11836                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
11837                       00000030            _ata_cmd_packet.bufseg	set	$30
11838                       00000014            .ata_cmd_packet.bufseg	set	$14
11839                       0000000C            _ata_cmd_packet.slave	set	$C
11840                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
11841                       0000002E            _ata_cmd_packet.inout	set	$2E
11842                       00000012            .ata_cmd_packet.inout	set	$12
11843                       0000002A            _ata_cmd_packet.length	set	$2A
11844                       0000000E            .ata_cmd_packet.length	set	$E
11845 343F           55                                 push bp
11846 3440           89E5                               mov bp, sp
11847 3442           8B56         1A                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
11848 3445           8B4E         14                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
11849 3448           E3           15                    jcxz ata_packet_no_before
11850 344A           8A66         0B                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11851 344D           80FC                   01          cmp ah, #0x01
11852 3450           74           05                    je ata_packet_in_before_32
11853                       00003452            ata_packet_in_before_16:
11854 3452           ED                                 in ax, dx
11855 3453           E2           FD                    loop ata_packet_in_before_16
11856 3455           EB           08                    jmp ata_packet_no_before
11857                       00003457            ata_packet_in_before_32:
11858 3457     66    50                                 push eax
11859                       00003459            ata_packet_in_before_32_loop:
11860 3459     66    ED                                 in eax, dx
11861 345B           E2           FC                    loop ata_packet_in_before_32_loop
11862 345D     66    58                                 pop eax
11863                       0000345F            ata_packet_no_before:
11864 345F           8B4E         16                    mov cx, _ata_cmd_packet.lcount + 2[bp]
11865 3462           E3           17                    jcxz ata_packet_after
11866 3464           8B7E         34                    mov di, _ata_cmd_packet.bufoff + 2[bp]
11867 3467           8B46         32                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
11868 346A           8EC0                               mov es, ax
11869 346C           8A66         0B                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11870 346F           80FC                   01          cmp ah, #0x01
11871 3472           74           04                    je ata_packet_in_32
11872                       00003474            ata_packet_in_16:
11873 3474           F3                                 rep
11874 3475           6D                                   insw ;; CX words transfered tp port(DX) to ES:[DI]
11875 3476           EB           03                    jmp ata_packet_after
11876                       00003478            ata_packet_in_32:
11877 3478           F3                                 rep
11878 3479     66    6D                                   insd ;; CX dwords transfered to port(DX) to ES:[DI]
11879                       0000347B            ata_packet_after:
11880 347B           8B4E         12                    mov cx, _ata_cmd_packet.lafter + 2[bp]
11881 347E           E3           15                    jcxz ata_packet_done
11882 3480           8A66         0B                    mov ah, _ata_cmd_packet.lmode + 2[bp]
11883 3483           80FC                   01          cmp ah, #0x01
11884 3486           74           05                    je ata_packet_in_after_32
11885                       00003488            ata_packet_in_after_16:
11886 3488           ED                                 in ax, dx
11887 3489           E2           FD                    loop ata_packet_in_after_16
11888 348B           EB           08                    jmp ata_packet_done
11889                       0000348D            ata_packet_in_after_32:
11890 348D     66    50                                 push eax
11891                       0000348F            ata_packet_in_after_32_loop:
11892 348F     66    ED                                 in eax, dx
11893 3491           E2           FC                    loop ata_packet_in_after_32_loop
11894 3493     66    58                                 pop eax
11895                       00003495            ata_packet_done:
11896 3495           5D                                 pop bp
11897                                           ! 2139 endasm
11898                                           !BCC_ENDASM
11899                                           !BCC_EOS
11900                                           ! 2140       bufoff += count;
11901                                           ! Debug: addab unsigned short count = [S+$1E-$10] to unsigned short bufoff = [S+$1E+$14] (used reg = )
11902 3496           8B46         16            mov	ax,$16[bp]
11903 3499           0346         F2            add	ax,-$E[bp]
11904 349C           8946         16            mov	$16[bp],ax
11905                                           !BCC_EOS
11906                                           ! 2141       transfer += count;
11907                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$1E-$10] (used reg = )
11908 349F           8B46         F2            mov	ax,-$E[bp]
11909 34A2           31DB                       xor	bx,bx
11910                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
11911 34A4           8D7E         E4            lea	di,-$1C[bp]
11912 34A7           E8         CBE9            call	laddul
11913 34AA           8946         E4            mov	-$1C[bp],ax
11914 34AD           895E         E6            mov	-$1A[bp],bx
11915                                           !BCC_EOS
11916                                           ! 2142       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
11917                                           ! Debug: list unsigned long transfer = [S+$1E-$1E] (used reg = )
11918 34B0           FF76         E6            push	-$1A[bp]
11919 34B3           FF76         E4            push	-$1C[bp]
11920                                           ! Debug: list * unsigned long = const $236 (used reg = )
11921 34B6           B8                   0236  mov	ax,#$236
11922 34B9           50                         push	ax
11923                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
11924 34BA           FF76         FE            push	-2[bp]
11925                                           ! Debug: func () void = write_dword+0 (used reg = )
11926 34BD           E8         CBAC            call	_write_dword
11927 34C0           83C4                   08  add	sp,*8
11928                                           !BCC_EOS
11929                                           ! 2143       }
11930                                           ! 2144     }
11931                       000034C3            .273:
11932 34C3           E9         FDE1            br 	.274
11933                       000034C6            .28F:
11934                       000034C6            .272:
11935                                           ! 2145   if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
11936                       000034C6            .271:
11937                                           ! 2146          != 0x40 ) {
11938                                           ! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
11939 34C6           8A46         EF            mov	al,-$11[bp]
11940 34C9           24                     E9  and	al,#$E9
11941                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11942 34CB           3C                     40  cmp	al,*$40
11943 34CD           74           07            je  	.290
11944                       000034CF            .291:
11945                                           ! 2147     ;
11946                                           !BCC_EOS
11947                                           ! 2148     return 4;
11948 34CF           B8                   0004  mov	ax,*4
11949 34D2           89EC                       mov	sp,bp
11950 34D4           5D                         pop	bp
11951 34D5           C3                         ret
11952                                           !BCC_EOS
11953                                           ! 2149     }
11954                                           ! 2150   outb(iobase2+6, 0x08);
11955                       000034D6            .290:
11956                                           ! Debug: list int = const 8 (used reg = )
11957 34D6           B8                   0008  mov	ax,*8
11958 34D9           50                         push	ax
11959                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
11960 34DA           8B46         FA            mov	ax,-6[bp]
11961                                           ! Debug: list unsigned int = ax+6 (used reg = )
11962 34DD           05                   0006  add	ax,*6
11963 34E0           50                         push	ax
11964                                           ! Debug: func () void = outb+0 (used reg = )
11965 34E1           E8         D07A            call	_outb
11966 34E4           83C4                   04  add	sp,*4
11967                                           !BCC_EOS
11968                                           ! 2151   return 0;
11969 34E7           31C0                       xor	ax,ax
11970 34E9           89EC                       mov	sp,bp
11971 34EB           5D                         pop	bp
11972 34EC           C3                         ret
11973                                           !BCC_EOS
11974                                           ! 2152 }
11975                                           ! 2153   Bit16u
11976                                           ! Register BX used in function ata_cmd_packet
11977                                           ! 2154 atapi_get_sense(device)
11978                                           ! 2155   Bit16u device;
11979                                           export	_atapi_get_sense
11980                       000034ED            _atapi_get_sense:
11981                                           !BCC_EOS
11982                                           ! 2156 {
11983                                           ! 2157   Bit8u atacmd[12];
11984                                           !BCC_EOS
11985                                           ! 2158   Bit8u buffer[16];
11986                                           !BCC_EOS
11987                                           ! 2159   Bit8u i;
11988                                           !BCC_EOS
11989                                           ! 2160   memsetb(get_SS(),atacmd,0,12);
11990 34ED           55                         push	bp
11991 34EE           89E5                       mov	bp,sp
11992 34F0           83C4                   E2  add	sp,*-$1E
11993                                           ! Debug: list int = const $C (used reg = )
11994 34F3           B8                   000C  mov	ax,*$C
11995 34F6           50                         push	ax
11996                                           ! Debug: list int = const 0 (used reg = )
11997 34F7           31C0                       xor	ax,ax
11998 34F9           50                         push	ax
11999                                           ! Debug: list * unsigned char atacmd = S+$24-$E (used reg = )
12000 34FA           8D5E         F4            lea	bx,-$C[bp]
12001 34FD           53                         push	bx
12002                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12003 34FE           E8         D156            call	_get_SS
12004                                           ! Debug: list unsigned short = ax+0 (used reg = )
12005 3501           50                         push	ax
12006                                           ! Debug: func () void = memsetb+0 (used reg = )
12007 3502           E8         CAFB            call	_memsetb
12008 3505           83C4                   08  add	sp,*8
12009                                           !BCC_EOS
12010                                           ! 2161   atacmd[0]=0x03;
12011                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$20-$E] (used reg = )
12012 3508           B0                     03  mov	al,*3
12013 350A           8846         F4            mov	-$C[bp],al
12014                                           !BCC_EOS
12015                                           ! 2162   atacmd[4]=0x20;
12016                                           ! Debug: eq int = const $20 to unsigned char atacmd = [S+$20-$A] (used reg = )
12017 350D           B0                     20  mov	al,*$20
12018 350F           8846         F8            mov	-8[bp],al
12019                                           !BCC_EOS
12020                                           ! 2163   if (ata_cmd_packet(device, 1
12021                                           ! 2163 2, get_SS(), atacmd, 0, 16L, 0x01, get_SS(), buffer) != 0)
12022                                           ! Debug: list * unsigned char buffer = S+$20-$1E (used reg = )
12023 3512           8D5E         E4            lea	bx,-$1C[bp]
12024 3515           53                         push	bx
12025                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12026 3516           E8         D13E            call	_get_SS
12027                                           ! Debug: list unsigned short = ax+0 (used reg = )
12028 3519           50                         push	ax
12029                                           ! Debug: list int = const 1 (used reg = )
12030 351A           B8                   0001  mov	ax,*1
12031 351D           50                         push	ax
12032                                           ! Debug: list long = const $10 (used reg = )
12033 351E           B8                   0010  mov	ax,*$10
12034 3521           31DB                       xor	bx,bx
12035 3523           53                         push	bx
12036 3524           50                         push	ax
12037                                           ! Debug: list int = const 0 (used reg = )
12038 3525           31C0                       xor	ax,ax
12039 3527           50                         push	ax
12040                                           ! Debug: list * unsigned char atacmd = S+$2C-$E (used reg = )
12041 3528           8D5E         F4            lea	bx,-$C[bp]
12042 352B           53                         push	bx
12043                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12044 352C           E8         D128            call	_get_SS
12045                                           ! Debug: list unsigned short = ax+0 (used reg = )
12046 352F           50                         push	ax
12047                                           ! Debug: list int = const $C (used reg = )
12048 3530           B8                   000C  mov	ax,*$C
12049 3533           50                         push	ax
12050                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
12051 3534           FF76         04            push	4[bp]
12052                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12053 3537           E8         FB72            call	_ata_cmd_packet
12054 353A           83C4                   14  add	sp,*$14
12055                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12056 353D           85C0                       test	ax,ax
12057 353F           74           07            je  	.292
12058                       00003541            .293:
12059                                           ! 2164     return 0x0002;
12060 3541           B8                   0002  mov	ax,*2
12061 3544           89EC                       mov	sp,bp
12062 3546           5D                         pop	bp
12063 3547           C3                         ret
12064                                           !BCC_EOS
12065                                           ! 2165   if ((buffer[0] & 0x7e) == 0x70) {
12066                       00003548            .292:
12067                                           ! Debug: and int = const $7E to unsigned char buffer = [S+$20-$1E] (used reg = )
12068 3548           8A46         E4            mov	al,-$1C[bp]
12069 354B           24                     7E  and	al,*$7E
12070                                           ! Debug: logeq int = const $70 to unsigned char = al+0 (used reg = )
12071 354D           3C                     70  cmp	al,*$70
12072 354F           75           18            jne 	.294
12073                       00003551            .295:
12074                                           ! 2166     return (((Bit16u)buffer[2]&0x0f)*0x100)+buffer[12];
12075                                           ! Debug: cast unsigned short = const 0 to unsigned char buffer = [S+$20-$1C] (used reg = )
12076 3551           8A46         E6            mov	al,-$1A[bp]
12077 3554           30E4                       xor	ah,ah
12078                                           ! Debug: and int = const $F to unsigned short = ax+0 (used reg = )
12079 3556           24                     0F  and	al,*$F
12080                                           ! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
12081 3558           30E4                       xor	ah,ah
12082 355A           B9                   0100  mov	cx,#$100
12083 355D           F7E9                       imul	cx
12084                                           ! Debug: add unsigned char buffer = [S+$20-$12] to unsigned int = ax+0 (used reg = )
12085 355F           0246         F0            add	al,-$10[bp]
12086 3562           80D4                   00  adc	ah,*0
12087                                           ! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
12088 3565           89EC                       mov	sp,bp
12089 3567           5D                         pop	bp
12090 3568           C3                         ret
12091                                           !BCC_EOS
12092                                           ! 2167     }
12093                                           ! 2168   return 0;
12094                       00003569            .294:
12095 3569           31C0                       xor	ax,ax
12096 356B           89EC                       mov	sp,bp
12097 356D           5D                         pop	bp
12098 356E           C3                         ret
12099                                           !BCC_EOS
12100                                           ! 2169 }
12101                                           ! 2170   Bit16u
12102                                           ! Register BX used in function atapi_get_sense
12103                                           ! 2171 atapi_is_ready(device)
12104                                           ! 2172   Bit16u device;
12105                                           export	_atapi_is_ready
12106                       0000356F            _atapi_is_ready:
12107                                           !BCC_EOS
12108                                           ! 2173 {
12109                                           ! 2174   Bit8u atacmd[12];
12110                                           !BCC_EOS
12111                                           ! 2175   Bit8u buffer[];
12112                                           !BCC_EOS
12113                                           ! 2176   memsetb(get_SS(),atacmd,0,12);
12114 356F           55                         push	bp
12115 3570           89E5                       mov	bp,sp
12116 3572           83C4                   F4  add	sp,*-$C
12117                                           ! Debug: list int = const $C (used reg = )
12118 3575           B8                   000C  mov	ax,*$C
12119 3578           50                         push	ax
12120                                           ! Debug: list int = const 0 (used reg = )
12121 3579           31C0                       xor	ax,ax
12122 357B           50                         push	ax
12123                                           ! Debug: list * unsigned char atacmd = S+$12-$E (used reg = )
12124 357C           8D5E         F4            lea	bx,-$C[bp]
12125 357F           53                         push	bx
12126                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12127 3580           E8         D0D4            call	_get_SS
12128                                           ! Debug: list unsigned short = ax+0 (used reg = )
12129 3583           50                         push	ax
12130                                           ! Debug: func () void = memsetb+0 (used reg = )
12131 3584           E8         CA79            call	_memsetb
12132 3587           83C4                   08  add	sp,*8
12133                                           !BCC_EOS
12134                                           ! 2177   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 0L, 0x00, get_SS(), buffer) != 0)
12135                                           ! Debug: list * unsigned char buffer = S+$E-$E (used reg = )
12136 358A           8D5E         F4            lea	bx,-$C[bp]
12137 358D           53                         push	bx
12138                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12139 358E           E8         D0C6            call	_get_SS
12140                                           ! Debug: list unsigned short = ax+0 (used reg = )
12141 3591           50                         push	ax
12142                                           ! Debug: list int = const 0 (used reg = )
12143 3592           31C0                       xor	ax,ax
12144 3594           50                         push	ax
12145                                           ! Debug: list long = const 0 (used reg = )
12146 3595           31C0                       xor	ax,ax
12147 3597           31DB                       xor	bx,bx
12148 3599           53                         push	bx
12149 359A           50                         push	ax
12150                                           ! Debug: list int = const 0 (used reg = )
12151 359B           31C0                       xor	ax,ax
12152 359D           50                         push	ax
12153                                           ! Debug: list * unsigned char atacmd = S+$1A-$E (used reg = )
12154 359E           8D5E         F4            lea	bx,-$C[bp]
12155 35A1           53                         push	bx
12156                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12157 35A2           E8         D0B2            call	_get_SS
12158                                           ! Debug: list unsigned short = ax+0 (used reg = )
12159 35A5           50                         push	ax
12160                                           ! Debug: list int = const $C (used reg = )
12161 35A6           B8                   000C  mov	ax,*$C
12162 35A9           50                         push	ax
12163                                           ! Debug: list unsigned short device = [S+$20+2] (used reg = )
12164 35AA           FF76         04            push	4[bp]
12165                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12166 35AD           E8         FAFC            call	_ata_cmd_packet
12167 35B0           83C4                   14  add	sp,*$14
12168                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12169 35B3           85C0                       test	ax,ax
12170 35B5           74           07            je  	.296
12171                       000035B7            .297:
12172                                           ! 2178     return 0x000f;
12173 35B7           B8                   000F  mov	ax,*$F
12174 35BA           89EC                       mov	sp,bp
12175 35BC           5D                         pop	bp
12176 35BD           C3                         ret
12177                                           !BCC_EOS
12178                                           ! 2179   if (atapi_get_sense(device) !=0 ) {
12179                       000035BE            .296:
12180                                           ! Debug: list unsigned short device = [S+$E+2] (used reg = )
12181 35BE           FF76         04            push	4[bp]
12182                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
12183 35C1           E8         FF29            call	_atapi_get_sense
12184 35C4           44                         inc	sp
12185 35C5           44                         inc	sp
12186                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12187 35C6           85C0                       test	ax,ax
12188 35C8           74           55            je  	.298
12189                       000035CA            .299:
12190                                           ! 2180     memsetb(get_SS(),atacmd,0,12);
12191                                           ! Debug: list int = const $C (used reg = )
12192 35CA           B8                   000C  mov	ax,*$C
12193 35CD           50                         push	ax
12194                                           ! Debug: list int = const 0 (used reg = )
12195 35CE           31C0                       xor	ax,ax
12196 35D0           50                         push	ax
12197                                           ! Debug: list * unsigned char atacmd = S+$12-$E (used reg = )
12198 35D1           8D5E         F4            lea	bx,-$C[bp]
12199 35D4           53                         push	bx
12200                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12201 35D5           E8         D07F            call	_get_SS
12202                                           ! Debug: list unsigned short = ax+0 (used reg = )
12203 35D8           50                         push	ax
12204                                           ! Debug: func () void = memsetb+0 (used reg = )
12205 35D9           E8         CA24            call	_memsetb
12206 35DC           83C4                   08  add	sp,*8
12207                                           !BCC_EOS
12208                                           ! 2181     if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 0L, 0x00, get_SS(), buffer) != 0)
12209                                           ! Debug: list * unsigned char buffer = S+$E-$E (used reg = )
12210 35DF           8D5E         F4            lea	bx,-$C[bp]
12211 35E2           53                         push	bx
12212                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12213 35E3           E8         D071            call	_get_SS
12214                                           ! Debug: list unsigned short = ax+0 (used reg = )
12215 35E6           50                         push	ax
12216                                           ! Debug: list int = const 0 (used reg = )
12217 35E7           31C0                       xor	ax,ax
12218 35E9           50                         push	ax
12219                                           ! Debug: list long = const 0 (used reg = )
12220 35EA           31C0                       xor	ax,ax
12221 35EC           31DB                       xor	bx,bx
12222 35EE           53                         push	bx
12223 35EF           50                         push	ax
12224                                           ! Debug: list int = const 0 (used reg = )
12225 35F0           31C0                       xor	ax,ax
12226 35F2           50                         push	ax
12227                                           ! Debug: list * unsigned char atacmd = S+$1A-$E (used reg = )
12228 35F3           8D5E         F4            lea	bx,-$C[bp]
12229 35F6           53                         push	bx
12230                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12231 35F7           E8         D05D            call	_get_SS
12232                                           ! Debug: list unsigned short = ax+0 (used reg = )
12233 35FA           50                         push	ax
12234                                           ! Debug: list int = const $C (used reg = )
12235 35FB           B8                   000C  mov	ax,*$C
12236 35FE           50                         push	ax
12237                                           ! Debug: list unsigned short device = [S+$20+2] (used reg = )
12238 35FF           FF76         04            push	4[bp]
12239                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12240 3602           E8         FAA7            call	_ata_cmd_packet
12241 3605           83C4                   14  add	sp,*$14
12242                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12243 3608           85C0                       test	ax,ax
12244 360A           74           07            je  	.29A
12245                       0000360C            .29B:
12246                                           ! 2182       return 0x000f;
12247 360C           B8                   000F  mov	ax,*$F
12248 360F           89EC                       mov	sp,bp
12249 3611           5D                         pop	bp
12250 3612           C3                         ret
12251                                           !BCC_EOS
12252                                           ! 2183     return atapi_get_sense(device);
12253                       00003613            .29A:
12254                                           ! Debug: list unsigned short device = [S+$E+2] (used reg = )
12255 3613           FF76         04            push	4[bp]
12256                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
12257 3616           E8         FED4            call	_atapi_get_sense
12258 3619           44                         inc	sp
12259 361A           44                         inc	sp
12260                                           ! Debug: cast unsigned short = const 0 to unsigned short = ax+0 (used reg = )
12261 361B           89EC                       mov	sp,bp
12262 361D           5D                         pop	bp
12263 361E           C3                         ret
12264                                           !BCC_EOS
12265                                           ! 2184     }
12266                                           ! 2185   return 0;
12267                       0000361F            .298:
12268 361F           31C0                       xor	ax,ax
12269 3621           89EC                       mov	sp,bp
12270 3623           5D                         pop	bp
12271 3624           C3                         ret
12272                                           !BCC_EOS
12273                                           ! 2186 }
12274                                           ! 2187   Bit16u
12275                                           ! Register BX used in function atapi_is_ready
12276                                           ! 2188 atapi_is_cdrom(device)
12277                                           ! 2189   Bit8u device;
12278                                           export	_atapi_is_cdrom
12279                       00003625            _atapi_is_cdrom:
12280                                           !BCC_EOS
12281                                           ! 2190 {
12282                                           ! 2191   Bit16u ebda_seg=read_word(0x0040,0x000E);
12283 3625           55                         push	bp
12284 3626           89E5                       mov	bp,sp
12285 3628           4C                         dec	sp
12286 3629           4C                         dec	sp
12287                                           ! Debug: list int = const $E (used reg = )
12288 362A           B8                   000E  mov	ax,*$E
12289 362D           50                         push	ax
12290                                           ! Debug: list int = const $40 (used reg = )
12291 362E           B8                   0040  mov	ax,*$40
12292 3631           50                         push	ax
12293                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12294 3632           E8         CFDC            call	_read_word
12295 3635           83C4                   04  add	sp,*4
12296                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12297 3638           8946         FE            mov	-2[bp],ax
12298                                           !BCC_EOS
12299                                           ! 2192   if (device >= (4*2))
12300                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
12301 363B           8A46         04            mov	al,4[bp]
12302 363E           3C                     08  cmp	al,*8
12303 3640           72           06            jb  	.29C
12304                       00003642            .29D:
12305                                           ! 2193     return 0;
12306 3642           31C0                       xor	ax,ax
12307 3644           89EC                       mov	sp,bp
12308 3646           5D                         pop	bp
12309 3647           C3                         ret
12310                                           !BCC_EOS
12311                                           ! 2194   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
12312                       00003648            .29C:
12313                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
12314 3648           8A46         04            mov	al,4[bp]
12315 364B           30E4                       xor	ah,ah
12316 364D           B9                   001A  mov	cx,*$1A
12317 3650           F7E9                       imul	cx
12318 3652           89C3                       mov	bx,ax
12319                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
12320                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
12321 3654           81C3                 0142  add	bx,#$142
12322 3658           53                         push	bx
12323                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
12324 3659           FF76         FE            push	-2[bp]
12325                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12326 365C           E8         CF9F            call	_read_byte
12327 365F           83C4                   04  add	sp,*4
12328                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
12329 3662           3C                     03  cmp	al,*3
12330 3664           74           06            je  	.29E
12331                       00003666            .29F:
12332                                           ! 2195     return 0;
12333 3666           31C0                       xor	ax,ax
12334 3668           89EC                       mov	sp,bp
12335 366A           5D                         pop	bp
12336 366B           C3                         ret
12337                                           !BCC_EOS
12338                                           ! 2196   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
12339                       0000366C            .29E:
12340                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
12341 366C           8A46         04            mov	al,4[bp]
12342 366F           30E4                       xor	ah,ah
12343 3671           B9                   001A  mov	cx,*$1A
12344 3674           F7E9                       imul	cx
12345 3676           89C3                       mov	bx,ax
12346                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
12347                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
12348 3678           81C3                 0143  add	bx,#$143
12349 367C           53                         push	bx
12350                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
12351 367D           FF76         FE            push	-2[bp]
12352                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12353 3680           E8         CF7B            call	_read_byte
12354 3683           83C4                   04  add	sp,*4
12355                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
12356 3686           3C                     05  cmp	al,*5
12357 3688           74           06            je  	.2A0
12358                       0000368A            .2A1:
12359                                           ! 2197     return 0;
12360 368A           31C0                       xor	ax,ax
12361 368C           89EC                       mov	sp,bp
12362 368E           5D                         pop	bp
12363 368F           C3                         ret
12364                                           !BCC_EOS
12365                                           ! 2198   return 1;
12366                       00003690            .2A0:
12367 3690           B8                   0001  mov	ax,*1
12368 3693           89EC                       mov	sp,bp
12369 3695           5D                         pop	bp
12370 3696           C3                         ret
12371                                           !BCC_EOS
12372                                           ! 2199 }
12373                                           ! 2200   void
12374                                           ! Register BX used in function atapi_is_cdrom
12375                                           ! 2201 cdemu_init()
12376                                           ! 2202 {
12377                                           export	_cdemu_init
12378                       00003697            _cdemu_init:
12379                                           ! 2203   Bit16u ebda_seg=read_word(0x0040,0x000E);
12380 3697           55                         push	bp
12381 3698           89E5                       mov	bp,sp
12382 369A           4C                         dec	sp
12383 369B           4C                         dec	sp
12384                                           ! Debug: list int = const $E (used reg = )
12385 369C           B8                   000E  mov	ax,*$E
12386 369F           50                         push	ax
12387                                           ! Debug: list int = const $40 (used reg = )
12388 36A0           B8                   0040  mov	ax,*$40
12389 36A3           50                         push	ax
12390                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12391 36A4           E8         CF6A            call	_read_word
12392 36A7           83C4                   04  add	sp,*4
12393                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12394 36AA           8946         FE            mov	-2[bp],ax
12395                                           !BCC_EOS
12396                                           ! 2204   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
12397                                           ! Debug: list int = const 0 (used reg = )
12398 36AD           31C0                       xor	ax,ax
12399 36AF           50                         push	ax
12400                                           ! Debug: list * unsigned char = const $23A (used reg = )
12401 36B0           B8                   023A  mov	ax,#$23A
12402 36B3           50                         push	ax
12403                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
12404 36B4           FF76         FE            push	-2[bp]
12405                                           ! Debug: func () void = write_byte+0 (used reg = )
12406 36B7           E8         CF6A            call	_write_byte
12407 36BA           83C4                   06  add	sp,*6
12408                                           !BCC_EOS
12409                                           ! 2205 }
12410 36BD           89EC                       mov	sp,bp
12411 36BF           5D                         pop	bp
12412 36C0           C3                         ret
12413                                           ! 2206   Bit8u
12414                                           ! 2207 cdemu_isactive()
12415                                           ! 2208 {
12416                                           export	_cdemu_isactive
12417                       000036C1            _cdemu_isactive:
12418                                           ! 2209   Bit16u ebda_seg=read_word(0x0040,0x000E);
12419 36C1           55                         push	bp
12420 36C2           89E5                       mov	bp,sp
12421 36C4           4C                         dec	sp
12422 36C5           4C                         dec	sp
12423                                           ! Debug: list int = const $E (used reg = )
12424 36C6           B8                   000E  mov	ax,*$E
12425 36C9           50                         push	ax
12426                                           ! Debug: list int = const $40 (used reg = )
12427 36CA           B8                   0040  mov	ax,*$40
12428 36CD           50                         push	ax
12429                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12430 36CE           E8         CF40            call	_read_word
12431 36D1           83C4                   04  add	sp,*4
12432                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12433 36D4           8946         FE            mov	-2[bp],ax
12434                                           !BCC_EOS
12435                                           ! 2210   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
12436                                           ! Debug: list * unsigned char = const $23A (used reg = )
12437 36D7           B8                   023A  mov	ax,#$23A
12438 36DA           50                         push	ax
12439                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
12440 36DB           FF76         FE            push	-2[bp]
12441                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12442 36DE           E8         CF1D            call	_read_byte
12443 36E1           83C4                   04  add	sp,*4
12444                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
12445 36E4           89EC                       mov	sp,bp
12446 36E6           5D                         pop	bp
12447 36E7           C3                         ret
12448                                           !BCC_EOS
12449                                           ! 2211 }
12450                                           ! 2212   Bit8u
12451                                           ! 2213 cdemu_emulated_drive()
12452                                           ! 2214 {
12453                                           export	_cdemu_emulated_drive
12454                       000036E8            _cdemu_emulated_drive:
12455                                           ! 2215   Bit16u ebda_seg=read_word(0x0040,0x000E);
12456 36E8           55                         push	bp
12457 36E9           89E5                       mov	bp,sp
12458 36EB           4C                         dec	sp
12459 36EC           4C                         dec	sp
12460                                           ! Debug: list int = const $E (used reg = )
12461 36ED           B8                   000E  mov	ax,*$E
12462 36F0           50                         push	ax
12463                                           ! Debug: list int = const $40 (used reg = )
12464 36F1           B8                   0040  mov	ax,*$40
12465 36F4           50                         push	ax
12466                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12467 36F5           E8         CF19            call	_read_word
12468 36F8           83C4                   04  add	sp,*4
12469                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12470 36FB           8946         FE            mov	-2[bp],ax
12471                                           !BCC_EOS
12472                                           ! 2216   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
12473                                           ! Debug: list * unsigned char = const $23C (used reg = )
12474 36FE           B8                   023C  mov	ax,#$23C
12475 3701           50                         push	ax
12476                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
12477 3702           FF76         FE            push	-2[bp]
12478                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12479 3705           E8         CEF6            call	_read_byte
12480 3708           83C4                   04  add	sp,*4
12481                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
12482 370B           89EC                       mov	sp,bp
12483 370D           5D                         pop	bp
12484 370E           C3                         ret
12485                                           !BCC_EOS
12486                                           ! 2217 }
12487                                           ! 2218 static char isotag[6]="CD001";
12488                                           
12489                       0000370F            _isotag:
12490                       0000370F            .2A2:
12491 370F                        43            .ascii	"CD001"
12492 3714                        00            .byte	0
12493                                           !BCC_EOS
12494                                           ! 2219 static char eltorito[24]="EL TORITO SPECIFICATION";
12495                       00003715            _eltorito:
12496                       00003715            .2A3:
12497 3715                        45            .ascii	"EL TORITO SPECIFICATION"
12498 372C                        00            .byte	0
12499                                           !BCC_EOS
12500                                           ! 2220   Bit16u
12501                                           ! 2221 cdrom_boot()
12502                                           ! 2222 {
12503                                           
12504                                           export	_cdrom_boot
12505                       0000372D            _cdrom_boot:
12506                                           ! 2223   Bit16u ebda_seg=read_word(0x0040,0x000E);
12507 372D           55                         push	bp
12508 372E           89E5                       mov	bp,sp
12509 3730           4C                         dec	sp
12510 3731           4C                         dec	sp
12511                                           ! Debug: list int = const $E (used reg = )
12512 3732           B8                   000E  mov	ax,*$E
12513 3735           50                         push	ax
12514                                           ! Debug: list int = const $40 (used reg = )
12515 3736           B8                   0040  mov	ax,*$40
12516 3739           50                         push	ax
12517                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12518 373A           E8         CED4            call	_read_word
12519 373D           83C4                   04  add	sp,*4
12520                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
12521 3740           8946         FE            mov	-2[bp],ax
12522                                           !BCC_EOS
12523                                           ! 2224   Bit8u atacmd[12], buffer[2048];
12524                                           !BCC_EOS
12525                                           ! 2225   Bit32u lba;
12526                                           !BCC_EOS
12527                                           ! 2226   Bit16u boot_segment, nbsectors, i, error;
12528                                           !BCC_EOS
12529                                           ! 2227   Bit8u device;
12530                                           !BCC_EOS
12531                                           ! 2228   for (device=0; device<(4*2);device++) {
12532 3743           81C4                 F7E6  add	sp,#-$81A
12533                                           ! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
12534 3747           30C0                       xor	al,al
12535 3749           8886       F7E5            mov	-$81B[bp],al
12536                                           !BCC_EOS
12537                                           !BCC_EOS
12538 374D           EB           1B            jmp .2A6
12539                       0000374F            .2A7:
12540                                           ! 2229     if (atapi_is_cdrom(device)) break;
12541                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
12542 374F           8A86       F7E5            mov	al,-$81B[bp]
12543 3753           30E4                       xor	ah,ah
12544 3755           50                         push	ax
12545                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
12546 3756           E8         FECC            call	_atapi_is_cdrom
12547 3759           44                         inc	sp
12548 375A           44                         inc	sp
12549 375B           85C0                       test	ax,ax
12550 375D           74           02            je  	.2A8
12551                       0000375F            .2A9:
12552 375F           EB           11            jmp .2A4
12553                                           !BCC_EOS
12554                                           ! 2230     }
12555                       00003761            .2A8:
12556                                           ! 2231   if(device >= (4*2)) return 2;
12557                       00003761            .2A5:
12558                                           ! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
12559 3761           8A86       F7E5            mov	al,-$81B[bp]
12560 3765           40                         inc	ax
12561 3766           8886       F7E5            mov	-$81B[bp],al
12562                       0000376A            .2A6:
12563                                           ! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
12564 376A           8A86       F7E5            mov	al,-$81B[bp]
12565 376E           3C                     08  cmp	al,*8
12566 3770           72           DD            jb 	.2A7
12567                       00003772            .2AA:
12568                       00003772            .2A4:
12569                                           ! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
12570 3772           8A86       F7E5            mov	al,-$81B[bp]
12571 3776           3C                     08  cmp	al,*8
12572 3778           72           07            jb  	.2AB
12573                       0000377A            .2AC:
12574 377A           B8                   0002  mov	ax,*2
12575 377D           89EC                       mov	sp,bp
12576 377F           5D                         pop	bp
12577 3780           C3                         ret
12578                                           !BCC_EOS
12579                                           ! 2232   memsetb(get_SS(),atacmd,0,12);
12580                       00003781            .2AB:
12581                                           ! Debug: list int = const $C (used reg = )
12582 3781           B8                   000C  mov	ax,*$C
12583 3784           50                         push	ax
12584                                           ! Debug: list int = const 0 (used reg = )
12585 3785           31C0                       xor	ax,ax
12586 3787           50                         push	ax
12587                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
12588 3788           8D5E         F2            lea	bx,-$E[bp]
12589 378B           53                         push	bx
12590                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12591 378C           E8         CEC8            call	_get_SS
12592                                           ! Debug: list unsigned short = ax+0 (used reg = )
12593 378F           50                         push	ax
12594                                           ! Debug: func () void = memsetb+0 (used reg = )
12595 3790           E8         C86D            call	_memsetb
12596 3793           83C4                   08  add	sp,*8
12597                                           !BCC_EOS
12598                                           ! 2233   atacmd[0]=0x28;
12599                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
12600 3796           B0                     28  mov	al,*$28
12601 3798           8846         F2            mov	-$E[bp],al
12602                                           !BCC_EOS
12603                                           ! 2234   atacmd[7]=(0x01 & 0xff00) >> 8;
12604                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
12605 379B           30C0                       xor	al,al
12606 379D           8846         F9            mov	-7[bp],al
12607                                           !BCC_EOS
12608                                           ! 2235   atacmd[8]=(0x01 & 0x00ff);
12609                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
12610 37A0           B0                     01  mov	al,*1
12611 37A2           8846         FA            mov	-6[bp],al
12612                                           !BCC_EOS
12613                                           ! 2236   atacmd[2]=(0x11 & 0xff000000) >> 24;
12614                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
12615 37A5           30C0                       xor	al,al
12616 37A7           8846         F4            mov	-$C[bp],al
12617                                           !BCC_EOS
12618                                           ! 2237   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
12619                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
12620 37AA           30C0                       xor	al,al
12621 37AC           8846         F5            mov	-$B[bp],al
12622                                           !BCC_EOS
12623                                           ! 2238   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
12624                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
12625 37AF           30C0                       xor	al,al
12626 37B1           8846         F6            mov	-$A[bp],al
12627                                           !BCC_EOS
12628                                           ! 2239   atacmd[5]=(0x11 
12629                                           ! 2239 & 0x000000ff);
12630                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
12631 37B4           B0                     11  mov	al,*$11
12632 37B6           8846         F7            mov	-9[bp],al
12633                                           !BCC_EOS
12634                                           ! 2240   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
12635                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
12636 37B9           8D9E       F7F2            lea	bx,-$80E[bp]
12637 37BD           53                         push	bx
12638                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12639 37BE           E8         CE96            call	_get_SS
12640                                           ! Debug: list unsigned short = ax+0 (used reg = )
12641 37C1           50                         push	ax
12642                                           ! Debug: list int = const 1 (used reg = )
12643 37C2           B8                   0001  mov	ax,*1
12644 37C5           50                         push	ax
12645                                           ! Debug: list long = const $800 (used reg = )
12646 37C6           B8                   0800  mov	ax,#$800
12647 37C9           31DB                       xor	bx,bx
12648 37CB           53                         push	bx
12649 37CC           50                         push	ax
12650                                           ! Debug: list int = const 0 (used reg = )
12651 37CD           31C0                       xor	ax,ax
12652 37CF           50                         push	ax
12653                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
12654 37D0           8D5E         F2            lea	bx,-$E[bp]
12655 37D3           53                         push	bx
12656                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12657 37D4           E8         CE80            call	_get_SS
12658                                           ! Debug: list unsigned short = ax+0 (used reg = )
12659 37D7           50                         push	ax
12660                                           ! Debug: list int = const $C (used reg = )
12661 37D8           B8                   000C  mov	ax,*$C
12662 37DB           50                         push	ax
12663                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
12664 37DC           8A86       F7E5            mov	al,-$81B[bp]
12665 37E0           30E4                       xor	ah,ah
12666 37E2           50                         push	ax
12667                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12668 37E3           E8         F8C6            call	_ata_cmd_packet
12669 37E6           83C4                   14  add	sp,*$14
12670                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
12671 37E9           8986       F7E6            mov	-$81A[bp],ax
12672                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12673 37ED           85C0                       test	ax,ax
12674 37EF           74           07            je  	.2AD
12675                       000037F1            .2AE:
12676                                           ! 2241     return 3;
12677 37F1           B8                   0003  mov	ax,*3
12678 37F4           89EC                       mov	sp,bp
12679 37F6           5D                         pop	bp
12680 37F7           C3                         ret
12681                                           !BCC_EOS
12682                                           ! 2242   if(buffer[0]!=0)return 4;
12683                       000037F8            .2AD:
12684                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
12685 37F8           8A86       F7F2            mov	al,-$80E[bp]
12686 37FC           84C0                       test	al,al
12687 37FE           74           07            je  	.2AF
12688                       00003800            .2B0:
12689 3800           B8                   0004  mov	ax,*4
12690 3803           89EC                       mov	sp,bp
12691 3805           5D                         pop	bp
12692 3806           C3                         ret
12693                                           !BCC_EOS
12694                                           ! 2243   for(i=0;i<5;i++){
12695                       00003807            .2AF:
12696                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
12697 3807           31C0                       xor	ax,ax
12698 3809           8986       F7E8            mov	-$818[bp],ax
12699                                           !BCC_EOS
12700                                           !BCC_EOS
12701 380D           EB           3B            jmp .2B3
12702                       0000380F            .2B4:
12703                                           ! 2244     if(buffer[1+i]!=read_byte(0xf000,&isotag[i]))return 5;
12704                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
12705 380F           8B9E       F7E8            mov	bx,-$818[bp]
12706                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
12707                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
12708 3813           81C3                 370F  add	bx,#_isotag
12709 3817           53                         push	bx
12710                                           ! Debug: list unsigned int = const $F000 (used reg = )
12711 3818           B8                   F000  mov	ax,#$F000
12712 381B           50                         push	ax
12713                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12714 381C           E8         CDDF            call	_read_byte
12715 381F           83C4                   04  add	sp,*4
12716 3822           50                         push	ax
12717                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
12718                                           ! Debug: expression subtree swapping
12719 3823           8B86       F7E8            mov	ax,-$818[bp]
12720                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
12721 3827           40                         inc	ax
12722 3828           89EB                       mov	bx,bp
12723 382A           01C3                       add	bx,ax
12724                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = [bx-$80E] (used reg = )
12725 382C           8A87       F7F2            mov	al,-$80E[bx]
12726 3830           3A86       F7E2            cmp	al,-$81E[bp]
12727 3834           8DA6       F7E4            lea	sp,-$81C[bp]
12728 3838           74           07            je  	.2B5
12729                       0000383A            .2B6:
12730 383A           B8                   0005  mov	ax,*5
12731 383D           89EC                       mov	sp,bp
12732 383F           5D                         pop	bp
12733 3840           C3                         ret
12734                                           !BCC_EOS
12735                                           ! 2245    }
12736                       00003841            .2B5:
12737                                           ! 2246   for(i=0;i<23;i++)
12738                       00003841            .2B2:
12739                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
12740 3841           8B86       F7E8            mov	ax,-$818[bp]
12741 3845           40                         inc	ax
12742 3846           8986       F7E8            mov	-$818[bp],ax
12743                       0000384A            .2B3:
12744                                           ! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
12745 384A           8B86       F7E8            mov	ax,-$818[bp]
12746 384E           3D                   0005  cmp	ax,*5
12747 3851           72           BC            jb 	.2B4
12748                       00003853            .2B7:
12749                       00003853            .2B1:
12750                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
12751 3853           31C0                       xor	ax,ax
12752 3855           8986       F7E8            mov	-$818[bp],ax
12753                                           !BCC_EOS
12754                                           !BCC_EOS
12755                                           ! 2247     if(buffer[7+i]!=read_byte(0xf000,&eltorito[i]))return 6;
12756 3859           EB           3D            jmp .2BA
12757                       0000385B            .2BB:
12758                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
12759 385B           8B9E       F7E8            mov	bx,-$818[bp]
12760                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
12761                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
12762 385F           81C3                 3715  add	bx,#_eltorito
12763 3863           53                         push	bx
12764                                           ! Debug: list unsigned int = const $F000 (used reg = )
12765 3864           B8                   F000  mov	ax,#$F000
12766 3867           50                         push	ax
12767                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12768 3868           E8         CD93            call	_read_byte
12769 386B           83C4                   04  add	sp,*4
12770 386E           50                         push	ax
12771                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
12772                                           ! Debug: expression subtree swapping
12773 386F           8B86       F7E8            mov	ax,-$818[bp]
12774                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
12775 3873           05                   0007  add	ax,*7
12776 3876           89EB                       mov	bx,bp
12777 3878           01C3                       add	bx,ax
12778                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = [bx-$80E] (used reg = )
12779 387A           8A87       F7F2            mov	al,-$80E[bx]
12780 387E           3A86       F7E2            cmp	al,-$81E[bp]
12781 3882           8DA6       F7E4            lea	sp,-$81C[bp]
12782 3886           74           07            je  	.2BC
12783                       00003888            .2BD:
12784 3888           B8                   0006  mov	ax,*6
12785 388B           89EC                       mov	sp,bp
12786 388D           5D                         pop	bp
12787 388E           C3                         ret
12788                                           !BCC_EOS
12789                                           ! 2248   lba=buffer[0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
12790                       0000388F            .2BC:
12791                       0000388F            .2B9:
12792                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
12793 388F           8B86       F7E8            mov	ax,-$818[bp]
12794 3893           40                         inc	ax
12795 3894           8986       F7E8            mov	-$818[bp],ax
12796                       00003898            .2BA:
12797                                           ! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
12798 3898           8B86       F7E8            mov	ax,-$818[bp]
12799 389C           3D                   0017  cmp	ax,*$17
12800 389F           72           BA            jb 	.2BB
12801                       000038A1            .2BE:
12802                       000038A1            .2B8:
12803                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
12804 38A1           8A86       F839            mov	al,-$7C7[bp]
12805 38A5           30E4                       xor	ah,ah
12806 38A7           31DB                       xor	bx,bx
12807 38A9           53                         push	bx
12808 38AA           50                         push	ax
12809                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
12810 38AB           8A86       F83A            mov	al,-$7C6[bp]
12811 38AF           30E4                       xor	ah,ah
12812 38B1           B9                   0100  mov	cx,#$100
12813 38B4           F7E9                       imul	cx
12814                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
12815 38B6           31DB                       xor	bx,bx
12816 38B8           53                         push	bx
12817 38B9           50                         push	ax
12818                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
12819 38BA           8A86       F83B            mov	al,-$7C5[bp]
12820 38BE           30E4                       xor	ah,ah
12821 38C0           31DB                       xor	bx,bx
12822                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
12823 38C2           53                         push	bx
12824 38C3           50                         push	ax
12825 38C4           31C0                       xor	ax,ax
12826 38C6           BB                   0001  mov	bx,*1
12827 38C9           53                         push	bx
12828 38CA           50                         push	ax
12829 38CB           8B86       F7D8            mov	ax,-$828[bp]
12830 38CF           8B9E       F7DA            mov	bx,-$826[bp]
12831 38D3           8DBE       F7D4            lea	di,-$82C[bp]
12832 38D7           E8         C7DF            call	lmulul
12833 38DA           83C4                   08  add	sp,*8
12834 38DD           53                         push	bx
12835 38DE           50                         push	ax
12836                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
12837 38DF           8A86       F83C            mov	al,-$7C4[bp]
12838 38E3           30E4                       xor	ah,ah
12839 38E5           31DB                       xor	bx,bx
12840                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
12841 38E7           53                         push	bx
12842 38E8           50                         push	ax
12843 38E9           31C0                       xor	ax,ax
12844 38EB           BB                   0100  mov	bx,#$100
12845 38EE           53                         push	bx
12846 38EF           50                         push	ax
12847 38F0           8B86       F7D4            mov	ax,-$82C[bp]
12848 38F4           8B9E       F7D6            mov	bx,-$82A[bp]
12849 38F8           8DBE       F7D0            lea	di,-$830[bp]
12850 38FC           E8         C7BA            call	lmulul
12851 38FF           83C4                   08  add	sp,*8
12852                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
12853 3902           8DBE       F7D8            lea	di,-$828[bp]
12854 3906           E8         C78A            call	laddul
12855 3909           83C4                   04  add	sp,*4
12856                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
12857 390C           8DBE       F7DC            lea	di,-$824[bp]
12858 3910           E8         C780            call	laddul
12859 3913           83C4                   04  add	sp,*4
12860                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
12861 3916           8DBE       F7E0            lea	di,-$820[bp]
12862 391A           E8         C776            call	laddul
12863 391D           83C4                   04  add	sp,*4
12864                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
12865 3920           8986       F7EE            mov	-$812[bp],ax
12866 3924           899E       F7F0            mov	-$810[bp],bx
12867                                           !BCC_EOS
12868                                           ! 2249   memsetb(get_SS(),atacmd,0,12);
12869                                           ! Debug: list int = const $C (used reg = )
12870 3928           B8                   000C  mov	ax,*$C
12871 392B           50                         push	ax
12872                                           ! Debug: list int = const 0 (used reg = )
12873 392C           31C0                       xor	ax,ax
12874 392E           50                         push	ax
12875                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
12876 392F           8D5E         F2            lea	bx,-$E[bp]
12877 3932           53                         push	bx
12878                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12879 3933           E8         CD21            call	_get_SS
12880                                           ! Debug: list unsigned short = ax+0 (used reg = )
12881 3936           50                         push	ax
12882                                           ! Debug: func () void = memsetb+0 (used reg = )
12883 3937           E8         C6C6            call	_memsetb
12884 393A           83C4                   08  add	sp,*8
12885                                           !BCC_EOS
12886                                           ! 2250   atacmd[0]=0x28;
12887                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
12888 393D           B0                     28  mov	al,*$28
12889 393F           8846         F2            mov	-$E[bp],al
12890                                           !BCC_EOS
12891                                           ! 2251   atacmd[7]=(0x01 & 0xff00) >> 8;
12892                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
12893 3942           30C0                       xor	al,al
12894 3944           8846         F9            mov	-7[bp],al
12895                                           !BCC_EOS
12896                                           ! 2252   atacmd[8]=(0x01 & 0x00ff);
12897                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
12898 3947           B0                     01  mov	al,*1
12899 3949           8846         FA            mov	-6[bp],al
12900                                           !BCC_EOS
12901                                           ! 2253   atacmd[2]=(lba & 0xff000000) >> 24;
12902                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
12903                                           ! Debug: expression subtree swapping
12904 394C           31C0                       xor	ax,ax
12905 394E           BB                   FF00  mov	bx,#$FF00
12906 3951           8DBE       F7EE            lea	di,-$812[bp]
12907 3955           E8         C733            call	landul
12908                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
12909 3958           93                         xchg	bx,ax
12910 3959           88E0                       mov	al,ah
12911 395B           30E4                       xor	ah,ah
12912 395D           31DB                       xor	bx,bx
12913                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
12914 395F           8846         F4            mov	-$C[bp],al
12915                                           !BCC_EOS
12916                                           ! 2254   atacmd[3]=(lba & 0x00ff0000) >> 16;
12917                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
12918                                           ! Debug: expression subtree swapping
12919 3962           31C0                       xor	ax,ax
12920 3964           BB                   00FF  mov	bx,#$FF
12921 3967           8DBE       F7EE            lea	di,-$812[bp]
12922 396B           E8         C71D            call	landul
12923                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
12924 396E           93                         xchg	bx,ax
12925 396F           31DB                       xor	bx,bx
12926                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
12927 3971           8846         F5            mov	-$B[bp],al
12928                                           !BCC_EOS
12929                                           ! 2255   atacmd[4]=(lba & 0x0000ff00) >> 8;
12930                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
12931                                           ! Debug: expression subtree swapping
12932 3974           B8                   FF00  mov	ax,#$FF00
12933 3977           31DB                       xor	bx,bx
12934 3979           8DBE       F7EE            lea	di,-$812[bp]
12935 397D           E8         C70B            call	landul
12936                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
12937 3980           88E0                       mov	al,ah
12938 3982           88DC                       mov	ah,bl
12939 3984           88FB                       mov	bl,bh
12940 3986           28FF                       sub	bh,bh
12941                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
12942 3988           8846         F6            mov	-$A[bp],al
12943                                           !BCC_EOS
12944                                           ! 2256   atacmd[5]=(lba & 0x000000ff);
12945                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
12946                                           ! Debug: expression subtree swapping
12947 398B           B8                   00FF  mov	ax,#$FF
12948 398E           31DB                       xor	bx,bx
12949 3990           8DBE       F7EE            lea	di,-$812[bp]
12950 3994           E8         C6F4            call	landul
12951                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
12952 3997           8846         F7            mov	-9[bp],al
12953                                           !BCC_EOS
12954                                           ! 2257   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
12955                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
12956 399A           8D9E       F7F2            lea	bx,-$80E[bp]
12957 399E           53                         push	bx
12958                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12959 399F           E8         CCB5            call	_get_SS
12960                                           ! Debug: list unsigned short = ax+0 (used reg = )
12961 39A2           50                         push	ax
12962                                           ! Debug: list int = const 1 (used reg = )
12963 39A3           B8                   0001  mov	ax,*1
12964 39A6           50                         push	ax
12965                                           ! Debug: list long = const $800 (used reg = )
12966 39A7           B8                   0800  mov	ax,#$800
12967 39AA           31DB                       xor	bx,bx
12968 39AC           53                         push	bx
12969 39AD           50                         push	ax
12970                                           ! Debug: list int = const 0 (used reg = )
12971 39AE           31C0                       xor	ax,ax
12972 39B0           50                         push	ax
12973                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
12974 39B1           8D5E         F2            lea	bx,-$E[bp]
12975 39B4           53                         push	bx
12976                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
12977 39B5           E8         CC9F            call	_get_SS
12978                                           ! Debug: list unsigned short = ax+0 (used reg = )
12979 39B8           50                         push	ax
12980                                           ! Debug: list int = const $C (used reg = )
12981 39B9           B8                   000C  mov	ax,*$C
12982 39BC           50                         push	ax
12983                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
12984 39BD           8A86       F7E5            mov	al,-$81B[bp]
12985 39C1           30E4                       xor	ah,ah
12986 39C3           50                         push	ax
12987                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
12988 39C4           E8         F6E5            call	_ata_cmd_packet
12989 39C7           83C4                   14  add	sp,*$14
12990                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
12991 39CA           8986       F7E6            mov	-$81A[bp],ax
12992                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
12993 39CE           85C0                       test	ax,ax
12994 39D0           74           07            je  	.2BF
12995                       000039D2            .2C0:
12996                                           ! 2258     return 7;
12997 39D2           B8                   0007  mov	ax,*7
12998 39D5           89EC                       mov	sp,bp
12999 39D7           5D                         pop	bp
13000 39D8           C3                         ret
13001                                           !BCC_EOS
13002                                           ! 2259   if(buffer[0x00]!=0x01)return 8;
13003                       000039D9            .2BF:
13004                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
13005 39D9           8A86       F7F2            mov	al,-$80E[bp]
13006 39DD           3C                     01  cmp	al,*1
13007 39DF           74           07            je  	.2C1
13008                       000039E1            .2C2:
13009 39E1           B8                   0008  mov	ax,*8
13010 39E4           89EC                       mov	sp,bp
13011 39E6           5D                         pop	bp
13012 39E7           C3                         ret
13013                                           !BCC_EOS
13014                                           ! 2260   if(buffer[0x01]!=0x00)return 9;
13015                       000039E8            .2C1:
13016                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
13017 39E8           8A86       F7F3            mov	al,-$80D[bp]
13018 39EC           84C0                       test	al,al
13019 39EE           74           07            je  	.2C3
13020                       000039F0            .2C4:
13021 39F0           B8                   0009  mov	ax,*9
13022 39F3           89EC                       mov	sp,bp
13023 39F5           5D                         pop	bp
13024 39F6           C3                         ret
13025                                           !BCC_EOS
13026                                           ! 2261   if(buffer[0x1E]!=0x55)return 10;
13027                       000039F7            .2C3:
13028                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
13029 39F7           8A86       F810            mov	al,-$7F0[bp]
13030 39FB           3C                     55  cmp	al,*$55
13031 39FD           74           07            je  	.2C5
13032                       000039FF            .2C6:
13033 39FF           B8                   000A  mov	ax,*$A
13034 3A02           89EC                       mov	sp,bp
13035 3A04           5D                         pop	bp
13036 3A05           C3                         ret
13037                                           !BCC_EOS
13038                                           ! 2262   if(buffer[0x1F]!=0xAA)return 10;
13039                       00003A06            .2C5:
13040                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
13041 3A06           8A86       F811            mov	al,-$7EF[bp]
13042 3A0A           3C                     AA  cmp	al,#$AA
13043 3A0C           74           07            je  	.2C7
13044                       00003A0E            .2C8:
13045 3A0E           B8                   000A  mov	ax,*$A
13046 3A11           89EC                       mov	sp,bp
13047 3A13           5D                         pop	bp
13048 3A14           C3                         ret
13049                                           !BCC_EOS
13050                                           ! 2263   if(buffer[0x20]!=0x88)return 11;
13051                       00003A15            .2C7:
13052                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
13053 3A15           8A86       F812            mov	al,-$7EE[bp]
13054 3A19           3C                     88  cmp	al,#$88
13055 3A1B           74           07            je  	.2C9
13056                       00003A1D            .2CA:
13057 3A1D           B8                   000B  mov	ax,*$B
13058 3A20           89EC                       mov	sp,bp
13059 3A22           5D                         pop	bp
13060 3A23           C3                         ret
13061                                           !BCC_EOS
13062                                           ! 2264   tcpa_add_bootdevice((Bit32u)1L, (Bit32u)0L);
13063                       00003A24            .2C9:
13064                                           ! Debug: list unsigned long = const 0 (used reg = )
13065 3A24           31C0                       xor	ax,ax
13066 3A26           31DB                       xor	bx,bx
13067 3A28           53                         push	bx
13068 3A29           50                         push	ax
13069                                           ! Debug: list unsigned long = const 1 (used reg = )
13070 3A2A           B8                   0001  mov	ax,*1
13071 3A2D           31DB                       xor	bx,bx
13072 3A2F           53                         push	bx
13073 3A30           50                         push	ax
13074                                           ! Debug: func () void = tcpa_add_bootdevice+0 (used reg = )
13075 3A31           E8         6EAF            call	_tcpa_add_bootdevice
13076 3A34           83C4                   08  add	sp,*8
13077                                           !BCC_EOS
13078                                           ! 2265   tcpa_ipl((Bit32u)2L,(Bit32u)get_SS(),(Bit32u)buffer,(Bit32u)2048L);
13079                                           ! Debug: list unsigned long = const $800 (used reg = )
13080 3A37           B8                   0800  mov	ax,#$800
13081 3A3A           31DB                       xor	bx,bx
13082 3A3C           53                         push	bx
13083 3A3D           50                         push	ax
13084                                           ! Debug: cast unsigned long = const 0 to [$800] unsigned char buffer = S+$822-$810 (used reg = )
13085 3A3E           89E8                       mov	ax,bp
13086 3A40           05                   F7F2  add	ax,#-$80E
13087 3A43           31DB                       xor	bx,bx
13088                                           ! Debug: list unsigned long = bx+0 (used reg = )
13089 3A45           53                         push	bx
13090 3A46           50                         push	ax
13091                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13092 3A47           E8         CC0D            call	_get_SS
13093                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
13094 3A4A           31DB                       xor	bx,bx
13095                                           ! Debug: list unsigned long = bx+0 (used reg = )
13096 3A4C           53                         push	bx
13097 3A4D           50                         push	ax
13098                                           ! Debug: list unsigned long = const 2 (used reg = )
13099 3A4E           B8                   0002  mov	ax,*2
13100 3A51           31DB                       xor	bx,bx
13101 3A53           53                         push	bx
13102 3A54           50                         push	ax
13103                                           ! Debug: func () void = tcpa_ipl+0 (used reg = )
13104 3A55           E8         6E91            call	_tcpa_ipl
13105 3A58           83C4                   10  add	sp,*$10
13106                                           !BCC_EOS
13107                                           ! 2266   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
13108                                           ! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
13109 3A5B           8A86       F813            mov	al,-$7ED[bp]
13110 3A5F           30E4                       xor	ah,ah
13111 3A61           50                         push	ax
13112                                           ! Debug: list * unsigned char = const $23B (used reg = )
13113 3A62           B8                   023B  mov	ax,#$23B
13114 3A65           50                         push	ax
13115                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13116 3A66           FF76         FE            push	-2[bp]
13117                                           ! Debug: func () void = write_byte+0 (used reg = )
13118 3A69           E8         CBB8            call	_write_byte
13119 3A6C           83C4                   06  add	sp,*6
13120                                           !BCC_EOS
13121                                           ! 2267   if(buffer[0x21]==0){
13122                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
13123 3A6F           8A86       F813            mov	al,-$7ED[bp]
13124 3A73           84C0                       test	al,al
13125 3A75           75           13            jne 	.2CB
13126                       00003A77            .2CC:
13127                                           ! 2268     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
13128                                           ! Debug: list int = const $E0 (used reg = )
13129 3A77           B8                   00E0  mov	ax,#$E0
13130 3A7A           50                         push	ax
13131                                           ! Debug: list * unsigned char = const $23C (used reg = )
13132 3A7B           B8                   023C  mov	ax,#$23C
13133 3A7E           50                         push	ax
13134                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13135 3A7F           FF76         FE            push	-2[bp]
13136                                           ! Debug: func () void = write_byte+0 (used reg = )
13137 3A82           E8         CB9F            call	_write_byte
13138 3A85           83C4                   06  add	sp,*6
13139                                           !BCC_EOS
13140                                           ! 2269     }
13141                                           ! 2270   else if(buffer[0x21]<4)
13142 3A88           EB           2B            jmp .2CD
13143                       00003A8A            .2CB:
13144                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
13145 3A8A           8A86       F813            mov	al,-$7ED[bp]
13146 3A8E           3C                     04  cmp	al,*4
13147 3A90           73           12            jae 	.2CE
13148                       00003A92            .2CF:
13149                                           ! 2271     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
13150                                           ! Debug: list int = const 0 (used reg = )
13151 3A92           31C0                       xor	ax,ax
13152 3A94           50                         push	ax
13153                                           ! Debug: list * unsigned char = const $23C (used reg = )
13154 3A95           B8                   023C  mov	ax,#$23C
13155 3A98           50                         push	ax
13156                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13157 3A99           FF76         FE            push	-2[bp]
13158                                           ! Debug: func () void = write_byte+0 (used reg = )
13159 3A9C           E8         CB85            call	_write_byte
13160 3A9F           83C4                   06  add	sp,*6
13161                                           !BCC_EOS
13162                                           ! 2272   else
13163                                           ! 2273     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
13164 3AA2           EB           11            jmp .2D0
13165                       00003AA4            .2CE:
13166                                           ! Debug: list int = const $80 (used reg = )
13167 3AA4           B8                   0080  mov	ax,#$80
13168 3AA7           50                         push	ax
13169                                           ! Debug: list * unsigned char = const $23C (used reg = )
13170 3AA8           B8                   023C  mov	ax,#$23C
13171 3AAB           50                         push	ax
13172                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13173 3AAC           FF76         FE            push	-2[bp]
13174                                           ! Debug: func () void = write_byte+0 (used reg = )
13175 3AAF           E8         CB72            call	_write_byte
13176 3AB2           83C4                   06  add	sp,*6
13177                                           !BCC_EOS
13178                                           ! 2274   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index,device/2);
13179                       00003AB5            .2D0:
13180                       00003AB5            .2CD:
13181                                           ! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
13182 3AB5           8A86       F7E5            mov	al,-$81B[bp]
13183 3AB9           30E4                       xor	ah,ah
13184 3ABB           D1E8                       shr	ax,*1
13185                                           ! Debug: list unsigned int = ax+0 (used reg = )
13186 3ABD           50                         push	ax
13187                                           ! Debug: list * unsigned char = const $23D (used reg = )
13188 3ABE           B8                   023D  mov	ax,#$23D
13189 3AC1           50                         push	ax
13190                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13191 3AC2           FF76         FE            push	-2[bp]
13192                                           ! Debug: func () void = write_byte+0 (used reg = )
13193 3AC5           E8         CB5C            call	_write_byte
13194 3AC8           83C4                   06  add	sp,*6
13195                                           !BCC_EOS
13196                                           ! 2275   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
13197                                           ! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
13198 3ACB           8A86       F7E5            mov	al,-$81B[bp]
13199 3ACF           30E4                       xor	ah,ah
13200 3AD1           24                     01  and	al,*1
13201                                           ! Debug: list unsigned char = al+0 (used reg = )
13202 3AD3           30E4                       xor	ah,ah
13203 3AD5           50                         push	ax
13204                                           ! Debug: list * unsigned short = const $23E (used reg = )
13205 3AD6           B8                   023E  mov	ax,#$23E
13206 3AD9           50                         push	ax
13207                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13208 3ADA           FF76         FE            push	-2[bp]
13209                                           ! Debug: func () void = write_byte+0 (used reg = )
13210 3ADD           E8         CB44            call	_write_byte
13211 3AE0           83C4                   06  add	sp,*6
13212                                           !BCC_EOS
13213                                           ! 2276   boot_segment=buffer[0x23]*0x100+buffer[0x22];
13214                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
13215 3AE3           8A86       F815            mov	al,-$7EB[bp]
13216 3AE7           30E4                       xor	ah,ah
13217 3AE9           B9                   0100  mov	cx,#$100
13218 3AEC           F7E9                       imul	cx
13219                                           ! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
13220 3AEE           0286       F814            add	al,-$7EC[bp]
13221 3AF2           80D4                   00  adc	ah,*0
13222                                           ! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
13223 3AF5           8986       F7EC            mov	-$814[bp],ax
13224                                           !BCC_EOS
13225                                           ! 2277   if(boot_segment==0x0000)boot_segment=0x07C0;
13226                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
13227 3AF9           8B86       F7EC            mov	ax,-$814[bp]
13228 3AFD           85C0                       test	ax,ax
13229 3AFF           75           07            jne 	.2D1
13230                       00003B01            .2D2:
13231                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
13232 3B01           B8                   07C0  mov	ax,#$7C0
13233 3B04           8986       F7EC            mov	-$814[bp],ax
13234                                           !BCC_EOS
13235                                           ! 2278   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
13236                       00003B08            .2D1:
13237                                           ! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
13238 3B08           FFB6       F7EC            push	-$814[bp]
13239                                           ! Debug: list * unsigned short = const $246 (used reg = )
13240 3B0C           B8                   0246  mov	ax,#$246
13241 3B0F           50                         push	ax
13242                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13243 3B10           FF76         FE            push	-2[bp]
13244                                           ! Debug: func () void = write_word+0 (used reg = )
13245 3B13           E8         CB26            call	_write_word
13246 3B16           83C4                   06  add	sp,*6
13247                                           !BCC_EOS
13248                                           ! 2279   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
13249                                           ! Debug: list int = const 0 (used reg = )
13250 3B19           31C0                       xor	ax,ax
13251 3B1B           50                         push	ax
13252                                           ! Debug: list * unsigned short = const $244 (used reg = )
13253 3B1C           B8                   0244  mov	ax,#$244
13254 3B1F           50                         push	ax
13255                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13256 3B20           FF76         FE            push	-2[bp]
13257                                           ! Debug: func () void = write_word+0 (used reg = )
13258 3B23           E8         CB16            call	_write_word
13259 3B26           83C4                   06  add	sp,*6
13260                                           !BCC_EOS
13261                                           ! 2280   nbsectors=buffer[0x27]*0x100+buffer[0x26];
13262                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
13263 3B29           8A86       F819            mov	al,-$7E7[bp]
13264 3B2D           30E4                       xor	ah,ah
13265 3B2F           B9                   0100  mov	cx,#$100
13266 3B32           F7E9                       imul	cx
13267                                           ! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
13268 3B34           0286       F818            add	al,-$7E8[bp]
13269 3B38           80D4                   00  adc	ah,*0
13270                                           ! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
13271 3B3B           8986       F7EA            mov	-$816[bp],ax
13272                                           !BCC_EOS
13273                                           ! 2281   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
13274                                           ! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
13275 3B3F           FFB6       F7EA            push	-$816[bp]
13276                                           ! Debug: list * unsigned short = const $248 (used reg = )
13277 3B43           B8                   0248  mov	ax,#$248
13278 3B46           50                         push	ax
13279                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13280 3B47           FF76         FE            push	-2[bp]
13281                                           ! Debug: func () void = write_word+0 (used reg = )
13282 3B4A           E8         CAEF            call	_write_word
13283 3B4D           83C4                   06  add	sp,*6
13284                                           !BCC_EOS
13285                                           ! 2282   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
13286                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
13287 3B50           8A86       F81A            mov	al,-$7E6[bp]
13288 3B54           30E4                       xor	ah,ah
13289 3B56           31DB                       xor	bx,bx
13290 3B58           53                         push	bx
13291 3B59           50                         push	ax
13292                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
13293 3B5A           8A86       F81B            mov	al,-$7E5[bp]
13294 3B5E           30E4                       xor	ah,ah
13295 3B60           B9                   0100  mov	cx,#$100
13296 3B63           F7E9                       imul	cx
13297                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
13298 3B65           31DB                       xor	bx,bx
13299 3B67           53                         push	bx
13300 3B68           50                         push	ax
13301                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
13302 3B69           8A86       F81C            mov	al,-$7E4[bp]
13303 3B6D           30E4                       xor	ah,ah
13304 3B6F           31DB                       xor	bx,bx
13305                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
13306 3B71           53                         push	bx
13307 3B72           50                         push	ax
13308 3B73           31C0                       xor	ax,ax
13309 3B75           BB                   0001  mov	bx,*1
13310 3B78           53                         push	bx
13311 3B79           50                         push	ax
13312 3B7A           8B86       F7D8            mov	ax,-$828[bp]
13313 3B7E           8B9E       F7DA            mov	bx,-$826[bp]
13314 3B82           8DBE       F7D4            lea	di,-$82C[bp]
13315 3B86           E8         C530            call	lmulul
13316 3B89           83C4                   08  add	sp,*8
13317 3B8C           53                         push	bx
13318 3B8D           50                         push	ax
13319                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
13320 3B8E           8A86       F81D            mov	al,-$7E3[bp]
13321 3B92           30E4                       xor	ah,ah
13322 3B94           31DB                       xor	bx,bx
13323                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
13324 3B96           53                         push	bx
13325 3B97           50                         push	ax
13326 3B98           31C0                       xor	ax,ax
13327 3B9A           BB                   0100  mov	bx,#$100
13328 3B9D           53                         push	bx
13329 3B9E           50                         push	ax
13330 3B9F           8B86       F7D4            mov	ax,-$82C[bp]
13331 3BA3           8B9E       F7D6            mov	bx,-$82A[bp]
13332 3BA7           8DBE       F7D0            lea	di,-$830[bp]
13333 3BAB           E8         C50B            call	lmulul
13334 3BAE           83C4                   08  add	sp,*8
13335                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
13336 3BB1           8DBE       F7D8            lea	di,-$828[bp]
13337 3BB5           E8         C4DB            call	laddul
13338 3BB8           83C4                   04  add	sp,*4
13339                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
13340 3BBB           8DBE       F7DC            lea	di,-$824[bp]
13341 3BBF           E8         C4D1            call	laddul
13342 3BC2           83C4                   04  add	sp,*4
13343                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
13344 3BC5           8DBE       F7E0            lea	di,-$820[bp]
13345 3BC9           E8         C4C7            call	laddul
13346 3BCC           83C4                   04  add	sp,*4
13347                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
13348 3BCF           8986       F7EE            mov	-$812[bp],ax
13349 3BD3           899E       F7F0            mov	-$810[bp],bx
13350                                           !BCC_EOS
13351                                           ! 2283   write_dword(ebda_seg,&
13352                                           ! 2283 ((ebda_data_t *) 0)->cdemu.ilba,lba);
13353                                           ! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
13354 3BD7           FFB6       F7F0            push	-$810[bp]
13355 3BDB           FFB6       F7EE            push	-$812[bp]
13356                                           ! Debug: list * unsigned long = const $240 (used reg = )
13357 3BDF           B8                   0240  mov	ax,#$240
13358 3BE2           50                         push	ax
13359                                           ! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
13360 3BE3           FF76         FE            push	-2[bp]
13361                                           ! Debug: func () void = write_dword+0 (used reg = )
13362 3BE6           E8         C483            call	_write_dword
13363 3BE9           83C4                   08  add	sp,*8
13364                                           !BCC_EOS
13365                                           ! 2284   memsetb(get_SS(),atacmd,0,12);
13366                                           ! Debug: list int = const $C (used reg = )
13367 3BEC           B8                   000C  mov	ax,*$C
13368 3BEF           50                         push	ax
13369                                           ! Debug: list int = const 0 (used reg = )
13370 3BF0           31C0                       xor	ax,ax
13371 3BF2           50                         push	ax
13372                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
13373 3BF3           8D5E         F2            lea	bx,-$E[bp]
13374 3BF6           53                         push	bx
13375                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13376 3BF7           E8         CA5D            call	_get_SS
13377                                           ! Debug: list unsigned short = ax+0 (used reg = )
13378 3BFA           50                         push	ax
13379                                           ! Debug: func () void = memsetb+0 (used reg = )
13380 3BFB           E8         C402            call	_memsetb
13381 3BFE           83C4                   08  add	sp,*8
13382                                           !BCC_EOS
13383                                           ! 2285   atacmd[0]=0x28;
13384                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
13385 3C01           B0                     28  mov	al,*$28
13386 3C03           8846         F2            mov	-$E[bp],al
13387                                           !BCC_EOS
13388                                           ! 2286   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
13389                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
13390 3C06           8B86       F7EA            mov	ax,-$816[bp]
13391                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
13392 3C0A           48                         dec	ax
13393 3C0B           D1E8                       shr	ax,*1
13394 3C0D           D1E8                       shr	ax,*1
13395                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
13396                                           ! Debug: expression subtree swapping
13397                                           ! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
13398 3C0F           40                         inc	ax
13399 3C10           30C0                       xor	al,al
13400                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
13401 3C12           88E0                       mov	al,ah
13402 3C14           30E4                       xor	ah,ah
13403                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
13404 3C16           8846         F9            mov	-7[bp],al
13405                                           !BCC_EOS
13406                                           ! 2287   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
13407                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
13408 3C19           8B86       F7EA            mov	ax,-$816[bp]
13409                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
13410 3C1D           48                         dec	ax
13411 3C1E           D1E8                       shr	ax,*1
13412 3C20           D1E8                       shr	ax,*1
13413                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
13414                                           ! Debug: expression subtree swapping
13415                                           ! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
13416 3C22           40                         inc	ax
13417                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
13418 3C23           8846         FA            mov	-6[bp],al
13419                                           !BCC_EOS
13420                                           ! 2288   atacmd[2]=(lba & 0xff000000) >> 24;
13421                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
13422                                           ! Debug: expression subtree swapping
13423 3C26           31C0                       xor	ax,ax
13424 3C28           BB                   FF00  mov	bx,#$FF00
13425 3C2B           8DBE       F7EE            lea	di,-$812[bp]
13426 3C2F           E8         C459            call	landul
13427                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
13428 3C32           93                         xchg	bx,ax
13429 3C33           88E0                       mov	al,ah
13430 3C35           30E4                       xor	ah,ah
13431 3C37           31DB                       xor	bx,bx
13432                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
13433 3C39           8846         F4            mov	-$C[bp],al
13434                                           !BCC_EOS
13435                                           ! 2289   atacmd[3]=(lba & 0x00ff0000) >> 16;
13436                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
13437                                           ! Debug: expression subtree swapping
13438 3C3C           31C0                       xor	ax,ax
13439 3C3E           BB                   00FF  mov	bx,#$FF
13440 3C41           8DBE       F7EE            lea	di,-$812[bp]
13441 3C45           E8         C443            call	landul
13442                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
13443 3C48           93                         xchg	bx,ax
13444 3C49           31DB                       xor	bx,bx
13445                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
13446 3C4B           8846         F5            mov	-$B[bp],al
13447                                           !BCC_EOS
13448                                           ! 2290   atacmd[4]=(lba & 0x0000ff00) >> 8;
13449                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
13450                                           ! Debug: expression subtree swapping
13451 3C4E           B8                   FF00  mov	ax,#$FF00
13452 3C51           31DB                       xor	bx,bx
13453 3C53           8DBE       F7EE            lea	di,-$812[bp]
13454 3C57           E8         C431            call	landul
13455                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
13456 3C5A           88E0                       mov	al,ah
13457 3C5C           88DC                       mov	ah,bl
13458 3C5E           88FB                       mov	bl,bh
13459 3C60           28FF                       sub	bh,bh
13460                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
13461 3C62           8846         F6            mov	-$A[bp],al
13462                                           !BCC_EOS
13463                                           ! 2291   atacmd[5]=(lba & 0x000000ff);
13464                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
13465                                           ! Debug: expression subtree swapping
13466 3C65           B8                   00FF  mov	ax,#$FF
13467 3C68           31DB                       xor	bx,bx
13468 3C6A           8DBE       F7EE            lea	di,-$812[bp]
13469 3C6E           E8         C41A            call	landul
13470                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
13471 3C71           8846         F7            mov	-9[bp],al
13472                                           !BCC_EOS
13473                                           ! 2292   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
13474                                           ! Debug: list int = const 0 (used reg = )
13475 3C74           31C0                       xor	ax,ax
13476 3C76           50                         push	ax
13477                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
13478 3C77           FFB6       F7EC            push	-$814[bp]
13479                                           ! Debug: list int = const 1 (used reg = )
13480 3C7B           B8                   0001  mov	ax,*1
13481 3C7E           50                         push	ax
13482                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
13483 3C7F           8B86       F7EA            mov	ax,-$816[bp]
13484 3C83           31DB                       xor	bx,bx
13485                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
13486 3C85           53                         push	bx
13487 3C86           50                         push	ax
13488 3C87           B8                   0200  mov	ax,#$200
13489 3C8A           31DB                       xor	bx,bx
13490 3C8C           53                         push	bx
13491 3C8D           50                         push	ax
13492 3C8E           8B86       F7DA            mov	ax,-$826[bp]
13493 3C92           8B9E       F7DC            mov	bx,-$824[bp]
13494 3C96           8DBE       F7D6            lea	di,-$82A[bp]
13495 3C9A           E8         C41C            call	lmulul
13496 3C9D           83C4                   08  add	sp,*8
13497                                           ! Debug: list unsigned long = bx+0 (used reg = )
13498 3CA0           53                         push	bx
13499 3CA1           50                         push	ax
13500                                           ! Debug: list int = const 0 (used reg = )
13501 3CA2           31C0                       xor	ax,ax
13502 3CA4           50                         push	ax
13503                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
13504 3CA5           8D5E         F2            lea	bx,-$E[bp]
13505 3CA8           53                         push	bx
13506                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13507 3CA9           E8         C9AB            call	_get_SS
13508                                           ! Debug: list unsigned short = ax+0 (used reg = )
13509 3CAC           50                         push	ax
13510                                           ! Debug: list int = const $C (used reg = )
13511 3CAD           B8                   000C  mov	ax,*$C
13512 3CB0           50                         push	ax
13513                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
13514 3CB1           8A86       F7E5            mov	al,-$81B[bp]
13515 3CB5           30E4                       xor	ah,ah
13516 3CB7           50                         push	ax
13517                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13518 3CB8           E8         F3F1            call	_ata_cmd_packet
13519 3CBB           83C4                   14  add	sp,*$14
13520                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
13521 3CBE           8986       F7E6            mov	-$81A[bp],ax
13522                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13523 3CC2           85C0                       test	ax,ax
13524 3CC4           74           07            je  	.2D3
13525                       00003CC6            .2D4:
13526                                           ! 2293     return 12;
13527 3CC6           B8                   000C  mov	ax,*$C
13528 3CC9           89EC                       mov	sp,bp
13529 3CCB           5D                         pop	bp
13530 3CCC           C3                         ret
13531                                           !BCC_EOS
13532                                           ! 2294   tcpa_ipl((Bit32u)1L,(Bit32u)boot_segment,(Bit32u)0L,(Bit32u)512L);
13533                       00003CCD            .2D3:
13534                                           ! Debug: list unsigned long = const $200 (used reg = )
13535 3CCD           B8                   0200  mov	ax,#$200
13536 3CD0           31DB                       xor	bx,bx
13537 3CD2           53                         push	bx
13538 3CD3           50                         push	ax
13539                                           ! Debug: list unsigned long = const 0 (used reg = )
13540 3CD4           31C0                       xor	ax,ax
13541 3CD6           31DB                       xor	bx,bx
13542 3CD8           53                         push	bx
13543 3CD9           50                         push	ax
13544                                           ! Debug: cast unsigned long = const 0 to unsigned short boot_segment = [S+$826-$816] (used reg = )
13545 3CDA           8B86       F7EC            mov	ax,-$814[bp]
13546 3CDE           31DB                       xor	bx,bx
13547                                           ! Debug: list unsigned long = bx+0 (used reg = )
13548 3CE0           53                         push	bx
13549 3CE1           50                         push	ax
13550                                           ! Debug: list unsigned long = const 1 (used reg = )
13551 3CE2           B8                   0001  mov	ax,*1
13552 3CE5           31DB                       xor	bx,bx
13553 3CE7           53                         push	bx
13554 3CE8           50                         push	ax
13555                                           ! Debug: func () void = tcpa_ipl+0 (used reg = )
13556 3CE9           E8         6BFD            call	_tcpa_ipl
13557 3CEC           83C4                   10  add	sp,*$10
13558                                           !BCC_EOS
13559                                           ! 2295   switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
13560                                           ! Debug: list * unsigned char = const $23B (used reg = )
13561 3CEF           B8                   023B  mov	ax,#$23B
13562 3CF2           50                         push	ax
13563                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
13564 3CF3           FF76         FE            push	-2[bp]
13565                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13566 3CF6           E8         C905            call	_read_byte
13567 3CF9           83C4                   04  add	sp,*4
13568 3CFC           E9         0120            br 	.2D7
13569                                           ! 2296     case 0x01:
13570                                           ! 2297       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
13571                       00003CFF            .2D8:
13572                                           ! Debug: list int = const $F (used reg = )
13573 3CFF           B8                   000F  mov	ax,*$F
13574 3D02           50                         push	ax
13575                                           ! Debug: list * unsigned short = const $24E (used reg = )
13576 3D03           B8                   024E  mov	ax,#$24E
13577 3D06           50                         push	ax
13578                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13579 3D07           FF76         FE            push	-2[bp]
13580                                           ! Debug: func () void = write_word+0 (used reg = )
13581 3D0A           E8         C92F            call	_write_word
13582 3D0D           83C4                   06  add	sp,*6
13583                                           !BCC_EOS
13584                                           ! 2298       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
13585                                           ! Debug: list int = const $50 (used reg = )
13586 3D10           B8                   0050  mov	ax,*$50
13587 3D13           50                         push	ax
13588                                           ! Debug: list * unsigned short = const $24C (used reg = )
13589 3D14           B8                   024C  mov	ax,#$24C
13590 3D17           50                         push	ax
13591                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13592 3D18           FF76         FE            push	-2[bp]
13593                                           ! Debug: func () void = write_word+0 (used reg = )
13594 3D1B           E8         C91E            call	_write_word
13595 3D1E           83C4                   06  add	sp,*6
13596                                           !BCC_EOS
13597                                           ! 2299       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
13598                                           ! Debug: list int = const 2 (used reg = )
13599 3D21           B8                   0002  mov	ax,*2
13600 3D24           50                         push	ax
13601                                           ! Debug: list * unsigned short = const $24A (used reg = )
13602 3D25           B8                   024A  mov	ax,#$24A
13603 3D28           50                         push	ax
13604                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13605 3D29           FF76         FE            push	-2[bp]
13606                                           ! Debug: func () void = write_word+0 (used reg = )
13607 3D2C           E8         C90D            call	_write_word
13608 3D2F           83C4                   06  add	sp,*6
13609                                           !BCC_EOS
13610                                           ! 2300       break;
13611 3D32           E9         0102            br 	.2D5
13612                                           !BCC_EOS
13613                                           ! 2301     case 0x02:
13614                                           ! 2302       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
13615                       00003D35            .2D9:
13616                                           ! Debug: list int = const $12 (used reg = )
13617 3D35           B8                   0012  mov	ax,*$12
13618 3D38           50                         push	ax
13619                                           ! Debug: list * unsigned short = const $24E (used reg = )
13620 3D39           B8                   024E  mov	ax,#$24E
13621 3D3C           50                         push	ax
13622                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13623 3D3D           FF76         FE            push	-2[bp]
13624                                           ! Debug: func () void = write_word+0 (used reg = )
13625 3D40           E8         C8F9            call	_write_word
13626 3D43           83C4                   06  add	sp,*6
13627                                           !BCC_EOS
13628                                           ! 2303       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
13629                                           ! Debug: list int = const $50 (used reg = )
13630 3D46           B8                   0050  mov	ax,*$50
13631 3D49           50                         push	ax
13632                                           ! Debug: list * unsigned short = const $24C (used reg = )
13633 3D4A           B8                   024C  mov	ax,#$24C
13634 3D4D           50                         push	ax
13635                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13636 3D4E           FF76         FE            push	-2[bp]
13637                                           ! Debug: func () void = write_word+0 (used reg = )
13638 3D51           E8         C8E8            call	_write_word
13639 3D54           83C4                   06  add	sp,*6
13640                                           !BCC_EOS
13641                                           ! 2304       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
13642                                           ! Debug: list int = const 2 (used reg = )
13643 3D57           B8                   0002  mov	ax,*2
13644 3D5A           50                         push	ax
13645                                           ! Debug: list * unsigned short = const $24A (used reg = )
13646 3D5B           B8                   024A  mov	ax,#$24A
13647 3D5E           50                         push	ax
13648                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13649 3D5F           FF76         FE            push	-2[bp]
13650                                           ! Debug: func () void = write_word+0 (used reg = )
13651 3D62           E8         C8D7            call	_write_word
13652 3D65           83C4                   06  add	sp,*6
13653                                           !BCC_EOS
13654                                           ! 2305       break;
13655 3D68           E9         00CC            br 	.2D5
13656                                           !BCC_EOS
13657                                           ! 2306     case 0x03:
13658                                           ! 2307       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
13659                       00003D6B            .2DA:
13660                                           ! Debug: list int = const $24 (used reg = )
13661 3D6B           B8                   0024  mov	ax,*$24
13662 3D6E           50                         push	ax
13663                                           ! Debug: list * unsigned short = const $24E (used reg = )
13664 3D6F           B8                   024E  mov	ax,#$24E
13665 3D72           50                         push	ax
13666                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13667 3D73           FF76         FE            push	-2[bp]
13668                                           ! Debug: func () void = write_word+0 (used reg = )
13669 3D76           E8         C8C3            call	_write_word
13670 3D79           83C4                   06  add	sp,*6
13671                                           !BCC_EOS
13672                                           ! 2308       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
13673                                           ! Debug: list int = const $50 (used reg = )
13674 3D7C           B8                   0050  mov	ax,*$50
13675 3D7F           50                         push	ax
13676                                           ! Debug: list * unsigned short = const $24C (used reg = )
13677 3D80           B8                   024C  mov	ax,#$24C
13678 3D83           50                         push	ax
13679                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13680 3D84           FF76         FE            push	-2[bp]
13681                                           ! Debug: func () void = write_word+0 (used reg = )
13682 3D87           E8         C8B2            call	_write_word
13683 3D8A           83C4                   06  add	sp,*6
13684                                           !BCC_EOS
13685                                           ! 2309       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
13686                                           ! Debug: list int = const 2 (used reg = )
13687 3D8D           B8                   0002  mov	ax,*2
13688 3D90           50                         push	ax
13689                                           ! Debug: list * unsigned short = const $24A (used reg = )
13690 3D91           B8                   024A  mov	ax,#$24A
13691 3D94           50                         push	ax
13692                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13693 3D95           FF76         FE            push	-2[bp]
13694                                           ! Debug: func () void = write_word+0 (used reg = )
13695 3D98           E8         C8A1            call	_write_word
13696 3D9B           83C4                   06  add	sp,*6
13697                                           !BCC_EOS
13698                                           ! 2310       break;
13699 3D9E           E9         0096            br 	.2D5
13700                                           !BCC_EOS
13701                                           ! 2311     case 0x04:
13702                                           ! 2312       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
13703                       00003DA1            .2DB:
13704                                           ! Debug: list int = const $1C4 (used reg = )
13705 3DA1           B8                   01C4  mov	ax,#$1C4
13706 3DA4           50                         push	ax
13707                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
13708 3DA5           FFB6       F7EC            push	-$814[bp]
13709                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13710 3DA9           E8         C852            call	_read_byte
13711 3DAC           83C4                   04  add	sp,*4
13712                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
13713 3DAF           24                     3F  and	al,*$3F
13714                                           ! Debug: list unsigned char = al+0 (used reg = )
13715 3DB1           30E4                       xor	ah,ah
13716 3DB3           50                         push	ax
13717                                           ! Debug: list * unsigned short = const $24E (used reg = )
13718 3DB4           B8                   024E  mov	ax,#$24E
13719 3DB7           50                         push	ax
13720                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13721 3DB8           FF76         FE            push	-2[bp]
13722                                           ! Debug: func () void = write_word+0 (used reg = )
13723 3DBB           E8         C87E            call	_write_word
13724 3DBE           83C4                   06  add	sp,*6
13725                                           !BCC_EOS
13726                                           ! 2313       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
13727                                           ! 2314        (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
13728                                           ! Debug: list int = const $1C5 (used reg = )
13729 3DC1           B8                   01C5  mov	ax,#$1C5
13730 3DC4           50                         push	ax
13731                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
13732 3DC5           FFB6       F7EC            push	-$814[bp]
13733                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13734 3DC9           E8         C832            call	_read_byte
13735 3DCC           83C4                   04  add	sp,*4
13736 3DCF           50                         push	ax
13737                                           ! Debug: list int = const $1C4 (used reg = )
13738 3DD0           B8                   01C4  mov	ax,#$1C4
13739 3DD3           50                         push	ax
13740                                           ! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
13741 3DD4           FFB6       F7EC            push	-$814[bp]
13742                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13743 3DD8           E8         C823            call	_read_byte
13744 3DDB           83C4                   04  add	sp,*4
13745                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
13746 3DDE           30E4                       xor	ah,ah
13747 3DE0           D1E0                       shl	ax,*1
13748 3DE2           D1E0                       shl	ax,*1
13749                                           ! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
13750 3DE4           0286       F7E2            add	al,0+..FFF8[bp]
13751 3DE8           80D4                   00  adc	ah,*0
13752 3DEB           44                         inc	sp
13753 3DEC           44                         inc	sp
13754                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
13755                                           ! Debug: list unsigned int = ax+1 (used reg = )
13756 3DED           40                         inc	ax
13757 3DEE           50                         push	ax
13758                                           ! Debug: list * unsigned short = const $24C (used reg = )
13759 3DEF           B8                   024C  mov	ax,#$24C
13760 3DF2           50                         push	ax
13761                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13762 3DF3           FF76         FE            push	-2[bp]
13763                                           ! Debug: func () void = write_word+0 (used reg = )
13764 3DF6           E8         C843            call	_write_word
13765 3DF9           83C4                   06  add	sp,*6
13766                                           !BCC_EOS
13767                                           ! 2315       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
13768                                           ! Debug: list int = const $1C3 (used reg = )
13769 3DFC           B8                   01C3  mov	ax,#$1C3
13770 3DFF           50                         push	ax
13771                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
13772 3E00           FFB6       F7EC            push	-$814[bp]
13773                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13774 3E04           E8         C7F7            call	_read_byte
13775 3E07           83C4                   04  add	sp,*4
13776                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
13777 3E0A           30E4                       xor	ah,ah
13778                                           ! Debug: list unsigned int = ax+1 (used reg = )
13779 3E0C           40                         inc	ax
13780 3E0D           50                         push	ax
13781                                           ! Debug: list * unsigned short = const $24A (used reg = )
13782 3E0E           B8                   024A  mov	ax,#$24A
13783 3E11           50                         push	ax
13784                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13785 3E12           FF76         FE            push	-2[bp]
13786                                           ! Debug: func () void = write_word+0 (used reg = )
13787 3E15           E8         C824            call	_write_word
13788 3E18           83C4                   06  add	sp,*6
13789                                           !BCC_EOS
13790                                           ! 2316       break;
13791 3E1B           EB           1A            jmp .2D5
13792                                           !BCC_EOS
13793                                           ! 2317    }
13794                                           ! 2318   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
13795 3E1D           EB           18            jmp .2D5
13796                       00003E1F            .2D7:
13797 3E1F           2C                     01  sub	al,*1
13798 3E21         0F84         FEDA            beq 	.2D8
13799 3E25           2C                     01  sub	al,*1
13800 3E27         0F84         FF0A            beq 	.2D9
13801 3E2B           2C                     01  sub	al,*1
13802 3E2D         0F84         FF3A            beq 	.2DA
13803 3E31           2C                     01  sub	al,*1
13804 3E33         0F84         FF6A            beq 	.2DB
13805                       00003E37            .2D5:
13806                       FFFFF7E2            ..FFF8	=	-$81E
13807                                           ! Debug: list * unsigned char = const $23B (used reg = )
13808 3E37           B8                   023B  mov	ax,#$23B
13809 3E3A           50                         push	ax
13810                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
13811 3E3B           FF76         FE            push	-2[bp]
13812                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13813 3E3E           E8         C7BD            call	_read_byte
13814 3E41           83C4                   04  add	sp,*4
13815                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
13816 3E44           84C0                       test	al,al
13817 3E46           74           52            je  	.2DC
13818                       00003E48            .2DD:
13819                                           ! 2319     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
13820                                           ! Debug: list * unsigned char = const $23C (used reg = )
13821 3E48           B8                   023C  mov	ax,#$23C
13822 3E4B           50                         push	ax
13823                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
13824 3E4C           FF76         FE            push	-2[bp]
13825                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13826 3E4F           E8         C7AC            call	_read_byte
13827 3E52           83C4                   04  add	sp,*4
13828                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
13829 3E55           84C0                       test	al,al
13830 3E57           75           23            jne 	.2DE
13831                       00003E59            .2DF:
13832                                           ! 2320       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
13833                                           ! Debug: list int = const $10 (used reg = )
13834 3E59           B8                   0010  mov	ax,*$10
13835 3E5C           50                         push	ax
13836                                           ! Debug: list int = const $40 (used reg = )
13837 3E5D           B8                   0040  mov	ax,*$40
13838 3E60           50                         push	ax
13839                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13840 3E61           E8         C79A            call	_read_byte
13841 3E64           83C4                   04  add	sp,*4
13842                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
13843 3E67           0C                     41  or	al,*$41
13844                                           ! Debug: list unsigned char = al+0 (used reg = )
13845 3E69           30E4                       xor	ah,ah
13846 3E6B           50                         push	ax
13847                                           ! Debug: list int = const $10 (used reg = )
13848 3E6C           B8                   0010  mov	ax,*$10
13849 3E6F           50                         push	ax
13850                                           ! Debug: list int = const $40 (used reg = )
13851 3E70           B8                   0040  mov	ax,*$40
13852 3E73           50                         push	ax
13853                                           ! Debug: func () void = write_byte+0 (used reg = )
13854 3E74           E8         C7AD            call	_write_byte
13855 3E77           83C4                   06  add	sp,*6
13856                                           !BCC_EOS
13857                                           ! 2321     else
13858                                           ! 2322       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1)
13859 3E7A           EB           1E            jmp .2E0
13860                       00003E7C            .2DE:
13861                                           ! 2322 ;
13862                                           ! Debug: list * unsigned char = const $212 (used reg = )
13863 3E7C           B8                   0212  mov	ax,#$212
13864 3E7F           50                         push	ax
13865                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
13866 3E80           FF76         FE            push	-2[bp]
13867                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13868 3E83           E8         C778            call	_read_byte
13869 3E86           83C4                   04  add	sp,*4
13870                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
13871 3E89           30E4                       xor	ah,ah
13872                                           ! Debug: list unsigned int = ax+1 (used reg = )
13873 3E8B           40                         inc	ax
13874 3E8C           50                         push	ax
13875                                           ! Debug: list * unsigned char = const $212 (used reg = )
13876 3E8D           B8                   0212  mov	ax,#$212
13877 3E90           50                         push	ax
13878                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13879 3E91           FF76         FE            push	-2[bp]
13880                                           ! Debug: func () void = write_byte+0 (used reg = )
13881 3E94           E8         C78D            call	_write_byte
13882 3E97           83C4                   06  add	sp,*6
13883                                           !BCC_EOS
13884                                           ! 2323    }
13885                       00003E9A            .2E0:
13886                                           ! 2324   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
13887                       00003E9A            .2DC:
13888                                           ! Debug: list * unsigned char = const $23B (used reg = )
13889 3E9A           B8                   023B  mov	ax,#$23B
13890 3E9D           50                         push	ax
13891                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
13892 3E9E           FF76         FE            push	-2[bp]
13893                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13894 3EA1           E8         C75A            call	_read_byte
13895 3EA4           83C4                   04  add	sp,*4
13896                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
13897 3EA7           84C0                       test	al,al
13898 3EA9           74           11            je  	.2E1
13899                       00003EAB            .2E2:
13900                                           ! 2325     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
13901                                           ! Debug: list int = const 1 (used reg = )
13902 3EAB           B8                   0001  mov	ax,*1
13903 3EAE           50                         push	ax
13904                                           ! Debug: list * unsigned char = const $23A (used reg = )
13905 3EAF           B8                   023A  mov	ax,#$23A
13906 3EB2           50                         push	ax
13907                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
13908 3EB3           FF76         FE            push	-2[bp]
13909                                           ! Debug: func () void = write_byte+0 (used reg = )
13910 3EB6           E8         C76B            call	_write_byte
13911 3EB9           83C4                   06  add	sp,*6
13912                                           !BCC_EOS
13913                                           ! 2326   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
13914                       00003EBC            .2E1:
13915                                           ! Debug: list * unsigned char = const $23C (used reg = )
13916 3EBC           B8                   023C  mov	ax,#$23C
13917 3EBF           50                         push	ax
13918                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
13919 3EC0           FF76         FE            push	-2[bp]
13920                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13921 3EC3           E8         C738            call	_read_byte
13922 3EC6           83C4                   04  add	sp,*4
13923                                           ! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
13924 3EC9           30E4                       xor	ah,ah
13925 3ECB           B9                   0100  mov	cx,#$100
13926 3ECE           F7E9                       imul	cx
13927                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
13928                                           ! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
13929 3ED0           89EC                       mov	sp,bp
13930 3ED2           5D                         pop	bp
13931 3ED3           C3                         ret
13932                                           !BCC_EOS
13933                                           ! 2327 }
13934                                           ! 2328   void
13935                                           ! Register BX used in function cdrom_boot
13936                                           ! 2329 int14_function(regs, ds, iret_addr)
13937                                           ! 2330   pusha_regs_t regs;
13938                                           export	_int14_function
13939                       00003ED4            _int14_function:
13940                                           !BCC_EOS
13941                                           ! 2331   Bit16u ds;
13942                                           !BCC_EOS
13943                                           ! 2332   iret_addr_t iret_addr;
13944                                           !BCC_EOS
13945                                           ! 2333 {
13946                                           ! 2334   Bit16u addr,timer,val16;
13947                                           !BCC_EOS
13948                                           ! 2335   Bit8u timeout;
13949                                           !BCC_EOS
13950                                           ! 2336 #asm
13951 3ED4           55                         push	bp
13952 3ED5           89E5                       mov	bp,sp
13953 3ED7           83C4                   F8  add	sp,*-8
13954                                           !BCC_EOS
13955                                           !BCC_ASM
13956                       0000001C            _int14_function.ds	set	$1C
13957                       00000014            .int14_function.ds	set	$14
13958                       00000004            _int14_function.timer	set	4
13959                       FFFFFFFC            .int14_function.timer	set	-4
13960                       00000001            _int14_function.timeout	set	1
13961                       FFFFFFF9            .int14_function.timeout	set	-7
13962                       0000001E            _int14_function.iret_addr	set	$1E
13963                       00000016            .int14_function.iret_addr	set	$16
13964                       00000006            _int14_function.addr	set	6
13965                       FFFFFFFE            .int14_function.addr	set	-2
13966                       00000002            _int14_function.val16	set	2
13967                       FFFFFFFA            .int14_function.val16	set	-6
13968                       0000000C            _int14_function.regs	set	$C
13969                       00000004            .int14_function.regs	set	4
13970 3EDA           FB                           sti
13971                                           ! 2338 endasm
13972                                           !BCC_ENDASM
13973                                           !BCC_EOS
13974                                           ! 2339   addr = read_word(0x0040, (regs.u.r16.dx << 1));
13975                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
13976 3EDB           8B46         0E            mov	ax,$E[bp]
13977 3EDE           D1E0                       shl	ax,*1
13978                                           ! Debug: list unsigned int = ax+0 (used reg = )
13979 3EE0           50                         push	ax
13980                                           ! Debug: list int = const $40 (used reg = )
13981 3EE1           B8                   0040  mov	ax,*$40
13982 3EE4           50                         push	ax
13983                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13984 3EE5           E8         C729            call	_read_word
13985 3EE8           83C4                   04  add	sp,*4
13986                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
13987 3EEB           8946         FE            mov	-2[bp],ax
13988                                           !BCC_EOS
13989                                           ! 2340   timeout = read_byte(0x0040, 0x007C + regs.u.r16.dx);
13990                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
13991                                           ! Debug: expression subtree swapping
13992 3EEE           8B46         0E            mov	ax,$E[bp]
13993                                           ! Debug: list unsigned int = ax+$7C (used reg = )
13994 3EF1           05                   007C  add	ax,*$7C
13995 3EF4           50                         push	ax
13996                                           ! Debug: list int = const $40 (used reg = )
13997 3EF5           B8                   0040  mov	ax,*$40
13998 3EF8           50                         push	ax
13999                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14000 3EF9           E8         C702            call	_read_byte
14001 3EFC           83C4                   04  add	sp,*4
14002                                           ! Debug: eq unsigned char = al+0 to unsigned char timeout = [S+$A-9] (used reg = )
14003 3EFF           8846         F9            mov	-7[bp],al
14004                                           !BCC_EOS
14005                                           ! 2341   if ((regs.u.r16.dx < 4) && (addr > 0)) {
14006                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
14007 3F02           8B46         0E            mov	ax,$E[bp]
14008 3F05           3D                   0004  cmp	ax,*4
14009 3F08         0F83         022C            bhis	.2E3
14010                       00003F0C            .2E5:
14011                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
14012 3F0C           8B46         FE            mov	ax,-2[bp]
14013 3F0F           85C0                       test	ax,ax
14014 3F11         0F84         0223            beq 	.2E3
14015                       00003F15            .2E4:
14016                                           ! 2342     switch (regs.u.r8.ah) {
14017 3F15           8A46         13            mov	al,$13[bp]
14018 3F18           E9         0203            br 	.2E8
14019                                           ! 2343       case 0:
14020                                           ! 2344         outb(addr+3, inb(addr+3) | 0x80);
14021                       00003F1B            .2E9:
14022                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
14023 3F1B           8B46         FE            mov	ax,-2[bp]
14024                                           ! Debug: list unsigned int = ax+3 (used reg = )
14025 3F1E           05                   0003  add	ax,*3
14026 3F21           50                         push	ax
14027                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14028 3F22           E8         C623            call	_inb
14029 3F25           44                         inc	sp
14030 3F26           44                         inc	sp
14031                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
14032 3F27           0C                     80  or	al,#$80
14033                                           ! Debug: list unsigned char = al+0 (used reg = )
14034 3F29           30E4                       xor	ah,ah
14035 3F2B           50                         push	ax
14036                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
14037 3F2C           8B46         FE            mov	ax,-2[bp]
14038                                           ! Debug: list unsigned int = ax+3 (used reg = )
14039 3F2F           05                   0003  add	ax,*3
14040 3F32           50                         push	ax
14041                                           ! Debug: func () void = outb+0 (used reg = )
14042 3F33           E8         C628            call	_outb
14043 3F36           83C4                   04  add	sp,*4
14044                                           !BCC_EOS
14045                                           ! 2345         if (regs.u.r8.al & 0xE0 == 0) {
14046                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
14047 3F39           8A46         12            mov	al,$12[bp]
14048 3F3C           30C0                       xor	al,al
14049 3F3E           84C0                       test	al,al
14050 3F40           74           1E            je  	.2EA
14051                       00003F42            .2EB:
14052                                           ! 2346           outb(addr, 0x17);
14053                                           ! Debug: list int = const $17 (used reg = )
14054 3F42           B8                   0017  mov	ax,*$17
14055 3F45           50                         push	ax
14056                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
14057 3F46           FF76         FE            push	-2[bp]
14058                                           ! Debug: func () void = outb+0 (used reg = )
14059 3F49           E8         C612            call	_outb
14060 3F4C           83C4                   04  add	sp,*4
14061                                           !BCC_EOS
14062                                           ! 2347           outb(addr+1, 0x04);
14063                                           ! Debug: list int = const 4 (used reg = )
14064 3F4F           B8                   0004  mov	ax,*4
14065 3F52           50                         push	ax
14066                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
14067 3F53           8B46         FE            mov	ax,-2[bp]
14068                                           ! Debug: list unsigned int = ax+1 (used reg = )
14069 3F56           40                         inc	ax
14070 3F57           50                         push	ax
14071                                           ! Debug: func () void = outb+0 (used reg = )
14072 3F58           E8         C603            call	_outb
14073 3F5B           83C4                   04  add	sp,*4
14074                                           !BCC_EOS
14075                                           ! 2348         } else {
14076 3F5E           EB           39            jmp .2EC
14077                       00003F60            .2EA:
14078                                           ! 2349           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
14079                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
14080 3F60           8A46         12            mov	al,$12[bp]
14081 3F63           24                     E0  and	al,#$E0
14082                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
14083 3F65           30E4                       xor	ah,ah
14084 3F67           B1                     05  mov	cl,*5
14085 3F69           D3E8                       shr	ax,cl
14086                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
14087 3F6B           89C3                       mov	bx,ax
14088 3F6D           B8                   0600  mov	ax,#$600
14089 3F70           89D9                       mov	cx,bx
14090 3F72           D3F8                       sar	ax,cl
14091                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
14092 3F74           8946         FA            mov	-6[bp],ax
14093                                           !BCC_EOS
14094                                           ! 2350           outb(addr, val16 & 0xFF);
14095                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
14096 3F77           8A46         FA            mov	al,-6[bp]
14097                                           ! Debug: list unsigned char = al+0 (used reg = )
14098 3F7A           30E4                       xor	ah,ah
14099 3F7C           50                         push	ax
14100                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
14101 3F7D           FF76         FE            push	-2[bp]
14102                                           ! Debug: func () void = outb+0 (used reg = )
14103 3F80           E8         C5DB            call	_outb
14104 3F83           83C4                   04  add	sp,*4
14105                                           !BCC_EOS
14106                                           ! 2351           outb(addr+1, val16 >> 8);
14107                                           ! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
14108 3F86           8B46         FA            mov	ax,-6[bp]
14109 3F89           88E0                       mov	al,ah
14110 3F8B           30E4                       xor	ah,ah
14111                                           ! Debug: list unsigned int = ax+0 (used reg = )
14112 3F8D           50                         push	ax
14113                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
14114 3F8E           8B46         FE            mov	ax,-2[bp]
14115                                           ! Debug: list unsigned int = ax+1 (used reg = )
14116 3F91           40                         inc	ax
14117 3F92           50                         push	ax
14118                                           ! Debug: func () void = outb+0 (used reg = )
14119 3F93           E8         C5C8            call	_outb
14120 3F96           83C4                   04  add	sp,*4
14121                                           !BCC_EOS
14122                                           ! 2352         }
14123                                           ! 2353         outb(addr+3, regs.u.r8.al & 0x1F);
14124                       00003F99            .2EC:
14125                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
14126 3F99           8A46         12            mov	al,$12[bp]
14127 3F9C           24                     1F  and	al,*$1F
14128                                           ! Debug: list unsigned char = al+0 (used reg = )
14129 3F9E           30E4                       xor	ah,ah
14130 3FA0           50                         push	ax
14131                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
14132 3FA1           8B46         FE            mov	ax,-2[bp]
14133                                           ! Debug: list unsigned int = ax+3 (used reg = )
14134 3FA4           05                   0003  add	ax,*3
14135 3FA7           50                         push	ax
14136                                           ! Debug: func () void = outb+0 (used reg = )
14137 3FA8           E8         C5B3            call	_outb
14138 3FAB           83C4                   04  add	sp,*4
14139                                           !BCC_EOS
14140                                           ! 2354         regs.u.r8.ah = inb(addr+5);
14141                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
14142 3FAE           8B46         FE            mov	ax,-2[bp]
14143                                           ! Debug: list unsigned int = ax+5 (used reg = )
14144 3FB1           05                   0005  add	ax,*5
14145 3FB4           50                         push	ax
14146                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14147 3FB5           E8         C590            call	_inb
14148 3FB8           44                         inc	sp
14149 3FB9           44                         inc	sp
14150                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
14151 3FBA           8846         13            mov	$13[bp],al
14152                                           !BCC_EOS
14153                                           ! 2355         regs.u.r8.al = inb(addr+6);
14154                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
14155 3FBD           8B46         FE            mov	ax,-2[bp]
14156                                           ! Debug: list unsigned int = ax+6 (used reg = )
14157 3FC0           05                   0006  add	ax,*6
14158 3FC3           50                         push	ax
14159                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14160 3FC4           E8         C581            call	_inb
14161 3FC7           44                         inc	sp
14162 3FC8           44                         inc	sp
14163                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
14164 3FC9           8846         12            mov	$12[bp],al
14165                                           !BCC_EOS
14166                                           ! 2356         iret_addr.flags.u.r8.flagsl &= 0xfe;
14167                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
14168 3FCC           8A46         1A            mov	al,$1A[bp]
14169 3FCF           24                     FE  and	al,#$FE
14170 3FD1           8846         1A            mov	$1A[bp],al
14171                                           !BCC_EOS
14172                                           ! 2357         break;
14173 3FD4           E9         015F            br 	.2E6
14174                                           !BCC_EOS
14175                                           ! 2358       case 1:
14176                                           ! 2359         timer = read_word(0x0040, 0x006C);
14177                       00003FD7            .2ED:
14178                                           ! Debug: list int = const $6C (used reg = )
14179 3FD7           B8                   006C  mov	ax,*$6C
14180 3FDA           50                         push	ax
14181                                           ! Debug: list int = const $40 (used reg = )
14182 3FDB           B8                   0040  mov	ax,*$40
14183 3FDE           50                         push	ax
14184                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
14185 3FDF           E8         C62F            call	_read_word
14186 3FE2           83C4                   04  add	sp,*4
14187                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
14188 3FE5           8946         FC            mov	-4[bp],ax
14189                                           !BCC_EOS
14190                                           ! 2360         while (((inb(addr+5) & 0x60) != 0x60) && (timeout)) {
14191 3FE8           EB           26            jmp .2EF
14192                       00003FEA            .2F0:
14193                                           ! 2361           val16 = read_word(0x0040, 0x006C);
14194                                           ! Debug: list int = const $6C (used reg = )
14195 3FEA           B8                   006C  mov	ax,*$6C
14196 3FED           50                         push	ax
14197                                           ! Debug: list int = const $40 (used reg = )
14198 3FEE           B8                   0040  mov	ax,*$40
14199 3FF1           50                         push	ax
14200                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
14201 3FF2           E8         C61C            call	_read_word
14202 3FF5           83C4                   04  add	sp,*4
14203                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
14204 3FF8           8946         FA            mov	-6[bp],ax
14205                                           !BCC_EOS
14206                                           ! 2362           if (val16 != timer) {
14207                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
14208 3FFB           8B46         FA            mov	ax,-6[bp]
14209 3FFE           3B46         FC            cmp	ax,-4[bp]
14210 4001           74           0D            je  	.2F1
14211                       00004003            .2F2:
14212                                           ! 2363             timer = val16;
14213                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
14214 4003           8B46         FA            mov	ax,-6[bp]
14215 4006           8946         FC            mov	-4[bp],ax
14216                                           !BCC_EOS
14217                                           ! 2364             timeout--;
14218                                           ! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
14219 4009           8A46         F9            mov	al,-7[bp]
14220 400C           48                         dec	ax
14221 400D           8846         F9            mov	-7[bp],al
14222                                           !BCC_EOS
14223                                           ! 2365             }
14224                                           ! 2366           }
14225                       00004010            .2F1:
14226                                           ! 2367         if (timeout) outb(addr, regs.u.r8.al);
14227                       00004010            .2EF:
14228                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
14229 4010           8B46         FE            mov	ax,-2[bp]
14230                                           ! Debug: list unsigned int = ax+5 (used reg = )
14231 4013           05                   0005  add	ax,*5
14232 4016           50                         push	ax
14233                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14234 4017           E8         C52E            call	_inb
14235 401A           44                         inc	sp
14236 401B           44                         inc	sp
14237                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
14238 401C           24                     60  and	al,*$60
14239                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
14240 401E           3C                     60  cmp	al,*$60
14241 4020           74           07            je  	.2F3
14242                       00004022            .2F4:
14243 4022           8A46         F9            mov	al,-7[bp]
14244 4025           84C0                       test	al,al
14245 4027           75           C1            jne	.2F0
14246                       00004029            .2F3:
14247                       00004029            .2EE:
14248 4029           8A46         F9            mov	al,-7[bp]
14249 402C           84C0                       test	al,al
14250 402E           74           0F            je  	.2F5
14251                       00004030            .2F6:
14252                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
14253 4030           8A46         12            mov	al,$12[bp]
14254 4033           30E4                       xor	ah,ah
14255 4035           50                         push	ax
14256                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
14257 4036           FF76         FE            push	-2[bp]
14258                                           ! Debug: func () void = outb+0 (used reg = )
14259 4039           E8         C522            call	_outb
14260 403C           83C4                   04  add	sp,*4
14261                                           !BCC_EOS
14262                                           ! 2368         regs.u.r8.ah = inb(addr+5);
14263                       0000403F            .2F5:
14264                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
14265 403F           8B46         FE            mov	ax,-2[bp]
14266                                           ! Debug: list unsigned int = ax+5 (used reg = )
14267 4042           05                   0005  add	ax,*5
14268 4045           50                         push	ax
14269                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14270 4046           E8         C4FF            call	_inb
14271 4049           44                         inc	sp
14272 404A           44                         inc	sp
14273                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
14274 404B           8846         13            mov	$13[bp],al
14275                                           !BCC_EOS
14276                                           ! 2369         if (!timeout) regs.u.r8.ah |= 0x80;
14277 404E           8A46         F9            mov	al,-7[bp]
14278 4051           84C0                       test	al,al
14279 4053           75           08            jne 	.2F7
14280                       00004055            .2F8:
14281                                           ! Debug: orab int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
14282 4055           8A46         13            mov	al,$13[bp]
14283 4058           0C                     80  or	al,#$80
14284 405A           8846         13            mov	$13[bp],al
14285                                           !BCC_EOS
14286                                           ! 2370         iret_addr.flags.u.r8.flagsl &= 0xfe;
14287                       0000405D            .2F7:
14288                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
14289 405D           8A46         1A            mov	al,$1A[bp]
14290 4060           24                     FE  and	al,#$FE
14291 4062           8846         1A            mov	$1A[bp],al
14292                                           !BCC_EOS
14293                                           ! 2371         break;
14294 4065           E9         00CE            br 	.2E6
14295                                           !BCC_EOS
14296                                           ! 2372       case 2:
14297                                           ! 2373         timer = read_word(0x0040, 0x006C);
14298                       00004068            .2F9:
14299                                           ! Debug: list int = const $6C (used reg = )
14300 4068           B8                   006C  mov	ax,*$6C
14301 406B           50                         push	ax
14302                                           ! Debug: list int = const $40 (used reg = )
14303 406C           B8                   0040  mov	ax,*$40
14304 406F           50                         push	ax
14305                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
14306 4070           E8         C59E            call	_read_word
14307 4073           83C4                   04  add	sp,*4
14308                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
14309 4076           8946         FC            mov	-4[bp],ax
14310                                           !BCC_EOS
14311                                           ! 2374         while (((inb(addr+5) & 0x01) == 0) && (timeout)) {
14312 4079           EB           26            jmp .2FB
14313                       0000407B            .2FC:
14314                                           ! 2375           val16 = read_word(0x0040, 0x006C);
14315                                           ! Debug: list int = const $6C (used reg = )
14316 407B           B8                   006C  mov	ax,*$6C
14317 407E           50                         push	ax
14318                                           ! Debug: list int = const $40 (used reg = )
14319 407F           B8                   0040  mov	ax,*$40
14320 4082           50                         push	ax
14321                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
14322 4083           E8         C58B            call	_read_word
14323 4086           83C4                   04  add	sp,*4
14324                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
14325 4089           8946         FA            mov	-6[bp],ax
14326                                           !BCC_EOS
14327                                           ! 2376           if (val16 != timer) {
14328                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
14329 408C           8B46         FA            mov	ax,-6[bp]
14330 408F           3B46         FC            cmp	ax,-4[bp]
14331 4092           74           0D            je  	.2FD
14332                       00004094            .2FE:
14333                                           ! 2377             timer = val16;
14334                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
14335 4094           8B46         FA            mov	ax,-6[bp]
14336 4097           8946         FC            mov	-4[bp],ax
14337                                           !BCC_EOS
14338                                           ! 2378             timeout--;
14339                                           ! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
14340 409A           8A46         F9            mov	al,-7[bp]
14341 409D           48                         dec	ax
14342 409E           8846         F9            mov	-7[bp],al
14343                                           !BCC_EOS
14344                                           ! 2379             }
14345                                           ! 2380           }
14346                       000040A1            .2FD:
14347                                           ! 2381         if (timeout) {
14348                       000040A1            .2FB:
14349                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
14350 40A1           8B46         FE            mov	ax,-2[bp]
14351                                           ! Debug: list unsigned int = ax+5 (used reg = )
14352 40A4           05                   0005  add	ax,*5
14353 40A7           50                         push	ax
14354                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14355 40A8           E8         C49D            call	_inb
14356 40AB           44                         inc	sp
14357 40AC           44                         inc	sp
14358                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
14359 40AD           24                     01  and	al,*1
14360                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
14361 40AF           84C0                       test	al,al
14362 40B1           75           07            jne 	.2FF
14363                       000040B3            .300:
14364 40B3           8A46         F9            mov	al,-7[bp]
14365 40B6           84C0                       test	al,al
14366 40B8           75           C1            jne	.2FC
14367                       000040BA            .2FF:
14368                       000040BA            .2FA:
14369 40BA           8A46         F9            mov	al,-7[bp]
14370 40BD           84C0                       test	al,al
14371 40BF           74           12            je  	.301
14372                       000040C1            .302:
14373                                           ! 2382           regs.u.r8.ah = 0;
14374                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$A+$11] (used reg = )
14375 40C1           30C0                       xor	al,al
14376 40C3           8846         13            mov	$13[bp],al
14377                                           !BCC_EOS
14378                                           ! 2383           regs.u.r8.al = inb(addr);
14379                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
14380 40C6           FF76         FE            push	-2[bp]
14381                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14382 40C9           E8         C47C            call	_inb
14383 40CC           44                         inc	sp
14384 40CD           44                         inc	sp
14385                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
14386 40CE           8846         12            mov	$12[bp],al
14387                                           !BCC_EOS
14388                                           ! 2384         } else {
14389 40D1           EB           0F            jmp .303
14390                       000040D3            .301:
14391                                           ! 2385           regs.u.r8.ah = inb(addr+5);
14392                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
14393 40D3           8B46         FE            mov	ax,-2[bp]
14394                                           ! Debug: list unsigned int = ax+5 (used reg = )
14395 40D6           05                   0005  add	ax,*5
14396 40D9           50                         push	ax
14397                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14398 40DA           E8         C46B            call	_inb
14399 40DD           44                         inc	sp
14400 40DE           44                         inc	sp
14401                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
14402 40DF           8846         13            mov	$13[bp],al
14403                                           !BCC_EOS
14404                                           ! 2386           }
14405                                           ! 2387         iret_addr.flags.u.r8.flagsl &= 0xfe;
14406                       000040E2            .303:
14407                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
14408 40E2           8A46         1A            mov	al,$1A[bp]
14409 40E5           24                     FE  and	al,#$FE
14410 40E7           8846         1A            mov	$1A[bp],al
14411                                           !BCC_EOS
14412                                           ! 2388         break;
14413 40EA           EB           4A            jmp .2E6
14414                                           !BCC_EOS
14415                                           ! 2389       case 3:
14416                                           ! 2390         regs.u.r8.ah = inb(addr+5);
14417                       000040EC            .304:
14418                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
14419 40EC           8B46         FE            mov	ax,-2[bp]
14420                                           ! Debug: list unsigned int = ax+5 (used reg = )
14421 40EF           05                   0005  add	ax,*5
14422 40F2           50                         push	ax
14423                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14424 40F3           E8         C452            call	_inb
14425 40F6           44                         inc	sp
14426 40F7           44                         inc	sp
14427                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
14428 40F8           8846         13            mov	$13[bp],al
14429                                           !BCC_EOS
14430                                           ! 2391        
14431                                           ! 2391  regs.u.r8.al = inb(addr+6);
14432                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
14433 40FB           8B46         FE            mov	ax,-2[bp]
14434                                           ! Debug: list unsigned int = ax+6 (used reg = )
14435 40FE           05                   0006  add	ax,*6
14436 4101           50                         push	ax
14437                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14438 4102           E8         C443            call	_inb
14439 4105           44                         inc	sp
14440 4106           44                         inc	sp
14441                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
14442 4107           8846         12            mov	$12[bp],al
14443                                           !BCC_EOS
14444                                           ! 2392         iret_addr.flags.u.r8.flagsl &= 0xfe;
14445                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
14446 410A           8A46         1A            mov	al,$1A[bp]
14447 410D           24                     FE  and	al,#$FE
14448 410F           8846         1A            mov	$1A[bp],al
14449                                           !BCC_EOS
14450                                           ! 2393         break;
14451 4112           EB           22            jmp .2E6
14452                                           !BCC_EOS
14453                                           ! 2394       default:
14454                                           ! 2395         iret_addr.flags.u.r8.flagsl |= 0x01;
14455                       00004114            .305:
14456                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
14457 4114           8A46         1A            mov	al,$1A[bp]
14458 4117           0C                     01  or	al,*1
14459 4119           8846         1A            mov	$1A[bp],al
14460                                           !BCC_EOS
14461                                           ! 2396       }
14462                                           ! 2397   } else {
14463 411C           EB           18            jmp .2E6
14464                       0000411E            .2E8:
14465 411E           2C                     00  sub	al,*0
14466 4120         0F84         FDF7            beq 	.2E9
14467 4124           2C                     01  sub	al,*1
14468 4126         0F84         FEAD            beq 	.2ED
14469 412A           2C                     01  sub	al,*1
14470 412C         0F84         FF38            beq 	.2F9
14471 4130           2C                     01  sub	al,*1
14472 4132           74           B8            je 	.304
14473 4134           EB           DE            jmp	.305
14474                       00004136            .2E6:
14475                       FFFFFFF6            ..FFF7	=	-$A
14476 4136           EB           08            jmp .306
14477                       00004138            .2E3:
14478                                           ! 2398     iret_addr.flags.u.r8.flagsl |= 0x01;
14479                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
14480 4138           8A46         1A            mov	al,$1A[bp]
14481 413B           0C                     01  or	al,*1
14482 413D           8846         1A            mov	$1A[bp],al
14483                                           !BCC_EOS
14484                                           ! 2399     }
14485                                           ! 2400 }
14486                       00004140            .306:
14487 4140           89EC                       mov	sp,bp
14488 4142           5D                         pop	bp
14489 4143           C3                         ret
14490                                           ! 2401   void
14491                                           ! Register BX used in function int14_function
14492                                           ! 2402 int15_function(regs, ES, DS, FLAGS)
14493                                           ! 2403   pusha_regs_t regs;
14494                                           export	_int15_function
14495                       00004144            _int15_function:
14496                                           !BCC_EOS
14497                                           ! 2404   Bit16u ES, DS, FLAGS;
14498                                           !BCC_EOS
14499                                           ! 2405 {
14500                                           ! 2406   Bit16u ebda_seg=read_word(0x0040,0x000E);
14501 4144           55                         push	bp
14502 4145           89E5                       mov	bp,sp
14503 4147           4C                         dec	sp
14504 4148           4C                         dec	sp
14505                                           ! Debug: list int = const $E (used reg = )
14506 4149           B8                   000E  mov	ax,*$E
14507 414C           50                         push	ax
14508                                           ! Debug: list int = const $40 (used reg = )
14509 414D           B8                   0040  mov	ax,*$40
14510 4150           50                         push	ax
14511                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
14512 4151           E8         C4BD            call	_read_word
14513 4154           83C4                   04  add	sp,*4
14514                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
14515 4157           8946         FE            mov	-2[bp],ax
14516                                           !BCC_EOS
14517                                           ! 2407   bx_bool prev_a20_enable;
14518                                           !BCC_EOS
14519                                           ! 2408   Bit16u base15_00;
14520                                           !BCC_EOS
14521                                           ! 2409   Bit8u base23_16;
14522                                           !BCC_EOS
14523                                           ! 2410   Bit16u ss;
14524                                           !BCC_EOS
14525                                           ! 2411   Bit16u CX,DX;
14526                                           !BCC_EOS
14527                                           ! 2412   Bit16u bRegister;
14528                                           !BCC_EOS
14529                                           ! 2413   Bit8u irqDisable;
14530                                           !BCC_EOS
14531                                           ! 2414 ;
14532 415A           83C4                   F0  add	sp,*-$10
14533                                           !BCC_EOS
14534                                           ! 2415   switch (regs.u.r8.ah) {
14535 415D           8A46         13            mov	al,$13[bp]
14536 4160           E9         04C6            br 	.309
14537                                           ! 2416     case 0x24:
14538                                           ! 2417       switch (regs.u.r8.al) {
14539                       00004163            .30A:
14540 4163           8A46         12            mov	al,$12[bp]
14541 4166           E9         0089            br 	.30D
14542                                           ! 2418         case 0x00:
14543                                           ! 2419           set_enable_a20(0);
14544                       00004169            .30E:
14545                                           ! Debug: list int = const 0 (used reg = )
14546 4169           31C0                       xor	ax,ax
14547 416B           50                         push	ax
14548                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14549 416C           E8         D4D2            call	_set_enable_a20
14550 416F           44                         inc	sp
14551 4170           44                         inc	sp
14552                                           !BCC_EOS
14553                                           ! 2420           FLAGS &= 0xfffe;
14554                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
14555 4171           8B46         18            mov	ax,$18[bp]
14556 4174           24                     FE  and	al,#$FE
14557 4176           8946         18            mov	$18[bp],ax
14558                                           !BCC_EOS
14559                                           ! 2421           regs.u.r8.ah = 0;
14560                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
14561 4179           30C0                       xor	al,al
14562 417B           8846         13            mov	$13[bp],al
14563                                           !BCC_EOS
14564                                           ! 2422           break;
14565 417E           E9         0087            br 	.30B
14566                                           !BCC_EOS
14567                                           ! 2423         case 0x01:
14568                                           ! 2424           set_enable_a20(1);
14569                       00004181            .30F:
14570                                           ! Debug: list int = const 1 (used reg = )
14571 4181           B8                   0001  mov	ax,*1
14572 4184           50                         push	ax
14573                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
14574 4185           E8         D4B9            call	_set_enable_a20
14575 4188           44                         inc	sp
14576 4189           44                         inc	sp
14577                                           !BCC_EOS
14578                                           ! 2425           FLAGS &= 0xfffe;
14579                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
14580 418A           8B46         18            mov	ax,$18[bp]
14581 418D           24                     FE  and	al,#$FE
14582 418F           8946         18            mov	$18[bp],ax
14583                                           !BCC_EOS
14584                                           ! 2426           regs.u.r8.ah = 0;
14585                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
14586 4192           30C0                       xor	al,al
14587 4194           8846         13            mov	$13[bp],al
14588                                           !BCC_EOS
14589                                           ! 2427           break;
14590 4197           EB           6F            jmp .30B
14591                                           !BCC_EOS
14592                                           ! 2428         case 0x02:
14593                                           ! 2429           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
14594                       00004199            .310:
14595                                           ! Debug: list int = const $92 (used reg = )
14596 4199           B8                   0092  mov	ax,#$92
14597 419C           50                         push	ax
14598                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14599 419D           E8         C3A8            call	_inb
14600 41A0           44                         inc	sp
14601 41A1           44                         inc	sp
14602                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
14603 41A2           30E4                       xor	ah,ah
14604 41A4           D1E8                       shr	ax,*1
14605                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
14606 41A6           24                     01  and	al,*1
14607                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
14608 41A8           8846         12            mov	$12[bp],al
14609                                           !BCC_EOS
14610                                           ! 2430           FLAGS &= 0xfffe;
14611                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
14612 41AB           8B46         18            mov	ax,$18[bp]
14613 41AE           24                     FE  and	al,#$FE
14614 41B0           8946         18            mov	$18[bp],ax
14615                                           !BCC_EOS
14616                                           ! 2431           regs.u.r8.ah = 0;
14617                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
14618 41B3           30C0                       xor	al,al
14619 41B5           8846         13            mov	$13[bp],al
14620                                           !BCC_EOS
14621                                           ! 2432           break;
14622 41B8           EB           4E            jmp .30B
14623                                           !BCC_EOS
14624                                           ! 2433         case 0x03:
14625                                           ! 2434           FLAGS &= 0xfffe;
14626                       000041BA            .311:
14627                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
14628 41BA           8B46         18            mov	ax,$18[bp]
14629 41BD           24                     FE  and	al,#$FE
14630 41BF           8946         18            mov	$18[bp],ax
14631                                           !BCC_EOS
14632                                           ! 2435           regs.u.r8.ah = 0;
14633                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
14634 41C2           30C0                       xor	al,al
14635 41C4           8846         13            mov	$13[bp],al
14636                                           !BCC_EOS
14637                                           ! 2436           regs.u.r16.bx = 3;
14638                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$14+$A] (used reg = )
14639 41C7           B8                   0003  mov	ax,*3
14640 41CA           8946         0C            mov	$C[bp],ax
14641                                           !BCC_EOS
14642                                           ! 2437           break;
14643 41CD           EB           39            jmp .30B
14644                                           !BCC_EOS
14645                                           ! 2438         default:
14646                                           ! 2439           bios_printf(4, "int15: Func 24h, subfunc %02xh, A20 gate control not supported\n", (unsigned) regs.u.r8.al);
14647                       000041CF            .312:
14648                                           ! Debug: list unsigned char regs = [S+$14+$10] (used reg = )
14649 41CF           8A46         12            mov	al,$12[bp]
14650 41D2           30E4                       xor	ah,ah
14651 41D4           50                         push	ax
14652                                           ! Debug: list * char = .313+0 (used reg = )
14653 41D5           BB                   D8DE  mov	bx,#.313
14654 41D8           53                         push	bx
14655                                           ! Debug: list int = const 4 (used reg = )
14656 41D9           B8                   0004  mov	ax,*4
14657 41DC           50                         push	ax
14658                                           ! Debug: func () void = bios_printf+0 (used reg = )
14659 41DD           E8         C6C9            call	_bios_printf
14660 41E0           83C4                   06  add	sp,*6
14661                                           !BCC_EOS
14662                                           ! 2440           FLAGS |= 0x0001;
14663                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
14664 41E3           8B46         18            mov	ax,$18[bp]
14665 41E6           0C                     01  or	al,*1
14666 41E8           8946         18            mov	$18[bp],ax
14667                                           !BCC_EOS
14668                                           ! 2441           regs.u.r8.ah = 0x86;
14669                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
14670 41EB           B0                     86  mov	al,#$86
14671 41ED           8846         13            mov	$13[bp],al
14672                                           !BCC_EOS
14673                                           ! 2442       }
14674                                           ! 2443       break;
14675 41F0           EB           16            jmp .30B
14676                       000041F2            .30D:
14677 41F2           2C                     00  sub	al,*0
14678 41F4         0F84         FF71            beq 	.30E
14679 41F8           2C                     01  sub	al,*1
14680 41FA         0F84         FF83            beq 	.30F
14681 41FE           2C                     01  sub	al,*1
14682 4200           74           97            je 	.310
14683 4202           2C                     01  sub	al,*1
14684 4204           74           B4            je 	.311
14685 4206           EB           C7            jmp	.312
14686                       00004208            .30B:
14687 4208           E9         046F            br 	.307
14688                                           !BCC_EOS
14689                                           ! 2444     case 0x41:
14690                                           ! 2445       FLAGS |= 0x0001;
14691                       0000420B            .314:
14692                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
14693 420B           8B46         18            mov	ax,$18[bp]
14694 420E           0C                     01  or	al,*1
14695 4210           8946         18            mov	$18[bp],ax
14696                                           !BCC_EOS
14697                                           ! 2446       regs.u.r8.ah = 0x86;
14698                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
14699 4213           B0                     86  mov	al,#$86
14700 4215           8846         13            mov	$13[bp],al
14701                                           !BCC_EOS
14702                                           ! 2447       break;
14703 4218           E9         045F            br 	.307
14704                                           !BCC_EOS
14705                                           ! 2448     case 0x4f:
14706                                           ! 2449       FLAGS |= 0x0001;
14707                       0000421B            .315:
14708                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
14709 421B           8B46         18            mov	ax,$18[bp]
14710 421E           0C                     01  or	al,*1
14711 4220           8946         18            mov	$18[bp],ax
14712                                           !BCC_EOS
14713                                           ! 2450       break;
14714 4223           E9         0454            br 	.307
14715                                           !BCC_EOS
14716                                           ! 2451     case 0x52:
14717                                           ! 2452       FLAGS &= 0xfffe;
14718                       00004226            .316:
14719                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
14720 4226           8B46         18            mov	ax,$18[bp]
14721 4229           24                     FE  and	al,#$FE
14722 422B           8946         18            mov	$18[bp],ax
14723                                           !BCC_EOS
14724                                           ! 2453       regs.u.r8.ah = 0;
14725                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
14726 422E           30C0                       xor	al,al
14727 4230           8846         13            mov	$13[bp],al
14728                                           !BCC_EOS
14729                                           ! 2454       break;
14730 4233           E9         0444            br 	.307
14731                                           !BCC_EOS
14732                                           ! 2455     case 0x83: {
14733                       00004236            .317:
14734                                           ! 2456       if( regs.u.r8.al == 0 ) {
14735                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$14+$10] (used reg = )
14736 4236           8A46         12            mov	al,$12[bp]
14737 4239           84C0                       test	al,al
14738 423B         0F85         00C1            bne 	.318
14739                       0000423F            .319:
14740                                           ! 2457         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
14741                                           ! Debug: list int = const $A0 (used reg = )
14742 423F           B8                   00A0  mov	ax,#$A0
14743 4242           50                         push	ax
14744                                           ! Debug: list int = const $40 (used reg = )
14745 4243           B8                   0040  mov	ax,*$40
14746 4246           50                         push	ax
14747                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14748 4247           E8         C3B4            call	_read_byte
14749 424A           83C4                   04  add	sp,*4
14750                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
14751 424D           24                     01  and	al,*1
14752                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
14753 424F           84C0                       test	al,al
14754 4251         0F85         009C            bne 	.31A
14755                       00004255            .31B:
14756                                           ! 2458           write_byte( 0x40, 0xA0, 1 );
14757                                           ! Debug: list int = const 1 (used reg = )
14758 4255           B8                   0001  mov	ax,*1
14759 4258           50                         push	ax
14760                                           ! Debug: list int = const $A0 (used reg = )
14761 4259           B8                   00A0  mov	ax,#$A0
14762 425C           50                         push	ax
14763                                           ! Debug: list int = const $40 (used reg = )
14764 425D           B8                   0040  mov	ax,*$40
14765 4260           50                         push	ax
14766                                           ! Debug: func () void = write_byte+0 (used reg = )
14767 4261           E8         C3C0            call	_write_byte
14768 4264           83C4                   06  add	sp,*6
14769                                           !BCC_EOS
14770                                           ! 2459           write_word( 0x40, 0x98, ES );
14771                                           ! Debug: list unsigned short ES = [S+$14+$12] (used reg = )
14772 4267           FF76         14            push	$14[bp]
14773                                           ! Debug: list int = const $98 (used reg = )
14774 426A           B8                   0098  mov	ax,#$98
14775 426D           50                         push	ax
14776                                           ! Debug: list int = const $40 (used reg = )
14777 426E           B8                   0040  mov	ax,*$40
14778 4271           50                         push	ax
14779                                           ! Debug: func () void = write_word+0 (used reg = )
14780 4272           E8         C3C7            call	_write_word
14781 4275           83C4                   06  add	sp,*6
14782                                           !BCC_EOS
14783                                           ! 2460           write_word( 0x40, 0x9A, regs.u.r16.bx );
14784                                           ! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
14785 4278           FF76         0C            push	$C[bp]
14786                                           ! Debug: list int = const $9A (used reg = )
14787 427B           B8                   009A  mov	ax,#$9A
14788 427E           50                         push	ax
14789                                           ! Debug: list int = const $40 (used reg = )
14790 427F           B8                   0040  mov	ax,*$40
14791 4282           50                         push	ax
14792                                           ! Debug: func () void = write_word+0 (used reg = )
14793 4283           E8         C3B6            call	_write_word
14794 4286           83C4                   06  add	sp,*6
14795                                           !BCC_EOS
14796                                           ! 2461           write_word( 0x40, 0x9C, regs.u.r16.dx );
14797                                           ! Debug: list unsigned short regs = [S+$14+$C] (used reg = )
14798 4289           FF76         0E            push	$E[bp]
14799                                           ! Debug: list int = const $9C (used reg = )
14800 428C           B8                   009C  mov	ax,#$9C
14801 428F           50                         push	ax
14802                                           ! Debug: list int = const $40 (used reg = )
14803 4290           B8                   0040  mov	ax,*$40
14804 4293           50                         push	ax
14805                                           ! Debug: func () void = write_word+0 (used reg = )
14806 4294           E8         C3A5            call	_write_word
14807 4297           83C4                   06  add	sp,*6
14808                                           !BCC_EOS
14809                                           ! 2462           write_word( 0x40, 0x9E, regs.u.r16.cx );
14810                                           ! Debug: list unsigned short regs = [S+$14+$E] (used reg = )
14811 429A           FF76         10            push	$10[bp]
14812                                           ! Debug: list int = const $9E (used reg = )
14813 429D           B8                   009E  mov	ax,#$9E
14814 42A0           50                         push	ax
14815                                           ! Debug: list int = const $40 (used reg = )
14816 42A1           B8                   0040  mov	ax,*$40
14817 42A4           50                         push	ax
14818                                           ! Debug: func () void = write_word+0 (used reg = )
14819 42A5           E8         C394            call	_write_word
14820 42A8           83C4                   06  add	sp,*6
14821                                           !BCC_EOS
14822                                           ! 2463           FLAGS &= 0xfffe;
14823                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
14824 42AB           8B46         18            mov	ax,$18[bp]
14825 42AE           24                     FE  and	al,#$FE
14826 42B0           8946         18            mov	$18[bp],ax
14827                                           !BCC_EOS
14828                                           ! 2464           irqDisable = inb( 0xA1 );
14829                                           ! Debug: list int = const $A1 (used reg = )
14830 42B3           B8                   00A1  mov	ax,#$A1
14831 42B6           50                         push	ax
14832                                           ! Debug: func () unsigned char = inb+0 (used reg = )
14833 42B7           E8         C28E            call	_inb
14834 42BA           44                         inc	sp
14835 42BB           44                         inc	sp
14836                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$14-$13] (used reg = )
14837 42BC           8846         EF            mov	-$11[bp],al
14838                                           !BCC_EOS
14839                                           ! 2465           outb( 0xA1, irqDisable & 0xFE );
14840                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$14-$13] (used reg = )
14841 42BF           8A46         EF            mov	al,-$11[bp]
14842 42C2           24                     FE  and	al,#$FE
14843                                           ! Debug: list unsigned char = al+0 (used reg = )
14844 42C4           30E4                       xor	ah,ah
14845 42C6           50                         push	ax
14846                                           ! Debug: list int = const $A1 (used reg = )
14847 42C7           B8                   00A1  mov	ax,#$A1
14848 42CA           50                         push	ax
14849                                           ! Debug: func () void = outb+0 (used reg = )
14850 42CB           E8         C290            call	_outb
14851 42CE           83C4                   04  add	sp,*4
14852                                           !BCC_EOS
14853                                           ! 2466           bRegister = inb_cmos( 0xB );
14854                                           ! Debug: list int = const $B (used reg = )
14855 42D1           B8                   000B  mov	ax,*$B
14856 42D4           50                         push	ax
14857                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14858 42D5           E8         C2B5            call	_inb_cmos
14859 42D8           44                         inc	sp
14860 42D9           44                         inc	sp
14861                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
14862 42DA           30E4                       xor	ah,ah
14863 42DC           8946         F0            mov	-$10[bp],ax
14864                                           !BCC_EOS
14865                                           ! 2467           outb_cmos( 0xB, bRegister | 0x40 );
14866                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$14-$12] (used reg = )
14867 42DF           8B46         F0            mov	ax,-$10[bp]
14868 42E2           0C                     40  or	al,*$40
14869                                           ! Debug: list unsigned int = ax+0 (used reg = )
14870 42E4           50                         push	ax
14871                                           ! Debug: list int = const $B (used reg = )
14872 42E5           B8                   000B  mov	ax,*$B
14873 42E8           50                         push	ax
14874                                           ! Debug: func () void = outb_cmos+0 (used reg = )
14875 42E9           E8         C292            call	_outb_cmos
14876 42EC           83C4                   04  add	sp,*4
14877                                           !BCC_EOS
14878                                           ! 2468         } else {
14879 42EF           EB           0D            jmp .31C
14880                       000042F1            .31A:
14881                                           ! 2469           ;
14882                                           !BCC_EOS
14883                                           ! 2470           FLAGS
14884                                           ! 2470  |= 0x0001;
14885                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
14886 42F1           8B46         18            mov	ax,$18[bp]
14887 42F4           0C                     01  or	al,*1
14888 42F6           8946         18            mov	$18[bp],ax
14889                                           !BCC_EOS
14890                                           ! 2471           regs.u.r8.ah = 0x86;
14891                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
14892 42F9           B0                     86  mov	al,#$86
14893 42FB           8846         13            mov	$13[bp],al
14894                                           !BCC_EOS
14895                                           ! 2472         }
14896                                           ! 2473       } else if( regs.u.r8.al == 1 ) {
14897                       000042FE            .31C:
14898 42FE           EB           54            jmp .31D
14899                       00004300            .318:
14900                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$14+$10] (used reg = )
14901 4300           8A46         12            mov	al,$12[bp]
14902 4303           3C                     01  cmp	al,*1
14903 4305           75           39            jne 	.31E
14904                       00004307            .31F:
14905                                           ! 2474         write_byte( 0x40, 0xA0, 0 );
14906                                           ! Debug: list int = const 0 (used reg = )
14907 4307           31C0                       xor	ax,ax
14908 4309           50                         push	ax
14909                                           ! Debug: list int = const $A0 (used reg = )
14910 430A           B8                   00A0  mov	ax,#$A0
14911 430D           50                         push	ax
14912                                           ! Debug: list int = const $40 (used reg = )
14913 430E           B8                   0040  mov	ax,*$40
14914 4311           50                         push	ax
14915                                           ! Debug: func () void = write_byte+0 (used reg = )
14916 4312           E8         C30F            call	_write_byte
14917 4315           83C4                   06  add	sp,*6
14918                                           !BCC_EOS
14919                                           ! 2475         FLAGS &= 0xfffe;
14920                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
14921 4318           8B46         18            mov	ax,$18[bp]
14922 431B           24                     FE  and	al,#$FE
14923 431D           8946         18            mov	$18[bp],ax
14924                                           !BCC_EOS
14925                                           ! 2476         bRegister = inb_cmos( 0xB );
14926                                           ! Debug: list int = const $B (used reg = )
14927 4320           B8                   000B  mov	ax,*$B
14928 4323           50                         push	ax
14929                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
14930 4324           E8         C266            call	_inb_cmos
14931 4327           44                         inc	sp
14932 4328           44                         inc	sp
14933                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
14934 4329           30E4                       xor	ah,ah
14935 432B           8946         F0            mov	-$10[bp],ax
14936                                           !BCC_EOS
14937                                           ! 2477         outb_cmos( 0xB, bRegister & ~0x40 );
14938                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$14-$12] (used reg = )
14939 432E           8B46         F0            mov	ax,-$10[bp]
14940 4331           24                     BF  and	al,#$BF
14941                                           ! Debug: list unsigned int = ax+0 (used reg = )
14942 4333           50                         push	ax
14943                                           ! Debug: list int = const $B (used reg = )
14944 4334           B8                   000B  mov	ax,*$B
14945 4337           50                         push	ax
14946                                           ! Debug: func () void = outb_cmos+0 (used reg = )
14947 4338           E8         C243            call	_outb_cmos
14948 433B           83C4                   04  add	sp,*4
14949                                           !BCC_EOS
14950                                           ! 2478       } else {
14951 433E           EB           14            jmp .320
14952                       00004340            .31E:
14953                                           ! 2479         ;
14954                                           !BCC_EOS
14955                                           ! 2480         FLAGS |= 0x0001;
14956                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
14957 4340           8B46         18            mov	ax,$18[bp]
14958 4343           0C                     01  or	al,*1
14959 4345           8946         18            mov	$18[bp],ax
14960                                           !BCC_EOS
14961                                           ! 2481         regs.u.r8.ah = 0x86;
14962                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
14963 4348           B0                     86  mov	al,#$86
14964 434A           8846         13            mov	$13[bp],al
14965                                           !BCC_EOS
14966                                           ! 2482         regs.u.r8.al--;
14967                                           ! Debug: postdec unsigned char regs = [S+$14+$10] (used reg = )
14968 434D           8A46         12            mov	al,$12[bp]
14969 4350           48                         dec	ax
14970 4351           8846         12            mov	$12[bp],al
14971                                           !BCC_EOS
14972                                           ! 2483       }
14973                                           ! 2484       break;
14974                       00004354            .320:
14975                       00004354            .31D:
14976 4354           E9         0323            br 	.307
14977                                           !BCC_EOS
14978                                           ! 2485     }
14979                                           ! 2486     case 0x87:
14980                                           ! 2487 #asm
14981                       00004357            .321:
14982                                           !BCC_EOS
14983                                           !BCC_ASM
14984                       00000006            _int15_function.CX	set	6
14985                       FFFFFFF4            .int15_function.CX	set	-$C
14986                       0000002A            _int15_function.FLAGS	set	$2A
14987                       00000018            .int15_function.FLAGS	set	$18
14988                       00000001            _int15_function.irqDisable	set	1
14989                       FFFFFFEF            .int15_function.irqDisable	set	-$11
14990                       00000028            _int15_function.DS	set	$28
14991                       00000016            .int15_function.DS	set	$16
14992                       00000004            _int15_function.DX	set	4
14993                       FFFFFFF2            .int15_function.DX	set	-$E
14994                       0000000B            _int15_function.base23_16	set	$B
14995                       FFFFFFF9            .int15_function.base23_16	set	-7
14996                       00000002            _int15_function.bRegister	set	2
14997                       FFFFFFF0            .int15_function.bRegister	set	-$10
14998                       00000026            _int15_function.ES	set	$26
14999                       00000014            .int15_function.ES	set	$14
15000                       00000010            _int15_function.ebda_seg	set	$10
15001                       FFFFFFFE            .int15_function.ebda_seg	set	-2
15002                       0000000C            _int15_function.base15_00	set	$C
15003                       FFFFFFFA            .int15_function.base15_00	set	-6
15004                       00000008            _int15_function.ss	set	8
15005                       FFFFFFF6            .int15_function.ss	set	-$A
15006                       00000016            _int15_function.regs	set	$16
15007                       00000004            .int15_function.regs	set	4
15008                       0000000E            _int15_function.prev_a20_enable	set	$E
15009                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
15010 4357           FA                           cli
15011                                           ! 2489 endasm
15012                                           !BCC_ENDASM
15013                                           !BCC_EOS
15014                                           ! 2490       prev_a20_enable = set_enable_a20(1);
15015                                           ! Debug: list int = const 1 (used reg = )
15016 4358           B8                   0001  mov	ax,*1
15017 435B           50                         push	ax
15018                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
15019 435C           E8         D2E2            call	_set_enable_a20
15020 435F           44                         inc	sp
15021 4360           44                         inc	sp
15022                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$14-6] (used reg = )
15023 4361           8946         FC            mov	-4[bp],ax
15024                                           !BCC_EOS
15025                                           ! 2491       base15_00 = (ES << 4) + regs.u.r16.si;
15026                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
15027 4364           8B46         14            mov	ax,$14[bp]
15028 4367           B1                     04  mov	cl,*4
15029 4369           D3E0                       shl	ax,cl
15030                                           ! Debug: add unsigned short regs = [S+$14+4] to unsigned int = ax+0 (used reg = )
15031 436B           0346         06            add	ax,6[bp]
15032                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
15033 436E           8946         FA            mov	-6[bp],ax
15034                                           !BCC_EOS
15035                                           ! 2492       base23_16 = ES >> 12;
15036                                           ! Debug: sr int = const $C to unsigned short ES = [S+$14+$12] (used reg = )
15037 4371           8B46         14            mov	ax,$14[bp]
15038 4374           88E0                       mov	al,ah
15039 4376           30E4                       xor	ah,ah
15040 4378           B1                     04  mov	cl,*4
15041 437A           D3E8                       shr	ax,cl
15042                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
15043 437C           8846         F9            mov	-7[bp],al
15044                                           !BCC_EOS
15045                                           ! 2493       if (base15_00 < (ES<<4))
15046                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
15047 437F           8B46         14            mov	ax,$14[bp]
15048 4382           B1                     04  mov	cl,*4
15049 4384           D3E0                       shl	ax,cl
15050                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
15051 4386           3B46         FA            cmp	ax,-6[bp]
15052 4389           76           07            jbe 	.322
15053                       0000438B            .323:
15054                                           ! 2494         base23_16++;
15055                                           ! Debug: postinc unsigned char base23_16 = [S+$14-9] (used reg = )
15056 438B           8A46         F9            mov	al,-7[bp]
15057 438E           40                         inc	ax
15058 438F           8846         F9            mov	-7[bp],al
15059                                           !BCC_EOS
15060                                           ! 2495       write_word(ES, regs.u.r16.si+0x08+0, 47);
15061                       00004392            .322:
15062                                           ! Debug: list int = const $2F (used reg = )
15063 4392           B8                   002F  mov	ax,*$2F
15064 4395           50                         push	ax
15065                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
15066 4396           8B46         06            mov	ax,6[bp]
15067                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
15068                                           ! Debug: list unsigned int = ax+8 (used reg = )
15069 4399           05                   0008  add	ax,*8
15070 439C           50                         push	ax
15071                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15072 439D           FF76         14            push	$14[bp]
15073                                           ! Debug: func () void = write_word+0 (used reg = )
15074 43A0           E8         C299            call	_write_word
15075 43A3           83C4                   06  add	sp,*6
15076                                           !BCC_EOS
15077                                           ! 2496       write_word(ES, regs.u.r16.si+0x08+2, base15_00);
15078                                           ! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
15079 43A6           FF76         FA            push	-6[bp]
15080                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
15081 43A9           8B46         06            mov	ax,6[bp]
15082                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
15083                                           ! Debug: list unsigned int = ax+$A (used reg = )
15084 43AC           05                   000A  add	ax,*$A
15085 43AF           50                         push	ax
15086                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15087 43B0           FF76         14            push	$14[bp]
15088                                           ! Debug: func () void = write_word+0 (used reg = )
15089 43B3           E8         C286            call	_write_word
15090 43B6           83C4                   06  add	sp,*6
15091                                           !BCC_EOS
15092                                           ! 2497       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
15093                                           ! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
15094 43B9           8A46         F9            mov	al,-7[bp]
15095 43BC           30E4                       xor	ah,ah
15096 43BE           50                         push	ax
15097                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
15098 43BF           8B46         06            mov	ax,6[bp]
15099                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
15100                                           ! Debug: list unsigned int = ax+$C (used reg = )
15101 43C2           05                   000C  add	ax,*$C
15102 43C5           50                         push	ax
15103                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15104 43C6           FF76         14            push	$14[bp]
15105                                           ! Debug: func () void = write_byte+0 (used reg = )
15106 43C9           E8         C258            call	_write_byte
15107 43CC           83C4                   06  add	sp,*6
15108                                           !BCC_EOS
15109                                           ! 2498       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
15110                                           ! Debug: list int = const $93 (used reg = )
15111 43CF           B8                   0093  mov	ax,#$93
15112 43D2           50                         push	ax
15113                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
15114 43D3           8B46         06            mov	ax,6[bp]
15115                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
15116                                           ! Debug: list unsigned int = ax+$D (used reg = )
15117 43D6           05                   000D  add	ax,*$D
15118 43D9           50                         push	ax
15119                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15120 43DA           FF76         14            push	$14[bp]
15121                                           ! Debug: func () void = write_byte+0 (used reg = )
15122 43DD           E8         C244            call	_write_byte
15123 43E0           83C4                   06  add	sp,*6
15124                                           !BCC_EOS
15125                                           ! 2499       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
15126                                           ! Debug: list int = const 0 (used reg = )
15127 43E3           31C0                       xor	ax,ax
15128 43E5           50                         push	ax
15129                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
15130 43E6           8B46         06            mov	ax,6[bp]
15131                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
15132                                           ! Debug: list unsigned int = ax+$E (used reg = )
15133 43E9           05                   000E  add	ax,*$E
15134 43EC           50                         push	ax
15135                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15136 43ED           FF76         14            push	$14[bp]
15137                                           ! Debug: func () void = write_word+0 (used reg = )
15138 43F0           E8         C249            call	_write_word
15139 43F3           83C4                   06  add	sp,*6
15140                                           !BCC_EOS
15141                                           ! 2500       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
15142                                           ! Debug: list unsigned int = const $FFFF (used reg = )
15143 43F6           B8                   FFFF  mov	ax,#$FFFF
15144 43F9           50                         push	ax
15145                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
15146 43FA           8B46         06            mov	ax,6[bp]
15147                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
15148                                           ! Debug: list unsigned int = ax+$20 (used reg = )
15149 43FD           05                   0020  add	ax,*$20
15150 4400           50                         push	ax
15151                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15152 4401           FF76         14            push	$14[bp]
15153                                           ! Debug: func () void = write_word+0 (used reg = )
15154 4404           E8         C235            call	_write_word
15155 4407           83C4                   06  add	sp,*6
15156                                           !BCC_EOS
15157                                           ! 2501       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
15158                                           ! Debug: list int = const 0 (used reg = )
15159 440A           31C0                       xor	ax,ax
15160 440C           50                         push	ax
15161                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
15162 440D           8B46         06            mov	ax,6[bp]
15163                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
15164                                           ! Debug: list unsigned int = ax+$22 (used reg = )
15165 4410           05                   0022  add	ax,*$22
15166 4413           50                         push	ax
15167                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15168 4414           FF76         14            push	$14[bp]
15169                                           ! Debug: func () void = write_word+0 (used reg = )
15170 4417           E8         C222            call	_write_word
15171 441A           83C4                   06  add	sp,*6
15172                                           !BCC_EOS
15173                                           ! 2502       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
15174                                           ! Debug: list int = const $F (used reg = )
15175 441D           B8                   000F  mov	ax,*$F
15176 4420           50                         push	ax
15177                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
15178 4421           8B46         06            mov	ax,6[bp]
15179                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
15180                                           ! Debug: list unsigned int = ax+$24 (used reg = )
15181 4424           05                   0024  add	ax,*$24
15182 4427           50                         push	ax
15183                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15184 4428           FF76         14            push	$14[bp]
15185                                           ! Debug: func () void = write_byte+0 (used reg = )
15186 442B           E8         C1F6            call	_write_byte
15187 442E           83C4                   06  add	sp,*6
15188                                           !BCC_EOS
15189                                           ! 2503       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
15190                                           ! Debug: list int = const $9B (used reg = )
15191 4431           B8                   009B  mov	ax,#$9B
15192 4434           50                         push	ax
15193                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
15194 4435           8B46         06            mov	ax,6[bp]
15195                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
15196                                           ! Debug: list unsigned int = ax+$25 (used reg = )
15197 4438           05                   0025  add	ax,*$25
15198 443B           50                         push	ax
15199                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15200 443C           FF76         14            push	$14[bp]
15201                                           ! Debug: func () void = write_byte+0 (used reg = )
15202 443F           E8         C1E2            call	_write_byte
15203 4442           83C4                   06  add	sp,*6
15204                                           !BCC_EOS
15205                                           ! 2504       write_word(ES, regs.u.r16.si+0x20+6, 0x0000);
15206                                           ! Debug: list int = const 0 (used reg = )
15207 4445           31C0                       xor	ax,ax
15208 4447           50                         push	ax
15209                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
15210 4448           8B46         06            mov	ax,6[bp]
15211                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
15212                                           ! Debug: list unsigned int = ax+$26 (used reg = )
15213 444B           05                   0026  add	ax,*$26
15214 444E           50                         push	ax
15215                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15216 444F           FF76         14            push	$14[bp]
15217                                           ! Debug: func () void = write_word+0 (used reg = )
15218 4452           E8         C1E7            call	_write_word
15219 4455           83C4                   06  add	sp,*6
15220                                           !BCC_EOS
15221                                           ! 2505       ss = get_SS();
15222                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
15223 4458           E8         C1FC            call	_get_SS
15224                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$14-$C] (used reg = )
15225 445B           8946         F6            mov	-$A[bp],ax
15226                                           !BCC_EOS
15227                                           ! 2506       base15_00 = ss << 4;
15228                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$14-$C] (used reg = )
15229 445E           8B46         F6            mov	ax,-$A[bp]
15230 4461           B1                     04  mov	cl,*4
15231 4463           D3E0                       shl	ax,cl
15232                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
15233 4465           8946         FA            mov	-6[bp],ax
15234                                           !BCC_EOS
15235                                           ! 2507       base23_16 = ss >> 12;
15236                                           ! Debug: sr int = const $C to unsigned short ss = [S+$14-$C] (used reg = )
15237 4468           8B46         F6            mov	ax,-$A[bp]
15238 446B           88E0                       mov	al,ah
15239 446D           30E4                       xor	ah,ah
15240 446F           B1                     04  mov	cl,*4
15241 4471           D3E8                       shr	ax,cl
15242                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
15243 4473           8846         F9            mov	-7[bp],al
15244                                           !BCC_EOS
15245                                           ! 2508       write_word(ES, regs.u.r16.si+0x28+0, 0xffff);
15246                                           ! Debug: list unsigned int = const $FFFF (used reg = )
15247 4476           B8                   FFFF  mov	ax,#$FFFF
15248 4479           50                         push	ax
15249                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
15250 447A           8B46         06            mov	ax,6[bp]
15251                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
15252                                           ! Debug: list unsigned int = ax+$28 (used reg = )
15253 447D           05                   0028  add	ax,*$28
15254 4480           50                         push	ax
15255                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15256 4481           FF76         14            push	$14[bp]
15257                                           ! Debug: func () void = write_word+0 (used reg = )
15258 4484           E8         C1B5            call	_write_word
15259 4487           83C4                   06  add	sp,*6
15260                                           !BCC_EOS
15261                                           ! 2509       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
15262                                           ! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
15263 448A           FF76         FA            push	-6[bp]
15264                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
15265 448D           8B46         06            mov	ax,6[bp]
15266                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
15267                                           ! Debug: list unsigned int = ax+$2A (used reg = )
15268 4490           05                   002A  add	ax,*$2A
15269 4493           50                         push	ax
15270                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15271 4494           FF76         14            push	$14[bp]
15272                                           ! Debug: func () void = write_word+0 (used reg = )
15273 4497           E8         C1A2            call	_write_word
15274 449A           83C4                   06  add	sp,*6
15275                                           !BCC_EOS
15276                                           ! 2510       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
15277                                           ! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
15278 449D           8A46         F9            mov	al,-7[bp]
15279 44A0           30E4                       xor	ah,ah
15280 44A2           50                         push	ax
15281                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
15282 44A3           8B46         06            mov	ax,6[bp]
15283                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
15284                                           ! Debug: list unsigned int = ax+$2C (used reg = )
15285 44A6           05                   002C  add	ax,*$2C
15286 44A9           50                         push	ax
15287                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15288 44AA           FF76         14            push	$14[bp]
15289                                           ! Debug: func () void = write_byte+0 (used reg = )
15290 44AD           E8         C174            call	_write_byte
15291 44B0           83C4                   06  add	sp,*6
15292                                           !BCC_EOS
15293                                           ! 2511       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
15294                                           ! Debug: list int = const $93 (used reg = )
15295 44B3           B8                   0093  mov	ax,#$93
15296 44B6           50                         push	ax
15297                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
15298 44B7           8B46         06            mov	ax,6[bp]
15299                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
15300                                           ! Debug: list unsigned int = ax+$2D (used reg = )
15301 44BA           05                   002D  add	ax,*$2D
15302 44BD           50                         push	ax
15303                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15304 44BE           FF76         14            push	$14[bp]
15305                                           ! Debug: func () void = write_byte+0 (used reg = )
15306 44C1           E8         C160            call	_write_byte
15307 44C4           83C4                   06  add	sp,*6
15308                                           !BCC_EOS
15309                                           ! 2512       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
15310                                           ! Debug: list int = const 0 (used reg = )
15311 44C7           31C0                       xor	ax,ax
15312 44C9           50                         push	ax
15313                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
15314 44CA           8B46         06            mov	ax,6[bp]
15315                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
15316                                           ! Debug: list unsigned int = ax+$2E (used reg = )
15317 44CD           05                   002E  add	ax,*$2E
15318 44D0           50                         push	ax
15319                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
15320 44D1           FF76         14            push	$14[bp]
15321                                           ! Debug: func () void = write_word+0 (used reg = )
15322 44D4           E8         C165            call	_write_word
15323 44D7           83C4                   06  add	sp,*6
15324                                           !BCC_EOS
15325                                           ! 2513       CX = regs.u.r16.cx;
15326                                           ! Debug: eq unsigned short regs = [S+$14+$E] to unsigned short CX = [S+$14-$E] (used reg = )
15327 44DA           8B46         10            mov	ax,$10[bp]
15328 44DD           8946         F4            mov	-$C[bp],ax
15329                                           !BCC_EOS
15330                                           ! 2514 #asm
15331                                           !BCC_EOS
15332                                           !BCC_ASM
15333                       00000006            _int15_function.CX	set	6
15334                       FFFFFFF4            .int15_function.CX	set	-$C
15335                       0000002A            _int15_function.FLAGS	set	$2A
15336                       00000018            .int15_function.FLAGS	set	$18
15337                       00000001            _int15_function.irqDisable	set	1
15338                       FFFFFFEF            .int15_function.irqDisable	set	-$11
15339                       00000028            _int15_function.DS	set	$28
15340                       00000016            .int15_function.DS	set	$16
15341                       00000004            _int15_function.DX	set	4
15342                       FFFFFFF2            .int15_function.DX	set	-$E
15343                       0000000B            _int15_function.base23_16	set	$B
15344                       FFFFFFF9            .int15_function.base23_16	set	-7
15345                       00000002            _int15_function.bRegister	set	2
15346                       FFFFFFF0            .int15_function.bRegister	set	-$10
15347                       00000026            _int15_function.ES	set	$26
15348                       00000014            .int15_function.ES	set	$14
15349                       00000010            _int15_function.ebda_seg	set	$10
15350                       FFFFFFFE            .int15_function.ebda_seg	set	-2
15351                       0000000C            _int15_function.base15_00	set	$C
15352                       FFFFFFFA            .int15_function.base15_00	set	-6
15353                       00000008            _int15_function.ss	set	8
15354                       FFFFFFF6            .int15_function.ss	set	-$A
15355                       00000016            _int15_function.regs	set	$16
15356                       00000004            .int15_function.regs	set	4
15357                       0000000E            _int15_function.prev_a20_enable	set	$E
15358                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
15359 44E0           89E3                             mov bx, sp
15360 44E2           36                               SEG SS
15361 44E3           8B4F         06                    mov cx, _int15_function.CX [bx]
15362 44E6     66    50                               push eax
15363 44E8     66    31C0                             xor eax, eax
15364 44EB           8ED8                             mov ds, ax
15365 44ED           8C16       0469                  mov 0x0469, ss
15366 44F1           8926       0467                  mov 0x0467, sp
15367 44F5           26                               SEG ES
15368 44F6         0F0154         08                    lgdt [si + 0x08]
15369 44FA           2E                               SEG CS
15370 44FB         0F011E       F88C                    lidt [pmode_IDT_info]
15371                                                 ;; perhaps do something with IDT here
15372                                                 ;; set PE bit in CR0
15373 4500         0F20C0                             mov eax, cr0
15374 4503           0C                     01        or al, #0x01
15375 4505         0F22C0                             mov cr0, eax
15376                                                 ;; far jump to flush CPU queue after transition to protected mode
15377                                                 JMP_AP(0x0020, protected_mode)
 +a   4508                        EA              db 0xea
 +a   4509                      450D              dw  protected_mode
 +a   450B                      0020              dw 0x0020
15378                       0000450D            protected_mode:
15379                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
15380 450D           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
15381 4510           8ED0                             mov ss, ax
15382 4512           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
15383 4515           8ED8                             mov ds, ax
15384 4517           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
15385 451A           8EC0                             mov es, ax
15386 451C           31F6                             xor si, si
15387 451E           31FF                             xor di, di
15388 4520           FC                               cld
15389 4521           F3                               rep
15390 4522           A5                                 movsw ;; move CX words from DS:SI to ES:DI
15391                                                 ;; make sure DS and ES limits are 64KB
15392 4523           B8                   0028        mov ax, #0x28
15393 4526           8ED8                             mov ds, ax
15394 4528           8EC0                             mov es, ax
15395                                                 ;; reset PG bit in CR0 ???
15396 452A         0F20C0                             mov eax, cr0
15397 452D           24                     FE        and al, #0xFE
15398 452F         0F22C0                             mov cr0, eax
15399                                                 ;; far jump to flush CPU queue after transition to real mode
15400                                                 JMP_AP(0xf000, real_mode)
 +a   4532                        EA              db 0xea
 +a   4533                      4537              dw  real_mode
 +a   4535                      F000              dw 0xf000
15401                       00004537            real_mode:
15402                                                 ;; restore IDT to normal real-mode defaults
15403 4537           2E                               SEG CS
15404 4538         0F011E       F891                    lidt [rmode_IDT_info]
15405 453D           31C0                             xor ax, ax
15406 453F           8ED8                             mov ds, ax
15407 4541           8E16       0469                  mov ss, 0x0469
15408 4545           8B26       0467                  mov sp, 0x0467
15409 4549     66    58                               pop eax
15410                                           ! 2566 endasm
15411                                           !BCC_ENDASM
15412                                           !BCC_EOS
15413                                           ! 2567       set_enable_a20(prev_a20_enable);
15414                                           ! Debug: list unsigned short prev_a20_enable = [S+$14-6] (used reg = )
15415 454B           FF76         FC            push	-4[bp]
15416                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
15417 454E           E8         D0F0            call	_set_enable_a20
15418 4551           44                         inc	sp
15419 4552           44                         inc	sp
15420                                           !BCC_EOS
15421                                           ! 2568 #asm
15422                                           !BCC_EOS
15423                                           !BCC_ASM
15424                       00000006            _int15_function.CX	set	6
15425                       FFFFFFF4            .int15_function.CX	set	-$C
15426                       0000002A            _int15_function.FLAGS	set	$2A
15427                       00000018            .int15_function.FLAGS	set	$18
15428                       00000001            _int15_function.irqDisable	set	1
15429                       FFFFFFEF            .int15_function.irqDisable	set	-$11
15430                       00000028            _int15_function.DS	set	$28
15431                       00000016            .int15_function.DS	set	$16
15432                       00000004            _int15_function.DX	set	4
15433                       FFFFFFF2            .int15_function.DX	set	-$E
15434                       0000000B            _int15_function.base23_16	set	$B
15435                       FFFFFFF9            .int15_function.base23_16	set	-7
15436                       00000002            _int15_function.bRegister	set	2
15437                       FFFFFFF0            .int15_function.bRegister	set	-$10
15438                       00000026            _int15_function.ES	set	$26
15439                       00000014            .int15_function.ES	set	$14
15440                       00000010            _int15_function.ebda_seg	set	$10
15441                       FFFFFFFE            .int15_function.ebda_seg	set	-2
15442                       0000000C            _int15_function.base15_00	set	$C
15443                       FFFFFFFA            .int15_function.base15_00	set	-6
15444                       00000008            _int15_function.ss	set	8
15445                       FFFFFFF6            .int15_function.ss	set	-$A
15446                       00000016            _int15_function.regs	set	$16
15447                       00000004            .int15_function.regs	set	4
15448                       0000000E            _int15_function.prev_a20_enable	set	$E
15449                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
15450 4553           FB                           sti
15451                                           ! 2570 endasm
15452                                           !BCC_ENDASM
15453                                           !BCC_EOS
15454                                           ! 2571       regs.u.r8.ah = 0;
15455                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
15456 4554           30C0                       xor	al,al
15457 4556           8846         13            mov	$13[bp],al
15458                                           !BCC_EOS
15459                                           ! 2572       FLAGS &= 0xfffe;
15460                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
15461 4559           8B46         18            mov	ax,$18[bp]
15462 455C           24                     FE  and	al,#$FE
15463 455E           8946         18            mov	$18[bp],ax
15464                                           !BCC_EOS
15465                                           ! 2573       break;
15466 4561           E9         0116            br 	.307
15467                                           !BCC_EOS
15468                                           ! 2574     case 0x88:
15469                                           ! 2575       regs.u.r8.al = inb_cmos(0x30);
15470                       00004564            .324:
15471                                           ! Debug: list int = const $30 (used reg = )
15472 4564           B8                   0030  mov	ax,*$30
15473 4567           50                         push	ax
15474                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
15475 4568           E8         C022            call	_inb_cmos
15476 456B           44                         inc	sp
15477 456C           44                         inc	sp
15478                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
15479 456D           8846         12            mov	$12[bp],al
15480                                           !BCC_EOS
15481                                           ! 2576       regs.u.r8.ah = inb_cmos(0x31);
15482                                           ! Debug: list int = const $31 (used reg = )
15483 4570           B8                   0031  mov	ax,*$31
15484 4573           50                         push	ax
15485                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
15486 4574           E8         C016            call	_inb_cmos
15487 4577           44                         inc	sp
15488 4578           44                         inc	sp
15489                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$11] (used reg = )
15490 4579           8846         13            mov	$13[bp],al
15491                                           !BCC_EOS
15492                                           ! 2577       if(regs.u.r16.ax > 0x3c00)
15493                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$14+$10] (used reg = )
15494 457C           8B46         12            mov	ax,$12[bp]
15495 457F           3D                   3C00  cmp	ax,#$3C00
15496 4582           76           06            jbe 	.325
15497                       00004584            .326:
15498                                           ! 2578         regs.u.r16.ax = 0x3c00;
15499                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$14+$10] (used reg = )
15500 4584           B8                   3C00  mov	ax,#$3C00
15501 4587           8946         12            mov	$12[bp],ax
15502                                           !BCC_EOS
15503                                           ! 2579       FLAGS &= 0xfffe;
15504                       0000458A            .325:
15505                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
15506 458A           8B46         18            mov	ax,$18[bp]
15507 458D           24                     FE  and	al,#$FE
15508 458F           8946         18            mov	$18[bp],ax
15509                                           !BCC_EOS
15510                                           ! 2580       break;
15511 4592           E9         00E5            br 	.307
15512                                           !BCC_EOS
15513                                           ! 2581     case 0x90:
15514                                           ! 2582       break;
15515                       00004595            .327:
15516 4595           E9         00E2            br 	.307
15517                                           !BCC_EOS
15518                                           ! 2583     case 0x91:
15519                                           ! 2584       break;
15520                       00004598            .328:
15521 4598           E9         00DF            br 	.307
15522                                           !BCC_EOS
15523                                           ! 2585     case 0xbf:
15524                                           ! 2586       bios_printf(4, "*** int 15h function AH=bf not yet supported!\n");
15525                       0000459B            .329:
15526                                           ! Debug: list * char = .32A+0 (used reg = )
15527 459B           BB                   D8AF  mov	bx,#.32A
15528 459E           53                         push	bx
15529                                           ! Debug: list int = const 4 (used reg = )
15530 459F           B8                   0004  mov	ax,*4
15531 45A2           50                         push	ax
15532                                           ! Debug: func () void = bios_printf+0 (used reg = )
15533 45A3           E8         C303            call	_bios_printf
15534 45A6           83C4                   04  add	sp,*4
15535                                           !BCC_EOS
15536                                           ! 2587       FLAGS |= 0x0001;
15537                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
15538 45A9           8B46         18            mov	ax,$18[bp]
15539 45AC           0C                     01  or	al,*1
15540 45AE           8946         18            mov	$18[bp],ax
15541                                           !BCC_EOS
15542                                           ! 2588       regs.u.r8.ah = 0x86;
15543                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
15544 45B1           B0                     86  mov	al,#$86
15545 45B3           8846         13            mov	$13[bp],al
15546                                           !BCC_EOS
15547                                           ! 2589       break;
15548 45B6           E9         00C1            br 	.307
15549                                           !BCC_EOS
15550                                           ! 2590     case 0xC0:
15551                                           ! 2591       FLAGS &= 0xfffe;
15552                       000045B9            .32B:
15553                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
15554 45B9           8B46         18            mov	ax,$18[bp]
15555 45BC           24                     FE  and	al,#$FE
15556 45BE           8946         18            mov	$18[bp],ax
15557                                           !BCC_EOS
15558                                           ! 2592       regs.u.r8.ah = 0;
15559                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
15560 45C1           30C0                       xor	al,al
15561 45C3           8846         13            mov	$13[bp],al
15562                                           !BCC_EOS
15563                                           ! 2593       regs.u.r16.bx = 0xe6f5;
15564                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$14+$A] (used reg = )
15565 45C6           B8                   E6F5  mov	ax,#$E6F5
15566 45C9           8946         0C            mov	$C[bp],ax
15567                                           !BCC_EOS
15568                                           ! 2594       ES = 0xF000;
15569                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$14+$12] (used reg = )
15570 45CC           B8                   F000  mov	ax,#$F000
15571 45CF           8946         14            mov	$14[bp],ax
15572                                           !BCC_EOS
15573                                           ! 2595       break;
15574 45D2           E9         00A5            br 	.307
15575                                           !BCC_EOS
15576                                           ! 2596     case 0xc1:
15577                                           ! 2597       ES = ebda_seg;
15578                       000045D5            .32C:
15579                                           ! Debug: eq unsigned short ebda_seg = [S+$14-4] to unsigned short ES = [S+$14+$12] (used reg = )
15580 45D5           8B46         FE            mov	ax,-2[bp]
15581 45D8           8946         14            mov	$14[bp],ax
15582                                           !BCC_EOS
15583                                           ! 2598       FLAGS &= 0xfffe;
15584                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
15585 45DB           8B46         18            mov	ax,$18[bp]
15586 45DE           24                     FE  and	al,#$FE
15587 45E0           8946         18            mov	$18[bp],ax
15588                                           !BCC_EOS
15589                                           ! 2599       break;
15590 45E3           E9         0094            br 	.307
15591                                           !BCC_EOS
15592                                           ! 2600     case 0xd8:
15593                                           ! 2601       bios_printf(8, "EISA BIOS not present\n");
15594                       000045E6            .32D:
15595                                           ! Debug: list * char = .32E+0 (used reg = )
15596 45E6           BB                   D898  mov	bx,#.32E
15597 45E9           53                         push	bx
15598                                           ! Debug: list int = const 8 (used reg = )
15599 45EA           B8                   0008  mov	ax,*8
15600 45ED           50                         push	ax
15601                                           ! Debug: func () void = bios_printf+0 (used reg = )
15602 45EE           E8         C2B8            call	_bios_printf
15603 45F1           83C4                   04  add	sp,*4
15604                                           !BCC_EOS
15605                                           ! 2602       FLAGS |= 0x0001;
15606                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
15607 45F4           8B46         18            mov	ax,$18[bp]
15608 45F7           0C                     01  or	al,*1
15609 45F9           8946         18            mov	$18[bp],ax
15610                                           !BCC_EOS
15611                                           ! 2603       regs.u.r8.ah = 0x86;
15612                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
15613 45FC           B0                     86  mov	al,#$86
15614 45FE           8846         13            mov	$13[bp],al
15615                                           !BCC_EOS
15616                                           ! 2604       break;
15617 4601           E9         0076            br 	.307
15618                                           !BCC_EOS
15619                                           ! 2605     default:
15620                                           ! 2606       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
15621                       00004604            .32F:
15622                                           ! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
15623 4604           FF76         0C            push	$C[bp]
15624                                           ! Debug: list unsigned short regs = [S+$16+$10] (used reg = )
15625 4607           FF76         12            push	$12[bp]
15626                                           ! Debug: list * char = .330+0 (used reg = )
15627 460A           BB                   D85E  mov	bx,#.330
15628 460D           53                         push	bx
15629                                           ! Debug: list int = const 4 (used reg = )
15630 460E           B8                   0004  mov	ax,*4
15631 4611           50                         push	ax
15632                                           ! Debug: func () void = bios_printf+0 (used reg = )
15633 4612           E8         C294            call	_bios_printf
15634 4615           83C4                   08  add	sp,*8
15635                                           !BCC_EOS
15636                                           ! 2607       FLAGS |= 0x0001;
15637                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
15638 4618           8B46         18            mov	ax,$18[bp]
15639 461B           0C                     01  or	al,*1
15640 461D           8946         18            mov	$18[bp],ax
15641                                           !BCC_EOS
15642                                           ! 2608       regs.u.r8.ah = 0x86;
15643                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
15644 4620           B0                     86  mov	al,#$86
15645 4622           8846         13            mov	$13[bp],al
15646                                           !BCC_EOS
15647                                           ! 2609       break;
15648 4625           EB           53            jmp .307
15649                                           !BCC_EOS
15650                                           ! 2610     }
15651                                           ! 2611 }
15652 4627           EB           51            jmp .307
15653                       00004629            .309:
15654 4629           2C                     24  sub	al,*$24
15655 462B         0F84         FB34            beq 	.30A
15656 462F           2C                     1D  sub	al,*$1D
15657 4631         0F84         FBD6            beq 	.314
15658 4635           2C                     0E  sub	al,*$E
15659 4637         0F84         FBE0            beq 	.315
15660 463B           2C                     03  sub	al,*3
15661 463D         0F84         FBE5            beq 	.316
15662 4641           2C                     31  sub	al,*$31
15663 4643         0F84         FBEF            beq 	.317
15664 4647           2C                     04  sub	al,*4
15665 4649         0F84         FD0A            beq 	.321
15666 464D           2C                     01  sub	al,*1
15667 464F         0F84         FF11            beq 	.324
15668 4653           2C                     08  sub	al,*8
15669 4655         0F84         FF3C            beq 	.327
15670 4659           2C                     01  sub	al,*1
15671 465B         0F84         FF39            beq 	.328
15672 465F           2C                     2E  sub	al,*$2E
15673 4661         0F84         FF36            beq 	.329
15674 4665           2C                     01  sub	al,*1
15675 4667         0F84         FF4E            beq 	.32B
15676 466B           2C                     01  sub	al,*1
15677 466D         0F84         FF64            beq 	.32C
15678 4671           2C                     17  sub	al,*$17
15679 4673         0F84         FF6F            beq 	.32D
15680 4677           E9         FF8A            br 	.32F
15681                       0000467A            .307:
15682                       FFFFFFEC            ..FFF6	=	-$14
15683 467A           89EC                       mov	sp,bp
15684 467C           5D                         pop	bp
15685 467D           C3                         ret
15686                                           ! 2612   void
15687                                           ! Register BX used in function int15_function
15688                                           ! 2613 int15_function_mouse(regs, ES, DS, FLAGS)
15689                                           ! 2614   pusha_regs_t regs;
15690                                           export	_int15_function_mouse
15691                       0000467E            _int15_function_mouse:
15692                                           !BCC_EOS
15693                                           ! 2615   Bit16u ES, DS, FLAGS;
15694                                           !BCC_EOS
15695                                           ! 2616 {
15696                                           ! 2617   Bit16u ebda_seg=read_word(0x0040,0x000E);
15697 467E           55                         push	bp
15698 467F           89E5                       mov	bp,sp
15699 4681           4C                         dec	sp
15700 4682           4C                         dec	sp
15701                                           ! Debug: list int = const $E (used reg = )
15702 4683           B8                   000E  mov	ax,*$E
15703 4686           50                         push	ax
15704                                           ! Debug: list int = const $40 (used reg = )
15705 4687           B8                   0040  mov	ax,*$40
15706 468A           50                         push	ax
15707                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15708 468B           E8         BF83            call	_read_word
15709 468E           83C4                   04  add	sp,*4
15710                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
15711 4691           8946         FE            mov	-2[bp],ax
15712                                           !BCC_EOS
15713                                           ! 2618   Bit8u mou
15714                                           ! 2618 se_flags_1, mouse_flags_2;
15715                                           !BCC_EOS
15716                                           ! 2619   Bit16u mouse_driver_seg;
15717                                           !BCC_EOS
15718                                           ! 2620   Bit16u mouse_driver_offset;
15719                                           !BCC_EOS
15720                                           ! 2621   Bit8u comm_byte, prev_command_byte;
15721                                           !BCC_EOS
15722                                           ! 2622   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
15723                                           !BCC_EOS
15724                                           ! 2623 ;
15725 4694           83C4                   F4  add	sp,*-$C
15726                                           !BCC_EOS
15727                                           ! 2624   switch (regs.u.r8.ah) {
15728 4697           8A46         13            mov	al,$13[bp]
15729 469A           E9         05AD            br 	.333
15730                                           ! 2625     case 0xC2:
15731                                           ! 2626       switch (regs.u.r8.al) {
15732                       0000469D            .334:
15733 469D           8A46         12            mov	al,$12[bp]
15734 46A0           E9         055B            br 	.337
15735                                           ! 2627         case 0:
15736                                           ! 2628 ;
15737                       000046A3            .338:
15738                                           !BCC_EOS
15739                                           ! 2629           switch (regs.u.r8.bh) {
15740 46A3           8A46         0D            mov	al,$D[bp]
15741 46A6           E9         00E9            br 	.33B
15742                                           ! 2630             case 0:
15743                                           ! 2631 ;
15744                       000046A9            .33C:
15745                                           !BCC_EOS
15746                                           ! 2632               inhibit_mouse_int_and_events();
15747                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15748 46A9           E8         0D71            call	_inhibit_mouse_int_and_events
15749                                           !BCC_EOS
15750                                           ! 2633               ret = send_to_mouse_ctrl(0xF5);
15751                                           ! Debug: list int = const $F5 (used reg = )
15752 46AC           B8                   00F5  mov	ax,#$F5
15753 46AF           50                         push	ax
15754                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15755 46B0           E8         0EBB            call	_send_to_mouse_ctrl
15756 46B3           44                         inc	sp
15757 46B4           44                         inc	sp
15758                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15759 46B5           8846         F5            mov	-$B[bp],al
15760                                           !BCC_EOS
15761                                           ! 2634               if (ret == 0) {
15762                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15763 46B8           8A46         F5            mov	al,-$B[bp]
15764 46BB           84C0                       test	al,al
15765 46BD           75           2B            jne 	.33D
15766                       000046BF            .33E:
15767                                           ! 2635                 ret = get_mouse_data(&mouse_data1);
15768                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15769 46BF           8D5E         F4            lea	bx,-$C[bp]
15770 46C2           53                         push	bx
15771                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15772 46C3           E8         0EF2            call	_get_mouse_data
15773 46C6           44                         inc	sp
15774 46C7           44                         inc	sp
15775                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15776 46C8           8846         F5            mov	-$B[bp],al
15777                                           !BCC_EOS
15778                                           ! 2636                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
15779                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15780 46CB           8A46         F5            mov	al,-$B[bp]
15781 46CE           84C0                       test	al,al
15782 46D0           74           07            je  	.340
15783                       000046D2            .341:
15784                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15785 46D2           8A46         F4            mov	al,-$C[bp]
15786 46D5           3C                     FA  cmp	al,#$FA
15787 46D7           75           11            jne 	.33F
15788                       000046D9            .340:
15789                                           ! 2637                   FLAGS &= 0xfffe;
15790                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15791 46D9           8B46         18            mov	ax,$18[bp]
15792 46DC           24                     FE  and	al,#$FE
15793 46DE           8946         18            mov	$18[bp],ax
15794                                           !BCC_EOS
15795                                           ! 2638                   regs.u.r8.ah = 0;
15796                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15797 46E1           30C0                       xor	al,al
15798 46E3           8846         13            mov	$13[bp],al
15799                                           !BCC_EOS
15800                                           ! 2639                   return;
15801 46E6           89EC                       mov	sp,bp
15802 46E8           5D                         pop	bp
15803 46E9           C3                         ret
15804                                           !BCC_EOS
15805                                           ! 2640                   }
15806                                           ! 2641                 }
15807                       000046EA            .33F:
15808                                           ! 2642               FLAGS |= 0x0001;
15809                       000046EA            .33D:
15810                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15811 46EA           8B46         18            mov	ax,$18[bp]
15812 46ED           0C                     01  or	al,*1
15813 46EF           8946         18            mov	$18[bp],ax
15814                                           !BCC_EOS
15815                                           ! 2643               regs.u.r8.ah = ret;
15816                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15817 46F2           8A46         F5            mov	al,-$B[bp]
15818 46F5           8846         13            mov	$13[bp],al
15819                                           !BCC_EOS
15820                                           ! 2644               return;
15821 46F8           89EC                       mov	sp,bp
15822 46FA           5D                         pop	bp
15823 46FB           C3                         ret
15824                                           !BCC_EOS
15825                                           ! 2645               break;
15826 46FC           E9         00A1            br 	.339
15827                                           !BCC_EOS
15828                                           ! 2646             case 1:
15829                                           ! 2647 ;
15830                       000046FF            .342:
15831                                           !BCC_EOS
15832                                           ! 2648               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
15833                                           ! Debug: list int = const $27 (used reg = )
15834 46FF           B8                   0027  mov	ax,*$27
15835 4702           50                         push	ax
15836                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
15837 4703           FF76         FE            push	-2[bp]
15838                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15839 4706           E8         BEF5            call	_read_byte
15840 4709           83C4                   04  add	sp,*4
15841                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15842 470C           8846         FC            mov	-4[bp],al
15843                                           !BCC_EOS
15844                                           ! 2649               if ( (mouse_flags_2 & 0x80) == 0 ) {
15845                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
15846 470F           8A46         FC            mov	al,-4[bp]
15847 4712           24                     80  and	al,#$80
15848                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15849 4714           84C0                       test	al,al
15850 4716           75           11            jne 	.343
15851                       00004718            .344:
15852                                           ! 2650                 ;
15853                                           !BCC_EOS
15854                                           ! 2651                 FLAGS |= 0x0001;
15855                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15856 4718           8B46         18            mov	ax,$18[bp]
15857 471B           0C                     01  or	al,*1
15858 471D           8946         18            mov	$18[bp],ax
15859                                           !BCC_EOS
15860                                           ! 2652                 regs.u.r8.ah = 5;
15861                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
15862 4720           B0                     05  mov	al,*5
15863 4722           8846         13            mov	$13[bp],al
15864                                           !BCC_EOS
15865                                           ! 2653                 return;
15866 4725           89EC                       mov	sp,bp
15867 4727           5D                         pop	bp
15868 4728           C3                         ret
15869                                           !BCC_EOS
15870                                           ! 2654                 }
15871                                           ! 2655               inhibit_mouse_int_and_events();
15872                       00004729            .343:
15873                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
15874 4729           E8         0CF1            call	_inhibit_mouse_int_and_events
15875                                           !BCC_EOS
15876                                           ! 2656               ret = send_to_mouse_ctrl(0xF4);
15877                                           ! Debug: list int = const $F4 (used reg = )
15878 472C           B8                   00F4  mov	ax,#$F4
15879 472F           50                         push	ax
15880                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
15881 4730           E8         0E3B            call	_send_to_mouse_ctrl
15882 4733           44                         inc	sp
15883 4734           44                         inc	sp
15884                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15885 4735           8846         F5            mov	-$B[bp],al
15886                                           !BCC_EOS
15887                                           ! 2657               if (ret == 0) {
15888                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15889 4738           8A46         F5            mov	al,-$B[bp]
15890 473B           84C0                       test	al,al
15891 473D           75           2E            jne 	.345
15892                       0000473F            .346:
15893                                           ! 2658                 ret = get_mouse_data(&mouse_data1);
15894                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
15895 473F           8D5E         F4            lea	bx,-$C[bp]
15896 4742           53                         push	bx
15897                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
15898 4743           E8         0E72            call	_get_mouse_data
15899 4746           44                         inc	sp
15900 4747           44                         inc	sp
15901                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
15902 4748           8846         F5            mov	-$B[bp],al
15903                                           !BCC_EOS
15904                                           ! 2659                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
15905                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
15906 474B           8A46         F5            mov	al,-$B[bp]
15907 474E           84C0                       test	al,al
15908 4750           75           1B            jne 	.347
15909                       00004752            .349:
15910                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
15911 4752           8A46         F4            mov	al,-$C[bp]
15912 4755           3C                     FA  cmp	al,#$FA
15913 4757           75           14            jne 	.347
15914                       00004759            .348:
15915                                           ! 2660                   enable_mouse_int_and_events();
15916                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
15917 4759           E8         0D6E            call	_enable_mouse_int_and_events
15918                                           !BCC_EOS
15919                                           ! 2661                   FLAGS &= 0xfffe;
15920                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
15921 475C           8B46         18            mov	ax,$18[bp]
15922 475F           24                     FE  and	al,#$FE
15923 4761           8946         18            mov	$18[bp],ax
15924                                           !BCC_EOS
15925                                           ! 2662                   regs.u.r8.ah = 0;
15926                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
15927 4764           30C0                       xor	al,al
15928 4766           8846         13            mov	$13[bp],al
15929                                           !BCC_EOS
15930                                           ! 2663                   return;
15931 4769           89EC                       mov	sp,bp
15932 476B           5D                         pop	bp
15933 476C           C3                         ret
15934                                           !BCC_EOS
15935                                           ! 2664                   }
15936                                           ! 2665                 }
15937                       0000476D            .347:
15938                                           ! 2666               FLAGS |= 0x0001;
15939                       0000476D            .345:
15940                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15941 476D           8B46         18            mov	ax,$18[bp]
15942 4770           0C                     01  or	al,*1
15943 4772           8946         18            mov	$18[bp],ax
15944                                           !BCC_EOS
15945                                           ! 2667               regs.u.r8.ah = ret;
15946                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
15947 4775           8A46         F5            mov	al,-$B[bp]
15948 4778           8846         13            mov	$13[bp],al
15949                                           !BCC_EOS
15950                                           ! 2668               return;
15951 477B           89EC                       mov	sp,bp
15952 477D           5D                         pop	bp
15953 477E           C3                         ret
15954                                           !BCC_EOS
15955                                           ! 2669             default:
15956                                           ! 2670               ;
15957                       0000477F            .34A:
15958                                           !BCC_EOS
15959                                           ! 2671               FLAGS |= 0x0001;
15960                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
15961 477F           8B46         18            mov	ax,$18[bp]
15962 4782           0C                     01  or	al,*1
15963 4784           8946         18            mov	$18[bp],ax
15964                                           !BCC_EOS
15965                                           ! 2672               regs.u.r8.ah = 1;
15966                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
15967 4787           B0                     01  mov	al,*1
15968 4789           8846         13            mov	$13[bp],al
15969                                           !BCC_EOS
15970                                           ! 2673               return;
15971 478C           89EC                       mov	sp,bp
15972 478E           5D                         pop	bp
15973 478F           C3                         ret
15974                                           !BCC_EOS
15975                                           ! 2674             }
15976                                           ! 2675           break;
15977 4790           EB           0E            jmp .339
15978                       00004792            .33B:
15979 4792           2C                     00  sub	al,*0
15980 4794         0F84         FF11            beq 	.33C
15981 4798           2C                     01  sub	al,*1
15982 479A         0F84         FF61            beq 	.342
15983 479E           EB           DF            jmp	.34A
15984                       000047A0            .339:
15985 47A0           E9         0480            br 	.335
15986                                           !BCC_EOS
15987                                           ! 2676         case 1:
15988                                           ! 2677         case 5:
15989                       000047A3            .34B:
15990                                           ! 2678 ;
15991                       000047A3            .34C:
15992                                           !BCC_EOS
15993                                           ! 2679           if (regs.u.r8.al == 5) {
15994                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
15995 47A3           8A46         12            mov	al,$12[bp]
15996 47A6           3C                     05  cmp	al,*5
15997 47A8           75           5E            jne 	.34D
15998                       000047AA            .34E:
15999                                           ! 2680             if (regs.u.r8.bh != 3) {
16000                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
16001 47AA           8A46         0D            mov	al,$D[bp]
16002 47AD           3C                     03  cmp	al,*3
16003 47AF           74           11            je  	.34F
16004                       000047B1            .350:
16005                                           ! 2681               FLAGS |= 0x0001;
16006                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16007 47B1           8B46         18            mov	ax,$18[bp]
16008 47B4           0C                     01  or	al,*1
16009 47B6           8946         18            mov	$18[bp],ax
16010                                           !BCC_EOS
16011                                           ! 2682               regs.u.r8.ah = 0x02;
16012                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
16013 47B9           B0                     02  mov	al,*2
16014 47BB           8846         13            mov	$13[bp],al
16015                                           !BCC_EOS
16016                                           ! 2683               return;
16017 47BE           89EC                       mov	sp,bp
16018 47C0           5D                         pop	bp
16019 47C1           C3                         ret
16020                                           !BCC_EOS
16021                                           ! 2684             }
16022                                           ! 2685             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
16023                       000047C2            .34F:
16024                                           ! Debug: list int = const $27 (used reg = )
16025 47C2           B8                   0027  mov	ax,*$27
16026 47C5           50                         push	ax
16027                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
16028 47C6           FF76         FE            push	-2[bp]
16029                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
16030 47C9           E8         BE32            call	_read_byte
16031 47CC           83C4                   04  add	sp,*4
16032                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16033 47CF           8846         FC            mov	-4[bp],al
16034                                           !BCC_EOS
16035                                           ! 2686             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
16036                                           ! 2686 
16037                                           ! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16038 47D2           8A46         FC            mov	al,-4[bp]
16039 47D5           30C0                       xor	al,al
16040                                           ! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
16041 47D7           0A46         0D            or	al,$D[bp]
16042                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16043 47DA           8846         FC            mov	-4[bp],al
16044                                           !BCC_EOS
16045                                           ! 2687             mouse_flags_1 = 0x00;
16046                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
16047 47DD           30C0                       xor	al,al
16048 47DF           8846         FD            mov	-3[bp],al
16049                                           !BCC_EOS
16050                                           ! 2688             write_byte(ebda_seg, 0x0026, mouse_flags_1);
16051                                           ! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
16052 47E2           8A46         FD            mov	al,-3[bp]
16053 47E5           30E4                       xor	ah,ah
16054 47E7           50                         push	ax
16055                                           ! Debug: list int = const $26 (used reg = )
16056 47E8           B8                   0026  mov	ax,*$26
16057 47EB           50                         push	ax
16058                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
16059 47EC           FF76         FE            push	-2[bp]
16060                                           ! Debug: func () void = write_byte+0 (used reg = )
16061 47EF           E8         BE32            call	_write_byte
16062 47F2           83C4                   06  add	sp,*6
16063                                           !BCC_EOS
16064                                           ! 2689             write_byte(ebda_seg, 0x0027, mouse_flags_2);
16065                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16066 47F5           8A46         FC            mov	al,-4[bp]
16067 47F8           30E4                       xor	ah,ah
16068 47FA           50                         push	ax
16069                                           ! Debug: list int = const $27 (used reg = )
16070 47FB           B8                   0027  mov	ax,*$27
16071 47FE           50                         push	ax
16072                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
16073 47FF           FF76         FE            push	-2[bp]
16074                                           ! Debug: func () void = write_byte+0 (used reg = )
16075 4802           E8         BE1F            call	_write_byte
16076 4805           83C4                   06  add	sp,*6
16077                                           !BCC_EOS
16078                                           ! 2690           }
16079                                           ! 2691           inhibit_mouse_int_and_events();
16080                       00004808            .34D:
16081                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16082 4808           E8         0C12            call	_inhibit_mouse_int_and_events
16083                                           !BCC_EOS
16084                                           ! 2692           ret = send_to_mouse_ctrl(0xFF);
16085                                           ! Debug: list int = const $FF (used reg = )
16086 480B           B8                   00FF  mov	ax,#$FF
16087 480E           50                         push	ax
16088                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16089 480F           E8         0D5C            call	_send_to_mouse_ctrl
16090 4812           44                         inc	sp
16091 4813           44                         inc	sp
16092                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16093 4814           8846         F5            mov	-$B[bp],al
16094                                           !BCC_EOS
16095                                           ! 2693           if (ret == 0) {
16096                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16097 4817           8A46         F5            mov	al,-$B[bp]
16098 481A           84C0                       test	al,al
16099 481C         0F85         0087            bne 	.351
16100                       00004820            .352:
16101                                           ! 2694             ret = get_mouse_data(&mouse_data3);
16102                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
16103 4820           8D5E         F2            lea	bx,-$E[bp]
16104 4823           53                         push	bx
16105                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16106 4824           E8         0D91            call	_get_mouse_data
16107 4827           44                         inc	sp
16108 4828           44                         inc	sp
16109                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16110 4829           8846         F5            mov	-$B[bp],al
16111                                           !BCC_EOS
16112                                           ! 2695             if (mouse_data3 == 0xfe) {
16113                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
16114 482C           8A46         F2            mov	al,-$E[bp]
16115 482F           3C                     FE  cmp	al,#$FE
16116 4831           75           0C            jne 	.353
16117                       00004833            .354:
16118                                           ! 2696               FLAGS |= 0x0001;
16119                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16120 4833           8B46         18            mov	ax,$18[bp]
16121 4836           0C                     01  or	al,*1
16122 4838           8946         18            mov	$18[bp],ax
16123                                           !BCC_EOS
16124                                           ! 2697               return;
16125 483B           89EC                       mov	sp,bp
16126 483D           5D                         pop	bp
16127 483E           C3                         ret
16128                                           !BCC_EOS
16129                                           ! 2698             }
16130                                           ! 2699             if (mouse_data3 != 0xfa)
16131                       0000483F            .353:
16132                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
16133 483F           8A46         F2            mov	al,-$E[bp]
16134 4842           3C                     FA  cmp	al,#$FA
16135 4844           74           14            je  	.355
16136                       00004846            .356:
16137                                           ! 2700               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
16138                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
16139 4846           8A46         F2            mov	al,-$E[bp]
16140 4849           30E4                       xor	ah,ah
16141 484B           50                         push	ax
16142                                           ! Debug: list * char = .357+0 (used reg = )
16143 484C           BB                   D833  mov	bx,#.357
16144 484F           53                         push	bx
16145                                           ! Debug: list int = const 7 (used reg = )
16146 4850           B8                   0007  mov	ax,*7
16147 4853           50                         push	ax
16148                                           ! Debug: func () void = bios_printf+0 (used reg = )
16149 4854           E8         C052            call	_bios_printf
16150 4857           83C4                   06  add	sp,*6
16151                                           !BCC_EOS
16152                                           ! 2701             if ( ret == 0 ) {
16153                       0000485A            .355:
16154                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16155 485A           8A46         F5            mov	al,-$B[bp]
16156 485D           84C0                       test	al,al
16157 485F           75           46            jne 	.358
16158                       00004861            .359:
16159                                           ! 2702               ret = get_mouse_data(&mouse_data1);
16160                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16161 4861           8D5E         F4            lea	bx,-$C[bp]
16162 4864           53                         push	bx
16163                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16164 4865           E8         0D50            call	_get_mouse_data
16165 4868           44                         inc	sp
16166 4869           44                         inc	sp
16167                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16168 486A           8846         F5            mov	-$B[bp],al
16169                                           !BCC_EOS
16170                                           ! 2703               if ( ret == 0 ) {
16171                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16172 486D           8A46         F5            mov	al,-$B[bp]
16173 4870           84C0                       test	al,al
16174 4872           75           33            jne 	.35A
16175                       00004874            .35B:
16176                                           ! 2704                 ret = get_mouse_data(&mouse_data2);
16177                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16178 4874           8D5E         F3            lea	bx,-$D[bp]
16179 4877           53                         push	bx
16180                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16181 4878           E8         0D3D            call	_get_mouse_data
16182 487B           44                         inc	sp
16183 487C           44                         inc	sp
16184                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16185 487D           8846         F5            mov	-$B[bp],al
16186                                           !BCC_EOS
16187                                           ! 2705                 if ( ret == 0 ) {
16188                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16189 4880           8A46         F5            mov	al,-$B[bp]
16190 4883           84C0                       test	al,al
16191 4885           75           20            jne 	.35C
16192                       00004887            .35D:
16193                                           ! 2706                   enable_mouse_int_and_events();
16194                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
16195 4887           E8         0C40            call	_enable_mouse_int_and_events
16196                                           !BCC_EOS
16197                                           ! 2707                   FLAGS &= 0xfffe;
16198                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16199 488A           8B46         18            mov	ax,$18[bp]
16200 488D           24                     FE  and	al,#$FE
16201 488F           8946         18            mov	$18[bp],ax
16202                                           !BCC_EOS
16203                                           ! 2708                   regs.u.r8.ah = 0;
16204                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16205 4892           30C0                       xor	al,al
16206 4894           8846         13            mov	$13[bp],al
16207                                           !BCC_EOS
16208                                           ! 2709                   regs.u.r8.bl = mouse_data1;
16209                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
16210 4897           8A46         F4            mov	al,-$C[bp]
16211 489A           8846         0C            mov	$C[bp],al
16212                                           !BCC_EOS
16213                                           ! 2710                   regs.u.r8.bh = mouse_data2;
16214                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
16215 489D           8A46         F3            mov	al,-$D[bp]
16216 48A0           8846         0D            mov	$D[bp],al
16217                                           !BCC_EOS
16218                                           ! 2711                   return;
16219 48A3           89EC                       mov	sp,bp
16220 48A5           5D                         pop	bp
16221 48A6           C3                         ret
16222                                           !BCC_EOS
16223                                           ! 2712                   }
16224                                           ! 2713                 }
16225                       000048A7            .35C:
16226                                           ! 2714               }
16227                       000048A7            .35A:
16228                                           ! 2715             }
16229                       000048A7            .358:
16230                                           ! 2716           FLAGS |= 0x0001;
16231                       000048A7            .351:
16232                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16233 48A7           8B46         18            mov	ax,$18[bp]
16234 48AA           0C                     01  or	al,*1
16235 48AC           8946         18            mov	$18[bp],ax
16236                                           !BCC_EOS
16237                                           ! 2717           regs.u.r8.ah = ret;
16238                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
16239 48AF           8A46         F5            mov	al,-$B[bp]
16240 48B2           8846         13            mov	$13[bp],al
16241                                           !BCC_EOS
16242                                           ! 2718           return;
16243 48B5           89EC                       mov	sp,bp
16244 48B7           5D                         pop	bp
16245 48B8           C3                         ret
16246                                           !BCC_EOS
16247                                           ! 2719         case 2:
16248                                           ! 2720 ;
16249                       000048B9            .35E:
16250                                           !BCC_EOS
16251                                           ! 2721           switch (regs.u.r8.bh) {
16252 48B9           8A46         0D            mov	al,$D[bp]
16253 48BC           EB           38            jmp .361
16254                                           ! 2722             case 0: mouse_data1 = 10; break;
16255                       000048BE            .362:
16256                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16257 48BE           B0                     0A  mov	al,*$A
16258 48C0           8846         F4            mov	-$C[bp],al
16259                                           !BCC_EOS
16260 48C3           EB           54            jmp .35F
16261                                           !BCC_EOS
16262                                           ! 2723             case 1: mouse_data1 = 20; break;
16263                       000048C5            .363:
16264                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16265 48C5           B0                     14  mov	al,*$14
16266 48C7           8846         F4            mov	-$C[bp],al
16267                                           !BCC_EOS
16268 48CA           EB           4D            jmp .35F
16269                                           !BCC_EOS
16270                                           ! 2724             case 2: mouse_data1 = 40; break;
16271                       000048CC            .364:
16272                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16273 48CC           B0                     28  mov	al,*$28
16274 48CE           8846         F4            mov	-$C[bp],al
16275                                           !BCC_EOS
16276 48D1           EB           46            jmp .35F
16277                                           !BCC_EOS
16278                                           ! 2725             case 3: mouse_data1 = 60; break;
16279                       000048D3            .365:
16280                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16281 48D3           B0                     3C  mov	al,*$3C
16282 48D5           8846         F4            mov	-$C[bp],al
16283                                           !BCC_EOS
16284 48D8           EB           3F            jmp .35F
16285                                           !BCC_EOS
16286                                           ! 2726             case 4: mouse_data1 = 80; break;
16287                       000048DA            .366:
16288                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16289 48DA           B0                     50  mov	al,*$50
16290 48DC           8846         F4            mov	-$C[bp],al
16291                                           !BCC_EOS
16292 48DF           EB           38            jmp .35F
16293                                           !BCC_EOS
16294                                           ! 2727             case 5: mouse_data1 = 100; break;
16295                       000048E1            .367:
16296                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16297 48E1           B0                     64  mov	al,*$64
16298 48E3           8846         F4            mov	-$C[bp],al
16299                                           !BCC_EOS
16300 48E6           EB           31            jmp .35F
16301                                           !BCC_EOS
16302                                           ! 2728             case 6: mouse_data1 = 200; break;
16303                       000048E8            .368:
16304                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16305 48E8           B0                     C8  mov	al,#$C8
16306 48EA           8846         F4            mov	-$C[bp],al
16307                                           !BCC_EOS
16308 48ED           EB           2A            jmp .35F
16309                                           !BCC_EOS
16310                                           ! 2729             default: mouse_data1 = 0;
16311                       000048EF            .369:
16312                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16313 48EF           30C0                       xor	al,al
16314 48F1           8846         F4            mov	-$C[bp],al
16315                                           !BCC_EOS
16316                                           ! 2730           }
16317                                           ! 2731           if (mouse_data1 > 0) {
16318 48F4           EB           23            jmp .35F
16319                       000048F6            .361:
16320 48F6           2C                     00  sub	al,*0
16321 48F8           72           F5            jb 	.369
16322 48FA           3C                     06  cmp	al,*6
16323 48FC           77           19            ja  	.36A
16324 48FE           30E4                       xor	ah,ah
16325 4900           D1E0                       shl	ax,*1
16326 4902           89C3                       mov	bx,ax
16327 4904           2E                         seg	cs
16328 4905           FFA7       4909            br	.36B[bx]
16329                       00004909            .36B:
16330 4909                      48BE            .word	.362
16331 490B                      48C5            .word	.363
16332 490D                      48CC            .word	.364
16333 490F                      48D3            .word	.365
16334 4911                      48DA            .word	.366
16335 4913                      48E1            .word	.367
16336 4915                      48E8            .word	.368
16337                       00004917            .36A:
16338 4917           EB           D6            jmp	.369
16339                       00004919            .35F:
16340                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16341 4919           8A46         F4            mov	al,-$C[bp]
16342 491C           84C0                       test	al,al
16343 491E         0F84         0057            beq 	.36C
16344                       00004922            .36D:
16345                                           ! 2732             ret = send_to_mouse_ctrl(0xF3);
16346                                           ! Debug: list int = const $F3 (used reg = )
16347 4922           B8                   00F3  mov	ax,#$F3
16348 4925           50                         push	ax
16349                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16350 4926           E8         0C45            call	_send_to_mouse_ctrl
16351 4929           44                         inc	sp
16352 492A           44                         inc	sp
16353                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16354 492B           8846         F5            mov	-$B[bp],al
16355                                           !BCC_EOS
16356                                           ! 2733             if (ret == 0) {
16357                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16358 492E           8A46         F5            mov	al,-$B[bp]
16359 4931           84C0                       test	al,al
16360 4933           75           35            jne 	.36E
16361                       00004935            .36F:
16362                                           ! 2734               ret = get_mouse_data(&mouse_data2);
16363                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16364 4935           8D5E         F3            lea	bx,-$D[bp]
16365 4938           53                         push	bx
16366                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16367 4939           E8         0C7C            call	_get_mouse_data
16368 493C           44                         inc	sp
16369 493D           44                         inc	sp
16370                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16371 493E           8846         F5            mov	-$B[bp],al
16372                                           !BCC_EOS
16373                                           ! 2735               ret = send_to_mouse_ctrl(mouse_data1);
16374                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16375 4941           8A46         F4            mov	al,-$C[bp]
16376 4944           30E4                       xor	ah,ah
16377 4946           50                         push	ax
16378                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16379 4947           E8         0C24            call	_send_to_mouse_ctrl
16380 494A           44                         inc	sp
16381 494B           44                         inc	sp
16382                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16383 494C           8846         F5            mov	-$B[bp],al
16384                                           !BCC_EOS
16385                                           ! 2736               ret = get_mouse_data(&mouse_data2);
16386                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16387 494F           8D5E         F3            lea	bx,-$D[bp]
16388 4952           53                         push	bx
16389                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16390 4953           E8         0C62            call	_get_mouse_data
16391 4956           44                         inc	sp
16392 4957           44                         inc	sp
16393                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16394 4958           8846         F5            mov	-$B[bp],al
16395                                           !BCC_EOS
16396                                           ! 2737               FLAGS &= 0xfffe;
16397                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16398 495B           8B46         18            mov	ax,$18[bp]
16399 495E           24                     FE  and	al,#$FE
16400 4960           8946         18            mov	$18[bp],ax
16401                                           !BCC_EOS
16402                                           ! 2738               regs.u.r8.ah = 0;
16403                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16404 4963           30C0                       xor	al,al
16405 4965           8846         13            mov	$13[bp],al
16406                                           !BCC_EOS
16407                                           ! 2739             } else {
16408 4968           EB           0D            jmp .370
16409                       0000496A            .36E:
16410                                           ! 2740               FLAGS |= 0x0001;
16411                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16412 496A           8B46         18            mov	ax,$18[bp]
16413 496D           0C                     01  or	al,*1
16414 496F           8946         18            mov	$18[bp],ax
16415                                           !BCC_EOS
16416                                           ! 2741               regs.u.r8.ah = 0x86;
16417                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16418 4972           B0                     86  mov	al,#$86
16419 4974           8846         13            mov	$13[bp],al
16420                                           !BCC_EOS
16421                                           ! 2742             }
16422                                           ! 2743           } else {
16423                       00004977            .370:
16424 4977           EB           0D            jmp .371
16425                       00004979            .36C:
16426                                           ! 2744             FLAGS |= 0x0001;
16427                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16428 4979           8B46         18            mov	ax,$18[bp]
16429 497C           0C                     01  or	al,*1
16430 497E           8946         18            mov	$18[bp],ax
16431                                           !BCC_EOS
16432                                           ! 2745         
16433                                           ! 2745     regs.u.r8.ah = 0x86;
16434                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16435 4981           B0                     86  mov	al,#$86
16436 4983           8846         13            mov	$13[bp],al
16437                                           !BCC_EOS
16438                                           ! 2746           }
16439                                           ! 2747           break;
16440                       00004986            .371:
16441 4986           E9         029A            br 	.335
16442                                           !BCC_EOS
16443                                           ! 2748         case 3:
16444                                           ! 2749 ;
16445                       00004989            .372:
16446                                           !BCC_EOS
16447                                           ! 2750           FLAGS &= 0xfffe;
16448                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16449 4989           8B46         18            mov	ax,$18[bp]
16450 498C           24                     FE  and	al,#$FE
16451 498E           8946         18            mov	$18[bp],ax
16452                                           !BCC_EOS
16453                                           ! 2751           regs.u.r8.ah = 0;
16454                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16455 4991           30C0                       xor	al,al
16456 4993           8846         13            mov	$13[bp],al
16457                                           !BCC_EOS
16458                                           ! 2752           break;
16459 4996           E9         028A            br 	.335
16460                                           !BCC_EOS
16461                                           ! 2753         case 4:
16462                                           ! 2754 ;
16463                       00004999            .373:
16464                                           !BCC_EOS
16465                                           ! 2755           inhibit_mouse_int_and_events();
16466                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16467 4999           E8         0A81            call	_inhibit_mouse_int_and_events
16468                                           !BCC_EOS
16469                                           ! 2756           ret = send_to_mouse_ctrl(0xF2);
16470                                           ! Debug: list int = const $F2 (used reg = )
16471 499C           B8                   00F2  mov	ax,#$F2
16472 499F           50                         push	ax
16473                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16474 49A0           E8         0BCB            call	_send_to_mouse_ctrl
16475 49A3           44                         inc	sp
16476 49A4           44                         inc	sp
16477                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16478 49A5           8846         F5            mov	-$B[bp],al
16479                                           !BCC_EOS
16480                                           ! 2757           if (ret == 0) {
16481                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16482 49A8           8A46         F5            mov	al,-$B[bp]
16483 49AB           84C0                       test	al,al
16484 49AD           75           2D            jne 	.374
16485                       000049AF            .375:
16486                                           ! 2758             ret = get_mouse_data(&mouse_data1);
16487                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16488 49AF           8D5E         F4            lea	bx,-$C[bp]
16489 49B2           53                         push	bx
16490                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16491 49B3           E8         0C02            call	_get_mouse_data
16492 49B6           44                         inc	sp
16493 49B7           44                         inc	sp
16494                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16495 49B8           8846         F5            mov	-$B[bp],al
16496                                           !BCC_EOS
16497                                           ! 2759             ret = get_mouse_data(&mouse_data2);
16498                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16499 49BB           8D5E         F3            lea	bx,-$D[bp]
16500 49BE           53                         push	bx
16501                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16502 49BF           E8         0BF6            call	_get_mouse_data
16503 49C2           44                         inc	sp
16504 49C3           44                         inc	sp
16505                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16506 49C4           8846         F5            mov	-$B[bp],al
16507                                           !BCC_EOS
16508                                           ! 2760             FLAGS &= 0xfffe;
16509                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16510 49C7           8B46         18            mov	ax,$18[bp]
16511 49CA           24                     FE  and	al,#$FE
16512 49CC           8946         18            mov	$18[bp],ax
16513                                           !BCC_EOS
16514                                           ! 2761             regs.u.r8.ah = 0;
16515                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16516 49CF           30C0                       xor	al,al
16517 49D1           8846         13            mov	$13[bp],al
16518                                           !BCC_EOS
16519                                           ! 2762             regs.u.r8.bh = mouse_data2;
16520                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
16521 49D4           8A46         F3            mov	al,-$D[bp]
16522 49D7           8846         0D            mov	$D[bp],al
16523                                           !BCC_EOS
16524                                           ! 2763           } else {
16525 49DA           EB           0D            jmp .376
16526                       000049DC            .374:
16527                                           ! 2764             FLAGS |= 0x0001;
16528                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16529 49DC           8B46         18            mov	ax,$18[bp]
16530 49DF           0C                     01  or	al,*1
16531 49E1           8946         18            mov	$18[bp],ax
16532                                           !BCC_EOS
16533                                           ! 2765             regs.u.r8.ah = 0x86;
16534                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16535 49E4           B0                     86  mov	al,#$86
16536 49E6           8846         13            mov	$13[bp],al
16537                                           !BCC_EOS
16538                                           ! 2766           }
16539                                           ! 2767           break;
16540                       000049E9            .376:
16541 49E9           E9         0237            br 	.335
16542                                           !BCC_EOS
16543                                           ! 2768         case 6:
16544                                           ! 2769 ;
16545                       000049EC            .377:
16546                                           !BCC_EOS
16547                                           ! 2770           switch (regs.u.r8.bh) {
16548 49EC           8A46         0D            mov	al,$D[bp]
16549 49EF           E9         015C            br 	.37A
16550                                           ! 2771             case 0:
16551                                           ! 2772               comm_byte = inhibit_mouse_int_and_events();
16552                       000049F2            .37B:
16553                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16554 49F2           E8         0A28            call	_inhibit_mouse_int_and_events
16555                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
16556 49F5           8846         F7            mov	-9[bp],al
16557                                           !BCC_EOS
16558                                           ! 2773               ret = send_to_mouse_ctrl(0xE9);
16559                                           ! Debug: list int = const $E9 (used reg = )
16560 49F8           B8                   00E9  mov	ax,#$E9
16561 49FB           50                         push	ax
16562                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16563 49FC           E8         0B6F            call	_send_to_mouse_ctrl
16564 49FF           44                         inc	sp
16565 4A00           44                         inc	sp
16566                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16567 4A01           8846         F5            mov	-$B[bp],al
16568                                           !BCC_EOS
16569                                           ! 2774               if (ret == 0) {
16570                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16571 4A04           8A46         F5            mov	al,-$B[bp]
16572 4A07           84C0                       test	al,al
16573 4A09         0F85         0097            bne 	.37C
16574                       00004A0D            .37D:
16575                                           ! 2775                 ret = get_mouse_data(&mouse_data1);
16576                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16577 4A0D           8D5E         F4            lea	bx,-$C[bp]
16578 4A10           53                         push	bx
16579                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16580 4A11           E8         0BA4            call	_get_mouse_data
16581 4A14           44                         inc	sp
16582 4A15           44                         inc	sp
16583                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16584 4A16           8846         F5            mov	-$B[bp],al
16585                                           !BCC_EOS
16586                                           ! 2776                 if (mouse_data1 != 0xfa)
16587                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16588 4A19           8A46         F4            mov	al,-$C[bp]
16589 4A1C           3C                     FA  cmp	al,#$FA
16590 4A1E           74           14            je  	.37E
16591                       00004A20            .37F:
16592                                           ! 2777                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
16593                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16594 4A20           8A46         F4            mov	al,-$C[bp]
16595 4A23           30E4                       xor	ah,ah
16596 4A25           50                         push	ax
16597                                           ! Debug: list * char = .380+0 (used reg = )
16598 4A26           BB                   D807  mov	bx,#.380
16599 4A29           53                         push	bx
16600                                           ! Debug: list int = const 7 (used reg = )
16601 4A2A           B8                   0007  mov	ax,*7
16602 4A2D           50                         push	ax
16603                                           ! Debug: func () void = bios_printf+0 (used reg = )
16604 4A2E           E8         BE78            call	_bios_printf
16605 4A31           83C4                   06  add	sp,*6
16606                                           !BCC_EOS
16607                                           ! 2778                 if (ret == 0) {
16608                       00004A34            .37E:
16609                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16610 4A34           8A46         F5            mov	al,-$B[bp]
16611 4A37           84C0                       test	al,al
16612 4A39         0F85         0067            bne 	.381
16613                       00004A3D            .382:
16614                                           ! 2779                   ret = get_mouse_data(&mouse_data1);
16615                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16616 4A3D           8D5E         F4            lea	bx,-$C[bp]
16617 4A40           53                         push	bx
16618                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16619 4A41           E8         0B74            call	_get_mouse_data
16620 4A44           44                         inc	sp
16621 4A45           44                         inc	sp
16622                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16623 4A46           8846         F5            mov	-$B[bp],al
16624                                           !BCC_EOS
16625                                           ! 2780                   if ( ret == 0 ) {
16626                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16627 4A49           8A46         F5            mov	al,-$B[bp]
16628 4A4C           84C0                       test	al,al
16629 4A4E           75           54            jne 	.383
16630                       00004A50            .384:
16631                                           ! 2781                     ret = get_mouse_data(&mouse_data2);
16632                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
16633 4A50           8D5E         F3            lea	bx,-$D[bp]
16634 4A53           53                         push	bx
16635                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16636 4A54           E8         0B61            call	_get_mouse_data
16637 4A57           44                         inc	sp
16638 4A58           44                         inc	sp
16639                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16640 4A59           8846         F5            mov	-$B[bp],al
16641                                           !BCC_EOS
16642                                           ! 2782                     if ( ret == 0 ) {
16643                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16644 4A5C           8A46         F5            mov	al,-$B[bp]
16645 4A5F           84C0                       test	al,al
16646 4A61           75           41            jne 	.385
16647                       00004A63            .386:
16648                                           ! 2783                       ret = get_mouse_data(&mouse_data3);
16649                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
16650 4A63           8D5E         F2            lea	bx,-$E[bp]
16651 4A66           53                         push	bx
16652                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16653 4A67           E8         0B4E            call	_get_mouse_data
16654 4A6A           44                         inc	sp
16655 4A6B           44                         inc	sp
16656                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16657 4A6C           8846         F5            mov	-$B[bp],al
16658                                           !BCC_EOS
16659                                           ! 2784                       if ( ret == 0 ) {
16660                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16661 4A6F           8A46         F5            mov	al,-$B[bp]
16662 4A72           84C0                       test	al,al
16663 4A74           75           2E            jne 	.387
16664                       00004A76            .388:
16665                                           ! 2785                         FLAGS &= 0xfffe;
16666                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16667 4A76           8B46         18            mov	ax,$18[bp]
16668 4A79           24                     FE  and	al,#$FE
16669 4A7B           8946         18            mov	$18[bp],ax
16670                                           !BCC_EOS
16671                                           ! 2786                         regs.u.r8.ah = 0;
16672                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16673 4A7E           30C0                       xor	al,al
16674 4A80           8846         13            mov	$13[bp],al
16675                                           !BCC_EOS
16676                                           ! 2787                         regs.u.r8.bl = mouse_data1;
16677                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
16678 4A83           8A46         F4            mov	al,-$C[bp]
16679 4A86           8846         0C            mov	$C[bp],al
16680                                           !BCC_EOS
16681                                           ! 2788                         regs.u.r8.cl = mouse_data2;
16682                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
16683 4A89           8A46         F3            mov	al,-$D[bp]
16684 4A8C           8846         10            mov	$10[bp],al
16685                                           !BCC_EOS
16686                                           ! 2789                         regs.u.r8.dl = mouse_data3;
16687                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
16688 4A8F           8A46         F2            mov	al,-$E[bp]
16689 4A92           8846         0E            mov	$E[bp],al
16690                                           !BCC_EOS
16691                                           ! 2790                         set_kbd_command_byte(comm_byte);
16692                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16693 4A95           8A46         F7            mov	al,-9[bp]
16694 4A98           30E4                       xor	ah,ah
16695 4A9A           50                         push	ax
16696                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16697 4A9B           E8         0B5B            call	_set_kbd_command_byte
16698 4A9E           44                         inc	sp
16699 4A9F           44                         inc	sp
16700                                           !BCC_EOS
16701                                           ! 2791                         return;
16702 4AA0           89EC                       mov	sp,bp
16703 4AA2           5D                         pop	bp
16704 4AA3           C3                         ret
16705                                           !BCC_EOS
16706                                           ! 2792                         }
16707                                           ! 2793                       }
16708                       00004AA4            .387:
16709                                           ! 2794                     }
16710                       00004AA4            .385:
16711                                           ! 2795                   }
16712                       00004AA4            .383:
16713                                           ! 2796                 }
16714                       00004AA4            .381:
16715                                           ! 2797               FLAGS |= 0x0001;
16716                       00004AA4            .37C:
16717                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16718 4AA4           8B46         18            mov	ax,$18[bp]
16719 4AA7           0C                     01  or	al,*1
16720 4AA9           8946         18            mov	$18[bp],ax
16721                                           !BCC_EOS
16722                                           ! 2798               regs.u.r8.ah = ret;
16723                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
16724 4AAC           8A46         F5            mov	al,-$B[bp]
16725 4AAF           8846         13            mov	$13[bp],al
16726                                           !BCC_EOS
16727                                           ! 2799               set_kbd_command_byte(comm_byte);
16728                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16729 4AB2           8A46         F7            mov	al,-9[bp]
16730 4AB5           30E4                       xor	ah,ah
16731 4AB7           50                         push	ax
16732                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16733 4AB8           E8         0B3E            call	_set_kbd_command_byte
16734 4ABB           44                         inc	sp
16735 4ABC           44                         inc	sp
16736                                           !BCC_EOS
16737                                           ! 2800               return;
16738 4ABD           89EC                       mov	sp,bp
16739 4ABF           5D                         pop	bp
16740 4AC0           C3                         ret
16741                                           !BCC_EOS
16742                                           ! 2801             case 1:
16743                                           ! 2802             case 2:
16744                       00004AC1            .389:
16745                                           ! 2803               comm_byte = inhibit_mouse_int_and_events();
16746                       00004AC1            .38A:
16747                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16748 4AC1           E8         0959            call	_inhibit_mouse_int_and_events
16749                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
16750 4AC4           8846         F7            mov	-9[bp],al
16751                                           !BCC_EOS
16752                                           ! 2804               if (regs.u.r8.bh == 1) {
16753                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
16754 4AC7           8A46         0D            mov	al,$D[bp]
16755 4ACA           3C                     01  cmp	al,*1
16756 4ACC           75           0E            jne 	.38B
16757                       00004ACE            .38C:
16758                                           ! 2805                 ret = send_to_mous
16759                                           ! 2805 e_ctrl(0xE6);
16760                                           ! Debug: list int = const $E6 (used reg = )
16761 4ACE           B8                   00E6  mov	ax,#$E6
16762 4AD1           50                         push	ax
16763                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16764 4AD2           E8         0A99            call	_send_to_mouse_ctrl
16765 4AD5           44                         inc	sp
16766 4AD6           44                         inc	sp
16767                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16768 4AD7           8846         F5            mov	-$B[bp],al
16769                                           !BCC_EOS
16770                                           ! 2806               } else {
16771 4ADA           EB           0C            jmp .38D
16772                       00004ADC            .38B:
16773                                           ! 2807                 ret = send_to_mouse_ctrl(0xE7);
16774                                           ! Debug: list int = const $E7 (used reg = )
16775 4ADC           B8                   00E7  mov	ax,#$E7
16776 4ADF           50                         push	ax
16777                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
16778 4AE0           E8         0A8B            call	_send_to_mouse_ctrl
16779 4AE3           44                         inc	sp
16780 4AE4           44                         inc	sp
16781                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16782 4AE5           8846         F5            mov	-$B[bp],al
16783                                           !BCC_EOS
16784                                           ! 2808               }
16785                                           ! 2809               if (ret == 0) {
16786                       00004AE8            .38D:
16787                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16788 4AE8           8A46         F5            mov	al,-$B[bp]
16789 4AEB           84C0                       test	al,al
16790 4AED           75           19            jne 	.38E
16791                       00004AEF            .38F:
16792                                           ! 2810                 get_mouse_data(&mouse_data1);
16793                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
16794 4AEF           8D5E         F4            lea	bx,-$C[bp]
16795 4AF2           53                         push	bx
16796                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
16797 4AF3           E8         0AC2            call	_get_mouse_data
16798 4AF6           44                         inc	sp
16799 4AF7           44                         inc	sp
16800                                           !BCC_EOS
16801                                           ! 2811                 ret = (mouse_data1 != 0xFA);
16802                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
16803 4AF8           8A46         F4            mov	al,-$C[bp]
16804 4AFB           3C                     FA  cmp	al,#$FA
16805 4AFD           74           04            je 	.390
16806 4AFF           B0                     01  mov	al,*1
16807 4B01           EB           02            jmp	.391
16808                       00004B03            .390:
16809 4B03           30C0                       xor	al,al
16810                       00004B05            .391:
16811                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
16812 4B05           8846         F5            mov	-$B[bp],al
16813                                           !BCC_EOS
16814                                           ! 2812               }
16815                                           ! 2813               if (ret == 0) {
16816                       00004B08            .38E:
16817                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
16818 4B08           8A46         F5            mov	al,-$B[bp]
16819 4B0B           84C0                       test	al,al
16820 4B0D           75           0F            jne 	.392
16821                       00004B0F            .393:
16822                                           ! 2814                 FLAGS &= 0xfffe;
16823                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
16824 4B0F           8B46         18            mov	ax,$18[bp]
16825 4B12           24                     FE  and	al,#$FE
16826 4B14           8946         18            mov	$18[bp],ax
16827                                           !BCC_EOS
16828                                           ! 2815                 regs.u.r8.ah = 0;
16829                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
16830 4B17           30C0                       xor	al,al
16831 4B19           8846         13            mov	$13[bp],al
16832                                           !BCC_EOS
16833                                           ! 2816               } else {
16834 4B1C           EB           0D            jmp .394
16835                       00004B1E            .392:
16836                                           ! 2817                 FLAGS |= 0x0001;
16837                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
16838 4B1E           8B46         18            mov	ax,$18[bp]
16839 4B21           0C                     01  or	al,*1
16840 4B23           8946         18            mov	$18[bp],ax
16841                                           !BCC_EOS
16842                                           ! 2818                 regs.u.r8.ah = 0x86;
16843                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
16844 4B26           B0                     86  mov	al,#$86
16845 4B28           8846         13            mov	$13[bp],al
16846                                           !BCC_EOS
16847                                           ! 2819               }
16848                                           ! 2820               set_kbd_command_byte(comm_byte);
16849                       00004B2B            .394:
16850                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
16851 4B2B           8A46         F7            mov	al,-9[bp]
16852 4B2E           30E4                       xor	ah,ah
16853 4B30           50                         push	ax
16854                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
16855 4B31           E8         0AC5            call	_set_kbd_command_byte
16856 4B34           44                         inc	sp
16857 4B35           44                         inc	sp
16858                                           !BCC_EOS
16859                                           ! 2821               break;
16860 4B36           EB           2A            jmp .378
16861                                           !BCC_EOS
16862                                           ! 2822             default:
16863                                           ! 2823               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
16864                       00004B38            .395:
16865                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
16866 4B38           8A46         0D            mov	al,$D[bp]
16867 4B3B           30E4                       xor	ah,ah
16868 4B3D           50                         push	ax
16869                                           ! Debug: list * char = .396+0 (used reg = )
16870 4B3E           BB                   D7ED  mov	bx,#.396
16871 4B41           53                         push	bx
16872                                           ! Debug: list int = const 7 (used reg = )
16873 4B42           B8                   0007  mov	ax,*7
16874 4B45           50                         push	ax
16875                                           ! Debug: func () void = bios_printf+0 (used reg = )
16876 4B46           E8         BD60            call	_bios_printf
16877 4B49           83C4                   06  add	sp,*6
16878                                           !BCC_EOS
16879                                           ! 2824             }
16880                                           ! 2825           break;
16881 4B4C           EB           14            jmp .378
16882                       00004B4E            .37A:
16883 4B4E           2C                     00  sub	al,*0
16884 4B50         0F84         FE9E            beq 	.37B
16885 4B54           2C                     01  sub	al,*1
16886 4B56         0F84         FF67            beq 	.389
16887 4B5A           2C                     01  sub	al,*1
16888 4B5C         0F84         FF61            beq 	.38A
16889 4B60           EB           D6            jmp	.395
16890                       00004B62            .378:
16891 4B62           E9         00BE            br 	.335
16892                                           !BCC_EOS
16893                                           ! 2826         case 7:
16894                                           ! 2827 ;
16895                       00004B65            .397:
16896                                           !BCC_EOS
16897                                           ! 2828           mouse_driver_seg = ES;
16898                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16899 4B65           8B46         14            mov	ax,$14[bp]
16900 4B68           8946         FA            mov	-6[bp],ax
16901                                           !BCC_EOS
16902                                           ! 2829           mouse_driver_offset = regs.u.r16.bx;
16903                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16904 4B6B           8B46         0C            mov	ax,$C[bp]
16905 4B6E           8946         F8            mov	-8[bp],ax
16906                                           !BCC_EOS
16907                                           ! 2830           write_word(ebda_seg, 0x0022, mouse_driver_offset);
16908                                           ! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16909 4B71           FF76         F8            push	-8[bp]
16910                                           ! Debug: list int = const $22 (used reg = )
16911 4B74           B8                   0022  mov	ax,*$22
16912 4B77           50                         push	ax
16913                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
16914 4B78           FF76         FE            push	-2[bp]
16915                                           ! Debug: func () void = write_word+0 (used reg = )
16916 4B7B           E8         BABE            call	_write_word
16917 4B7E           83C4                   06  add	sp,*6
16918                                           !BCC_EOS
16919                                           ! 2831           write_word(ebda_seg, 0x0024, mouse_driver_seg);
16920                                           ! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16921 4B81           FF76         FA            push	-6[bp]
16922                                           ! Debug: list int = const $24 (used reg = )
16923 4B84           B8                   0024  mov	ax,*$24
16924 4B87           50                         push	ax
16925                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
16926 4B88           FF76         FE            push	-2[bp]
16927                                           ! Debug: func () void = write_word+0 (used reg = )
16928 4B8B           E8         BAAE            call	_write_word
16929 4B8E           83C4                   06  add	sp,*6
16930                                           !BCC_EOS
16931                                           ! 2832           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
16932                                           ! Debug: list int = const $27 (used reg = )
16933 4B91           B8                   0027  mov	ax,*$27
16934 4B94           50                         push	ax
16935                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
16936 4B95           FF76         FE            push	-2[bp]
16937                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
16938 4B98           E8         BA63            call	_read_byte
16939 4B9B           83C4                   04  add	sp,*4
16940                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16941 4B9E           8846         FC            mov	-4[bp],al
16942                                           !BCC_EOS
16943                                           ! 2833           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
16944                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
16945 4BA1           8B46         F8            mov	ax,-8[bp]
16946 4BA4           85C0                       test	ax,ax
16947 4BA6           75           1D            jne 	.398
16948                       00004BA8            .39A:
16949                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
16950 4BA8           8B46         FA            mov	ax,-6[bp]
16951 4BAB           85C0                       test	ax,ax
16952 4BAD           75           16            jne 	.398
16953                       00004BAF            .399:
16954                                           ! 2834             if ( (mouse_flags_2 & 0x80) != 0 ) {
16955                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16956 4BAF           8A46         FC            mov	al,-4[bp]
16957 4BB2           24                     80  and	al,#$80
16958                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
16959 4BB4           84C0                       test	al,al
16960 4BB6           74           0B            je  	.39B
16961                       00004BB8            .39C:
16962                                           ! 2835               mouse_flags_2 &= ~0x80;
16963                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16964 4BB8           8A46         FC            mov	al,-4[bp]
16965 4BBB           24                     7F  and	al,*$7F
16966 4BBD           8846         FC            mov	-4[bp],al
16967                                           !BCC_EOS
16968                                           ! 2836               inhibit_mouse_int_and_events();
16969                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
16970 4BC0           E8         085A            call	_inhibit_mouse_int_and_events
16971                                           !BCC_EOS
16972                                           ! 2837               }
16973                                           ! 2838             }
16974                       00004BC3            .39B:
16975                                           ! 2839           else {
16976 4BC3           EB           08            jmp .39D
16977                       00004BC5            .398:
16978                                           ! 2840             mouse_flags_2 |= 0x80;
16979                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16980 4BC5           8A46         FC            mov	al,-4[bp]
16981 4BC8           0C                     80  or	al,#$80
16982 4BCA           8846         FC            mov	-4[bp],al
16983                                           !BCC_EOS
16984                                           ! 2841             }
16985                                           ! 2842           write_byte(ebda_seg, 0x0027, mouse_flags_2);
16986                       00004BCD            .39D:
16987                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
16988 4BCD           8A46         FC            mov	al,-4[bp]
16989 4BD0           30E4                       xor	ah,ah
16990 4BD2           50                         push	ax
16991                                           ! Debug: list int = const $27 (used reg = )
16992 4BD3           B8                   0027  mov	ax,*$27
16993 4BD6           50                         push	ax
16994                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
16995 4BD7           FF76         FE            push	-2[bp]
16996                                           ! Debug: func () void = write_byte+0 (used reg = )
16997 4BDA           E8         BA47            call	_write_byte
16998 4BDD           83C4                   06  add	sp,*6
16999                                           !BCC_EOS
17000                                           ! 2843           FLAGS &= 0xfffe;
17001                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17002 4BE0           8B46         18            mov	ax,$18[bp]
17003 4BE3           24                     FE  and	al,#$FE
17004 4BE5           8946         18            mov	$18[bp],ax
17005                                           !BCC_EOS
17006                                           ! 2844           regs.u.r8.ah = 0;
17007                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17008 4BE8           30C0                       xor	al,al
17009 4BEA           8846         13            mov	$13[bp],al
17010                                           !BCC_EOS
17011                                           ! 2845           break;
17012 4BED           EB           34            jmp .335
17013                                           !BCC_EOS
17014                                           ! 2846         default:
17015                                           ! 2847 ;
17016                       00004BEF            .39E:
17017                                           !BCC_EOS
17018                                           ! 2848           regs.u.r8.ah = 1;
17019                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
17020 4BEF           B0                     01  mov	al,*1
17021 4BF1           8846         13            mov	$13[bp],al
17022                                           !BCC_EOS
17023                                           ! 2849           FLAGS |= 0x0001;
17024                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17025 4BF4           8B46         18            mov	ax,$18[bp]
17026 4BF7           0C                     01  or	al,*1
17027 4BF9           8946         18            mov	$18[bp],ax
17028                                           !BCC_EOS
17029                                           ! 2850         }
17030                                           ! 2851       break;
17031 4BFC           EB           25            jmp .335
17032                       00004BFE            .337:
17033 4BFE           2C                     00  sub	al,*0
17034 4C00           72           ED            jb 	.39E
17035 4C02           3C                     07  cmp	al,*7
17036 4C04           77           1B            ja  	.39F
17037 4C06           30E4                       xor	ah,ah
17038 4C08           D1E0                       shl	ax,*1
17039 4C0A           89C3                       mov	bx,ax
17040 4C0C           2E                         seg	cs
17041 4C0D           FFA7       4C11            br	.3A0[bx]
17042                       00004C11            .3A0:
17043 4C11                      46A3            .word	.338
17044 4C13                      47A3            .word	.34B
17045 4C15                      48B9            .word	.35E
17046 4C17                      4989            .word	.372
17047 4C19                      4999            .word	.373
17048 4C1B                      47A3            .word	.34C
17049 4C1D                      49EC            .word	.377
17050 4C1F                      4B65            .word	.397
17051                       00004C21            .39F:
17052 4C21           EB           CC            jmp	.39E
17053                       00004C23            .335:
17054 4C23           EB           2D            jmp .331
17055                                           !BCC_EOS
17056                                           ! 2852     default:
17057                                           ! 2853       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
17058                       00004C25            .3A1:
17059                                           ! Debug: list unsigned short regs = [S+$10+$A] (used reg = )
17060 4C25           FF76         0C            push	$C[bp]
17061                                           ! Debug: list unsigned short regs = [S+$12+$10] (used reg = )
17062 4C28           FF76         12            push	$12[bp]
17063                                           ! Debug: list * char = .3A2+0 (used reg = )
17064 4C2B           BB                   D7B3  mov	bx,#.3A2
17065 4C2E           53                         push	bx
17066                                           ! Debug: list int = const 4 (used reg = )
17067 4C2F           B8                   0004  mov	ax,*4
17068 4C32           50                         push	ax
17069                                           ! Debug: func () void = bios_printf+0 (used reg = )
17070 4C33           E8         BC73            call	_bios_printf
17071 4C36           83C4                   08  add	sp,*8
17072                                           !BCC_EOS
17073                                           ! 2854       FLAGS |= 0x0001;
17074                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17075 4C39           8B46         18            mov	ax,$18[bp]
17076 4C3C           0C                     01  or	al,*1
17077 4C3E           8946         18            mov	$18[bp],ax
17078                                           !BCC_EOS
17079                                           ! 2855       regs.u.r8.ah = 0x86;
17080                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17081 4C41           B0                     86  mov	al,#$86
17082 4C43           8846         13            mov	$13[bp],al
17083                                           !BCC_EOS
17084                                           ! 2856       break;
17085 4C46           EB           0A            jmp .331
17086                                           !BCC_EOS
17087                                           ! 2857     }
17088                                           ! 2858 }
17089 4C48           EB           08            jmp .331
17090                       00004C4A            .333:
17091 4C4A           2C                     C2  sub	al,#$C2
17092 4C4C         0F84         FA4D            beq 	.334
17093 4C50           EB           D3            jmp	.3A1
17094                       00004C52            .331:
17095                       FFFFFFF0            ..FFF5	=	-$10
17096 4C52           89EC                       mov	sp,bp
17097 4C54           5D                         pop	bp
17098 4C55           C3                         ret
17099                                           ! 2859   void
17100                                           ! Register BX used in function int15_function_mouse
17101                                           ! 2860 int15_function32(regs, ES, DS, FLAGS)
17102                                           ! 2861   pushad_regs_t regs;
17103                                           export	_int15_function32
17104                       00004C56            _int15_function32:
17105                                           !BCC_EOS
17106                                           ! 2862   Bit16u ES, DS, FLAGS;
17107                                           !BCC_EOS
17108                                           ! 2863 {
17109                                           ! 2864   Bit32u extended_memory_size=0;
17110 4C56           55                         push	bp
17111 4C57           89E5                       mov	bp,sp
17112 4C59           83C4                   FC  add	sp,*-4
17113                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
17114 4C5C           31C0                       xor	ax,ax
17115 4C5E           31DB                       xor	bx,bx
17116 4C60           8946         FC            mov	-4[bp],ax
17117 4C63           895E         FE            mov	-2[bp],bx
17118                                           !BCC_EOS
17119                                           ! 2865   Bit16u CX,DX;
17120                                           !BCC_EOS
17121                                           ! 2866   Bit16u off, e820_table_size;
17122                                           !BCC_EOS
17123                                           ! 2867   Bit32u base, type, size;
17124                                           !BCC_EOS
17125                                           ! 2868 ;
17126 4C66           83C4                   EC  add	sp,*-$14
17127                                           !BCC_EOS
17128                                           ! 2869   switch (regs.u.r8.ah) {
17129 4C69           8A46         21            mov	al,$21[bp]
17130 4C6C           E9         0352            br 	.3A5
17131                                           ! 2870     case 0x86:
17132                                           ! 2871       CX = regs.u.r16.cx;
17133                       00004C6F            .3A6:
17134                                           ! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short CX = [S+$1A-8] (used reg = )
17135 4C6F           8B46         1C            mov	ax,$1C[bp]
17136 4C72           8946         FA            mov	-6[bp],ax
17137                                           !BCC_EOS
17138                                           ! 2872       DX = regs.u.r16.dx;
17139                                           ! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short DX = [S+$1A-$A] (used reg = )
17140 4C75           8B46         18            mov	ax,$18[bp]
17141 4C78           8946         F8            mov	-8[bp],ax
17142                                           !BCC_EOS
17143                                           ! 2873 #asm
17144                                           !BCC_EOS
17145                                           !BCC_ASM
17146                       00000012            _int15_function32.CX	set	$12
17147                       FFFFFFFA            .int15_function32.CX	set	-6
17148                       00000014            _int15_function32.extended_memory_size	set	$14
17149                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
17150                       00000040            _int15_function32.FLAGS	set	$40
17151                       00000028            .int15_function32.FLAGS	set	$28
17152                       00000004            _int15_function32.type	set	4
17153                       FFFFFFEC            .int15_function32.type	set	-$14
17154                       0000003E            _int15_function32.DS	set	$3E
17155                       00000026            .int15_function32.DS	set	$26
17156                       00000010            _int15_function32.DX	set	$10
17157                       FFFFFFF8            .int15_function32.DX	set	-8
17158                       00000000            _int15_function32.size	set	0
17159                       FFFFFFE8            .int15_function32.size	set	-$18
17160                       0000003C            _int15_function32.ES	set	$3C
17161                       00000024            .int15_function32.ES	set	$24
17162                       0000000C            _int15_function32.e820_table_size	set	$C
17163                       FFFFFFF4            .int15_function32.e820_table_size	set	-$C
17164                       00000008            _int15_function32.base	set	8
17165                       FFFFFFF0            .int15_function32.base	set	-$10
17166                       0000001C            _int15_function32.regs	set	$1C
17167                       00000004            .int15_function32.regs	set	4
17168                       0000000E            _int15_function32.off	set	$E
17169                       FFFFFFF6            .int15_function32.off	set	-$A
17170                                                 ;; Get the count in eax
17171 4C7B           8B46         FA                  mov ax, .int15_function32.CX [bp]
17172 4C7E     66    C1E0                   10        shl eax, #16
17173 4C82           8B46         F8                  mov ax, .int15_function32.DX [bp]
17174                                                 ;; convert to numbers of 15usec ticks
17175 4C85     66    BB               0000000F        mov ebx, #15
17176 4C8B     66    31D2                             xor edx, edx
17177 4C8E     66    F7F3                             div eax, ebx
17178 4C91     66    89C1                             mov ecx, eax
17179                                                 ;; wait for ecx number of refresh requests
17180 4C94           E4                     61        in al, #0x61
17181 4C96           24                     10        and al,#0x10
17182 4C98           88C4                             mov ah, al
17183 4C9A     66    09C9                             or ecx, ecx
17184 4C9D           74           0E                  je int1586_tick_end
17185                       00004C9F            int1586_tick:
17186 4C9F           E4                     61        in al, #0x61
17187 4CA1           24                     10        and al,#0x10
17188 4CA3           38E0                             cmp al, ah
17189 4CA5           74           F8                  je int1586_tick
17190 4CA7           88C4                             mov ah, al
17191 4CA9     66    49                               dec ecx
17192 4CAB           75           F2                  jnz int1586_tick
17193                       00004CAD            int1586_tick_end:
17194                                           ! 2898 endasm
17195                                           !BCC_ENDASM
17196                                           !BCC_EOS
17197                                           ! 2899       break;
17198 4CAD           E9         031F            br 	.3A3
17199                                           !BCC_EOS
17200                                           ! 2900     case 0xe8:
17201                                           ! 2901         switch(regs.u.r8.al)
17202                       00004CB0            .3A7:
17203 4CB0           8A46         20            mov	al,$20[bp]
17204                                           ! 2902         {
17205 4CB3           E9         02D6            br 	.3AA
17206                                           ! 2903         case 0x20: {
17207                       00004CB6            .3AB:
17208                                           ! 2904             e820_table_size = read_word(0xe000, 0x8) * 0x14;
17209                                           ! Debug: list int = const 8 (used reg = )
17210 4CB6           B8                   0008  mov	ax,*8
17211 4CB9           50                         push	ax
17212                                           ! Debug: list unsigned int = const $E000 (used reg = )
17213 4CBA           B8                   E000  mov	ax,#$E000
17214 4CBD           50                         push	ax
17215                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
17216 4CBE           E8         B950            call	_read_word
17217 4CC1           83C4                   04  add	sp,*4
17218                                           ! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
17219 4CC4           B9                   0014  mov	cx,*$14
17220 4CC7           F7E9                       imul	cx
17221                                           ! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
17222 4CC9           8946         F4            mov	-$C[bp],ax
17223                                           !BCC_EOS
17224                                           ! 2905             if (regs.u.r32.edx != 0x534D4150)
17225                                           ! Debug: ne long = const $534D4150 to unsigned long regs = [S+$1A+$16] (used reg = )
17226                                           ! Debug: expression subtree swapping
17227 4CCC           B8                   4150  mov	ax,#$4150
17228 4CCF           BB                   534D  mov	bx,#$534D
17229 4CD2           53                         push	bx
17230 4CD3           50                         push	ax
17231 4CD4           8B46         18            mov	ax,$18[bp]
17232 4CD7           8B5E         1A            mov	bx,$1A[bp]
17233 4CDA           8D7E         E4            lea	di,-2+..FFF4[bp]
17234 4CDD           E8         B3BB            call	lcmpul
17235 4CE0           8D66         E8            lea	sp,2+..FFF4[bp]
17236 4CE3           74           06            je  	.3AC
17237                       00004CE5            .3AD:
17238                                           ! 2906                 goto int15_unimplemented;
17239 4CE5           83C4                   00  add	sp,#..FFF3-..FFF4
17240 4CE8           E9         02B1            br 	.FFF3
17241                                           !BCC_EOS
17242                                           ! 2907             if ((regs.u.r16.bx / 0x14) * 0x14 == regs.u.r16.bx) {
17243                       00004CEB            .3AC:
17244                                           ! Debug: div int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
17245 4CEB           8B46         14            mov	ax,$14[bp]
17246 4CEE           BB                   0014  mov	bx,*$14
17247 4CF1           E8         B445            call	idiv_u
17248                                           ! Debug: mul int = const $14 to unsigned int = ax+0 (used reg = )
17249 4CF4           B9                   0014  mov	cx,*$14
17250 4CF7           F7E9                       imul	cx
17251                                           ! Debug: logeq unsigned short regs = [S+$1A+$12] to unsigned int = ax+0 (used reg = )
17252 4CF9           3B46         14            cmp	ax,$14[bp]
17253 4CFC         0F85         0084            bne 	.3AE
17254                       00004D00            .3AF:
17255                                           ! 2908                 if (regs.u.r16.bx + 0x14 <= e820_table_size)
17256                                           ! Debug: add int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
17257 4D00           8B46         14            mov	ax,$14[bp]
17258                                           ! Debug: le unsigned short e820_table_size = [S+$1A-$E] to unsigned int = ax+$14 (used reg = )
17259 4D03           05                   0014  add	ax,*$14
17260 4D06           3B46         F4            cmp	ax,-$C[bp]
17261 4D09           77           1B            ja  	.3B0
17262                       00004D0B            .3B1:
17263                                           ! 2909                     memcpyb(ES, regs.u.r16.di,
17264                                           ! 2910                             0xe000, 0x10 + regs.u.r16.bx, 0x14);
17265                                           ! Debug: list int = const $14 (used reg = )
17266 4D0B           B8                   0014  mov	ax,*$14
17267 4D0E           50                         push	ax
17268                                           ! Debug: add unsigned short regs = [S+$1C+$12] to int = const $10 (used reg = )
17269                                           ! Debug: expression subtree swapping
17270 4D0F           8B46         14            mov	ax,$14[bp]
17271                                           ! Debug: list unsigned int = ax+$10 (used reg = )
17272 4D12           05                   0010  add	ax,*$10
17273 4D15           50                         push	ax
17274                                           ! Debug: list unsigned int = const $E000 (used reg = )
17275 4D16           B8                   E000  mov	ax,#$E000
17276 4D19           50                         push	ax
17277                                           ! Debug: list unsigned short regs = [S+$20+2] (used reg = )
17278 4D1A           FF76         04            push	4[bp]
17279                                           ! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
17280 4D1D           FF76         24            push	$24[bp]
17281                                           ! Debug: func () void = memcpyb+0 (used reg = )
17282 4D20           E8         B302            call	_memcpyb
17283 4D23           83C4                   0A  add	sp,*$A
17284                                           !BCC_EOS
17285                                           ! 2911                 regs.u.r32.ebx += 0x14;
17286                       00004D26            .3B0:
17287                                           ! Debug: addab unsigned long = const $14 to unsigned long regs = [S+$1A+$12] (used reg = )
17288 4D26           B8                   0014  mov	ax,*$14
17289 4D29           31DB                       xor	bx,bx
17290 4D2B           53                         push	bx
17291 4D2C           50                         push	ax
17292 4D2D           8B46         14            mov	ax,$14[bp]
17293 4D30           8B5E         16            mov	bx,$16[bp]
17294 4D33           8D7E         E4            lea	di,-2+..FFF4[bp]
17295 4D36           E8         B35A            call	laddul
17296 4D39           8946         14            mov	$14[bp],ax
17297 4D3C           895E         16            mov	$16[bp],bx
17298 4D3F           83C4                   04  add	sp,*4
17299                                           !BCC_EOS
17300                                           ! 2912                 if ((regs.u.r32.ebx + 0x14 - 1) > e820_table_size)
17301                                           ! Debug: cast unsigned long = const 0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
17302 4D42           8B46         F4            mov	ax,-$C[bp]
17303 4D45           31DB                       xor	bx,bx
17304 4D47           53                         push	bx
17305 4D48           50                         push	ax
17306                                           ! Debug: add unsigned long = const $14 to unsigned long regs = [S+$1E+$12] (used reg = )
17307                                           ! Debug: expression subtree swapping
17308 4D49           B8                   0014  mov	ax,*$14
17309 4D4C           31DB                       xor	bx,bx
17310 4D4E           8D7E         14            lea	di,$14[bp]
17311 4D51           E8         B33F            call	laddul
17312                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
17313 4D54           53                         push	bx
17314 4D55           50                         push	ax
17315 4D56           B8                   0001  mov	ax,*1
17316 4D59           31DB                       xor	bx,bx
17317 4D5B           53                         push	bx
17318 4D5C           50                         push	ax
17319 4D5D           8B46         E0            mov	ax,-6+..FFF4[bp]
17320 4D60           8B5E         E2            mov	bx,-4+..FFF4[bp]
17321 4D63           8D7E         DC            lea	di,-$A+..FFF4[bp]
17322 4D66           E8         B348            call	lsubul
17323 4D69           83C4                   08  add	sp,*8
17324                                           ! Debug: gt unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
17325 4D6C           8D7E         E4            lea	di,-2+..FFF4[bp]
17326 4D6F           E8         B329            call	lcmpul
17327 4D72           8D66         E8            lea	sp,2+..FFF4[bp]
17328 4D75           76           0A            jbe 	.3B2
17329                       00004D77            .3B3:
17330                                           ! 2913                     regs.u.r32.ebx = 0;
17331                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
17332 4D77           31C0                       xor	ax,ax
17333 4D79           31DB                       xor	bx,bx
17334 4D7B           8946         14            mov	$14[bp],ax
17335 4D7E           895E         16            mov	$16[bp],bx
17336                                           !BCC_EOS
17337                                           ! 2914             } else if (regs.u.r16.bx == 1) {
17338                       00004D81            .3B2:
17339 4D81           E9         00BB            br 	.3B4
17340                       00004D84            .3AE:
17341                                           ! Debug: logeq int = const 1 to unsigned short regs = [S+$1A+$12] (used reg = )
17342 4D84           8B46         14            mov	ax,$14[bp]
17343 4D87           3D                   0001  cmp	ax,*1
17344 4D8A         0F85         00AB            bne 	.3B5
17345                       00004D8E            .3B6:
17346                                           ! 2915                 for (off = 0; off < e820_table_size; off += 0x14) {
17347                                           ! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
17348 4D8E           31C0                       xor	ax,ax
17349 4D90           8946         F6            mov	-$A[bp],ax
17350                                           !BCC_EOS
17351                                           !BCC_EOS
17352 4D93           EB           62            jmp .3B9
17353                       00004D95            .3BA:
17354                                           ! 2916                     base = read_dword(0xe000, 0x10 + off);
17355                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $10 (used reg = )
17356                                           ! Debug: expression subtree swapping
17357 4D95           8B46         F6            mov	ax,-$A[bp]
17358                                           ! Debug: list unsigned int = ax+$10 (used reg = )
17359 4D98           05                   0010  add	ax,*$10
17360 4D9B           50                         push	ax
17361                                           ! Debug: list unsigned int = const $E000 (used reg = )
17362 4D9C           B8                   E000  mov	ax,#$E000
17363 4D9F           50                         push	ax
17364                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
17365 4DA0           E8         B2B2            call	_read_dword
17366 4DA3           89D3                       mov	bx,dx
17367 4DA5           83C4                   04  add	sp,*4
17368                                           ! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
17369 4DA8           8946         F0            mov	-$10[bp],ax
17370 4DAB           895E         F2            mov	-$E[bp],bx
17371                                           !BCC_EOS
17372                                           ! 2917                     type = read_dword(0xe000, 0x20 + off);
17373                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $20 (used reg = )
17374                                           ! Debug: expression subtree swapping
17375 4DAE           8B46         F6            mov	ax,-$A[bp]
17376                                           ! Debug: list unsigned int = ax+$20 (used reg = )
17377 4DB1           05                   0020  add	ax,*$20
17378 4DB4           50                         push	ax
17379                                           ! Debug: list unsigned int = const $E000 (used reg = )
17380 4DB5           B8                   E000  mov	ax,#$E000
17381 4DB8           50                         push	ax
17382                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
17383 4DB9           E8         B299            call	_read_dword
17384 4DBC           89D3                       mov	bx,dx
17385 4DBE           83C4                   04  add	sp,*4
17386                                           ! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
17387 4DC1           8946         EC            mov	-$14[bp],ax
17388 4DC4           895E         EE            mov	-$12[bp],bx
17389                                           !BCC_EOS
17390                                           ! 2918                     if ((base >= 0x100000) && (type == 1))
17391                                           ! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
17392 4DC7           31C0                       xor	ax,ax
17393 4DC9           BB                   0010  mov	bx,*$10
17394 4DCC           8D7E         F0            lea	di,-$10[bp]
17395 4DCF           E8         B2C9            call	lcmpul
17396 4DD2           77           1A            ja  	.3BB
17397                       00004DD4            .3BD:
17398                                           ! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
17399                                           ! Debug: expression subtree swapping
17400 4DD4           B8                   0001  mov	ax,*1
17401 4DD7           31DB                       xor	bx,bx
17402 4DD9           53                         push	bx
17403 4DDA           50                         push	ax
17404 4DDB           8B46         EC            mov	ax,-$14[bp]
17405 4DDE           8B5E         EE            mov	bx,-$12[bp]
17406 4DE1           8D7E         E4            lea	di,-2+..FFF4[bp]
17407 4DE4           E8         B2B4            call	lcmpul
17408 4DE7           8D66         E8            lea	sp,2+..FFF4[bp]
17409 4DEA           75           02            jne 	.3BB
17410                       00004DEC            .3BC:
17411                                           ! 2919                         break;
17412 4DEC           EB           11            jmp .3B7
17413                                           !BCC_EOS
17414                                           ! 2920                 }
17415                       00004DEE            .3BB:
17416                                           ! 2921                 if (off == e820_table_size) {
17417                       00004DEE            .3B8:
17418                                           ! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
17419 4DEE           8B46         F6            mov	ax,-$A[bp]
17420 4DF1           05                   0014  add	ax,*$14
17421 4DF4           8946         F6            mov	-$A[bp],ax
17422                       00004DF7            .3B9:
17423                                           ! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
17424 4DF7           8B46         F6            mov	ax,-$A[bp]
17425 4DFA           3B46         F4            cmp	ax,-$C[bp]
17426 4DFD           72           96            jb 	.3BA
17427                       00004DFF            .3BE:
17428                       00004DFF            .3B7:
17429                                           ! Debug: logeq unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
17430 4DFF           8B46         F6            mov	ax,-$A[bp]
17431 4E02           3B46         F4            cmp	ax,-$C[bp]
17432 4E05           75           0B            jne 	.3BF
17433                       00004E07            .3C0:
17434                                           ! 2922                     FLAGS |= 0x0001;
17435                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
17436 4E07           8B46         28            mov	ax,$28[bp]
17437 4E0A           0C                     01  or	al,*1
17438 4E0C           8946         28            mov	$28[bp],ax
17439                                           !BCC_EOS
17440                                           ! 2923                     break;
17441 4E0F           E9         0188            br 	.3A8
17442                                           !BCC_EOS
17443                                           ! 2924                 }
17444                                           ! 2925                 memcpyb(ES, regs.u.r16.di, 0xe000, 0x10 + off, 0x14);
17445                       00004E12            .3BF:
17446                                           ! Debug: list int = const $14 (used reg = )
17447 4E12           B8                   0014  mov	ax,*$14
17448 4E15           50                         push	ax
17449                                           ! Debug: add unsigned short off = [S+$1C-$C] to int = const $10 (used reg = )
17450                                           ! Debug: expression subtree swapping
17451 4E16           8B46         F6            mov	ax,-$A[bp]
17452                                           ! Debug: list unsigned int = ax+$10 (used reg = )
17453 4E19           05                   0010  add	ax,*$10
17454 4E1C           50                         push	ax
17455                                           ! Debug: list unsigned int = const $E000 (used reg = )
17456 4E1D           B8                   E000  mov	ax,#$E000
17457 4E20           50                         push	ax
17458                                           ! Debug: list unsigned short regs = [S+$20+2] (used reg = )
17459 4E21           FF76         04            push	4[bp]
17460                                           ! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
17461 4E24           FF76         24            push	$24[bp]
17462                                           ! Debug: func () void = memcpyb+0 (used reg = )
17463 4E27           E8         B1FB            call	_memcpyb
17464 4E2A           83C4                   0A  add	sp,*$A
17465                                           !BCC_EOS
17466                                           ! 2926                 regs.u.r32.ebx = 0;
17467                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
17468 4E2D           31C0                       xor	ax,ax
17469 4E2F           31DB                       xor	bx,bx
17470 4E31           8946         14            mov	$14[bp],ax
17471 4E34           895E         16            mov	$16[bp],bx
17472                                           !BCC_EOS
17473                                           ! 2927             } else {
17474 4E37           EB           06            jmp .3C1
17475                       00004E39            .3B5:
17476                                           ! 2928                 goto int15_unimplemented;
17477 4E39           83C4                   00  add	sp,#..FFF3-..FFF4
17478 4E3C           E9         015D            br 	.FFF3
17479                                           !BCC_EOS
17480                                           ! 2929             }
17481                                           ! 2930             regs.u.r32.eax = 0x534D4150;
17482                       00004E3F            .3C1:
17483                       00004E3F            .3B4:
17484                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$1A+$1E] (used reg = )
17485 4E3F           B8                   4150  mov	ax,#$4150
17486 4E42           BB                   534D  mov	bx,#$534D
17487 4E45           8946         20            mov	$20[bp],ax
17488 4E48           895E         22            mov	$22[bp],bx
17489                                           !BCC_EOS
17490                                           ! 2931             regs.u.r32.ecx = 0x14;
17491                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$1A+$1A] (used reg = )
17492 4E4B           B8                   0014  mov	ax,*$14
17493 4E4E           31DB                       xor	bx,bx
17494 4E50           8946         1C            mov	$1C[bp],ax
17495 4E53           895E         1E            mov	$1E[bp],bx
17496                                           !BCC_EOS
17497                                           ! 2932             FLAGS &= 0xfffe;
17498                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
17499 4E56           8B46         28            mov	ax,$28[bp]
17500 4E59           24                     FE  and	al,#$FE
17501 4E5B           8946         28            mov	$28[bp],ax
17502                                           !BCC_EOS
17503                                           ! 2933             break;
17504 4E5E           E9         0139            br 	.3A8
17505                                           !BCC_EOS
17506                                           ! 2934         }
17507                                           ! 2935         case 0x01: {
17508                       00004E61            .3C2:
17509                                           ! 2936             e820_table_size = read_word(0xe000, 0x8) * 0x14;
17510                                           ! Debug: list int = const 8 (used reg = )
17511 4E61           B8                   0008  mov	ax,*8
17512 4E64           50                         push	ax
17513                                           ! Debug: list unsigned int = const $E000 (used reg = )
17514 4E65           B8                   E000  mov	ax,#$E000
17515 4E68           50                         push	ax
17516                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
17517 4E69           E8         B7A5            call	_read_word
17518 4E6C           83C4                   04  add	sp,*4
17519                                           ! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
17520 4E6F           B9                   0014  mov	cx,*$14
17521 4E72           F7E9                       imul	cx
17522                                           ! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
17523 4E74           8946         F4            mov	-$C[bp],ax
17524                                           !BCC_EOS
17525                                           ! 2937             FLAGS &= 0xfffe;
17526                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
17527 4E77           8B46         28            mov	ax,$28[bp]
17528 4E7A           24                     FE  and	al,#$FE
17529 4E7C           8946         28            mov	$28[bp],ax
17530                                           !BCC_EOS
17531                                           ! 2938             regs.u.r8.cl = inb_cmos(0x3
17532                                           ! 2938 0);
17533                                           ! Debug: list int = const $30 (used reg = )
17534 4E7F           B8                   0030  mov	ax,*$30
17535 4E82           50                         push	ax
17536                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17537 4E83           E8         B707            call	_inb_cmos
17538 4E86           44                         inc	sp
17539 4E87           44                         inc	sp
17540                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1A] (used reg = )
17541 4E88           8846         1C            mov	$1C[bp],al
17542                                           !BCC_EOS
17543                                           ! 2939             regs.u.r8.ch = inb_cmos(0x31);
17544                                           ! Debug: list int = const $31 (used reg = )
17545 4E8B           B8                   0031  mov	ax,*$31
17546 4E8E           50                         push	ax
17547                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
17548 4E8F           E8         B6FB            call	_inb_cmos
17549 4E92           44                         inc	sp
17550 4E93           44                         inc	sp
17551                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1B] (used reg = )
17552 4E94           8846         1D            mov	$1D[bp],al
17553                                           !BCC_EOS
17554                                           ! 2940             if (regs.u.r16.cx > (15*1024))
17555                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
17556 4E97           8B46         1C            mov	ax,$1C[bp]
17557 4E9A           3D                   3C00  cmp	ax,#$3C00
17558 4E9D           76           06            jbe 	.3C3
17559                       00004E9F            .3C4:
17560                                           ! 2941                 regs.u.r16.cx = 15*1024;
17561                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
17562 4E9F           B8                   3C00  mov	ax,#$3C00
17563 4EA2           8946         1C            mov	$1C[bp],ax
17564                                           !BCC_EOS
17565                                           ! 2942             for (off = 0; off < e820_table_size; off += 0x14) {
17566                       00004EA5            .3C3:
17567                                           ! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
17568 4EA5           31C0                       xor	ax,ax
17569 4EA7           8946         F6            mov	-$A[bp],ax
17570                                           !BCC_EOS
17571                                           !BCC_EOS
17572 4EAA           EB           62            jmp .3C7
17573                       00004EAC            .3C8:
17574                                           ! 2943                 base = read_dword(0xe000, 0x10 + off);
17575                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $10 (used reg = )
17576                                           ! Debug: expression subtree swapping
17577 4EAC           8B46         F6            mov	ax,-$A[bp]
17578                                           ! Debug: list unsigned int = ax+$10 (used reg = )
17579 4EAF           05                   0010  add	ax,*$10
17580 4EB2           50                         push	ax
17581                                           ! Debug: list unsigned int = const $E000 (used reg = )
17582 4EB3           B8                   E000  mov	ax,#$E000
17583 4EB6           50                         push	ax
17584                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
17585 4EB7           E8         B19B            call	_read_dword
17586 4EBA           89D3                       mov	bx,dx
17587 4EBC           83C4                   04  add	sp,*4
17588                                           ! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
17589 4EBF           8946         F0            mov	-$10[bp],ax
17590 4EC2           895E         F2            mov	-$E[bp],bx
17591                                           !BCC_EOS
17592                                           ! 2944                 type = read_dword(0xe000, 0x20 + off);
17593                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $20 (used reg = )
17594                                           ! Debug: expression subtree swapping
17595 4EC5           8B46         F6            mov	ax,-$A[bp]
17596                                           ! Debug: list unsigned int = ax+$20 (used reg = )
17597 4EC8           05                   0020  add	ax,*$20
17598 4ECB           50                         push	ax
17599                                           ! Debug: list unsigned int = const $E000 (used reg = )
17600 4ECC           B8                   E000  mov	ax,#$E000
17601 4ECF           50                         push	ax
17602                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
17603 4ED0           E8         B182            call	_read_dword
17604 4ED3           89D3                       mov	bx,dx
17605 4ED5           83C4                   04  add	sp,*4
17606                                           ! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
17607 4ED8           8946         EC            mov	-$14[bp],ax
17608 4EDB           895E         EE            mov	-$12[bp],bx
17609                                           !BCC_EOS
17610                                           ! 2945                 if ((base >= 0x100000) && (type == 1))
17611                                           ! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
17612 4EDE           31C0                       xor	ax,ax
17613 4EE0           BB                   0010  mov	bx,*$10
17614 4EE3           8D7E         F0            lea	di,-$10[bp]
17615 4EE6           E8         B1B2            call	lcmpul
17616 4EE9           77           1A            ja  	.3C9
17617                       00004EEB            .3CB:
17618                                           ! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
17619                                           ! Debug: expression subtree swapping
17620 4EEB           B8                   0001  mov	ax,*1
17621 4EEE           31DB                       xor	bx,bx
17622 4EF0           53                         push	bx
17623 4EF1           50                         push	ax
17624 4EF2           8B46         EC            mov	ax,-$14[bp]
17625 4EF5           8B5E         EE            mov	bx,-$12[bp]
17626 4EF8           8D7E         E4            lea	di,-2+..FFF4[bp]
17627 4EFB           E8         B19D            call	lcmpul
17628 4EFE           8D66         E8            lea	sp,2+..FFF4[bp]
17629 4F01           75           02            jne 	.3C9
17630                       00004F03            .3CA:
17631                                           ! 2946                     break;
17632 4F03           EB           11            jmp .3C5
17633                                           !BCC_EOS
17634                                           ! 2947             }
17635                       00004F05            .3C9:
17636                                           ! 2948             regs.u.r16.dx = 0;
17637                       00004F05            .3C6:
17638                                           ! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
17639 4F05           8B46         F6            mov	ax,-$A[bp]
17640 4F08           05                   0014  add	ax,*$14
17641 4F0B           8946         F6            mov	-$A[bp],ax
17642                       00004F0E            .3C7:
17643                                           ! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
17644 4F0E           8B46         F6            mov	ax,-$A[bp]
17645 4F11           3B46         F4            cmp	ax,-$C[bp]
17646 4F14           72           96            jb 	.3C8
17647                       00004F16            .3CC:
17648                       00004F16            .3C5:
17649                                           ! Debug: eq int = const 0 to unsigned short regs = [S+$1A+$16] (used reg = )
17650 4F16           31C0                       xor	ax,ax
17651 4F18           8946         18            mov	$18[bp],ax
17652                                           !BCC_EOS
17653                                           ! 2949             if (off != e820_table_size) {
17654                                           ! Debug: ne unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
17655 4F1B           8B46         F6            mov	ax,-$A[bp]
17656 4F1E           3B46         F4            cmp	ax,-$C[bp]
17657 4F21           74           54            je  	.3CD
17658                       00004F23            .3CE:
17659                                           ! 2950                 size = base + read_dword(0xe000, 0x18 + off);
17660                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
17661                                           ! Debug: expression subtree swapping
17662 4F23           8B46         F6            mov	ax,-$A[bp]
17663                                           ! Debug: list unsigned int = ax+$18 (used reg = )
17664 4F26           05                   0018  add	ax,*$18
17665 4F29           50                         push	ax
17666                                           ! Debug: list unsigned int = const $E000 (used reg = )
17667 4F2A           B8                   E000  mov	ax,#$E000
17668 4F2D           50                         push	ax
17669                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
17670 4F2E           E8         B124            call	_read_dword
17671 4F31           89D3                       mov	bx,dx
17672 4F33           83C4                   04  add	sp,*4
17673                                           ! Debug: add unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
17674                                           ! Debug: expression subtree swapping
17675 4F36           8D7E         F0            lea	di,-$10[bp]
17676 4F39           E8         B157            call	laddul
17677                                           ! Debug: eq unsigned long = bx+0 to unsigned long size = [S+$1A-$1A] (used reg = )
17678 4F3C           8946         E8            mov	-$18[bp],ax
17679 4F3F           895E         EA            mov	-$16[bp],bx
17680                                           !BCC_EOS
17681                                           ! 2951                 if (size > 0x1000000) {
17682                                           ! Debug: gt long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
17683 4F42           31C0                       xor	ax,ax
17684 4F44           BB                   0100  mov	bx,#$100
17685 4F47           8D7E         E8            lea	di,-$18[bp]
17686 4F4A           E8         B14E            call	lcmpul
17687 4F4D           73           28            jae 	.3CF
17688                       00004F4F            .3D0:
17689                                           ! 2952                     size -= 0x1000000;
17690                                           ! Debug: subab long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
17691 4F4F           31C0                       xor	ax,ax
17692 4F51           BB                   0100  mov	bx,#$100
17693 4F54           53                         push	bx
17694 4F55           50                         push	ax
17695 4F56           8B46         E8            mov	ax,-$18[bp]
17696 4F59           8B5E         EA            mov	bx,-$16[bp]
17697 4F5C           8D7E         E4            lea	di,-2+..FFF4[bp]
17698 4F5F           E8         B14F            call	lsubul
17699 4F62           8946         E8            mov	-$18[bp],ax
17700 4F65           895E         EA            mov	-$16[bp],bx
17701 4F68           83C4                   04  add	sp,*4
17702                                           !BCC_EOS
17703                                           ! 2953                     regs.u.r16.dx = (Bit16u)(size >> 16);
17704                                           ! Debug: sr int = const $10 to unsigned long size = [S+$1A-$1A] (used reg = )
17705 4F6B           8B46         E8            mov	ax,-$18[bp]
17706 4F6E           8B5E         EA            mov	bx,-$16[bp]
17707 4F71           93                         xchg	bx,ax
17708 4F72           31DB                       xor	bx,bx
17709                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
17710                                           ! Debug: eq unsigned short = ax+0 to unsigned short regs = [S+$1A+$16] (used reg = )
17711 4F74           8946         18            mov	$18[bp],ax
17712                                           !BCC_EOS
17713                                           ! 2954                 }
17714                                           ! 2955             }
17715                       00004F77            .3CF:
17716                                           ! 2956             regs.u.r16.ax = regs.u.r16.cx;
17717                       00004F77            .3CD:
17718                                           ! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short regs = [S+$1A+$1E] (used reg = )
17719 4F77           8B46         1C            mov	ax,$1C[bp]
17720 4F7A           8946         20            mov	$20[bp],ax
17721                                           !BCC_EOS
17722                                           ! 2957             regs.u.r16.bx = regs.u.r16.dx;
17723                                           ! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short regs = [S+$1A+$12] (used reg = )
17724 4F7D           8B46         18            mov	ax,$18[bp]
17725 4F80           8946         14            mov	$14[bp],ax
17726                                           !BCC_EOS
17727                                           ! 2958             break;
17728 4F83           EB           15            jmp .3A8
17729                                           !BCC_EOS
17730                                           ! 2959         }
17731                                           ! 2960  default:
17732                                           ! 2961             goto int15_unimplemented;
17733                       00004F85            .3D1:
17734 4F85           83C4                   00  add	sp,#..FFF3-..FFF4
17735 4F88           EB           12            jmp .FFF3
17736                                           !BCC_EOS
17737                                           ! 2962         }
17738                                           ! 2963         break;
17739 4F8A           EB           0E            jmp .3A8
17740                       00004F8C            .3AA:
17741 4F8C           2C                     01  sub	al,*1
17742 4F8E         0F84         FECF            beq 	.3C2
17743 4F92           2C                     1F  sub	al,*$1F
17744 4F94         0F84         FD1E            beq 	.3AB
17745 4F98           EB           EB            jmp	.3D1
17746                       00004F9A            .3A8:
17747 4F9A           EB           33            jmp .3A3
17748                                           !BCC_EOS
17749                                           ! 2964     int15_unimplemented:
17750                       00004F9C            .FFF3:
17751                                           ! 2965     default:
17752                                           ! 2966       bios_printf(4, "*** int 15h function AX=%04x, BX=%04x not yet supported!\n", (unsigned) regs.u.r16.ax, (unsigned) regs.u.r16.bx);
17753                       00004F9C            .3D2:
17754                                           ! Debug: list unsigned short regs = [S+$1A+$12] (used reg = )
17755 4F9C           FF76         14            push	$14[bp]
17756                                           ! Debug: list unsigned short regs = [S+$1C+$1E] (used reg = )
17757 4F9F           FF76         20            push	$20[bp]
17758                                           ! Debug: list * char = .3D3+0 (used reg = )
17759 4FA2           BB                   D779  mov	bx,#.3D3
17760 4FA5           53                         push	bx
17761                                           ! Debug: list int = const 4 (used reg = )
17762 4FA6           B8                   0004  mov	ax,*4
17763 4FA9           50                         push	ax
17764                                           ! Debug: func () void = bios_printf+0 (used reg = )
17765 4FAA           E8         B8FC            call	_bios_printf
17766 4FAD           83C4                   08  add	sp,*8
17767                                           !BCC_EOS
17768                                           ! 2967       FLAGS |= 0x0001;
17769                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
17770 4FB0           8B46         28            mov	ax,$28[bp]
17771 4FB3           0C                     01  or	al,*1
17772 4FB5           8946         28            mov	$28[bp],ax
17773                                           !BCC_EOS
17774                                           ! 2968       regs.u.r8.ah = 0x86;
17775                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$1A+$1F] (used reg = )
17776 4FB8           B0                     86  mov	al,#$86
17777 4FBA           8846         21            mov	$21[bp],al
17778                                           !BCC_EOS
17779                                           ! 2969       break;
17780 4FBD           EB           10            jmp .3A3
17781                                           !BCC_EOS
17782                                           ! 2970     }
17783                                           ! 2971 }
17784 4FBF           EB           0E            jmp .3A3
17785                       00004FC1            .3A5:
17786 4FC1           2C                     86  sub	al,#$86
17787 4FC3         0F84         FCA8            beq 	.3A6
17788 4FC7           2C                     62  sub	al,*$62
17789 4FC9         0F84         FCE3            beq 	.3A7
17790 4FCD           EB           CD            jmp	.3D2
17791                       00004FCF            .3A3:
17792                       FFFFFFE6            ..FFF4	=	-$1A
17793                       FFFFFFE6            ..FFF3	=	-$1A
17794 4FCF           89EC                       mov	sp,bp
17795 4FD1           5D                         pop	bp
17796 4FD2           C3                         ret
17797                                           ! 2972   void
17798                                           ! Register BX used in function int15_function32
17799                                           ! 2973 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
17800                                           ! 2974   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
17801                                           export	_int16_function
17802                       00004FD3            _int16_function:
17803                                           !BCC_EOS
17804                                           ! 2975 {
17805                                           ! 2976   Bit8u scan_code, ascii_code, shift_flags, count;
17806                                           !BCC_EOS
17807                                           ! 2977   Bit16u kbd_code, max;
17808                                           !BCC_EOS
17809                                           ! 2978   ;
17810 4FD3           55                         push	bp
17811 4FD4           89E5                       mov	bp,sp
17812 4FD6           83C4                   F8  add	sp,*-8
17813                                           !BCC_EOS
17814                                           ! 2979   switch (( AX >> 8 )) {
17815                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$A+$10] (used reg = )
17816 4FD9           8B46         12            mov	ax,$12[bp]
17817 4FDC           88E0                       mov	al,ah
17818 4FDE           30E4                       xor	ah,ah
17819 4FE0           E9         02EB            br 	.3D6
17820                                           ! 2980     case 0x00:
17821                                           ! 2981       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
17822                       00004FE3            .3D7:
17823                                           ! Debug: list int = const 1 (used reg = )
17824 4FE3           B8                   0001  mov	ax,*1
17825 4FE6           50                         push	ax
17826                                           ! Debug: list * unsigned char ascii_code = S+$C-4 (used reg = )
17827 4FE7           8D5E         FE            lea	bx,-2[bp]
17828 4FEA           53                         push	bx
17829                                           ! Debug: list * unsigned char scan_code = S+$E-3 (used reg = )
17830 4FEB           8D5E         FF            lea	bx,-1[bp]
17831 4FEE           53                         push	bx
17832                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
17833 4FEF           E8         032A            call	_dequeue_key
17834 4FF2           83C4                   06  add	sp,*6
17835 4FF5           85C0                       test	ax,ax
17836 4FF7           75           0E            jne 	.3D8
17837                       00004FF9            .3D9:
17838                                           ! 2982         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
17839                                           ! Debug: list * char = .3DA+0 (used reg = )
17840 4FF9           BB                   D755  mov	bx,#.3DA
17841 4FFC           53                         push	bx
17842                                           ! Debug: list int = const 7 (used reg = )
17843 4FFD           B8                   0007  mov	ax,*7
17844 5000           50                         push	ax
17845                                           ! Debug: func () void = bios_printf+0 (used reg = )
17846 5001           E8         B8A5            call	_bios_printf
17847 5004           83C4                   04  add	sp,*4
17848                                           !BCC_EOS
17849                                           ! 2983         }
17850                                           ! 2984       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
17851                       00005007            .3D8:
17852                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$A-3] (used reg = )
17853 5007           8A46         FF            mov	al,-1[bp]
17854 500A           84C0                       test	al,al
17855 500C           74           0E            je  	.3DB
17856                       0000500E            .3DD:
17857                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$A-4] (used reg = )
17858 500E           8A46         FE            mov	al,-2[bp]
17859 5011           3C                     F0  cmp	al,#$F0
17860 5013           75           07            jne 	.3DB
17861                       00005015            .3DC:
17862                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$A-4] (used reg = )
17863 5015           30C0                       xor	al,al
17864 5017           8846         FE            mov	-2[bp],al
17865                                           !BCC_EOS
17866                                           ! 2985       else if (ascii_code == 0xE0) ascii_code = 0;
17867 501A           EB           0C            jmp .3DE
17868                       0000501C            .3DB:
17869                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$A-4] (used reg = )
17870 501C           8A46         FE            mov	al,-2[bp]
17871 501F           3C                     E0  cmp	al,#$E0
17872 5021           75           05            jne 	.3DF
17873                       00005023            .3E0:
17874                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$A-4] (used reg = )
17875 5023           30C0                       xor	al,al
17876 5025           8846         FE            mov	-2[bp],al
17877                                           !BCC_EOS
17878                                           ! 2986       AX = (scan_code << 8) | ascii_code;
17879                       00005028            .3DF:
17880                       00005028            .3DE:
17881                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$A-3] (used reg = )
17882 5028           8A46         FF            mov	al,-1[bp]
17883 502B           30E4                       xor	ah,ah
17884 502D           88C4                       mov	ah,al
17885 502F           30C0                       xor	al,al
17886                                           ! Debug: or unsigned char ascii_code = [S+$A-4] to unsigned int = ax+0 (used reg = )
17887 5031           0A46         FE            or	al,-2[bp]
17888                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
17889 5034           8946         12            mov	$12[bp],ax
17890                                           !BCC_EOS
17891                                           ! 2987       break;
17892 5037           E9         02DE            br 	.3D4
17893                                           !BCC_EOS
17894                                           ! 2988     case 0x01:
17895                                           ! 2989       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
17896                       0000503A            .3E1:
17897                                           ! Debug: list int = const 0 (used reg = )
17898 503A           31C0                       xor	ax,ax
17899 503C           50                         push	ax
17900                                           ! Debug: list * unsigned char ascii_code = S+$C-4 (used reg = )
17901 503D           8D5E         FE            lea	bx,-2[bp]
17902 5040           53                         push	bx
17903                                           ! Debug: list * unsigned char scan_code = S+$E-3 (used reg = )
17904 5041           8D5E         FF            lea	bx,-1[bp]
17905 5044           53                         push	bx
17906                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
17907 5045           E8         02D4            call	_dequeue_key
17908 5048           83C4                   06  add	sp,*6
17909 504B           85C0                       test	ax,ax
17910 504D           75           0C            jne 	.3E2
17911                       0000504F            .3E3:
17912                                           ! 2990         FLAGS |= 0x0040;
17913                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$A+$12] (used reg = )
17914 504F           8B46         14            mov	ax,$14[bp]
17915 5052           0C                     40  or	al,*$40
17916 5054           8946         14            mov	$14[bp],ax
17917                                           !BCC_EOS
17918                                           ! 2991         return;
17919 5057           89EC                       mov	sp,bp
17920 5059           5D                         pop	bp
17921 505A           C3                         ret
17922                                           !BCC_EOS
17923                                           ! 2992         }
17924                                           ! 2993       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
17925                       0000505B            .3E2:
17926                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$A-3] (used reg = )
17927 505B           8A46         FF            mov	al,-1[bp]
17928 505E           84C0                       test	al,al
17929 5060           74           0E            je  	.3E4
17930                       00005062            .3E6:
17931                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$A-4] (used reg = )
17932 5062           8A46         FE            mov	al,-2[bp]
17933 5065           3C                     F0  cmp	al,#$F0
17934 5067           75           07            jne 	.3E4
17935                       00005069            .3E5:
17936                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$A-4] (used reg = )
17937 5069           30C0                       xor	al,al
17938 506B           8846         FE            mov	-2[bp],al
17939                                           !BCC_EOS
17940                                           ! 2994       else if (ascii_code == 0xE0) ascii_code = 0;
17941 506E           EB           0C            jmp .3E7
17942                       00005070            .3E4:
17943                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$A-4] (used reg = )
17944 5070           8A46         FE            mov	al,-2[bp]
17945 5073           3C                     E0  cmp	al,#$E0
17946 5075           75           05            jne 	.3E8
17947                       00005077            .3E9:
17948                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$A-4] (used reg = )
17949 5077           30C0                       xor	al,al
17950 5079           8846         FE            mov	-2[bp],al
17951                                           !BCC_EOS
17952                                           ! 2995       AX = (scan_code << 8) | ascii_code;
17953                       0000507C            .3E8:
17954                       0000507C            .3E7:
17955                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$A-3] (used reg = )
17956 507C           8A46         FF            mov	al,-1[bp]
17957 507F           30E4                       xor	ah,ah
17958 5081           88C4                       mov	ah,al
17959 5083           30C0                       xor	al,al
17960                                           ! Debug: or unsigned char ascii_code = [S+$A-4] to unsigned int = ax+0 (used reg = )
17961 5085           0A46         FE            or	al,-2[bp]
17962                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
17963 5088           8946         12            mov	$12[bp],ax
17964                                           !BCC_EOS
17965                                           ! 2996       FLAGS &= 0xffbf;
17966                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$A+$12] (used reg = )
17967 508B           8B46         14            mov	ax,$14[bp]
17968 508E           24                     BF  and	al,#$BF
17969 5090           8946         14            mov	$14[bp],ax
17970                                           !BCC_EOS
17971                                           ! 2997       break;
17972 5093           E9         0282            br 	.3D4
17973                                           !BCC_EOS
17974                                           ! 2998     case 0x02:
17975                                           ! 2999       shift_flags = read_byte(0x0040, 0x17
17976                       00005096            .3EA:
17977                                           ! 2999 );
17978                                           ! Debug: list int = const $17 (used reg = )
17979 5096           B8                   0017  mov	ax,*$17
17980 5099           50                         push	ax
17981                                           ! Debug: list int = const $40 (used reg = )
17982 509A           B8                   0040  mov	ax,*$40
17983 509D           50                         push	ax
17984                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17985 509E           E8         B55D            call	_read_byte
17986 50A1           83C4                   04  add	sp,*4
17987                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$A-5] (used reg = )
17988 50A4           8846         FD            mov	-3[bp],al
17989                                           !BCC_EOS
17990                                           ! 3000       AX = ((AX & 0xff00) | (shift_flags));
17991                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$A+$10] (used reg = )
17992 50A7           8B46         12            mov	ax,$12[bp]
17993 50AA           30C0                       xor	al,al
17994                                           ! Debug: or unsigned char shift_flags = [S+$A-5] to unsigned int = ax+0 (used reg = )
17995 50AC           0A46         FD            or	al,-3[bp]
17996                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
17997 50AF           8946         12            mov	$12[bp],ax
17998                                           !BCC_EOS
17999                                           ! 3001       break;
18000 50B2           E9         0263            br 	.3D4
18001                                           !BCC_EOS
18002                                           ! 3002     case 0x05:
18003                                           ! 3003       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
18004                       000050B5            .3EB:
18005                                           ! Debug: and int = const $FF to unsigned short CX = [S+$A+$E] (used reg = )
18006 50B5           8A46         10            mov	al,$10[bp]
18007                                           ! Debug: list unsigned char = al+0 (used reg = )
18008 50B8           30E4                       xor	ah,ah
18009 50BA           50                         push	ax
18010                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$C+$E] (used reg = )
18011 50BB           8B46         10            mov	ax,$10[bp]
18012 50BE           88E0                       mov	al,ah
18013 50C0           30E4                       xor	ah,ah
18014                                           ! Debug: list unsigned int = ax+0 (used reg = )
18015 50C2           50                         push	ax
18016                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
18017 50C3           E8         0BE0            call	_enqueue_key
18018 50C6           83C4                   04  add	sp,*4
18019 50C9           85C0                       test	ax,ax
18020 50CB           75           0C            jne 	.3EC
18021                       000050CD            .3ED:
18022                                           ! 3004         AX = ((AX & 0xff00) | (1));
18023                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$A+$10] (used reg = )
18024 50CD           8B46         12            mov	ax,$12[bp]
18025 50D0           30C0                       xor	al,al
18026                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
18027 50D2           0C                     01  or	al,*1
18028                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
18029 50D4           8946         12            mov	$12[bp],ax
18030                                           !BCC_EOS
18031                                           ! 3005         }
18032                                           ! 3006       else {
18033 50D7           EB           0A            jmp .3EE
18034                       000050D9            .3EC:
18035                                           ! 3007         AX = ((AX & 0xff00) | (0));
18036                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$A+$10] (used reg = )
18037 50D9           8B46         12            mov	ax,$12[bp]
18038 50DC           30C0                       xor	al,al
18039                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
18040 50DE           0C                     00  or	al,*0
18041                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
18042 50E0           8946         12            mov	$12[bp],ax
18043                                           !BCC_EOS
18044                                           ! 3008         }
18045                                           ! 3009       break;
18046                       000050E3            .3EE:
18047 50E3           E9         0232            br 	.3D4
18048                                           !BCC_EOS
18049                                           ! 3010     case 0x09:
18050                                           ! 3011       AX = ((AX & 0xff00) | (0x30));
18051                       000050E6            .3EF:
18052                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$A+$10] (used reg = )
18053 50E6           8B46         12            mov	ax,$12[bp]
18054 50E9           30C0                       xor	al,al
18055                                           ! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
18056 50EB           0C                     30  or	al,*$30
18057                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
18058 50ED           8946         12            mov	$12[bp],ax
18059                                           !BCC_EOS
18060                                           ! 3012       break;
18061 50F0           E9         0225            br 	.3D4
18062                                           !BCC_EOS
18063                                           ! 3013     case 0x0A:
18064                                           ! 3014       count = 2;
18065                       000050F3            .3F0:
18066                                           ! Debug: eq int = const 2 to unsigned char count = [S+$A-6] (used reg = )
18067 50F3           B0                     02  mov	al,*2
18068 50F5           8846         FC            mov	-4[bp],al
18069                                           !BCC_EOS
18070                                           ! 3015       kbd_code = 0x0;
18071                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$A-8] (used reg = )
18072 50F8           31C0                       xor	ax,ax
18073 50FA           8946         FA            mov	-6[bp],ax
18074                                           !BCC_EOS
18075                                           ! 3016       outb(0x60, 0xf2);
18076                                           ! Debug: list int = const $F2 (used reg = )
18077 50FD           B8                   00F2  mov	ax,#$F2
18078 5100           50                         push	ax
18079                                           ! Debug: list int = const $60 (used reg = )
18080 5101           B8                   0060  mov	ax,*$60
18081 5104           50                         push	ax
18082                                           ! Debug: func () void = outb+0 (used reg = )
18083 5105           E8         B456            call	_outb
18084 5108           83C4                   04  add	sp,*4
18085                                           !BCC_EOS
18086                                           ! 3017       max=0xffff;
18087                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$A-$A] (used reg = )
18088 510B           B8                   FFFF  mov	ax,#$FFFF
18089 510E           8946         F8            mov	-8[bp],ax
18090                                           !BCC_EOS
18091                                           ! 3018       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
18092 5111           EB           0D            jmp .3F2
18093                       00005113            .3F3:
18094                                           ! Debug: list int = const 0 (used reg = )
18095 5113           31C0                       xor	ax,ax
18096 5115           50                         push	ax
18097                                           ! Debug: list int = const $80 (used reg = )
18098 5116           B8                   0080  mov	ax,#$80
18099 5119           50                         push	ax
18100                                           ! Debug: func () void = outb+0 (used reg = )
18101 511A           E8         B441            call	_outb
18102 511D           83C4                   04  add	sp,*4
18103                                           !BCC_EOS
18104                                           ! 3019       if (max>0x0) {
18105                       00005120            .3F2:
18106                                           ! Debug: list int = const $64 (used reg = )
18107 5120           B8                   0064  mov	ax,*$64
18108 5123           50                         push	ax
18109                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18110 5124           E8         B421            call	_inb
18111 5127           44                         inc	sp
18112 5128           44                         inc	sp
18113                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18114 5129           24                     01  and	al,*1
18115                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18116 512B           84C0                       test	al,al
18117 512D           75           0B            jne 	.3F4
18118                       0000512F            .3F5:
18119                                           ! Debug: predec unsigned short max = [S+$A-$A] (used reg = )
18120 512F           8B46         F8            mov	ax,-8[bp]
18121 5132           48                         dec	ax
18122 5133           8946         F8            mov	-8[bp],ax
18123                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
18124 5136           85C0                       test	ax,ax
18125 5138           75           D9            jne	.3F3
18126                       0000513A            .3F4:
18127                       0000513A            .3F1:
18128                                           ! Debug: gt int = const 0 to unsigned short max = [S+$A-$A] (used reg = )
18129 513A           8B46         F8            mov	ax,-8[bp]
18130 513D           85C0                       test	ax,ax
18131 513F           74           6D            je  	.3F6
18132                       00005141            .3F7:
18133                                           ! 3020         if ((inb(0x60) == 0xfa)) {
18134                                           ! Debug: list int = const $60 (used reg = )
18135 5141           B8                   0060  mov	ax,*$60
18136 5144           50                         push	ax
18137                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18138 5145           E8         B400            call	_inb
18139 5148           44                         inc	sp
18140 5149           44                         inc	sp
18141                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
18142 514A           3C                     FA  cmp	al,#$FA
18143 514C           75           60            jne 	.3F8
18144                       0000514E            .3F9:
18145                                           ! 3021           do {
18146                       0000514E            .3FC:
18147                                           ! 3022             max=0xffff;
18148                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$A-$A] (used reg = )
18149 514E           B8                   FFFF  mov	ax,#$FFFF
18150 5151           8946         F8            mov	-8[bp],ax
18151                                           !BCC_EOS
18152                                           ! 3023             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
18153 5154           EB           0D            jmp .3FE
18154                       00005156            .3FF:
18155                                           ! Debug: list int = const 0 (used reg = )
18156 5156           31C0                       xor	ax,ax
18157 5158           50                         push	ax
18158                                           ! Debug: list int = const $80 (used reg = )
18159 5159           B8                   0080  mov	ax,#$80
18160 515C           50                         push	ax
18161                                           ! Debug: func () void = outb+0 (used reg = )
18162 515D           E8         B3FE            call	_outb
18163 5160           83C4                   04  add	sp,*4
18164                                           !BCC_EOS
18165                                           ! 3024             if (max>0x0) {
18166                       00005163            .3FE:
18167                                           ! Debug: list int = const $64 (used reg = )
18168 5163           B8                   0064  mov	ax,*$64
18169 5166           50                         push	ax
18170                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18171 5167           E8         B3DE            call	_inb
18172 516A           44                         inc	sp
18173 516B           44                         inc	sp
18174                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18175 516C           24                     01  and	al,*1
18176                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
18177 516E           84C0                       test	al,al
18178 5170           75           0B            jne 	.400
18179                       00005172            .401:
18180                                           ! Debug: predec unsigned short max = [S+$A-$A] (used reg = )
18181 5172           8B46         F8            mov	ax,-8[bp]
18182 5175           48                         dec	ax
18183 5176           8946         F8            mov	-8[bp],ax
18184                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
18185 5179           85C0                       test	ax,ax
18186 517B           75           D9            jne	.3FF
18187                       0000517D            .400:
18188                       0000517D            .3FD:
18189                                           ! Debug: gt int = const 0 to unsigned short max = [S+$A-$A] (used reg = )
18190 517D           8B46         F8            mov	ax,-8[bp]
18191 5180           85C0                       test	ax,ax
18192 5182           74           1F            je  	.402
18193                       00005184            .403:
18194                                           ! 3025               kbd_code >>= 8;
18195                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$A-8] (used reg = )
18196 5184           8B46         FA            mov	ax,-6[bp]
18197 5187           88E0                       mov	al,ah
18198 5189           30E4                       xor	ah,ah
18199 518B           8946         FA            mov	-6[bp],ax
18200                                           !BCC_EOS
18201                                           ! 3026               kbd_code |= (inb(0x60) << 8);
18202                                           ! Debug: list int = const $60 (used reg = )
18203 518E           B8                   0060  mov	ax,*$60
18204 5191           50                         push	ax
18205                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18206 5192           E8         B3B3            call	_inb
18207 5195           44                         inc	sp
18208 5196           44                         inc	sp
18209                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
18210 5197           30E4                       xor	ah,ah
18211 5199           88C4                       mov	ah,al
18212 519B           30C0                       xor	al,al
18213                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$A-8] (used reg = )
18214 519D           0B46         FA            or	ax,-6[bp]
18215 51A0           8946         FA            mov	-6[bp],ax
18216                                           !BCC_EOS
18217                                           ! 3027             }
18218                                           ! 3028           } while (--count>0);
18219                       000051A3            .402:
18220                       000051A3            .3FB:
18221                                           ! Debug: predec unsigned char count = [S+$A-6] (used reg = )
18222 51A3           8A46         FC            mov	al,-4[bp]
18223 51A6           48                         dec	ax
18224 51A7           8846         FC            mov	-4[bp],al
18225                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
18226 51AA           84C0                       test	al,al
18227 51AC           75           A0            jne	.3FC
18228                       000051AE            .404:
18229                                           !BCC_EOS
18230                                           ! 3029  }
18231                       000051AE            .3FA:
18232                                           ! 3030       }
18233                       000051AE            .3F8:
18234                                           ! 3031       BX=kbd_code;
18235                       000051AE            .3F6:
18236                                           ! Debug: eq unsigned short kbd_code = [S+$A-8] to unsigned short BX = [S+$A+$A] (used reg = )
18237 51AE           8B46         FA            mov	ax,-6[bp]
18238 51B1           8946         0C            mov	$C[bp],ax
18239                                           !BCC_EOS
18240                                           ! 3032       break;
18241 51B4           E9         0161            br 	.3D4
18242                                           !BCC_EOS
18243                                           ! 3033     case 0x10:
18244                                           ! 3034       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
18245                       000051B7            .405:
18246                                           ! Debug: list int = const 1 (used reg = )
18247 51B7           B8                   0001  mov	ax,*1
18248 51BA           50                         push	ax
18249                                           ! Debug: list * unsigned char ascii_code = S+$C-4 (used reg = )
18250 51BB           8D5E         FE            lea	bx,-2[bp]
18251 51BE           53                         push	bx
18252                                           ! Debug: list * unsigned char scan_code = S+$E-3 (used reg = )
18253 51BF           8D5E         FF            lea	bx,-1[bp]
18254 51C2           53                         push	bx
18255                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18256 51C3           E8         0156            call	_dequeue_key
18257 51C6           83C4                   06  add	sp,*6
18258 51C9           85C0                       test	ax,ax
18259 51CB           75           0E            jne 	.406
18260                       000051CD            .407:
18261                                           ! 3035         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
18262                                           ! Debug: list * char = .408+0 (used reg = )
18263 51CD           BB                   D731  mov	bx,#.408
18264 51D0           53                         push	bx
18265                                           ! Debug: list int = const 7 (used reg = )
18266 51D1           B8                   0007  mov	ax,*7
18267 51D4           50                         push	ax
18268                                           ! Debug: func () void = bios_printf+0 (used reg = )
18269 51D5           E8         B6D1            call	_bios_printf
18270 51D8           83C4                   04  add	sp,*4
18271                                           !BCC_EOS
18272                                           ! 3036         }
18273                                           ! 3037       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18274                       000051DB            .406:
18275                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$A-3] (used reg = )
18276 51DB           8A46         FF            mov	al,-1[bp]
18277 51DE           84C0                       test	al,al
18278 51E0           74           0C            je  	.409
18279                       000051E2            .40B:
18280                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$A-4] (used reg = )
18281 51E2           8A46         FE            mov	al,-2[bp]
18282 51E5           3C                     F0  cmp	al,#$F0
18283 51E7           75           05            jne 	.409
18284                       000051E9            .40A:
18285                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$A-4] (used reg = )
18286 51E9           30C0                       xor	al,al
18287 51EB           8846         FE            mov	-2[bp],al
18288                                           !BCC_EOS
18289                                           ! 3038       AX = (scan_code << 8) | ascii_code;
18290                       000051EE            .409:
18291                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$A-3] (used reg = )
18292 51EE           8A46         FF            mov	al,-1[bp]
18293 51F1           30E4                       xor	ah,ah
18294 51F3           88C4                       mov	ah,al
18295 51F5           30C0                       xor	al,al
18296                                           ! Debug: or unsigned char ascii_code = [S+$A-4] to unsigned int = ax+0 (used reg = )
18297 51F7           0A46         FE            or	al,-2[bp]
18298                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
18299 51FA           8946         12            mov	$12[bp],ax
18300                                           !BCC_EOS
18301                                           ! 3039       break;
18302 51FD           E9         0118            br 	.3D4
18303                                           !BCC_EOS
18304                                           ! 3040     case 0x11:
18305                                           ! 3041       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
18306                       00005200            .40C:
18307                                           ! Debug: list int = const 0 (used reg = )
18308 5200           31C0                       xor	ax,ax
18309 5202           50                         push	ax
18310                                           ! Debug: list * unsigned char ascii_code = S+$C-4 (used reg = )
18311 5203           8D5E         FE            lea	bx,-2[bp]
18312 5206           53                         push	bx
18313                                           ! Debug: list * unsigned char scan_code = S+$E-3 (used reg = )
18314 5207           8D5E         FF            lea	bx,-1[bp]
18315 520A           53                         push	bx
18316                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
18317 520B           E8         010E            call	_dequeue_key
18318 520E           83C4                   06  add	sp,*6
18319 5211           85C0                       test	ax,ax
18320 5213           75           0C            jne 	.40D
18321                       00005215            .40E:
18322                                           ! 3042         FLAGS |= 0x0040;
18323                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$A+$12] (used reg = )
18324 5215           8B46         14            mov	ax,$14[bp]
18325 5218           0C                     40  or	al,*$40
18326 521A           8946         14            mov	$14[bp],ax
18327                                           !BCC_EOS
18328                                           ! 3043         return;
18329 521D           89EC                       mov	sp,bp
18330 521F           5D                         pop	bp
18331 5220           C3                         ret
18332                                           !BCC_EOS
18333                                           ! 3044         }
18334                                           ! 3045       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
18335                       00005221            .40D:
18336                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$A-3] (used reg = )
18337 5221           8A46         FF            mov	al,-1[bp]
18338 5224           84C0                       test	al,al
18339 5226           74           0C            je  	.40F
18340                       00005228            .411:
18341                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$A-4] (used reg = )
18342 5228           8A46         FE            mov	al,-2[bp]
18343 522B           3C                     F0  cmp	al,#$F0
18344 522D           75           05            jne 	.40F
18345                       0000522F            .410:
18346                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$A-4] (used reg = )
18347 522F           30C0                       xor	al,al
18348 5231           8846         FE            mov	-2[bp],al
18349                                           !BCC_EOS
18350                                           ! 3046       AX = (scan_code << 8) | ascii_code;
18351                       00005234            .40F:
18352                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$A-3] (used reg = )
18353 5234           8A46         FF            mov	al,-1[bp]
18354 5237           30E4                       xor	ah,ah
18355 5239           88C4                       mov	ah,al
18356 523B           30C0                       xor	al,al
18357                                           ! Debug: or unsigned char ascii_code = [S+$A-4] to unsigned int = ax+0 (used reg = )
18358 523D           0A46         FE            or	al,-2[bp]
18359                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
18360 5240           8946         12            mov	$12[bp],ax
18361                                           !BCC_EOS
18362                                           ! 3047       FLAGS &= 0xffbf;
18363                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$A+$12] (used reg = )
18364 5243           8B46         14            mov	ax,$14[bp]
18365 5246           24                     BF  and	al,#$BF
18366 5248           8946         14            mov	$14[bp],ax
18367                                           !BCC_EOS
18368                                           ! 3048       break;
18369 524B           E9         00CA            br 	.3D4
18370                                           !BCC_EOS
18371                                           ! 3049     case 0x12:
18372                                           ! 3050       shift_flags = read_byte(0x0040, 0x17);
18373                       0000524E            .412:
18374                                           ! Debug: list int = const $17 (used reg = )
18375 524E           B8                   0017  mov	ax,*$17
18376 5251           50                         push	ax
18377                                           ! Debug: list int = const $40 (used reg = )
18378 5252           B8                   0040  mov	ax,*$40
18379 5255           50                         push	ax
18380                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
18381 5256           E8         B3A5            call	_read_byte
18382 5259           83C4                   04  add	sp,*4
18383                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$A-5] (used reg = )
18384 525C           8846         FD            mov	-3[bp],al
18385                                           !BCC_EOS
18386                                           ! 3051       AX = ((AX & 0xff00) | (shift_flags));
18387                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$A+$10] (used reg = )
18388 525F           8B46         12            mov	ax,$12[bp]
18389 5262           30C0                       xor	al,al
18390                                           ! Debug: or unsigned char shift_flags = [S+$A-5] to unsigned int = ax+0 (used reg = )
18391 5264           0A46         FD            or	al,-3[bp]
18392                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
18393 5267           8946         12            mov	$12[bp],ax
18394                                           !BCC_EOS
18395                                           ! 3052       shift_flags = read_byte(0x0040, 0x18);
18396                                           ! Debug: list int = const $18 (used reg = )
18397 526A           B8                   0018  mov	ax,*$18
18398 526D           50                         push	ax
18399                                           ! Debug: list int = const $40 (used reg = )
18400 526E           B8                   0040  mov	ax,*$40
18401 5271           50                         push	ax
18402                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
18403 5272           E8         B389            call	_read_byte
18404 5275           83C4                   04  add	sp,*4
18405                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$A-5] (used reg = )
18406 5278           8846         FD            mov	-3[bp],al
18407                                           !BCC_EOS
18408                                           ! 3053       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
18409                                           ! Debug: sl int = const 8 to unsigned char shift_flags = [S+$A-5] (used reg = )
18410 527B           8A46         FD            mov	al,-3[bp]
18411 527E           30E4                       xor	ah,ah
18412 5280           88C4                       mov	ah,al
18413 5282           30C0                       xor	al,al
18414 5284           50                         push	ax
18415                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
18416 5285           8A46         12            mov	al,$12[bp]
18417                                           ! Debug: or unsigned int (temp) = [S+$C-$C] to unsigned char = al+0 (used reg = )
18418 5288           30E4                       xor	ah,ah
18419 528A           0B46         F6            or	ax,0+..FFF2[bp]
18420 528D           44                         inc	sp
18421 528E           44                         inc	sp
18422                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
18423 528F           8946         12            mov	$12[bp],ax
18424                                           !BCC_EOS
18425                                           ! 3054       ;
18426                                           !BCC_EOS
18427                                           ! 3055       break;
18428 5292           E9         0083            br 	.3D4
18429                                           !BCC_EOS
18430                                           ! 3056     case 0x92:
18431                                           ! 3057       AX = ((AX & 0x00ff) | ((0x80) << 8));
18432                       00005295            .413:
18433                                           ! Debug: and int = const $FF to unsigned short AX = [S+$A+$10] (used reg = )
18434 5295           8A46         12            mov	al,$12[bp]
18435                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
18436 5298           30E4                       xor	ah,ah
18437 529A           0D                   8000  or	ax,#-$8000
18438                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
18439 529D           8946         12            mov	$12[bp],ax
18440                                           !BCC_EOS
18441                                           ! 3058       break;
18442 52A0           EB           76            jmp .3D4
18443                                           !BCC_EOS
18444                                           ! 3059     case 0xA2:
18445                                           ! 3060       break;
18446                       000052A2            .414:
18447 52A2           EB           74            jmp .3D4
18448                                           !BCC_EOS
18449                                           ! 3061     case 0x6F:
18450                                           ! 3062       if (( AX & 0x00ff ) == 0x08)
18451                       000052A4            .415:
18452                                           ! Debug: and int = const $FF to unsigned short AX = [S+$A+$10] (used reg = )
18453 52A4           8A46         12            mov	al,$12[bp]
18454                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
18455 52A7           3C                     08  cmp	al,*8
18456 52A9           75           0B            jne 	.416
18457                       000052AB            .417:
18458                                           ! 3063  AX = ((AX & 0x00ff) | ((0x02) << 8));
18459                                           ! Debug: and int = const $FF to unsigned short AX = [S+$A+$10] (used reg = )
18460 52AB           8A46         12            mov	al,$12[bp]
18461                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
18462 52AE           30E4                       xor	ah,ah
18463 52B0           0D                   0200  or	ax,#$200
18464                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$A+$10] (used reg = )
18465 52B3           8946         12            mov	$12[bp],ax
18466                                           !BCC_EOS
18467                                           ! 3064     default:
18468                       000052B6            .416:
18469                                           ! 3065       bios_printf(4, "KBD: unsupported int 16h function %02x\n", ( AX >> 8 ));
18470                       000052B6            .418:
18471                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$A+$10] (used reg = )
18472 52B6           8B46         12            mov	ax,$12[bp]
18473 52B9           88E0                       mov	al,ah
18474 52BB           30E4                       xor	ah,ah
18475                                           ! Debug: list unsigned int = ax+0 (used reg = )
18476 52BD           50                         push	ax
18477                                           ! Debug: list * char = .419+0 (used reg = )
18478 52BE           BB                   D709  mov	bx,#.419
18479 52C1           53                         push	bx
18480                                           ! Debug: list int = const 4 (used reg = )
18481 52C2           B8                   0004  mov	ax,*4
18482 52C5           50                         push	ax
18483                                           ! Debug: func () void = bios_printf+0 (used reg = )
18484 52C6           E8         B5E0            call	_bios_printf
18485 52C9           83C4                   06  add	sp,*6
18486                                           !BCC_EOS
18487                                           ! 3066     }
18488                                           ! 3067 }
18489 52CC           EB           4A            jmp .3D4
18490                       000052CE            .3D6:
18491 52CE           2D                   0000  sub	ax,*0
18492 52D1           7C           E3            jl 	.418
18493 52D3           3D                   0012  cmp	ax,*$12
18494 52D6           77           2F            ja  	.41A
18495 52D8           D1E0                       shl	ax,*1
18496 52DA           89C3                       mov	bx,ax
18497 52DC           2E                         seg	cs
18498 52DD           FFA7       52E1            br	.41B[bx]
18499                       000052E1            .41B:
18500 52E1                      4FE3            .word	.3D7
18501 52E3                      503A            .word	.3E1
18502 52E5                      5096            .word	.3EA
18503 52E7                      52B6            .word	.418
18504 52E9                      52B6            .word	.418
18505 52EB                      50B5            .word	.3EB
18506 52ED                      52B6            .word	.418
18507 52EF                      52B6            .word	.418
18508 52F1                      52B6            .word	.418
18509 52F3                      50E6            .word	.3EF
18510 52F5                      50F3            .word	.3F0
18511 52F7                      52B6            .word	.418
18512 52F9                      52B6            .word	.418
18513 52FB                      52B6            .word	.418
18514 52FD                      52B6            .word	.418
18515 52FF                      52B6            .word	.418
18516 5301                      51B7            .word	.405
18517 5303                      5200            .word	.40C
18518 5305                      524E            .word	.412
18519                       00005307            .41A:
18520 5307           2D                   006F  sub	ax,*$6F
18521 530A           74           98            je 	.415
18522 530C           2D                   0023  sub	ax,*$23
18523 530F           74           84            je 	.413
18524 5311           2D                   0010  sub	ax,*$10
18525 5314           74           8C            je 	.414
18526 5316           EB           9E            jmp	.418
18527                       00005318            .3D4:
18528                       FFFFFFF6            ..FFF2	=	-$A
18529 5318           89EC                       mov	sp,bp
18530 531A           5D                         pop	bp
18531 531B           C3                         ret
18532                                           ! 3068   unsigned int
18533                                           ! Register BX used in function int16_function
18534                                           ! 3069 dequeue_key(scan_code, ascii_code, incr)
18535                                           ! 3070   Bit8u *scan_code;
18536                                           export	_dequeue_key
18537                       0000531C            _dequeue_key:
18538                                           !BCC_EOS
18539                                           ! 3071   Bit8u *ascii_code;
18540                                           !BCC_EOS
18541                                           ! 3072   unsigned int incr;
18542                                           !BCC_EOS
18543                                           ! 3073 {
18544                                           ! 3074   Bit16u buffer_start, buffer_end,
18545                                           ! 3074  buffer_head, buffer_tail;
18546                                           !BCC_EOS
18547                                           ! 3075   Bit16u ss;
18548                                           !BCC_EOS
18549                                           ! 3076   Bit8u acode, scode;
18550                                           !BCC_EOS
18551                                           ! 3077   buffer_start = read_word(0x0040, 0x0080);
18552 531C           55                         push	bp
18553 531D           89E5                       mov	bp,sp
18554 531F           83C4                   F4  add	sp,*-$C
18555                                           ! Debug: list int = const $80 (used reg = )
18556 5322           B8                   0080  mov	ax,#$80
18557 5325           50                         push	ax
18558                                           ! Debug: list int = const $40 (used reg = )
18559 5326           B8                   0040  mov	ax,*$40
18560 5329           50                         push	ax
18561                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
18562 532A           E8         B2E4            call	_read_word
18563 532D           83C4                   04  add	sp,*4
18564                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
18565 5330           8946         FE            mov	-2[bp],ax
18566                                           !BCC_EOS
18567                                           ! 3078   buffer_end = read_word(0x0040, 0x0082);
18568                                           ! Debug: list int = const $82 (used reg = )
18569 5333           B8                   0082  mov	ax,#$82
18570 5336           50                         push	ax
18571                                           ! Debug: list int = const $40 (used reg = )
18572 5337           B8                   0040  mov	ax,*$40
18573 533A           50                         push	ax
18574                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
18575 533B           E8         B2D3            call	_read_word
18576 533E           83C4                   04  add	sp,*4
18577                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
18578 5341           8946         FC            mov	-4[bp],ax
18579                                           !BCC_EOS
18580                                           ! 3079   buffer_head = read_word(0x0040, 0x001a);
18581                                           ! Debug: list int = const $1A (used reg = )
18582 5344           B8                   001A  mov	ax,*$1A
18583 5347           50                         push	ax
18584                                           ! Debug: list int = const $40 (used reg = )
18585 5348           B8                   0040  mov	ax,*$40
18586 534B           50                         push	ax
18587                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
18588 534C           E8         B2C2            call	_read_word
18589 534F           83C4                   04  add	sp,*4
18590                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
18591 5352           8946         FA            mov	-6[bp],ax
18592                                           !BCC_EOS
18593                                           ! 3080   buffer_tail = read_word(0x0040, 0x001c);
18594                                           ! Debug: list int = const $1C (used reg = )
18595 5355           B8                   001C  mov	ax,*$1C
18596 5358           50                         push	ax
18597                                           ! Debug: list int = const $40 (used reg = )
18598 5359           B8                   0040  mov	ax,*$40
18599 535C           50                         push	ax
18600                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
18601 535D           E8         B2B1            call	_read_word
18602 5360           83C4                   04  add	sp,*4
18603                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
18604 5363           8946         F8            mov	-8[bp],ax
18605                                           !BCC_EOS
18606                                           ! 3081   if (buffer_head != buffer_tail) {
18607                                           ! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
18608 5366           8B46         FA            mov	ax,-6[bp]
18609 5369           3B46         F8            cmp	ax,-8[bp]
18610 536C         0F84         0083            beq 	.41C
18611                       00005370            .41D:
18612                                           ! 3082     ss = get_SS();
18613                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
18614 5370           E8         B2E4            call	_get_SS
18615                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
18616 5373           8946         F6            mov	-$A[bp],ax
18617                                           !BCC_EOS
18618                                           ! 3083     acode = read_byte(0x0040, buffer_head);
18619                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
18620 5376           FF76         FA            push	-6[bp]
18621                                           ! Debug: list int = const $40 (used reg = )
18622 5379           B8                   0040  mov	ax,*$40
18623 537C           50                         push	ax
18624                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
18625 537D           E8         B27E            call	_read_byte
18626 5380           83C4                   04  add	sp,*4
18627                                           ! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
18628 5383           8846         F5            mov	-$B[bp],al
18629                                           !BCC_EOS
18630                                           ! 3084     scode = read_byte(0x0040, buffer_head+1);
18631                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
18632 5386           8B46         FA            mov	ax,-6[bp]
18633                                           ! Debug: list unsigned int = ax+1 (used reg = )
18634 5389           40                         inc	ax
18635 538A           50                         push	ax
18636                                           ! Debug: list int = const $40 (used reg = )
18637 538B           B8                   0040  mov	ax,*$40
18638 538E           50                         push	ax
18639                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
18640 538F           E8         B26C            call	_read_byte
18641 5392           83C4                   04  add	sp,*4
18642                                           ! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
18643 5395           8846         F4            mov	-$C[bp],al
18644                                           !BCC_EOS
18645                                           ! 3085     write_byte(ss, ascii_code, acode);
18646                                           ! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
18647 5398           8A46         F5            mov	al,-$B[bp]
18648 539B           30E4                       xor	ah,ah
18649 539D           50                         push	ax
18650                                           ! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
18651 539E           FF76         06            push	6[bp]
18652                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
18653 53A1           FF76         F6            push	-$A[bp]
18654                                           ! Debug: func () void = write_byte+0 (used reg = )
18655 53A4           E8         B27D            call	_write_byte
18656 53A7           83C4                   06  add	sp,*6
18657                                           !BCC_EOS
18658                                           ! 3086     write_byte(ss, scan_code, scode);
18659                                           ! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
18660 53AA           8A46         F4            mov	al,-$C[bp]
18661 53AD           30E4                       xor	ah,ah
18662 53AF           50                         push	ax
18663                                           ! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
18664 53B0           FF76         04            push	4[bp]
18665                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
18666 53B3           FF76         F6            push	-$A[bp]
18667                                           ! Debug: func () void = write_byte+0 (used reg = )
18668 53B6           E8         B26B            call	_write_byte
18669 53B9           83C4                   06  add	sp,*6
18670                                           !BCC_EOS
18671                                           ! 3087     if (incr) {
18672 53BC           8B46         08            mov	ax,8[bp]
18673 53BF           85C0                       test	ax,ax
18674 53C1           74           27            je  	.41E
18675                       000053C3            .41F:
18676                                           ! 3088       buffer_head += 2;
18677                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
18678 53C3           8B46         FA            mov	ax,-6[bp]
18679 53C6           40                         inc	ax
18680 53C7           40                         inc	ax
18681 53C8           8946         FA            mov	-6[bp],ax
18682                                           !BCC_EOS
18683                                           ! 3089       if (buffer_head >= buffer_end)
18684                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
18685 53CB           8B46         FA            mov	ax,-6[bp]
18686 53CE           3B46         FC            cmp	ax,-4[bp]
18687 53D1           72           06            jb  	.420
18688                       000053D3            .421:
18689                                           ! 3090         buffer_head = buffer_start;
18690                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
18691 53D3           8B46         FE            mov	ax,-2[bp]
18692 53D6           8946         FA            mov	-6[bp],ax
18693                                           !BCC_EOS
18694                                           ! 3091       write_word(0x0040, 0x001a, buffer_head);
18695                       000053D9            .420:
18696                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
18697 53D9           FF76         FA            push	-6[bp]
18698                                           ! Debug: list int = const $1A (used reg = )
18699 53DC           B8                   001A  mov	ax,*$1A
18700 53DF           50                         push	ax
18701                                           ! Debug: list int = const $40 (used reg = )
18702 53E0           B8                   0040  mov	ax,*$40
18703 53E3           50                         push	ax
18704                                           ! Debug: func () void = write_word+0 (used reg = )
18705 53E4           E8         B255            call	_write_word
18706 53E7           83C4                   06  add	sp,*6
18707                                           !BCC_EOS
18708                                           ! 3092       }
18709                                           ! 3093     return(1);
18710                       000053EA            .41E:
18711 53EA           B8                   0001  mov	ax,*1
18712 53ED           89EC                       mov	sp,bp
18713 53EF           5D                         pop	bp
18714 53F0           C3                         ret
18715                                           !BCC_EOS
18716                                           ! 3094     }
18717                                           ! 3095   else {
18718 53F1           EB           06            jmp .422
18719                       000053F3            .41C:
18720                                           ! 3096     return(0);
18721 53F3           31C0                       xor	ax,ax
18722 53F5           89EC                       mov	sp,bp
18723 53F7           5D                         pop	bp
18724 53F8           C3                         ret
18725                                           !BCC_EOS
18726                                           ! 3097     }
18727                                           ! 3098 }
18728                       000053F9            .422:
18729 53F9           89EC                       mov	sp,bp
18730 53FB           5D                         pop	bp
18731 53FC           C3                         ret
18732                                           ! 3099 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
18733                                           
18734                       000053FD            _panic_msg_keyb_buffer_full:
18735                       000053FD            .423:
18736 53FD                        25            .ascii	"%s: keyboard input buffer full"
18737 541B                        0A            .byte	$A
18738 541C                        00            .byte	0
18739                                           !BCC_EOS
18740                                           ! 3100   Bit8u
18741                                           ! 3101 inhibit_mouse_int_and_events()
18742                                           ! 3102 {
18743                                           
18744                                           export	_inhibit_mouse_int_and_events
18745                       0000541D            _inhibit_mouse_int_and_events:
18746                                           ! 3103   Bit8u command_byte, prev_command_byte;
18747                                           !BCC_EOS
18748                                           ! 3104   if ( inb(0x64) & 0x02 )
18749 541D           55                         push	bp
18750 541E           89E5                       mov	bp,sp
18751 5420           4C                         dec	sp
18752 5421           4C                         dec	sp
18753                                           ! Debug: list int = const $64 (used reg = )
18754 5422           B8                   0064  mov	ax,*$64
18755 5425           50                         push	ax
18756                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18757 5426           E8         B11F            call	_inb
18758 5429           44                         inc	sp
18759 542A           44                         inc	sp
18760                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
18761 542B           24                     02  and	al,*2
18762 542D           84C0                       test	al,al
18763 542F           74           12            je  	.424
18764                       00005431            .425:
18765                                           ! 3105     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
18766                                           ! Debug: list * char = .426+0 (used reg = )
18767 5431           BB                   D6FE  mov	bx,#.426
18768 5434           53                         push	bx
18769                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
18770 5435           BB                   53FD  mov	bx,#_panic_msg_keyb_buffer_full
18771 5438           53                         push	bx
18772                                           ! Debug: list int = const 7 (used reg = )
18773 5439           B8                   0007  mov	ax,*7
18774 543C           50                         push	ax
18775                                           ! Debug: func () void = bios_printf+0 (used reg = )
18776 543D           E8         B469            call	_bios_printf
18777 5440           83C4                   06  add	sp,*6
18778                                           !BCC_EOS
18779                                           ! 3106   outb(0x64, 0x20);
18780                       00005443            .424:
18781                                           ! Debug: list int = const $20 (used reg = )
18782 5443           B8                   0020  mov	ax,*$20
18783 5446           50                         push	ax
18784                                           ! Debug: list int = const $64 (used reg = )
18785 5447           B8                   0064  mov	ax,*$64
18786 544A           50                         push	ax
18787                                           ! Debug: func () void = outb+0 (used reg = )
18788 544B           E8         B110            call	_outb
18789 544E           83C4                   04  add	sp,*4
18790                                           !BCC_EOS
18791                                           ! 3107   while ( (inb(0x64) & 0x01) != 0x01 );
18792 5451           EB           00            jmp .428
18793                       00005453            .429:
18794                                           !BCC_EOS
18795                                           ! 3108   prev_command_byte = inb(0x60);
18796                       00005453            .428:
18797                                           ! Debug: list int = const $64 (used reg = )
18798 5453           B8                   0064  mov	ax,*$64
18799 5456           50                         push	ax
18800                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18801 5457           E8         B0EE            call	_inb
18802 545A           44                         inc	sp
18803 545B           44                         inc	sp
18804                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18805 545C           24                     01  and	al,*1
18806                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
18807 545E           3C                     01  cmp	al,*1
18808 5460           75           F1            jne	.429
18809                       00005462            .42A:
18810                       00005462            .427:
18811                                           ! Debug: list int = const $60 (used reg = )
18812 5462           B8                   0060  mov	ax,*$60
18813 5465           50                         push	ax
18814                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18815 5466           E8         B0DF            call	_inb
18816 5469           44                         inc	sp
18817 546A           44                         inc	sp
18818                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
18819 546B           8846         FE            mov	-2[bp],al
18820                                           !BCC_EOS
18821                                           ! 3109   command_byte = prev_command_byte;
18822                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
18823 546E           8A46         FE            mov	al,-2[bp]
18824 5471           8846         FF            mov	-1[bp],al
18825                                           !BCC_EOS
18826                                           ! 3110   if ( inb(0x64) & 0x02 )
18827                                           ! Debug: list int = const $64 (used reg = )
18828 5474           B8                   0064  mov	ax,*$64
18829 5477           50                         push	ax
18830                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18831 5478           E8         B0CD            call	_inb
18832 547B           44                         inc	sp
18833 547C           44                         inc	sp
18834                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
18835 547D           24                     02  and	al,*2
18836 547F           84C0                       test	al,al
18837 5481           74           12            je  	.42B
18838                       00005483            .42C:
18839                                           ! 3111     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
18840                                           ! Debug: list * char = .42D+0 (used reg = )
18841 5483           BB                   D6F3  mov	bx,#.42D
18842 5486           53                         push	bx
18843                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
18844 5487           BB                   53FD  mov	bx,#_panic_msg_keyb_buffer_full
18845 548A           53                         push	bx
18846                                           ! Debug: list int = const 7 (used reg = )
18847 548B           B8                   0007  mov	ax,*7
18848 548E           50                         push	ax
18849                                           ! Debug: func () void = bios_printf+0 (used reg = )
18850 548F           E8         B417            call	_bios_printf
18851 5492           83C4                   06  add	sp,*6
18852                                           !BCC_EOS
18853                                           ! 3112   command_byte &= 0xfd;
18854                       00005495            .42B:
18855                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
18856 5495           8A46         FF            mov	al,-1[bp]
18857 5498           24                     FD  and	al,#$FD
18858 549A           8846         FF            mov	-1[bp],al
18859                                           !BCC_EOS
18860                                           ! 3113   command_byte |= 0x20;
18861                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
18862 549D           8A46         FF            mov	al,-1[bp]
18863 54A0           0C                     20  or	al,*$20
18864 54A2           8846         FF            mov	-1[bp],al
18865                                           !BCC_EOS
18866                                           ! 3114   outb(0x64, 0x60);
18867                                           ! Debug: list int = const $60 (used reg = )
18868 54A5           B8                   0060  mov	ax,*$60
18869 54A8           50                         push	ax
18870                                           ! Debug: list int = const $64 (used reg = )
18871 54A9           B8                   0064  mov	ax,*$64
18872 54AC           50                         push	ax
18873                                           ! Debug: func () void = outb+0 (used reg = )
18874 54AD           E8         B0AE            call	_outb
18875 54B0           83C4                   04  add	sp,*4
18876                                           !BCC_EOS
18877                                           ! 3115   outb(0x60, command_byte);
18878                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
18879 54B3           8A46         FF            mov	al,-1[bp]
18880 54B6           30E4                       xor	ah,ah
18881 54B8           50                         push	ax
18882                                           ! Debug: list int = const $60 (used reg = )
18883 54B9           B8                   0060  mov	ax,*$60
18884 54BC           50                         push	ax
18885                                           ! Debug: func () void = outb+0 (used reg = )
18886 54BD           E8         B09E            call	_outb
18887 54C0           83C4                   04  add	sp,*4
18888                                           !BCC_EOS
18889                                           ! 3116   return(prev_command_byte);
18890 54C3           8A46         FE            mov	al,-2[bp]
18891 54C6           89EC                       mov	sp,bp
18892 54C8           5D                         pop	bp
18893 54C9           C3                         ret
18894                                           !BCC_EOS
18895                                           ! 3117 }
18896                                           ! 3118   void
18897                                           ! Register BX used in function inhibit_mouse_int_and_events
18898                                           ! 3119 enable_mouse_int_and_events()
18899                                           ! 3120 {
18900                                           export	_enable_mouse_int_and_events
18901                       000054CA            _enable_mouse_int_and_events:
18902                                           ! 3121   Bit8u command_byte;
18903                                           !BCC_EOS
18904                                           ! 3122   if ( inb(0x64) & 0x02 )
18905 54CA           55                         push	bp
18906 54CB           89E5                       mov	bp,sp
18907 54CD           4C                         dec	sp
18908 54CE           4C                         dec	sp
18909                                           ! Debug: list int = const $64 (used reg = )
18910 54CF           B8                   0064  mov	ax,*$64
18911 54D2           50                         push	ax
18912                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18913 54D3           E8         B072            call	_inb
18914 54D6           44                         inc	sp
18915 54D7           44                         inc	sp
18916                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
18917 54D8           24                     02  and	al,*2
18918 54DA           84C0                       test	al,al
18919 54DC           74           12            je  	.42E
18920                       000054DE            .42F:
18921                                           ! 3123     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
18922                                           ! Debug: list * char = .430+0 (used reg = )
18923 54DE           BB                   D6E9  mov	bx,#.430
18924 54E1           53                         push	bx
18925                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
18926 54E2           BB                   53FD  mov	bx,#_panic_msg_keyb_buffer_full
18927 54E5           53                         push	bx
18928                                           ! Debug: list int = const 7 (used reg = )
18929 54E6           B8                   0007  mov	ax,*7
18930 54E9           50                         push	ax
18931                                           ! Debug: func () void = bios_printf+0 (used reg = )
18932 54EA           E8         B3BC            call	_bios_printf
18933 54ED           83C4                   06  add	sp,*6
18934                                           !BCC_EOS
18935                                           ! 3124   outb(0x64, 0x20);
18936                       000054F0            .42E:
18937                                           ! Debug: list int = const $20 (used reg = )
18938 54F0           B8                   0020  mov	ax,*$20
18939 54F3           50                         push	ax
18940                                           ! Debug: list int = const $64 (used reg = )
18941 54F4           B8                   0064  mov	ax,*$64
18942 54F7           50                         push	ax
18943                                           ! Debug: func () void = outb+0 (used reg = )
18944 54F8           E8         B063            call	_outb
18945 54FB           83C4                   04  add	sp,*4
18946                                           !BCC_EOS
18947                                           ! 3125   while ( (inb(0x64) & 0x01) != 0x01 );
18948 54FE           EB           00            jmp .432
18949                       00005500            .433:
18950                                           !BCC_EOS
18951                                           ! 3126   command_byte = inb(0x60);
18952                       00005500            .432:
18953                                           ! Debug: list int = const $64 (used reg = )
18954 5500           B8                   0064  mov	ax,*$64
18955 5503           50                         push	ax
18956                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18957 5504           E8         B041            call	_inb
18958 5507           44                         inc	sp
18959 5508           44                         inc	sp
18960                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
18961 5509           24                     01  and	al,*1
18962                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
18963 550B           3C                     01  cmp	al,*1
18964 550D           75           F1            jne	.433
18965                       0000550F            .434:
18966                       0000550F            .431:
18967                                           ! Debug: list int = const $60 (used reg = )
18968 550F           B8                   0060  mov	ax,*$60
18969 5512           50                         push	ax
18970                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18971 5513           E8         B032            call	_inb
18972 5516           44                         inc	sp
18973 5517           44                         inc	sp
18974                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
18975 5518           8846         FF            mov	-1[bp],al
18976                                           !BCC_EOS
18977                                           ! 3127   if ( inb(0x64) & 0x02 )
18978                                           ! Debug: list int = const $64 (used reg = )
18979 551B           B8                   0064  mov	ax,*$64
18980 551E           50                         push	ax
18981                                           ! Debug: func () unsigned char = inb+0 (used reg = )
18982 551F           E8         B026            call	_inb
18983 5522           44                         inc	sp
18984 5523           44                         inc	sp
18985                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
18986 5524           24                     02  and	al,*2
18987 5526           84C0                       test	al,al
18988 5528           74           12            je  	.435
18989                       0000552A            .436:
18990                                           ! 3128     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
18991                                           ! Debug: list * char = .437+0 (used reg = )
18992 552A           BB                   D6DF  mov	bx,#.437
18993 552D           53                         push	bx
18994                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
18995 552E           BB                   53FD  mov	bx,#_panic_msg_keyb_buffer_full
18996 5531           53                         push	bx
18997                                           ! Debug: list int = const 7 (used reg = )
18998 5532           B8                   0007  mov	ax,*7
18999 5535           50                         push	ax
19000                                           ! Debug: func () void = bios_printf+0 (used reg = )
19001 5536           E8         B370            call	_bios_printf
19002 5539           83C4                   06  add	sp,*6
19003                                           !BCC_EOS
19004                                           ! 3129   command_byte |= 0x02;
19005                       0000553C            .435:
19006                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
19007 553C           8A46         FF            mov	al,-1[bp]
19008 553F           0C                     02  or	al,*2
19009 5541           8846         FF            mov	-1[bp],al
19010                                           !BCC_EOS
19011                                           ! 3130   command_byte &= 0xdf;
19012                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
19013 5544           8A46         FF            mov	al,-1[bp]
19014 5547           24                     DF  and	al,#$DF
19015 5549           8846         FF            mov	-1[bp],al
19016                                           !BCC_EOS
19017                                           ! 3131   outb(0x64, 0x60);
19018                                           ! Debug: list int = const $60 (used reg = )
19019 554C           B8                   0060  mov	ax,*$60
19020 554F           50                         push	ax
19021                                           ! Debug: list int = const $64 (used reg = )
19022 5550           B8                   0064  mov	ax,*$64
19023 5553           50                         push	ax
19024                                           ! Debug: func () void = outb+0 (used reg = )
19025 5554           E8         B007            call	_outb
19026 5557           83C4                   04  add	sp,*4
19027                                           !BCC_EOS
19028                                           ! 3132   outb(0x60, command_byte);
19029                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
19030 555A           8A46         FF            mov	al,-1[bp]
19031 555D           30E4                       xor	ah,ah
19032 555F           50                         push	ax
19033                                           ! Debug: list int = const $60 (used reg = )
19034 5560           B8                   0060  mov	ax,*$60
19035 5563           50                         push	ax
19036                                           ! Debug: func () void = outb+0 (used reg = )
19037 5564           E8         AFF7            call	_outb
19038 5567           83C4                   04  add	sp,*4
19039                                           !BCC_EOS
19040                                           ! 3133 }
19041 556A           89EC                       mov	sp,bp
19042 556C           5D                         pop	bp
19043 556D           C3                         ret
19044                                           ! 3134   Bit8u
19045                                           ! Register BX used in function enable_mouse_int_and_events
19046                                           ! 3135 send_to_mouse_ctrl(sendbyte)
19047                                           ! 3136   Bit8u sendbyte;
19048                                           export	_send_to_mouse_ctrl
19049                       0000556E            _send_to_mouse_ctrl:
19050                                           !BCC_EOS
19051                                           ! 3137 {
19052                                           ! 3138   Bit8u response;
19053                                           !BCC_EOS
19054                                           ! 3139   if ( inb(0x64) & 0x02 )
19055 556E           55                         push	bp
19056 556F           89E5                       mov	bp,sp
19057 5571           4C                         dec	sp
19058 5572           4C                         dec	sp
19059                                           ! Debug: list int = const $64 (used reg = )
19060 5573           B8                   0064  mov	ax,*$64
19061 5576           50                         push	ax
19062                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19063 5577           E8         AFCE            call	_inb
19064 557A           44                         inc	sp
19065 557B           44                         inc	sp
19066                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19067 557C           24                     02  and	al,*2
19068 557E           84C0                       test	al,al
19069 5580           74           12            je  	.438
19070                       00005582            .439:
19071                                           ! 3140     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
19072                                           ! Debug: list * char = .43A+0 (used reg = )
19073 5582           BB                   D6D5  mov	bx,#.43A
19074 5585           53                         push	bx
19075                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19076 5586           BB                   53FD  mov	bx,#_panic_msg_keyb_buffer_full
19077 5589           53                         push	bx
19078                                           ! Debug: list int = const 7 (used reg = )
19079 558A           B8                   0007  mov	ax,*7
19080 558D           50                         push	ax
19081                                           ! Debug: func () void = bios_printf+0 (used reg = )
19082 558E           E8         B318            call	_bios_printf
19083 5591           83C4                   06  add	sp,*6
19084                                           !BCC_EOS
19085                                           ! 3141   outb(0x64, 0xD4);
19086                       00005594            .438:
19087                                           ! Debug: list int = const $D4 (used reg = )
19088 5594           B8                   00D4  mov	ax,#$D4
19089 5597           50                         push	ax
19090                                           ! Debug: list int = const $64 (used reg = )
19091 5598           B8                   0064  mov	ax,*$64
19092 559B           50                         push	ax
19093                                           ! Debug: func () void = outb+0 (used reg = )
19094 559C           E8         AFBF            call	_outb
19095 559F           83C4                   04  add	sp,*4
19096                                           !BCC_EOS
19097                                           ! 3142   outb(0x60, sendbyte);
19098                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
19099 55A2           8A46         04            mov	al,4[bp]
19100 55A5           30E4                       xor	ah,ah
19101 55A7           50                         push	ax
19102                                           ! Debug: list int = const $60 (used reg = )
19103 55A8           B8                   0060  mov	ax,*$60
19104 55AB           50                         push	ax
19105                                           ! Debug: func () void = outb+0 (used reg = )
19106 55AC           E8         AFAF            call	_outb
19107 55AF           83C4                   04  add	sp,*4
19108                                           !BCC_EOS
19109                                           ! 3143   return(0);
19110 55B2           30C0                       xor	al,al
19111 55B4           89EC                       mov	sp,bp
19112 55B6           5D                         pop	bp
19113 55B7           C3                         ret
19114                                           !BCC_EOS
19115                                           ! 3144 }
19116                                           ! 3145   Bit8u
19117                                           ! Register BX used in function send_to_mouse_ctrl
19118                                           ! 3146 get_mouse_data(data)
19119                                           ! 3147   Bit8u *data;
19120                                           export	_get_mouse_data
19121                       000055B8            _get_mouse_data:
19122                                           !BCC_EOS
19123                                           ! 3148 {
19124                                           ! 3149   Bit8u response;
19125                                           !BCC_EOS
19126                                           ! 3150   Bit16u ss;
19127                                           !BCC_EOS
19128                                           ! 3151   while ( (inb
19129 55B8           55                         push	bp
19130 55B9           89E5                       mov	bp,sp
19131 55BB           83C4                   FC  add	sp,*-4
19132                                           ! 3151 (0x64) & 0x21) != 0x21 ) {
19133 55BE           EB           00            jmp .43C
19134                       000055C0            .43D:
19135                                           ! 3152     }
19136                                           ! 3153   response = inb(0x60);
19137                       000055C0            .43C:
19138                                           ! Debug: list int = const $64 (used reg = )
19139 55C0           B8                   0064  mov	ax,*$64
19140 55C3           50                         push	ax
19141                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19142 55C4           E8         AF81            call	_inb
19143 55C7           44                         inc	sp
19144 55C8           44                         inc	sp
19145                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
19146 55C9           24                     21  and	al,*$21
19147                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
19148 55CB           3C                     21  cmp	al,*$21
19149 55CD           75           F1            jne	.43D
19150                       000055CF            .43E:
19151                       000055CF            .43B:
19152                                           ! Debug: list int = const $60 (used reg = )
19153 55CF           B8                   0060  mov	ax,*$60
19154 55D2           50                         push	ax
19155                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19156 55D3           E8         AF72            call	_inb
19157 55D6           44                         inc	sp
19158 55D7           44                         inc	sp
19159                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
19160 55D8           8846         FF            mov	-1[bp],al
19161                                           !BCC_EOS
19162                                           ! 3154   ss = get_SS();
19163                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
19164 55DB           E8         B079            call	_get_SS
19165                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
19166 55DE           8946         FC            mov	-4[bp],ax
19167                                           !BCC_EOS
19168                                           ! 3155   write_byte(ss, data, response);
19169                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
19170 55E1           8A46         FF            mov	al,-1[bp]
19171 55E4           30E4                       xor	ah,ah
19172 55E6           50                         push	ax
19173                                           ! Debug: list * unsigned char data = [S+8+2] (used reg = )
19174 55E7           FF76         04            push	4[bp]
19175                                           ! Debug: list unsigned short ss = [S+$A-6] (used reg = )
19176 55EA           FF76         FC            push	-4[bp]
19177                                           ! Debug: func () void = write_byte+0 (used reg = )
19178 55ED           E8         B034            call	_write_byte
19179 55F0           83C4                   06  add	sp,*6
19180                                           !BCC_EOS
19181                                           ! 3156   return(0);
19182 55F3           30C0                       xor	al,al
19183 55F5           89EC                       mov	sp,bp
19184 55F7           5D                         pop	bp
19185 55F8           C3                         ret
19186                                           !BCC_EOS
19187                                           ! 3157 }
19188                                           ! 3158   void
19189                                           ! 3159 set_kbd_command_byte(command_byte)
19190                                           ! 3160   Bit8u command_byte;
19191                                           export	_set_kbd_command_byte
19192                       000055F9            _set_kbd_command_byte:
19193                                           !BCC_EOS
19194                                           ! 3161 {
19195                                           ! 3162   if ( inb(0x64) & 0x02 )
19196 55F9           55                         push	bp
19197 55FA           89E5                       mov	bp,sp
19198                                           ! Debug: list int = const $64 (used reg = )
19199 55FC           B8                   0064  mov	ax,*$64
19200 55FF           50                         push	ax
19201                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19202 5600           E8         AF45            call	_inb
19203 5603           89EC                       mov	sp,bp
19204                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
19205 5605           24                     02  and	al,*2
19206 5607           84C0                       test	al,al
19207 5609           74           11            je  	.43F
19208                       0000560B            .440:
19209                                           ! 3163     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
19210                                           ! Debug: list * char = .441+0 (used reg = )
19211 560B           BB                   D6CA  mov	bx,#.441
19212 560E           53                         push	bx
19213                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
19214 560F           BB                   53FD  mov	bx,#_panic_msg_keyb_buffer_full
19215 5612           53                         push	bx
19216                                           ! Debug: list int = const 7 (used reg = )
19217 5613           B8                   0007  mov	ax,*7
19218 5616           50                         push	ax
19219                                           ! Debug: func () void = bios_printf+0 (used reg = )
19220 5617           E8         B28F            call	_bios_printf
19221 561A           89EC                       mov	sp,bp
19222                                           !BCC_EOS
19223                                           ! 3164   outb(0x64, 0xD4);
19224                       0000561C            .43F:
19225                                           ! Debug: list int = const $D4 (used reg = )
19226 561C           B8                   00D4  mov	ax,#$D4
19227 561F           50                         push	ax
19228                                           ! Debug: list int = const $64 (used reg = )
19229 5620           B8                   0064  mov	ax,*$64
19230 5623           50                         push	ax
19231                                           ! Debug: func () void = outb+0 (used reg = )
19232 5624           E8         AF37            call	_outb
19233 5627           89EC                       mov	sp,bp
19234                                           !BCC_EOS
19235                                           ! 3165   outb(0x64, 0x60);
19236                                           ! Debug: list int = const $60 (used reg = )
19237 5629           B8                   0060  mov	ax,*$60
19238 562C           50                         push	ax
19239                                           ! Debug: list int = const $64 (used reg = )
19240 562D           B8                   0064  mov	ax,*$64
19241 5630           50                         push	ax
19242                                           ! Debug: func () void = outb+0 (used reg = )
19243 5631           E8         AF2A            call	_outb
19244 5634           89EC                       mov	sp,bp
19245                                           !BCC_EOS
19246                                           ! 3166   outb(0x60, command_byte);
19247                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
19248 5636           8A46         04            mov	al,4[bp]
19249 5639           30E4                       xor	ah,ah
19250 563B           50                         push	ax
19251                                           ! Debug: list int = const $60 (used reg = )
19252 563C           B8                   0060  mov	ax,*$60
19253 563F           50                         push	ax
19254                                           ! Debug: func () void = outb+0 (used reg = )
19255 5640           E8         AF1B            call	_outb
19256 5643           89EC                       mov	sp,bp
19257                                           !BCC_EOS
19258                                           ! 3167 }
19259 5645           5D                         pop	bp
19260 5646           C3                         ret
19261                                           ! 3168   void
19262                                           ! Register BX used in function set_kbd_command_byte
19263                                           ! 3169 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
19264                                           ! 3170   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
19265                                           export	_int09_function
19266                       00005647            _int09_function:
19267                                           !BCC_EOS
19268                                           ! 3171 {
19269                                           ! 3172   Bit8u scancode, asciicode, shift_flags;
19270                                           !BCC_EOS
19271                                           ! 3173   Bit8u mf2_flags, mf2_state, led_flags;
19272                                           !BCC_EOS
19273                                           ! 3174   scancode = ( AX & 0x00ff );
19274 5647           55                         push	bp
19275 5648           89E5                       mov	bp,sp
19276 564A           83C4                   FA  add	sp,*-6
19277                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
19278 564D           8A46         12            mov	al,$12[bp]
19279                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
19280 5650           8846         FF            mov	-1[bp],al
19281                                           !BCC_EOS
19282                                           ! 3175   if (scancode == 0) {
19283                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
19284 5653           8A46         FF            mov	al,-1[bp]
19285 5656           84C0                       test	al,al
19286 5658           75           12            jne 	.442
19287                       0000565A            .443:
19288                                           ! 3176     bios_printf(4, "KBD: int09 handler: AL=0\n");
19289                                           ! Debug: list * char = .444+0 (used reg = )
19290 565A           BB                   D6B0  mov	bx,#.444
19291 565D           53                         push	bx
19292                                           ! Debug: list int = const 4 (used reg = )
19293 565E           B8                   0004  mov	ax,*4
19294 5661           50                         push	ax
19295                                           ! Debug: func () void = bios_printf+0 (used reg = )
19296 5662           E8         B244            call	_bios_printf
19297 5665           83C4                   04  add	sp,*4
19298                                           !BCC_EOS
19299                                           ! 3177     return;
19300 5668           89EC                       mov	sp,bp
19301 566A           5D                         pop	bp
19302 566B           C3                         ret
19303                                           !BCC_EOS
19304                                           ! 3178     }
19305                                           ! 3179   shift_flags = read_byte(0x0040, 0x17);
19306                       0000566C            .442:
19307                                           ! Debug: list int = const $17 (used reg = )
19308 566C           B8                   0017  mov	ax,*$17
19309 566F           50                         push	ax
19310                                           ! Debug: list int = const $40 (used reg = )
19311 5670           B8                   0040  mov	ax,*$40
19312 5673           50                         push	ax
19313                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19314 5674           E8         AF87            call	_read_byte
19315 5677           83C4                   04  add	sp,*4
19316                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
19317 567A           8846         FD            mov	-3[bp],al
19318                                           !BCC_EOS
19319                                           ! 3180   mf2_flags = read_byte(0x0040, 0x18);
19320                                           ! Debug: list int = const $18 (used reg = )
19321 567D           B8                   0018  mov	ax,*$18
19322 5680           50                         push	ax
19323                                           ! Debug: list int = const $40 (used reg = )
19324 5681           B8                   0040  mov	ax,*$40
19325 5684           50                         push	ax
19326                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19327 5685           E8         AF76            call	_read_byte
19328 5688           83C4                   04  add	sp,*4
19329                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
19330 568B           8846         FC            mov	-4[bp],al
19331                                           !BCC_EOS
19332                                           ! 3181   mf2_state = read_byte(0x0040, 0x96);
19333                                           ! Debug: list int = const $96 (used reg = )
19334 568E           B8                   0096  mov	ax,#$96
19335 5691           50                         push	ax
19336                                           ! Debug: list int = const $40 (used reg = )
19337 5692           B8                   0040  mov	ax,*$40
19338 5695           50                         push	ax
19339                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19340 5696           E8         AF65            call	_read_byte
19341 5699           83C4                   04  add	sp,*4
19342                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
19343 569C           8846         FB            mov	-5[bp],al
19344                                           !BCC_EOS
19345                                           ! 3182   led_flags = read_byte(0x0040, 0x97);
19346                                           ! Debug: list int = const $97 (used reg = )
19347 569F           B8                   0097  mov	ax,#$97
19348 56A2           50                         push	ax
19349                                           ! Debug: list int = const $40 (used reg = )
19350 56A3           B8                   0040  mov	ax,*$40
19351 56A6           50                         push	ax
19352                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19353 56A7           E8         AF54            call	_read_byte
19354 56AA           83C4                   04  add	sp,*4
19355                                           ! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+8-8] (used reg = )
19356 56AD           8846         FA            mov	-6[bp],al
19357                                           !BCC_EOS
19358                                           ! 3183   asciicode = 0;
19359                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
19360 56B0           30C0                       xor	al,al
19361 56B2           8846         FE            mov	-2[bp],al
19362                                           !BCC_EOS
19363                                           ! 3184   switch (scancode) {
19364 56B5           8A46         FF            mov	al,-1[bp]
19365 56B8           E9         0582            br 	.447
19366                                           ! 3185     case 0x3a:
19367                                           ! 3186       shift_flags ^= 0x40;
19368                       000056BB            .448:
19369                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
19370 56BB           8A46         FD            mov	al,-3[bp]
19371 56BE           34                     40  xor	al,*$40
19372 56C0           8846         FD            mov	-3[bp],al
19373                                           !BCC_EOS
19374                                           ! 3187       write_byte(0x0040, 0x17, shift_flags);
19375                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
19376 56C3           8A46         FD            mov	al,-3[bp]
19377 56C6           30E4                       xor	ah,ah
19378 56C8           50                         push	ax
19379                                           ! Debug: list int = const $17 (used reg = )
19380 56C9           B8                   0017  mov	ax,*$17
19381 56CC           50                         push	ax
19382                                           ! Debug: list int = const $40 (used reg = )
19383 56CD           B8                   0040  mov	ax,*$40
19384 56D0           50                         push	ax
19385                                           ! Debug: func () void = write_byte+0 (used reg = )
19386 56D1           E8         AF50            call	_write_byte
19387 56D4           83C4                   06  add	sp,*6
19388                                           !BCC_EOS
19389                                           ! 3188       mf2_flags |= 0x40;
19390                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
19391 56D7           8A46         FC            mov	al,-4[bp]
19392 56DA           0C                     40  or	al,*$40
19393 56DC           8846         FC            mov	-4[bp],al
19394                                           !BCC_EOS
19395                                           ! 3189       write_byte(0x0040, 0x18, mf2_flags);
19396                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
19397 56DF           8A46         FC            mov	al,-4[bp]
19398 56E2           30E4                       xor	ah,ah
19399 56E4           50                         push	ax
19400                                           ! Debug: list int = const $18 (used reg = )
19401 56E5           B8                   0018  mov	ax,*$18
19402 56E8           50                         push	ax
19403                                           ! Debug: list int = const $40 (used reg = )
19404 56E9           B8                   0040  mov	ax,*$40
19405 56EC           50                         push	ax
19406                                           ! Debug: func () void = write_byte+0 (used reg = )
19407 56ED           E8         AF34            call	_write_byte
19408 56F0           83C4                   06  add	sp,*6
19409                                           !BCC_EOS
19410                                           ! 3190       led_flags ^= 0x04;
19411                                           ! Debug: eorab int = const 4 to unsigned char led_flags = [S+8-8] (used reg = )
19412 56F3           8A46         FA            mov	al,-6[bp]
19413 56F6           34                     04  xor	al,*4
19414 56F8           8846         FA            mov	-6[bp],al
19415                                           !BCC_EOS
19416                                           ! 3191       write_byte(0x0040, 0x97, led_flags);
19417                                           ! Debug: list unsigned char led_flags = [S+8-8] (used reg = )
19418 56FB           8A46         FA            mov	al,-6[bp]
19419 56FE           30E4                       xor	ah,ah
19420 5700           50                         push	ax
19421                                           ! Debug: list int = const $97 (used reg = )
19422 5701           B8                   0097  mov	ax,#$97
19423 5704           50                         push	ax
19424                                           ! Debug: list int = const $40 (used reg = )
19425 5705           B8                   0040  mov	ax,*$40
19426 5708           50                         push	ax
19427                                           ! Debug: func () void = write_byte+0 (used reg = )
19428 5709           E8         AF18            call	_write_byte
19429 570C           83C4                   06  add	sp,*6
19430                                           !BCC_EOS
19431                                           ! 3192       break;
19432 570F           E9         0588            br 	.445
19433                                           !BCC_EOS
19434                                           ! 3193     case 0xba:
19435                                           ! 3194       mf2_flags &= ~0x40;
19436                       00005712            .449:
19437                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
19438 5712           8A46         FC            mov	al,-4[bp]
19439 5715           24                     BF  and	al,#$BF
19440 5717           8846         FC            mov	-4[bp],al
19441                                           !BCC_EOS
19442                                           ! 3195       write_byte(0x0040, 0x18, mf2_flags);
19443                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
19444 571A           8A46         FC            mov	al,-4[bp]
19445 571D           30E4                       xor	ah,ah
19446 571F           50                         push	ax
19447                                           ! Debug: list int = const $18 (used reg = )
19448 5720           B8                   0018  mov	ax,*$18
19449 5723           50                         push	ax
19450                                           ! Debug: list int = const $40 (used reg = )
19451 5724           B8                   0040  mov	ax,*$40
19452 5727           50                         push	ax
19453                                           ! Debug: func () void = write_byte+0 (used reg = )
19454 5728           E8         AEF9            call	_write_byte
19455 572B           83C4                   06  add	sp,*6
19456                                           !BCC_EOS
19457                                           ! 3196       break;
19458 572E           E9         0569            br 	.445
19459                                           !BCC_EOS
19460                                           ! 3197     case 0x2a:
19461                                           ! 3198       shift_flags |= 0x02;
19462                       00005731            .44A:
19463                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
19464 5731           8A46         FD            mov	al,-3[bp]
19465 5734           0C                     02  or	al,*2
19466 5736           8846         FD            mov	-3[bp],al
19467                                           !BCC_EOS
19468                                           ! 3199       write_byte(0x0040, 0x17, shift_flags);
19469                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
19470 5739           8A46         FD            mov	al,-3[bp]
19471 573C           30E4                       xor	ah,ah
19472 573E           50                         push	ax
19473                                           ! Debug: list int = const $17 (used reg = )
19474 573F           B8                   0017  mov	ax,*$17
19475 5742           50                         push	ax
19476                                           ! Debug: list int = const $40 (used reg = )
19477 5743           B8                   0040  mov	ax,*$40
19478 5746           50                         push	ax
19479                                           ! Debug: func () void = write_byte+0 (used reg = )
19480 5747           E8         AEDA            call	_write_byte
19481 574A           83C4                   06  add	sp,*6
19482                                           !BCC_EOS
19483                                           ! 3200       led_flags &= ~0x04;
19484                                           ! Debug: andab int = const -5 to unsigned char led_flags = [S+8-8] (used reg = )
19485 574D           8A46         FA            mov	al,-6[bp]
19486 5750           24                     FB  and	al,#$FB
19487 5752           8846         FA            mov	-6[bp],al
19488                                           !BCC_EOS
19489                                           ! 3201       write_byte(0x0040, 0x97, led_flags);
19490                                           ! Debug: list unsigned char led_flags = [S+8-8] (used reg = )
19491 5755           8A46         FA            mov	al,-6[bp]
19492 5758           30E4                       xor	ah,ah
19493 575A           50                         push	ax
19494                                           ! Debug: list int = const $97 (used reg = )
19495 575B           B8                   0097  mov	ax,#$97
19496 575E           50                         push	ax
19497                                           ! Debug: list int = const $40 (used reg = )
19498 575F           B8                   0040  mov	ax,*$40
19499 5762           50                         push	ax
19500                                           ! Debug: func () void = write_byte+0 (used reg = )
19501 5763           E8         AEBE            call	_write_byte
19502 5766           83C4                   06  add	sp,*6
19503                                           !BCC_EOS
19504                                           ! 3202       break;
19505 5769           E9         052E            br 	.445
19506                                           !BCC_EOS
19507                                           ! 3203     case 0xaa:
19508                                           ! 3204       shift_flags &= ~0x02;
19509                       0000576C            .44B:
19510                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
19511 576C           8A46         FD            mov	al,-3[bp]
19512 576F           24                     FD  and	al,#$FD
19513 5771           8846         FD            mov	-3[bp],al
19514                                           !BCC_EOS
19515                                           ! 3205       write_byte(0x0040, 0x17, shift_flags);
19516                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
19517 5774           8A46         FD            mov	al,-3[bp]
19518 5777           30E4                       xor	ah,ah
19519 5779           50                         push	ax
19520                                           ! Debug: list int = const $17 (used reg = )
19521 577A           B8                   0017  mov	ax,*$17
19522 577D           50                         push	ax
19523                                           ! Debug: list int = const $40 (used reg = )
19524 577E           B8                   0040  mov	ax,*$40
19525 5781           50                         push	ax
19526                                           ! Debug: func () void = write_byte+0 (used reg = )
19527 5782           E8         AE9F            call	_write_byte
19528 5785           83C4                   06  add	sp,*6
19529                                           !BCC_EOS
19530                                           ! 3206       break;
19531 5788           E9         050F            br 	.445
19532                                           !BCC_EOS
19533                                           ! 3207     case 0x36:
19534                                           ! 3208       shift_flags |= 0x01;
19535                       0000578B            .44C:
19536                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
19537 578B           8A46         FD            mov	al,-3[bp]
19538 578E           0C                     01  or	al,*1
19539 5790           8846         FD            mov	-3[bp],al
19540                                           !BCC_EOS
19541                                           ! 3209       write_byte(0x0040, 0x17, shift_flags);
19542                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
19543 5793           8A46         FD            mov	al,-3[bp]
19544 5796           30E4                       xor	ah,ah
19545 5798           50                         push	ax
19546                                           ! Debug: list int = const $17 (used reg = )
19547 5799           B8                   0017  mov	ax,*$17
19548 579C           50                         push	ax
19549                                           ! Debug: list int = const $40 (used reg = )
19550 579D           B8                   0040  mov	ax,*$40
19551 57A0           50                         push	ax
19552                                           ! Debug: func () void = write_byte+0 (used reg = )
19553 57A1           E8         AE80            call	_write_byte
19554 57A4           83C4                   06  add	sp,*6
19555                                           !BCC_EOS
19556                                           ! 3210       led_flags &= ~0x04;
19557                                           ! Debug: andab int = const -5 to unsigned char led_flags = [S+8-8] (used reg = )
19558 57A7           8A46         FA            mov	al,-6[bp]
19559 57AA           24                     FB  and	al,#$FB
19560 57AC           8846         FA            mov	-6[bp],al
19561                                           !BCC_EOS
19562                                           ! 3211       write_byte(0x0040, 0x97, led_flags);
19563                                           ! Debug: list unsigned char led_flags = [S+8-8] (used reg = )
19564 57AF           8A46         FA            mov	al,-6[bp]
19565 57B2           30E4                       xor	ah,ah
19566 57B4           50                         push	ax
19567                                           ! Debug: list int = const $97 (used reg = )
19568 57B5           B8                   0097  mov	ax,#$97
19569 57B8           50                         push	ax
19570                                           ! Debug: list int = const $40 (used reg = )
19571 57B9           B8                   0040  mov	ax,*$40
19572 57BC           50                         push	ax
19573                                           ! Debug: func () void = write_byte+0 (used reg = )
19574 57BD           E8         AE64            call	_write_byte
19575 57C0           83C4                   06  add	sp,*6
19576                                           !BCC_EOS
19577                                           ! 3212       break;
19578 57C3           E9         04D4            br 	.445
19579                                           !BCC_EOS
19580                                           ! 3213     case 0xb6:
19581                                           ! 3214       shift_flags &= ~0x01;
19582                       000057C6            .44D:
19583                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
19584 57C6           8A46         FD            mov	al,-3[bp]
19585 57C9           24                     FE  and	al,#$FE
19586 57CB           8846         FD            mov	-3[bp],al
19587                                           !BCC_EOS
19588                                           ! 3215       write_byte(0x0040, 0x17, shift_flags);
19589                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
19590 57CE           8A46         FD            mov	al,-3[bp]
19591 57D1           30E4                       xor	ah,ah
19592 57D3           50                         push	ax
19593                                           ! Debug: list int = const $17 (used reg = )
19594 57D4           B8                   0017  mov	ax,*$17
19595 57D7           50                         push	ax
19596                                           ! Debug: list int = const $40 (used reg = )
19597 57D8           B8                   0040  mov	ax,*$40
19598 57DB           50                         push	ax
19599                                           ! Debug: func () void = write_byte+0 (used reg = )
19600 57DC           E8         AE45            call	_write_byte
19601 57DF           83C4                   06  add	sp,*6
19602                                           !BCC_EOS
19603                                           ! 3216       break;
19604 57E2           E9         04B5            br 	.445
19605                                           !BCC_EOS
19606                                           ! 3217     case 0x1d:
19607                                           ! 3218       shift_flags |= 0x04;
19608                       000057E5            .44E:
19609                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
19610 57E5           8A46         FD            mov	al,-3[bp]
19611 57E8           0C                     04  or	al,*4
19612 57EA           8846         FD            mov	-3[bp],al
19613                                           !BCC_EOS
19614                                           ! 3219       write_byte(0x0040, 0x17, shift_flags);
19615                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
19616 57ED           8A46         FD            mov	al,-3[bp]
19617 57F0           30E4                       xor	ah,ah
19618 57F2           50                         push	ax
19619                                           ! Debug: list int = const $17 (used reg = )
19620 57F3           B8                   0017  mov	ax,*$17
19621 57F6           50                         push	ax
19622                                           ! Debug: list int = const $40 (used reg = )
19623 57F7           B8                   0040  mov	ax,*$40
19624 57FA           50                         push	ax
19625                                           ! Debug: func () void = write_byte+0 (used reg = )
19626 57FB           E8         AE26            call	_write_byte
19627 57FE           83C4                   06  add	sp,*6
19628                                           !BCC_EOS
19629                                           ! 3220       if (mf2_state & 0x01) {
19630                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19631 5801           8A46         FB            mov	al,-5[bp]
19632 5804           24                     01  and	al,*1
19633 5806           84C0                       test	al,al
19634 5808           74           0A            je  	.44F
19635                       0000580A            .450:
19636                                           ! 3221         mf2_flags |= 0x04;
19637                                           ! Debug: orab int = const 4 to unsigned char mf2_flags = [S+8-6] (used reg = )
19638 580A           8A46         FC            mov	al,-4[bp]
19639 580D           0C                     04  or	al,*4
19640 580F           8846         FC            mov	-4[bp],al
19641                                           !BCC_EOS
19642                                           ! 3222       } else {
19643 5812           EB           08            jmp .451
19644                       00005814            .44F:
19645                                           ! 3223         mf2_flags |= 0x01;
19646                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
19647 5814           8A46         FC            mov	al,-4[bp]
19648 5817           0C                     01  or	al,*1
19649 5819           8846         FC            mov	-4[bp],al
19650                                           !BCC_EOS
19651                                           ! 3224         }
19652                                           ! 3225       write_byte(0x0040, 0x18, mf2_flags);
19653                       0000581C            .451:
19654                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
19655 581C           8A46         FC            mov	al,-4[bp]
19656 581F           30E4                       xor	ah,ah
19657 5821           50                         push	ax
19658                                           ! Debug: list int = const $18 (used reg = )
19659 5822           B8                   0018  mov	ax,*$18
19660 5825           50                         push	ax
19661                                           ! Debug: list int = const $40 (used reg = )
19662 5826           B8                   0040  mov	ax,*$40
19663 5829           50                         push	ax
19664                                           ! Debug: func () void = write_byte+0 (used reg = )
19665 582A           E8         ADF7            call	_write_byte
19666 582D           83C4                   06  add	sp,*6
19667                                           !BCC_EOS
19668                                           ! 3226       break;
19669 5830           E9         0467            br 	.445
19670                                           !BCC_EOS
19671                                           ! 3227     case 0x9d:
19672                                           ! 3228       shift_flags &= ~0x04;
19673                       00005833            .452:
19674                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
19675 5833           8A46         FD            mov	al,-3[bp]
19676 5836           24                     FB  and	al,#$FB
19677 5838           8846         FD            mov	-3[bp],al
19678                                           !BCC_EOS
19679                                           ! 3229       write_byte(0x0040, 0
19680                                           ! 3229 x17, shift_flags);
19681                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
19682 583B           8A46         FD            mov	al,-3[bp]
19683 583E           30E4                       xor	ah,ah
19684 5840           50                         push	ax
19685                                           ! Debug: list int = const $17 (used reg = )
19686 5841           B8                   0017  mov	ax,*$17
19687 5844           50                         push	ax
19688                                           ! Debug: list int = const $40 (used reg = )
19689 5845           B8                   0040  mov	ax,*$40
19690 5848           50                         push	ax
19691                                           ! Debug: func () void = write_byte+0 (used reg = )
19692 5849           E8         ADD8            call	_write_byte
19693 584C           83C4                   06  add	sp,*6
19694                                           !BCC_EOS
19695                                           ! 3230       if (mf2_state & 0x01) {
19696                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19697 584F           8A46         FB            mov	al,-5[bp]
19698 5852           24                     01  and	al,*1
19699 5854           84C0                       test	al,al
19700 5856           74           0A            je  	.453
19701                       00005858            .454:
19702                                           ! 3231         mf2_flags &= ~0x04;
19703                                           ! Debug: andab int = const -5 to unsigned char mf2_flags = [S+8-6] (used reg = )
19704 5858           8A46         FC            mov	al,-4[bp]
19705 585B           24                     FB  and	al,#$FB
19706 585D           8846         FC            mov	-4[bp],al
19707                                           !BCC_EOS
19708                                           ! 3232       } else {
19709 5860           EB           08            jmp .455
19710                       00005862            .453:
19711                                           ! 3233         mf2_flags &= ~0x01;
19712                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
19713 5862           8A46         FC            mov	al,-4[bp]
19714 5865           24                     FE  and	al,#$FE
19715 5867           8846         FC            mov	-4[bp],al
19716                                           !BCC_EOS
19717                                           ! 3234         }
19718                                           ! 3235       write_byte(0x0040, 0x18, mf2_flags);
19719                       0000586A            .455:
19720                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
19721 586A           8A46         FC            mov	al,-4[bp]
19722 586D           30E4                       xor	ah,ah
19723 586F           50                         push	ax
19724                                           ! Debug: list int = const $18 (used reg = )
19725 5870           B8                   0018  mov	ax,*$18
19726 5873           50                         push	ax
19727                                           ! Debug: list int = const $40 (used reg = )
19728 5874           B8                   0040  mov	ax,*$40
19729 5877           50                         push	ax
19730                                           ! Debug: func () void = write_byte+0 (used reg = )
19731 5878           E8         ADA9            call	_write_byte
19732 587B           83C4                   06  add	sp,*6
19733                                           !BCC_EOS
19734                                           ! 3236       break;
19735 587E           E9         0419            br 	.445
19736                                           !BCC_EOS
19737                                           ! 3237     case 0x38:
19738                                           ! 3238       shift_flags |= 0x08;
19739                       00005881            .456:
19740                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
19741 5881           8A46         FD            mov	al,-3[bp]
19742 5884           0C                     08  or	al,*8
19743 5886           8846         FD            mov	-3[bp],al
19744                                           !BCC_EOS
19745                                           ! 3239       write_byte(0x0040, 0x17, shift_flags);
19746                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
19747 5889           8A46         FD            mov	al,-3[bp]
19748 588C           30E4                       xor	ah,ah
19749 588E           50                         push	ax
19750                                           ! Debug: list int = const $17 (used reg = )
19751 588F           B8                   0017  mov	ax,*$17
19752 5892           50                         push	ax
19753                                           ! Debug: list int = const $40 (used reg = )
19754 5893           B8                   0040  mov	ax,*$40
19755 5896           50                         push	ax
19756                                           ! Debug: func () void = write_byte+0 (used reg = )
19757 5897           E8         AD8A            call	_write_byte
19758 589A           83C4                   06  add	sp,*6
19759                                           !BCC_EOS
19760                                           ! 3240       if (mf2_state & 0x01) {
19761                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19762 589D           8A46         FB            mov	al,-5[bp]
19763 58A0           24                     01  and	al,*1
19764 58A2           84C0                       test	al,al
19765 58A4           74           0A            je  	.457
19766                       000058A6            .458:
19767                                           ! 3241         mf2_flags |= 0x08;
19768                                           ! Debug: orab int = const 8 to unsigned char mf2_flags = [S+8-6] (used reg = )
19769 58A6           8A46         FC            mov	al,-4[bp]
19770 58A9           0C                     08  or	al,*8
19771 58AB           8846         FC            mov	-4[bp],al
19772                                           !BCC_EOS
19773                                           ! 3242       } else {
19774 58AE           EB           08            jmp .459
19775                       000058B0            .457:
19776                                           ! 3243         mf2_flags |= 0x02;
19777                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
19778 58B0           8A46         FC            mov	al,-4[bp]
19779 58B3           0C                     02  or	al,*2
19780 58B5           8846         FC            mov	-4[bp],al
19781                                           !BCC_EOS
19782                                           ! 3244         }
19783                                           ! 3245       write_byte(0x0040, 0x18, mf2_flags);
19784                       000058B8            .459:
19785                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
19786 58B8           8A46         FC            mov	al,-4[bp]
19787 58BB           30E4                       xor	ah,ah
19788 58BD           50                         push	ax
19789                                           ! Debug: list int = const $18 (used reg = )
19790 58BE           B8                   0018  mov	ax,*$18
19791 58C1           50                         push	ax
19792                                           ! Debug: list int = const $40 (used reg = )
19793 58C2           B8                   0040  mov	ax,*$40
19794 58C5           50                         push	ax
19795                                           ! Debug: func () void = write_byte+0 (used reg = )
19796 58C6           E8         AD5B            call	_write_byte
19797 58C9           83C4                   06  add	sp,*6
19798                                           !BCC_EOS
19799                                           ! 3246       break;
19800 58CC           E9         03CB            br 	.445
19801                                           !BCC_EOS
19802                                           ! 3247     case 0xb8:
19803                                           ! 3248       shift_flags &= ~0x08;
19804                       000058CF            .45A:
19805                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
19806 58CF           8A46         FD            mov	al,-3[bp]
19807 58D2           24                     F7  and	al,#$F7
19808 58D4           8846         FD            mov	-3[bp],al
19809                                           !BCC_EOS
19810                                           ! 3249       write_byte(0x0040, 0x17, shift_flags);
19811                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
19812 58D7           8A46         FD            mov	al,-3[bp]
19813 58DA           30E4                       xor	ah,ah
19814 58DC           50                         push	ax
19815                                           ! Debug: list int = const $17 (used reg = )
19816 58DD           B8                   0017  mov	ax,*$17
19817 58E0           50                         push	ax
19818                                           ! Debug: list int = const $40 (used reg = )
19819 58E1           B8                   0040  mov	ax,*$40
19820 58E4           50                         push	ax
19821                                           ! Debug: func () void = write_byte+0 (used reg = )
19822 58E5           E8         AD3C            call	_write_byte
19823 58E8           83C4                   06  add	sp,*6
19824                                           !BCC_EOS
19825                                           ! 3250       if (mf2_state & 0x01) {
19826                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19827 58EB           8A46         FB            mov	al,-5[bp]
19828 58EE           24                     01  and	al,*1
19829 58F0           84C0                       test	al,al
19830 58F2           74           0A            je  	.45B
19831                       000058F4            .45C:
19832                                           ! 3251         mf2_flags &= ~0x08;
19833                                           ! Debug: andab int = const -9 to unsigned char mf2_flags = [S+8-6] (used reg = )
19834 58F4           8A46         FC            mov	al,-4[bp]
19835 58F7           24                     F7  and	al,#$F7
19836 58F9           8846         FC            mov	-4[bp],al
19837                                           !BCC_EOS
19838                                           ! 3252       } else {
19839 58FC           EB           08            jmp .45D
19840                       000058FE            .45B:
19841                                           ! 3253         mf2_flags &= ~0x02;
19842                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
19843 58FE           8A46         FC            mov	al,-4[bp]
19844 5901           24                     FD  and	al,#$FD
19845 5903           8846         FC            mov	-4[bp],al
19846                                           !BCC_EOS
19847                                           ! 3254         }
19848                                           ! 3255       write_byte(0x0040, 0x18, mf2_flags);
19849                       00005906            .45D:
19850                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
19851 5906           8A46         FC            mov	al,-4[bp]
19852 5909           30E4                       xor	ah,ah
19853 590B           50                         push	ax
19854                                           ! Debug: list int = const $18 (used reg = )
19855 590C           B8                   0018  mov	ax,*$18
19856 590F           50                         push	ax
19857                                           ! Debug: list int = const $40 (used reg = )
19858 5910           B8                   0040  mov	ax,*$40
19859 5913           50                         push	ax
19860                                           ! Debug: func () void = write_byte+0 (used reg = )
19861 5914           E8         AD0D            call	_write_byte
19862 5917           83C4                   06  add	sp,*6
19863                                           !BCC_EOS
19864                                           ! 3256       break;
19865 591A           E9         037D            br 	.445
19866                                           !BCC_EOS
19867                                           ! 3257     case 0x45:
19868                                           ! 3258       if ((mf2_state & 0x01) == 0) {
19869                       0000591D            .45E:
19870                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19871 591D           8A46         FB            mov	al,-5[bp]
19872 5920           24                     01  and	al,*1
19873                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19874 5922           84C0                       test	al,al
19875 5924           75           54            jne 	.45F
19876                       00005926            .460:
19877                                           ! 3259         mf2_flags |= 0x20;
19878                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
19879 5926           8A46         FC            mov	al,-4[bp]
19880 5929           0C                     20  or	al,*$20
19881 592B           8846         FC            mov	-4[bp],al
19882                                           !BCC_EOS
19883                                           ! 3260         write_byte(0x0040, 0x18, mf2_flags);
19884                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
19885 592E           8A46         FC            mov	al,-4[bp]
19886 5931           30E4                       xor	ah,ah
19887 5933           50                         push	ax
19888                                           ! Debug: list int = const $18 (used reg = )
19889 5934           B8                   0018  mov	ax,*$18
19890 5937           50                         push	ax
19891                                           ! Debug: list int = const $40 (used reg = )
19892 5938           B8                   0040  mov	ax,*$40
19893 593B           50                         push	ax
19894                                           ! Debug: func () void = write_byte+0 (used reg = )
19895 593C           E8         ACE5            call	_write_byte
19896 593F           83C4                   06  add	sp,*6
19897                                           !BCC_EOS
19898                                           ! 3261         shift_flags ^= 0x20;
19899                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
19900 5942           8A46         FD            mov	al,-3[bp]
19901 5945           34                     20  xor	al,*$20
19902 5947           8846         FD            mov	-3[bp],al
19903                                           !BCC_EOS
19904                                           ! 3262         led_flags ^= 0x02;
19905                                           ! Debug: eorab int = const 2 to unsigned char led_flags = [S+8-8] (used reg = )
19906 594A           8A46         FA            mov	al,-6[bp]
19907 594D           34                     02  xor	al,*2
19908 594F           8846         FA            mov	-6[bp],al
19909                                           !BCC_EOS
19910                                           ! 3263         write_byte(0x0040, 0x17, shift_flags);
19911                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
19912 5952           8A46         FD            mov	al,-3[bp]
19913 5955           30E4                       xor	ah,ah
19914 5957           50                         push	ax
19915                                           ! Debug: list int = const $17 (used reg = )
19916 5958           B8                   0017  mov	ax,*$17
19917 595B           50                         push	ax
19918                                           ! Debug: list int = const $40 (used reg = )
19919 595C           B8                   0040  mov	ax,*$40
19920 595F           50                         push	ax
19921                                           ! Debug: func () void = write_byte+0 (used reg = )
19922 5960           E8         ACC1            call	_write_byte
19923 5963           83C4                   06  add	sp,*6
19924                                           !BCC_EOS
19925                                           ! 3264         write_byte(0x0040, 0x97, led_flags);
19926                                           ! Debug: list unsigned char led_flags = [S+8-8] (used reg = )
19927 5966           8A46         FA            mov	al,-6[bp]
19928 5969           30E4                       xor	ah,ah
19929 596B           50                         push	ax
19930                                           ! Debug: list int = const $97 (used reg = )
19931 596C           B8                   0097  mov	ax,#$97
19932 596F           50                         push	ax
19933                                           ! Debug: list int = const $40 (used reg = )
19934 5970           B8                   0040  mov	ax,*$40
19935 5973           50                         push	ax
19936                                           ! Debug: func () void = write_byte+0 (used reg = )
19937 5974           E8         ACAD            call	_write_byte
19938 5977           83C4                   06  add	sp,*6
19939                                           !BCC_EOS
19940                                           ! 3265         }
19941                                           ! 3266       break;
19942                       0000597A            .45F:
19943 597A           E9         031D            br 	.445
19944                                           !BCC_EOS
19945                                           ! 3267     case 0xc5:
19946                                           ! 3268       if ((mf2_state & 0x01) == 0) {
19947                       0000597D            .461:
19948                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
19949 597D           8A46         FB            mov	al,-5[bp]
19950 5980           24                     01  and	al,*1
19951                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19952 5982           84C0                       test	al,al
19953 5984           75           1C            jne 	.462
19954                       00005986            .463:
19955                                           ! 3269         mf2_flags &= ~0x20;
19956                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
19957 5986           8A46         FC            mov	al,-4[bp]
19958 5989           24                     DF  and	al,#$DF
19959 598B           8846         FC            mov	-4[bp],al
19960                                           !BCC_EOS
19961                                           ! 3270         write_byte(0x0040, 0x18, mf2_flags);
19962                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
19963 598E           8A46         FC            mov	al,-4[bp]
19964 5991           30E4                       xor	ah,ah
19965 5993           50                         push	ax
19966                                           ! Debug: list int = const $18 (used reg = )
19967 5994           B8                   0018  mov	ax,*$18
19968 5997           50                         push	ax
19969                                           ! Debug: list int = const $40 (used reg = )
19970 5998           B8                   0040  mov	ax,*$40
19971 599B           50                         push	ax
19972                                           ! Debug: func () void = write_byte+0 (used reg = )
19973 599C           E8         AC85            call	_write_byte
19974 599F           83C4                   06  add	sp,*6
19975                                           !BCC_EOS
19976                                           ! 3271         }
19977                                           ! 3272       break;
19978                       000059A2            .462:
19979 59A2           E9         02F5            br 	.445
19980                                           !BCC_EOS
19981                                           ! 3273     case 0x46:
19982                                           ! 3274       mf2_flags |= 0x10;
19983                       000059A5            .464:
19984                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
19985 59A5           8A46         FC            mov	al,-4[bp]
19986 59A8           0C                     10  or	al,*$10
19987 59AA           8846         FC            mov	-4[bp],al
19988                                           !BCC_EOS
19989                                           ! 3275       write_byte(0x0040, 0x18, mf2_flags);
19990                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
19991 59AD           8A46         FC            mov	al,-4[bp]
19992 59B0           30E4                       xor	ah,ah
19993 59B2           50                         push	ax
19994                                           ! Debug: list int = const $18 (used reg = )
19995 59B3           B8                   0018  mov	ax,*$18
19996 59B6           50                         push	ax
19997                                           ! Debug: list int = const $40 (used reg = )
19998 59B7           B8                   0040  mov	ax,*$40
19999 59BA           50                         push	ax
20000                                           ! Debug: func () void = write_byte+0 (used reg = )
20001 59BB           E8         AC66            call	_write_byte
20002 59BE           83C4                   06  add	sp,*6
20003                                           !BCC_EOS
20004                                           ! 3276       shift_flags ^= 0x10;
20005                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
20006 59C1           8A46         FD            mov	al,-3[bp]
20007 59C4           34                     10  xor	al,*$10
20008 59C6           8846         FD            mov	-3[bp],al
20009                                           !BCC_EOS
20010                                           ! 3277       led_flags ^= 0x01;
20011                                           ! Debug: eorab int = const 1 to unsigned char led_flags = [S+8-8] (used reg = )
20012 59C9           8A46         FA            mov	al,-6[bp]
20013 59CC           34                     01  xor	al,*1
20014 59CE           8846         FA            mov	-6[bp],al
20015                                           !BCC_EOS
20016                                           ! 3278       write_byte(0x0040, 0x17, shift_flags);
20017                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
20018 59D1           8A46         FD            mov	al,-3[bp]
20019 59D4           30E4                       xor	ah,ah
20020 59D6           50                         push	ax
20021                                           ! Debug: list int = const $17 (used reg = )
20022 59D7           B8                   0017  mov	ax,*$17
20023 59DA           50                         push	ax
20024                                           ! Debug: list int = const $40 (used reg = )
20025 59DB           B8                   0040  mov	ax,*$40
20026 59DE           50                         push	ax
20027                                           ! Debug: func () void = write_byte+0 (used reg = )
20028 59DF           E8         AC42            call	_write_byte
20029 59E2           83C4                   06  add	sp,*6
20030                                           !BCC_EOS
20031                                           ! 3279       write_byte(0x0040, 0x97, led_flags);
20032                                           ! Debug: list unsigned char led_flags = [S+8-8] (used reg = )
20033 59E5           8A46         FA            mov	al,-6[bp]
20034 59E8           30E4                       xor	ah,ah
20035 59EA           50                         push	ax
20036                                           ! Debug: list int = const $97 (used reg = )
20037 59EB           B8                   0097  mov	ax,#$97
20038 59EE           50                         push	ax
20039                                           ! Debug: list int = const $40 (used reg = )
20040 59EF           B8                   0040  mov	ax,*$40
20041 59F2           50                         push	ax
20042                                           ! Debug: func () void = write_byte+0 (used reg = )
20043 59F3           E8         AC2E            call	_write_byte
20044 59F6           83C4                   06  add	sp,*6
20045                                           !BCC_EOS
20046                                           ! 3280       break;
20047 59F9           E9         029E            br 	.445
20048                                           !BCC_EOS
20049                                           ! 3281     case 0xc6:
20050                                           ! 3282       mf2_flags &= ~0x10;
20051                       000059FC            .465:
20052                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
20053 59FC           8A46         FC            mov	al,-4[bp]
20054 59FF           24                     EF  and	al,#$EF
20055 5A01           8846         FC            mov	-4[bp],al
20056                                           !BCC_EOS
20057                                           ! 3283       write_byte(0x0040, 0x18, mf2_flags);
20058                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
20059 5A04           8A46         FC            mov	al,-4[bp]
20060 5A07           30E4                       xor	ah,ah
20061 5A09           50                         push	ax
20062                                           ! Debug: list int = const $18 (used reg = )
20063 5A0A           B8                   0018  mov	ax,*$18
20064 5A0D           50                         push	ax
20065                                           ! Debug: list int = const $40 (used reg = )
20066 5A0E           B8                   0040  mov	ax,*$40
20067 5A11           50                         push	ax
20068                                           ! Debug: func () void = write_byte+0 (used reg = )
20069 5A12           E8         AC0F            call	_write_byte
20070 5A15           83C4                   06  add	sp,*6
20071                                           !BCC_EOS
20072                                           ! 3284       break;
20073 5A18           E9         027F            br 	.445
20074                                           !BCC_EOS
20075                                           ! 3285     case 0x53:
20076                                           ! 3286         if ((shift_flags & 0x0c) == 0x0c)
20077                       00005A1B            .466:
20078                                           ! Debug: and int = const $C to unsigned char shift_flags = [S+8-5] (used reg = )
20079 5A1B           8A46         FD            mov	al,-3[bp]
20080 5A1E           24                     0C  and	al,*$C
20081                                           ! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
20082 5A20           3C                     0C  cmp	al,*$C
20083 5A22           75           03            jne 	.467
20084                       00005A24            .468:
20085                                           ! 3287             machine_reset();
20086                                           ! Debug: func () void = machine_reset+0 (used reg = )
20087 5A24           E8         B540            call	_machine_reset
20088                                           !BCC_EOS
20089                                           ! 3288     default:
20090                       00005A27            .467:
20091                                           ! 3289       if (scancode & 0x80) return;
20092                       00005A27            .469:
20093                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
20094 5A27           8A46         FF            mov	al,-1[bp]
20095 5A2A           24                     80  and	al,#$80
20096 5A2C           84C0                       test	al,al
20097 5A2E           74           04            je  	.46A
20098                       00005A30            .46B:
20099 5A30           89EC                       mov	sp,bp
20100 5A32           5D                         pop	bp
20101 5A33           C3                         ret
20102                                           !BCC_EOS
20103                                           ! 3290       if (scancode > 0x58) {
20104                       00005A34            .46A:
20105                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
20106 5A34           8A46         FF            mov	al,-1[bp]
20107 5A37           3C                     58  cmp	al,*$58
20108 5A39           76           18            jbe 	.46C
20109                       00005A3B            .46D:
20110                                           ! 3291         bios_printf(4, "KBD: int09h_handler(): unknown scancode (%x) read!\n", scancode);
20111                                           ! Debug: list unsigned char scancode = [S+8-3] (used reg = )
20112 5A3B           8A46         FF            mov	al,-1[bp]
20113 5A3E           30E4                       xor	ah,ah
20114 5A40           50                         push	ax
20115                                           ! Debug: list * char = .46E+0 (used reg = )
20116 5A41           BB                   D67C  mov	bx,#.46E
20117 5A44           53                         push	bx
20118                                           ! Debug: list int = const 4 (used reg = )
20119 5A45           B8                   0004  mov	ax,*4
20120 5A48           50                         push	ax
20121                                           ! Debug: func () void = bios_printf+0 (used reg = )
20122 5A49           E8         AE5D            call	_bios_printf
20123 5A4C           83C4                   06  add	sp,*6
20124                                           !BCC_EOS
20125                                           ! 3292         return;
20126 5A4F           89EC                       mov	sp,bp
20127 5A51           5D                         pop	bp
20128 5A52           C3                         ret
20129                                           !BCC_EOS
20130                                           ! 3293         }
20131                                           ! 3294       if (shift_flags & 0x08) {
20132                       00005A53            .46C:
20133                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
20134 5A53           8A46         FD            mov	al,-3[bp]
20135 5A56           24                     08  and	al,*8
20136 5A58           84C0                       test	al,al
20137 5A5A           74           3D            je  	.46F
20138                       00005A5C            .470:
20139                                           ! 3295         asciicode = scan_to_scanascii[scancode].alt;
20140                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20141 5A5C           8A46         FF            mov	al,-1[bp]
20142 5A5F           30E4                       xor	ah,ah
20143 5A61           89C2                       mov	dx,ax
20144 5A63           D1E0                       shl	ax,*1
20145 5A65           D1E0                       shl	ax,*1
20146 5A67           01D0                       add	ax,dx
20147 5A69           D1E0                       shl	ax,*1
20148 5A6B           89C3                       mov	bx,ax
20149 5A6D           81C3                 01CE  add	bx,#_scan_to_scanascii
20150                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
20151 5A71           8A47         06            mov	al,6[bx]
20152 5A74           8846         FE            mov	-2[bp],al
20153                                           !BCC_EOS
20154                                           ! 3296         scancode = scan_to_scanascii[scancode].alt >> 8;
20155                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20156 5A77           8A46         FF            mov	al,-1[bp]
20157 5A7A           30E4                       xor	ah,ah
20158 5A7C           89C2                       mov	dx,ax
20159 5A7E           D1E0                       shl	ax,*1
20160 5A80           D1E0                       shl	ax,*1
20161 5A82           01D0                       add	ax,dx
20162 5A84           D1E0                       shl	ax,*1
20163 5A86           89C3                       mov	bx,ax
20164 5A88           81C3                 01CE  add	bx,#_scan_to_scanascii
20165                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
20166 5A8C           8B47         06            mov	ax,6[bx]
20167 5A8F           88E0                       mov	al,ah
20168 5A91           30E4                       xor	ah,ah
20169                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20170 5A93           8846         FF            mov	-1[bp],al
20171                                           !BCC_EOS
20172                                           ! 3297         }
20173                                           ! 3298       else if (shift_flags & 0x04) {
20174 5A96           E9         0172            br 	.471
20175                       00005A99            .46F:
20176                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
20177 5A99           8A46         FD            mov	al,-3[bp]
20178 5A9C           24                     04  and	al,*4
20179 5A9E           84C0                       test	al,al
20180 5AA0           74           3D            je  	.472
20181                       00005AA2            .473:
20182                                           ! 3299         asciicode = scan_to_scanascii[scancode].control;
20183                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20184 5AA2           8A46         FF            mov	al,-1[bp]
20185 5AA5           30E4                       xor	ah,ah
20186 5AA7           89C2                       mov	dx,ax
20187 5AA9           D1E0                       shl	ax,*1
20188 5AAB           D1E0                       shl	ax,*1
20189 5AAD           01D0                       add	ax,dx
20190 5AAF           D1E0                       shl	ax,*1
20191 5AB1           89C3                       mov	bx,ax
20192 5AB3           81C3                 01CE  add	bx,#_scan_to_scanascii
20193                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
20194 5AB7           8A47         04            mov	al,4[bx]
20195 5ABA           8846         FE            mov	-2[bp],al
20196                                           !BCC_EOS
20197                                           ! 3300         scancode = scan_to_scanascii[scancode].control
20198                                           ! 3300  >> 8;
20199                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20200 5ABD           8A46         FF            mov	al,-1[bp]
20201 5AC0           30E4                       xor	ah,ah
20202 5AC2           89C2                       mov	dx,ax
20203 5AC4           D1E0                       shl	ax,*1
20204 5AC6           D1E0                       shl	ax,*1
20205 5AC8           01D0                       add	ax,dx
20206 5ACA           D1E0                       shl	ax,*1
20207 5ACC           89C3                       mov	bx,ax
20208 5ACE           81C3                 01CE  add	bx,#_scan_to_scanascii
20209                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
20210 5AD2           8B47         04            mov	ax,4[bx]
20211 5AD5           88E0                       mov	al,ah
20212 5AD7           30E4                       xor	ah,ah
20213                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20214 5AD9           8846         FF            mov	-1[bp],al
20215                                           !BCC_EOS
20216                                           ! 3301         }
20217                                           ! 3302       else if (shift_flags & 0x03) {
20218 5ADC           E9         012C            br 	.474
20219                       00005ADF            .472:
20220                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
20221 5ADF           8A46         FD            mov	al,-3[bp]
20222 5AE2           24                     03  and	al,*3
20223 5AE4           84C0                       test	al,al
20224 5AE6         0F84         0092            beq 	.475
20225                       00005AEA            .476:
20226                                           ! 3303         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
20227                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20228 5AEA           8A46         FF            mov	al,-1[bp]
20229 5AED           30E4                       xor	ah,ah
20230 5AEF           89C2                       mov	dx,ax
20231 5AF1           D1E0                       shl	ax,*1
20232 5AF3           D1E0                       shl	ax,*1
20233 5AF5           01D0                       add	ax,dx
20234 5AF7           D1E0                       shl	ax,*1
20235 5AF9           89C3                       mov	bx,ax
20236 5AFB           81C3                 01CE  add	bx,#_scan_to_scanascii
20237                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
20238 5AFF           8A46         FD            mov	al,-3[bp]
20239 5B02           2247         08            and	al,8[bx]
20240 5B05           84C0                       test	al,al
20241 5B07           74           36            je  	.477
20242                       00005B09            .478:
20243                                           ! 3304           asciicode = scan_to_scanascii[scancode].normal;
20244                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20245 5B09           8A46         FF            mov	al,-1[bp]
20246 5B0C           30E4                       xor	ah,ah
20247 5B0E           89C2                       mov	dx,ax
20248 5B10           D1E0                       shl	ax,*1
20249 5B12           D1E0                       shl	ax,*1
20250 5B14           01D0                       add	ax,dx
20251 5B16           D1E0                       shl	ax,*1
20252 5B18           89C3                       mov	bx,ax
20253                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
20254 5B1A           8A87       01CE            mov	al,_scan_to_scanascii[bx]
20255 5B1E           8846         FE            mov	-2[bp],al
20256                                           !BCC_EOS
20257                                           ! 3305           scancode = scan_to_scanascii[scancode].normal >> 8;
20258                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20259 5B21           8A46         FF            mov	al,-1[bp]
20260 5B24           30E4                       xor	ah,ah
20261 5B26           89C2                       mov	dx,ax
20262 5B28           D1E0                       shl	ax,*1
20263 5B2A           D1E0                       shl	ax,*1
20264 5B2C           01D0                       add	ax,dx
20265 5B2E           D1E0                       shl	ax,*1
20266 5B30           89C3                       mov	bx,ax
20267                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20268 5B32           8B87       01CE            mov	ax,_scan_to_scanascii[bx]
20269 5B36           88E0                       mov	al,ah
20270 5B38           30E4                       xor	ah,ah
20271                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20272 5B3A           8846         FF            mov	-1[bp],al
20273                                           !BCC_EOS
20274                                           ! 3306           }
20275                                           ! 3307         else {
20276 5B3D           EB           3A            jmp .479
20277                       00005B3F            .477:
20278                                           ! 3308           asciicode = scan_to_scanascii[scancode].shift;
20279                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20280 5B3F           8A46         FF            mov	al,-1[bp]
20281 5B42           30E4                       xor	ah,ah
20282 5B44           89C2                       mov	dx,ax
20283 5B46           D1E0                       shl	ax,*1
20284 5B48           D1E0                       shl	ax,*1
20285 5B4A           01D0                       add	ax,dx
20286 5B4C           D1E0                       shl	ax,*1
20287 5B4E           89C3                       mov	bx,ax
20288 5B50           81C3                 01CE  add	bx,#_scan_to_scanascii
20289                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
20290 5B54           8A47         02            mov	al,2[bx]
20291 5B57           8846         FE            mov	-2[bp],al
20292                                           !BCC_EOS
20293                                           ! 3309           scancode = scan_to_scanascii[scancode].shift >> 8;
20294                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20295 5B5A           8A46         FF            mov	al,-1[bp]
20296 5B5D           30E4                       xor	ah,ah
20297 5B5F           89C2                       mov	dx,ax
20298 5B61           D1E0                       shl	ax,*1
20299 5B63           D1E0                       shl	ax,*1
20300 5B65           01D0                       add	ax,dx
20301 5B67           D1E0                       shl	ax,*1
20302 5B69           89C3                       mov	bx,ax
20303 5B6B           81C3                 01CE  add	bx,#_scan_to_scanascii
20304                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
20305 5B6F           8B47         02            mov	ax,2[bx]
20306 5B72           88E0                       mov	al,ah
20307 5B74           30E4                       xor	ah,ah
20308                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20309 5B76           8846         FF            mov	-1[bp],al
20310                                           !BCC_EOS
20311                                           ! 3310           }
20312                                           ! 3311         }
20313                       00005B79            .479:
20314                                           ! 3312       else {
20315 5B79           E9         008F            br 	.47A
20316                       00005B7C            .475:
20317                                           ! 3313         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
20318                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20319 5B7C           8A46         FF            mov	al,-1[bp]
20320 5B7F           30E4                       xor	ah,ah
20321 5B81           89C2                       mov	dx,ax
20322 5B83           D1E0                       shl	ax,*1
20323 5B85           D1E0                       shl	ax,*1
20324 5B87           01D0                       add	ax,dx
20325 5B89           D1E0                       shl	ax,*1
20326 5B8B           89C3                       mov	bx,ax
20327 5B8D           81C3                 01CE  add	bx,#_scan_to_scanascii
20328                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
20329 5B91           8A46         FD            mov	al,-3[bp]
20330 5B94           2247         08            and	al,8[bx]
20331 5B97           84C0                       test	al,al
20332 5B99           74           3C            je  	.47B
20333                       00005B9B            .47C:
20334                                           ! 3314           asciicode = scan_to_scanascii[scancode].shift;
20335                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20336 5B9B           8A46         FF            mov	al,-1[bp]
20337 5B9E           30E4                       xor	ah,ah
20338 5BA0           89C2                       mov	dx,ax
20339 5BA2           D1E0                       shl	ax,*1
20340 5BA4           D1E0                       shl	ax,*1
20341 5BA6           01D0                       add	ax,dx
20342 5BA8           D1E0                       shl	ax,*1
20343 5BAA           89C3                       mov	bx,ax
20344 5BAC           81C3                 01CE  add	bx,#_scan_to_scanascii
20345                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
20346 5BB0           8A47         02            mov	al,2[bx]
20347 5BB3           8846         FE            mov	-2[bp],al
20348                                           !BCC_EOS
20349                                           ! 3315           scancode = scan_to_scanascii[scancode].shift >> 8;
20350                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20351 5BB6           8A46         FF            mov	al,-1[bp]
20352 5BB9           30E4                       xor	ah,ah
20353 5BBB           89C2                       mov	dx,ax
20354 5BBD           D1E0                       shl	ax,*1
20355 5BBF           D1E0                       shl	ax,*1
20356 5BC1           01D0                       add	ax,dx
20357 5BC3           D1E0                       shl	ax,*1
20358 5BC5           89C3                       mov	bx,ax
20359 5BC7           81C3                 01CE  add	bx,#_scan_to_scanascii
20360                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
20361 5BCB           8B47         02            mov	ax,2[bx]
20362 5BCE           88E0                       mov	al,ah
20363 5BD0           30E4                       xor	ah,ah
20364                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20365 5BD2           8846         FF            mov	-1[bp],al
20366                                           !BCC_EOS
20367                                           ! 3316           }
20368                                           ! 3317         else {
20369 5BD5           EB           34            jmp .47D
20370                       00005BD7            .47B:
20371                                           ! 3318           asciicode = scan_to_scanascii[scancode].normal;
20372                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20373 5BD7           8A46         FF            mov	al,-1[bp]
20374 5BDA           30E4                       xor	ah,ah
20375 5BDC           89C2                       mov	dx,ax
20376 5BDE           D1E0                       shl	ax,*1
20377 5BE0           D1E0                       shl	ax,*1
20378 5BE2           01D0                       add	ax,dx
20379 5BE4           D1E0                       shl	ax,*1
20380 5BE6           89C3                       mov	bx,ax
20381                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
20382 5BE8           8A87       01CE            mov	al,_scan_to_scanascii[bx]
20383 5BEC           8846         FE            mov	-2[bp],al
20384                                           !BCC_EOS
20385                                           ! 3319           scancode = scan_to_scanascii[scancode].normal >> 8;
20386                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
20387 5BEF           8A46         FF            mov	al,-1[bp]
20388 5BF2           30E4                       xor	ah,ah
20389 5BF4           89C2                       mov	dx,ax
20390 5BF6           D1E0                       shl	ax,*1
20391 5BF8           D1E0                       shl	ax,*1
20392 5BFA           01D0                       add	ax,dx
20393 5BFC           D1E0                       shl	ax,*1
20394 5BFE           89C3                       mov	bx,ax
20395                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
20396 5C00           8B87       01CE            mov	ax,_scan_to_scanascii[bx]
20397 5C04           88E0                       mov	al,ah
20398 5C06           30E4                       xor	ah,ah
20399                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
20400 5C08           8846         FF            mov	-1[bp],al
20401                                           !BCC_EOS
20402                                           ! 3320           }
20403                                           ! 3321         }
20404                       00005C0B            .47D:
20405                                           ! 3322       if (scancode==0 && asciicode==0) {
20406                       00005C0B            .47A:
20407                       00005C0B            .474:
20408                       00005C0B            .471:
20409                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
20410 5C0B           8A46         FF            mov	al,-1[bp]
20411 5C0E           84C0                       test	al,al
20412 5C10           75           15            jne 	.47E
20413                       00005C12            .480:
20414                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
20415 5C12           8A46         FE            mov	al,-2[bp]
20416 5C15           84C0                       test	al,al
20417 5C17           75           0E            jne 	.47E
20418                       00005C19            .47F:
20419                                           ! 3323         bios_printf(4, "KBD: int09h_handler(): scancode & asciicode are zero?\n");
20420                                           ! Debug: list * char = .481+0 (used reg = )
20421 5C19           BB                   D645  mov	bx,#.481
20422 5C1C           53                         push	bx
20423                                           ! Debug: list int = const 4 (used reg = )
20424 5C1D           B8                   0004  mov	ax,*4
20425 5C20           50                         push	ax
20426                                           ! Debug: func () void = bios_printf+0 (used reg = )
20427 5C21           E8         AC85            call	_bios_printf
20428 5C24           83C4                   04  add	sp,*4
20429                                           !BCC_EOS
20430                                           ! 3324         }
20431                                           ! 3325       enqueue_key(scancode, asciicode);
20432                       00005C27            .47E:
20433                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
20434 5C27           8A46         FE            mov	al,-2[bp]
20435 5C2A           30E4                       xor	ah,ah
20436 5C2C           50                         push	ax
20437                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
20438 5C2D           8A46         FF            mov	al,-1[bp]
20439 5C30           30E4                       xor	ah,ah
20440 5C32           50                         push	ax
20441                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
20442 5C33           E8         0070            call	_enqueue_key
20443 5C36           83C4                   04  add	sp,*4
20444                                           !BCC_EOS
20445                                           ! 3326       break;
20446 5C39           EB           5F            jmp .445
20447                                           !BCC_EOS
20448                                           ! 3327     }
20449                                           ! 3328   mf2_state &= ~0x01;
20450 5C3B           EB           5D            jmp .445
20451                       00005C3D            .447:
20452 5C3D           2C                     1D  sub	al,*$1D
20453 5C3F         0F84         FBA2            beq 	.44E
20454 5C43           2C                     0D  sub	al,*$D
20455 5C45         0F84         FAE8            beq 	.44A
20456 5C49           2C                     0C  sub	al,*$C
20457 5C4B         0F84         FB3C            beq 	.44C
20458 5C4F           2C                     02  sub	al,*2
20459 5C51         0F84         FC2C            beq 	.456
20460 5C55           2C                     02  sub	al,*2
20461 5C57         0F84         FA60            beq 	.448
20462 5C5B           2C                     0B  sub	al,*$B
20463 5C5D         0F84         FCBC            beq 	.45E
20464 5C61           2C                     01  sub	al,*1
20465 5C63         0F84         FD3E            beq 	.464
20466 5C67           2C                     0D  sub	al,*$D
20467 5C69         0F84         FDAE            beq 	.466
20468 5C6D           2C                     4A  sub	al,*$4A
20469 5C6F         0F84         FBC0            beq 	.452
20470 5C73           2C                     0D  sub	al,*$D
20471 5C75         0F84         FAF3            beq 	.44B
20472 5C79           2C                     0C  sub	al,*$C
20473 5C7B         0F84         FB47            beq 	.44D
20474 5C7F           2C                     02  sub	al,*2
20475 5C81         0F84         FC4A            beq 	.45A
20476 5C85           2C                     02  sub	al,*2
20477 5C87         0F84         FA87            beq 	.449
20478 5C8B           2C                     0B  sub	al,*$B
20479 5C8D         0F84         FCEC            beq 	.461
20480 5C91           2C                     01  sub	al,*1
20481 5C93         0F84         FD65            beq 	.465
20482 5C97           E9         FD8D            br 	.469
20483                       00005C9A            .445:
20484                       FFFFFFF8            ..FFF1	=	-8
20485                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
20486 5C9A           8A46         FB            mov	al,-5[bp]
20487 5C9D           24                     FE  and	al,#$FE
20488 5C9F           8846         FB            mov	-5[bp],al
20489                                           !BCC_EOS
20490                                           ! 3329 }
20491 5CA2           89EC                       mov	sp,bp
20492 5CA4           5D                         pop	bp
20493 5CA5           C3                         ret
20494                                           ! 3330   unsigned int
20495                                           ! Register BX used in function int09_function
20496                                           ! 3331 enqueue_key(scan_code, ascii_code)
20497                                           ! 3332   Bit8u scan_code, ascii_code;
20498                                           export	_enqueue_key
20499                       00005CA6            _enqueue_key:
20500                                           !BCC_EOS
20501                                           ! 3333 {
20502                                           ! 3334   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
20503                                           !BCC_EOS
20504                                           ! 3335   buffer_start = read_word(0x0040, 0x0080);
20505 5CA6           55                         push	bp
20506 5CA7           89E5                       mov	bp,sp
20507 5CA9           83C4                   F6  add	sp,*-$A
20508                                           ! Debug: list int = const $80 (used reg = )
20509 5CAC           B8                   0080  mov	ax,#$80
20510 5CAF           50                         push	ax
20511                                           ! Debug: list int = const $40 (used reg = )
20512 5CB0           B8                   0040  mov	ax,*$40
20513 5CB3           50                         push	ax
20514                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20515 5CB4           E8         A95A            call	_read_word
20516 5CB7           83C4                   04  add	sp,*4
20517                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
20518 5CBA           8946         FE            mov	-2[bp],ax
20519                                           !BCC_EOS
20520                                           ! 3336   buffer_end = read_word(0x0040, 0x0082);
20521                                           ! Debug: list int = const $82 (used reg = )
20522 5CBD           B8                   0082  mov	ax,#$82
20523 5CC0           50                         push	ax
20524                                           ! Debug: list int = const $40 (used reg = )
20525 5CC1           B8                   0040  mov	ax,*$40
20526 5CC4           50                         push	ax
20527                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20528 5CC5           E8         A949            call	_read_word
20529 5CC8           83C4                   04  add	sp,*4
20530                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
20531 5CCB           8946         FC            mov	-4[bp],ax
20532                                           !BCC_EOS
20533                                           ! 3337   buffer_head = read_word(0x0040, 0x001A);
20534                                           ! Debug: list int = const $1A (used reg = )
20535 5CCE           B8                   001A  mov	ax,*$1A
20536 5CD1           50                         push	ax
20537                                           ! Debug: list int = const $40 (used reg = )
20538 5CD2           B8                   0040  mov	ax,*$40
20539 5CD5           50                         push	ax
20540                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20541 5CD6           E8         A938            call	_read_word
20542 5CD9           83C4                   04  add	sp,*4
20543                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
20544 5CDC           8946         FA            mov	-6[bp],ax
20545                                           !BCC_EOS
20546                                           ! 3338   buffer_tail = read_word(0x0040, 0x001C);
20547                                           ! Debug: list int = const $1C (used reg = )
20548 5CDF           B8                   001C  mov	ax,*$1C
20549 5CE2           50                         push	ax
20550                                           ! Debug: list int = const $40 (used reg = )
20551 5CE3           B8                   0040  mov	ax,*$40
20552 5CE6           50                         push	ax
20553                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20554 5CE7           E8         A927            call	_read_word
20555 5CEA           83C4                   04  add	sp,*4
20556                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
20557 5CED           8946         F8            mov	-8[bp],ax
20558                                           !BCC_EOS
20559                                           ! 3339   temp_tail = buffer_tail;
20560                                           ! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
20561 5CF0           8B46         F8            mov	ax,-8[bp]
20562 5CF3           8946         F6            mov	-$A[bp],ax
20563                                           !BCC_EOS
20564                                           ! 3340   buffer_tail += 2;
20565                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
20566 5CF6           8B46         F8            mov	ax,-8[bp]
20567 5CF9           40                         inc	ax
20568 5CFA           40                         inc	ax
20569 5CFB           8946         F8            mov	-8[bp],ax
20570                                           !BCC_EOS
20571                                           ! 3341   if (buffer_tail >= buffer_end)
20572                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
20573 5CFE           8B46         F8            mov	ax,-8[bp]
20574 5D01           3B46         FC            cmp	ax,-4[bp]
20575 5D04           72           06            jb  	.482
20576                       00005D06            .483:
20577                                           ! 3342     buffer_tail = buffer_start;
20578                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
20579 5D06           8B46         FE            mov	ax,-2[bp]
20580 5D09           8946         F8            mov	-8[bp],ax
20581                                           !BCC_EOS
20582                                           ! 3343   if (buffer_tail == buffer_head) {
20583                       00005D0C            .482:
20584                                           ! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
20585 5D0C           8B46         F8            mov	ax,-8[bp]
20586 5D0F           3B46         FA            cmp	ax,-6[bp]
20587 5D12           75           06            jne 	.484
20588                       00005D14            .485:
20589                                           ! 3344     return(0);
20590 5D14           31C0                       xor	ax,ax
20591 5D16           89EC                       mov	sp,bp
20592 5D18           5D                         pop	bp
20593 5D19           C3                         ret
20594                                           !BCC_EOS
20595                                           ! 3345     }
20596                                           ! 3346    write_byte(0x0040, temp_tail, ascii_code);
20597                       00005D1A            .484:
20598                                           ! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
20599 5D1A           8A46         06            mov	al,6[bp]
20600 5D1D           30E4                       xor	ah,ah
20601 5D1F           50                         push	ax
20602                                           ! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
20603 5D20           FF76         F6            push	-$A[bp]
20604                                           ! Debug: list int = const $40 (used reg = )
20605 5D23           B8                   0040  mov	ax,*$40
20606 5D26           50                         push	ax
20607                                           ! Debug: func () void = write_byte+0 (used reg = )
20608 5D27           E8         A8FA            call	_write_byte
20609 5D2A           83C4                   06  add	sp,*6
20610                                           !BCC_EOS
20611                                           ! 3347    write_byte(0x0040, temp_tail+1, scan_code);
20612                                           ! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
20613 5D2D           8A46         04            mov	al,4[bp]
20614 5D30           30E4                       xor	ah,ah
20615 5D32           50                         push	ax
20616                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
20617 5D33           8B46         F6            mov	ax,-$A[bp]
20618                                           ! Debug: list unsigned int = ax+1 (used reg = )
20619 5D36           40                         inc	ax
20620 5D37           50                         push	ax
20621                                           ! Debug: list int = const $40 (used reg = )
20622 5D38           B8                   0040  mov	ax,*$40
20623 5D3B           50                         push	ax
20624                                           ! Debug: func () void = write_byte+0 (used reg = )
20625 5D3C           E8         A8E5            call	_write_byte
20626 5D3F           83C4                   06  add	sp,*6
20627                                           !BCC_EOS
20628                                           ! 3348    write_word(0x0040, 0x001C, buffer_tail);
20629                                           ! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
20630 5D42           FF76         F8            push	-8[bp]
20631                                           ! Debug: list int = const $1C (used reg = )
20632 5D45           B8                   001C  mov	ax,*$1C
20633 5D48           50                         push	ax
20634                                           ! Debug: list int = const $40 (used reg = )
20635 5D49           B8                   0040  mov	ax,*$40
20636 5D4C           50                         push	ax
20637                                           ! Debug: func () void = write_word+0 (used reg = )
20638 5D4D           E8         A8EC            call	_write_word
20639 5D50           83C4                   06  add	sp,*6
20640                                           !BCC_EOS
20641                                           ! 3349    return(1);
20642 5D53           B8                   0001  mov	ax,*1
20643 5D56           89EC                       mov	sp,bp
20644 5D58           5D                         pop	bp
20645 5D59           C3                         ret
20646                                           !BCC_EOS
20647                                           ! 3350 }
20648                                           ! 3351   void
20649                                           ! 3352 int74_function(make_farcall, Z, Y, X, status)
20650                                           ! 3353   Bit16u make_farcall, Z, Y, X, status;
20651                                           export	_int74_function
20652                       00005D5A            _int74_function:
20653                                           !BCC_EOS
20654                                           ! 3354 {
20655                                           ! 3355   Bit16u ebda_seg=read_word(0x0040,0x000E);
20656 5D5A           55                         push	bp
20657 5D5B           89E5                       mov	bp,sp
20658 5D5D           4C                         dec	sp
20659 5D5E           4C                         dec	sp
20660                                           ! Debug: list int = const $E (used reg = )
20661 5D5F           B8                   000E  mov	ax,*$E
20662 5D62           50                         push	ax
20663                                           ! Debug: list int = const $40 (used reg = )
20664 5D63           B8                   0040  mov	ax,*$40
20665 5D66           50                         push	ax
20666                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20667 5D67           E8         A8A7            call	_read_word
20668 5D6A           83C4                   04  add	sp,*4
20669                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
20670 5D6D           8946         FE            mov	-2[bp],ax
20671                                           !BCC_EOS
20672                                           ! 3356   Bit8u in_byte, index, package_count;
20673                                           !BCC_EOS
20674                                           ! 3357   Bit8u mouse_flags_1, mouse_flags_2;
20675                                           !BCC_EOS
20676                                           ! 3358 ;
20677 5D70           83C4                   FA  add	sp,*-6
20678                                           !BCC_EOS
20679                                           ! 3359   make_farcall = 0;
20680                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
20681 5D73           31C0                       xor	ax,ax
20682 5D75           8946         04            mov	4[bp],ax
20683                                           !BCC_EOS
20684                                           ! 3360   in_byte = inb(0x64);
20685                                           ! Debug: list int = const $64 (used reg = )
20686 5D78           B8                   0064  mov	ax,*$64
20687 5D7B           50                         push	ax
20688                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20689 5D7C           E8         A7C9            call	_inb
20690 5D7F           44                         inc	sp
20691 5D80           44                         inc	sp
20692                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
20693 5D81           8846         FD            mov	-3[bp],al
20694                                           !BCC_EOS
20695                                           ! 3361   if ( (in_byte & 0x21) != 0x21 ) {
20696                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
20697 5D84           8A46         FD            mov	al,-3[bp]
20698 5D87           24                     21  and	al,*$21
20699                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
20700 5D89           3C                     21  cmp	al,*$21
20701 5D8B           74           04            je  	.486
20702                       00005D8D            .487:
20703                                           ! 3362     return;
20704 5D8D           89EC                       mov	sp,bp
20705 5D8F           5D                         pop	bp
20706 5D90           C3                         ret
20707                                           !BCC_EOS
20708                                           ! 3363     }
20709                                           ! 3364   in_byte = inb(0x60);
20710                       00005D91            .486:
20711                                           ! Debug: list int = const $60 (used reg = )
20712 5D91           B8                   0060  mov	ax,*$60
20713 5D94           50                         push	ax
20714                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20715 5D95           E8         A7B0            call	_inb
20716 5D98           44                         inc	sp
20717 5D99           44                         inc	sp
20718                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
20719 5D9A           8846         FD            mov	-3[bp],al
20720                                           !BCC_EOS
20721                                           ! 3365 ;
20722                                           !BCC_EOS
20723                                           ! 3366   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
20724                                           ! Debug: list int = const $26 (used reg = )
20725 5D9D           B8                   0026  mov	ax,*$26
20726 5DA0           50                         push	ax
20727                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
20728 5DA1           FF76         FE            push	-2[bp]
20729                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20730 5DA4           E8         A857            call	_read_byte
20731 5DA7           83C4                   04  add	sp,*4
20732                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
20733 5DAA           8846         FA            mov	-6[bp],al
20734                                           !BCC_EOS
20735                                           ! 3367   mouse_flags_2 = 
20736                                           ! 3367 read_byte(ebda_seg, 0x0027);
20737                                           ! Debug: list int = const $27 (used reg = )
20738 5DAD           B8                   0027  mov	ax,*$27
20739 5DB0           50                         push	ax
20740                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
20741 5DB1           FF76         FE            push	-2[bp]
20742                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20743 5DB4           E8         A847            call	_read_byte
20744 5DB7           83C4                   04  add	sp,*4
20745                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
20746 5DBA           8846         F9            mov	-7[bp],al
20747                                           !BCC_EOS
20748                                           ! 3368   if ( (mouse_flags_2 & 0x80) != 0x80 ) {
20749                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
20750 5DBD           8A46         F9            mov	al,-7[bp]
20751 5DC0           24                     80  and	al,#$80
20752                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
20753 5DC2           3C                     80  cmp	al,#$80
20754 5DC4           74           04            je  	.488
20755                       00005DC6            .489:
20756                                           ! 3369       return;
20757 5DC6           89EC                       mov	sp,bp
20758 5DC8           5D                         pop	bp
20759 5DC9           C3                         ret
20760                                           !BCC_EOS
20761                                           ! 3370     }
20762                                           ! 3371   package_count = mouse_flags_2 & 0x07;
20763                       00005DCA            .488:
20764                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
20765 5DCA           8A46         F9            mov	al,-7[bp]
20766 5DCD           24                     07  and	al,*7
20767                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
20768 5DCF           8846         FB            mov	-5[bp],al
20769                                           !BCC_EOS
20770                                           ! 3372   index = mouse_flags_1 & 0x07;
20771                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
20772 5DD2           8A46         FA            mov	al,-6[bp]
20773 5DD5           24                     07  and	al,*7
20774                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
20775 5DD7           8846         FC            mov	-4[bp],al
20776                                           !BCC_EOS
20777                                           ! 3373   write_byte(ebda_seg, 0x28 + index, in_byte);
20778                                           ! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
20779 5DDA           8A46         FD            mov	al,-3[bp]
20780 5DDD           30E4                       xor	ah,ah
20781 5DDF           50                         push	ax
20782                                           ! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
20783                                           ! Debug: expression subtree swapping
20784 5DE0           8A46         FC            mov	al,-4[bp]
20785 5DE3           30E4                       xor	ah,ah
20786                                           ! Debug: list unsigned int = ax+$28 (used reg = )
20787 5DE5           05                   0028  add	ax,*$28
20788 5DE8           50                         push	ax
20789                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
20790 5DE9           FF76         FE            push	-2[bp]
20791                                           ! Debug: func () void = write_byte+0 (used reg = )
20792 5DEC           E8         A835            call	_write_byte
20793 5DEF           83C4                   06  add	sp,*6
20794                                           !BCC_EOS
20795                                           ! 3374   if ( (index+1) >= package_count ) {
20796                                           ! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
20797 5DF2           8A46         FC            mov	al,-4[bp]
20798 5DF5           30E4                       xor	ah,ah
20799                                           ! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
20800 5DF7           40                         inc	ax
20801 5DF8           50                         push	ax
20802 5DF9           8A46         FB            mov	al,-5[bp]
20803 5DFC           30E4                       xor	ah,ah
20804 5DFE           3B46         F6            cmp	ax,-$A[bp]
20805 5E01           8D66         F8            lea	sp,-8[bp]
20806 5E04           77           51            ja  	.48A
20807                       00005E06            .48B:
20808                                           ! 3375 ;
20809                                           !BCC_EOS
20810                                           ! 3376     status = read_byte(ebda_seg, 0x0028 + 0);
20811                                           ! Debug: list int = const $28 (used reg = )
20812 5E06           B8                   0028  mov	ax,*$28
20813 5E09           50                         push	ax
20814                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
20815 5E0A           FF76         FE            push	-2[bp]
20816                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20817 5E0D           E8         A7EE            call	_read_byte
20818 5E10           83C4                   04  add	sp,*4
20819                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
20820 5E13           30E4                       xor	ah,ah
20821 5E15           8946         0C            mov	$C[bp],ax
20822                                           !BCC_EOS
20823                                           ! 3377     X = read_byte(ebda_seg, 0x0028 + 1);
20824                                           ! Debug: list int = const $29 (used reg = )
20825 5E18           B8                   0029  mov	ax,*$29
20826 5E1B           50                         push	ax
20827                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
20828 5E1C           FF76         FE            push	-2[bp]
20829                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20830 5E1F           E8         A7DC            call	_read_byte
20831 5E22           83C4                   04  add	sp,*4
20832                                           ! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
20833 5E25           30E4                       xor	ah,ah
20834 5E27           8946         0A            mov	$A[bp],ax
20835                                           !BCC_EOS
20836                                           ! 3378     Y = read_byte(ebda_seg, 0x0028 + 2);
20837                                           ! Debug: list int = const $2A (used reg = )
20838 5E2A           B8                   002A  mov	ax,*$2A
20839 5E2D           50                         push	ax
20840                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
20841 5E2E           FF76         FE            push	-2[bp]
20842                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20843 5E31           E8         A7CA            call	_read_byte
20844 5E34           83C4                   04  add	sp,*4
20845                                           ! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
20846 5E37           30E4                       xor	ah,ah
20847 5E39           8946         08            mov	8[bp],ax
20848                                           !BCC_EOS
20849                                           ! 3379     Z = 0;
20850                                           ! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
20851 5E3C           31C0                       xor	ax,ax
20852 5E3E           8946         06            mov	6[bp],ax
20853                                           !BCC_EOS
20854                                           ! 3380     mouse_flags_1 = 0;
20855                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
20856 5E41           30C0                       xor	al,al
20857 5E43           8846         FA            mov	-6[bp],al
20858                                           !BCC_EOS
20859                                           ! 3381     if (mouse_flags_2 & 0x80)
20860                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
20861 5E46           8A46         F9            mov	al,-7[bp]
20862 5E49           24                     80  and	al,#$80
20863 5E4B           84C0                       test	al,al
20864 5E4D           74           06            je  	.48C
20865                       00005E4F            .48D:
20866                                           ! 3382       make_farcall = 1;
20867                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
20868 5E4F           B8                   0001  mov	ax,*1
20869 5E52           8946         04            mov	4[bp],ax
20870                                           !BCC_EOS
20871                                           ! 3383     }
20872                       00005E55            .48C:
20873                                           ! 3384   else {
20874 5E55           EB           07            jmp .48E
20875                       00005E57            .48A:
20876                                           ! 3385     mouse_flags_1++;
20877                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
20878 5E57           8A46         FA            mov	al,-6[bp]
20879 5E5A           40                         inc	ax
20880 5E5B           8846         FA            mov	-6[bp],al
20881                                           !BCC_EOS
20882                                           ! 3386     }
20883                                           ! 3387   write_byte(ebda_seg, 0x0026, mouse_flags_1);
20884                       00005E5E            .48E:
20885                                           ! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
20886 5E5E           8A46         FA            mov	al,-6[bp]
20887 5E61           30E4                       xor	ah,ah
20888 5E63           50                         push	ax
20889                                           ! Debug: list int = const $26 (used reg = )
20890 5E64           B8                   0026  mov	ax,*$26
20891 5E67           50                         push	ax
20892                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
20893 5E68           FF76         FE            push	-2[bp]
20894                                           ! Debug: func () void = write_byte+0 (used reg = )
20895 5E6B           E8         A7B6            call	_write_byte
20896 5E6E           83C4                   06  add	sp,*6
20897                                           !BCC_EOS
20898                                           ! 3388 }
20899 5E71           89EC                       mov	sp,bp
20900 5E73           5D                         pop	bp
20901 5E74           C3                         ret
20902                                           ! 3389   void
20903                                           ! 3390 int13_harddisk(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
20904                                           ! 3391   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
20905                                           export	_int13_harddisk
20906                       00005E75            _int13_harddisk:
20907                                           !BCC_EOS
20908                                           ! 3392 {
20909                                           ! 3393   Bit32u lba;
20910                                           !BCC_EOS
20911                                           ! 3394   Bit16u ebda_seg=read_word(0x0040,0x000E);
20912 5E75           55                         push	bp
20913 5E76           89E5                       mov	bp,sp
20914 5E78           83C4                   FA  add	sp,*-6
20915                                           ! Debug: list int = const $E (used reg = )
20916 5E7B           B8                   000E  mov	ax,*$E
20917 5E7E           50                         push	ax
20918                                           ! Debug: list int = const $40 (used reg = )
20919 5E7F           B8                   0040  mov	ax,*$40
20920 5E82           50                         push	ax
20921                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20922 5E83           E8         A78B            call	_read_word
20923 5E86           83C4                   04  add	sp,*4
20924                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+8-8] (used reg = )
20925 5E89           8946         FA            mov	-6[bp],ax
20926                                           !BCC_EOS
20927                                           ! 3395   Bit16u cylinder, head, sector;
20928                                           !BCC_EOS
20929                                           ! 3396   Bit16u segment, offset;
20930                                           !BCC_EOS
20931                                           ! 3397   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
20932                                           !BCC_EOS
20933                                           ! 3398   Bit16u size, count;
20934                                           !BCC_EOS
20935                                           ! 3399   Bit8u device, status;
20936                                           !BCC_EOS
20937                                           ! 3400   ;
20938 5E8C           83C4                   E4  add	sp,*-$1C
20939                                           !BCC_EOS
20940                                           ! 3401   write_byte(0x0040, 0x008e, 0);
20941                                           ! Debug: list int = const 0 (used reg = )
20942 5E8F           31C0                       xor	ax,ax
20943 5E91           50                         push	ax
20944                                           ! Debug: list int = const $8E (used reg = )
20945 5E92           B8                   008E  mov	ax,#$8E
20946 5E95           50                         push	ax
20947                                           ! Debug: list int = const $40 (used reg = )
20948 5E96           B8                   0040  mov	ax,*$40
20949 5E99           50                         push	ax
20950                                           ! Debug: func () void = write_byte+0 (used reg = )
20951 5E9A           E8         A787            call	_write_byte
20952 5E9D           83C4                   06  add	sp,*6
20953                                           !BCC_EOS
20954                                           ! 3402   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff ) >= 0x80 + (4*2)) ) {
20955                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
20956 5EA0           8A46         0E            mov	al,$E[bp]
20957                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
20958 5EA3           3C                     80  cmp	al,#$80
20959 5EA5           72           07            jb  	.490
20960                       00005EA7            .491:
20961                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
20962 5EA7           8A46         0E            mov	al,$E[bp]
20963                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
20964 5EAA           3C                     88  cmp	al,#$88
20965 5EAC           72           22            jb  	.48F
20966                       00005EAE            .490:
20967                                           ! 3403     bios_printf(4, "int13_harddisk: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
20968                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
20969 5EAE           8A46         0E            mov	al,$E[bp]
20970                                           ! Debug: list unsigned char = al+0 (used reg = )
20971 5EB1           30E4                       xor	ah,ah
20972 5EB3           50                         push	ax
20973                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$26+$14] (used reg = )
20974 5EB4           8B46         16            mov	ax,$16[bp]
20975 5EB7           88E0                       mov	al,ah
20976 5EB9           30E4                       xor	ah,ah
20977                                           ! Debug: list unsigned int = ax+0 (used reg = )
20978 5EBB           50                         push	ax
20979                                           ! Debug: list * char = .492+0 (used reg = )
20980 5EBC           BB                   D60E  mov	bx,#.492
20981 5EBF           53                         push	bx
20982                                           ! Debug: list int = const 4 (used reg = )
20983 5EC0           B8                   0004  mov	ax,*4
20984 5EC3           50                         push	ax
20985                                           ! Debug: func () void = bios_printf+0 (used reg = )
20986 5EC4           E8         A9E2            call	_bios_printf
20987 5EC7           83C4                   08  add	sp,*8
20988                                           !BCC_EOS
20989                                           ! 3404     goto int13_fail;
20990 5ECA           83C4                   00  add	sp,#..FFF0+$24
20991 5ECD           E9         0E12            br 	.FFF0
20992                                           !BCC_EOS
20993                                           ! 3405     }
20994                                           ! 3406   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
20995                       00005ED0            .48F:
20996                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
20997 5ED0           8A46         0E            mov	al,$E[bp]
20998                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
20999 5ED3           30E4                       xor	ah,ah
21000                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $213 (used reg = )
21001 5ED5           05                   FF80  add	ax,*-$80
21002 5ED8           89C3                       mov	bx,ax
21003                                           ! Debug: address unsigned char = [bx+$213] (used reg = )
21004                                           ! Debug: list * unsigned char = bx+$213 (used reg = )
21005 5EDA           81C3                 0213  add	bx,#$213
21006 5EDE           53                         push	bx
21007                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21008 5EDF           FF76         FA            push	-6[bp]
21009                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21010 5EE2           E8         A719            call	_read_byte
21011 5EE5           83C4                   04  add	sp,*4
21012                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$24-$23] (used reg = )
21013 5EE8           8846         DF            mov	-$21[bp],al
21014                                           !BCC_EOS
21015                                           ! 3407   if (device >= (4*2)) {
21016                                           ! Debug: ge int = const 8 to unsigned char device = [S+$24-$23] (used reg = )
21017 5EEB           8A46         DF            mov	al,-$21[bp]
21018 5EEE           3C                     08  cmp	al,*8
21019 5EF0           72           22            jb  	.493
21020                       00005EF2            .494:
21021                                           ! 3408     bios_printf(4, "int13_harddisk: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
21022                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$24+$C] (used reg = )
21023 5EF2           8A46         0E            mov	al,$E[bp]
21024                                           ! Debug: list unsigned char = al+0 (used reg = )
21025 5EF5           30E4                       xor	ah,ah
21026 5EF7           50                         push	ax
21027                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$26+$14] (used reg = )
21028 5EF8           8B46         16            mov	ax,$16[bp]
21029 5EFB           88E0                       mov	al,ah
21030 5EFD           30E4                       xor	ah,ah
21031                                           ! Debug: list unsigned int = ax+0 (used reg = )
21032 5EFF           50                         push	ax
21033                                           ! Debug: list * char = .495+0 (used reg = )
21034 5F00           BB                   D5D0  mov	bx,#.495
21035 5F03           53                         push	bx
21036                                           ! Debug: list int = const 4 (used reg = )
21037 5F04           B8                   0004  mov	ax,*4
21038 5F07           50                         push	ax
21039                                           ! Debug: func () void = bios_printf+0 (used reg = )
21040 5F08           E8         A99E            call	_bios_printf
21041 5F0B           83C4                   08  add	sp,*8
21042                                           !BCC_EOS
21043                                           ! 3409     goto int13_fail;
21044 5F0E           83C4                   00  add	sp,#..FFF0+$24
21045 5F11           E9         0DCE            br 	.FFF0
21046                                           !BCC_EOS
21047                                           ! 3410     }
21048                                           ! 3411   switch (( AX >> 8 )) {
21049                       00005F14            .493:
21050                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
21051 5F14           8B46         16            mov	ax,$16[bp]
21052 5F17           88E0                       mov	al,ah
21053 5F19           30E4                       xor	ah,ah
21054 5F1B           E9         0D43            br 	.498
21055                                           ! 3412     case 0x00:
21056                                           ! 3413       ata_reset (device);
21057                       00005F1E            .499:
21058                                           ! Debug: list unsigned char device = [S+$24-$23] (used reg = )
21059 5F1E           8A46         DF            mov	al,-$21[bp]
21060 5F21           30E4                       xor	ah,ah
21061 5F23           50                         push	ax
21062                                           ! Debug: func () void = ata_reset+0 (used reg = )
21063 5F24           E8         C8C7            call	_ata_reset
21064 5F27           44                         inc	sp
21065 5F28           44                         inc	sp
21066                                           !BCC_EOS
21067                                           ! 3414       goto int13_success;
21068 5F29           83C4                   0E  add	sp,#..FFEE-..FFEF
21069 5F2C           E9         0DE0            br 	.FFEE
21070                                           !BCC_EOS
21071                                           ! 3415       break;
21072 5F2F           E9         0DAD            br 	.496
21073                                           !BCC_EOS
21074                                           ! 3416     case 0x01:
21075                                           ! 3417       status = read_byte(0x0040, 0x0074);
21076                       00005F32            .49A:
21077                                           ! Debug: list int = const $74 (used reg = )
21078 5F32           B8                   0074  mov	ax,*$74
21079 5F35           50                         push	ax
21080                                           ! Debug: list int = const $40 (used reg = )
21081 5F36           B8                   0040  mov	ax,*$40
21082 5F39           50                         push	ax
21083                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21084 5F3A           E8         A6C1            call	_read_byte
21085 5F3D           83C4                   04  add	sp,*4
21086                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$24-$24] (used reg = )
21087 5F40           8846         DE            mov	-$22[bp],al
21088                                           !BCC_EOS
21089                                           ! 3418       AX = ((AX & 0x00ff) | ((status) << 8));
21090                                           ! Debug: sl int = const 8 to unsigned char status = [S+$24-$24] (used reg = )
21091 5F43           8A46         DE            mov	al,-$22[bp]
21092 5F46           30E4                       xor	ah,ah
21093 5F48           88C4                       mov	ah,al
21094 5F4A           30C0                       xor	al,al
21095 5F4C           50                         push	ax
21096                                           ! Debug: and int = const $FF to unsigned short AX = [S+$26+$14] (used reg = )
21097 5F4D           8A46         16            mov	al,$16[bp]
21098                                           ! Debug: or unsigned int (temp) = [S+$26-$26] to unsigned char = al+0 (used reg = )
21099 5F50           30E4                       xor	ah,ah
21100 5F52           0B46         CE            or	ax,0+..FFEF[bp]
21101 5F55           44                         inc	sp
21102 5F56           44                         inc	sp
21103                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$24+$14] (used reg = )
21104 5F57           8946         16            mov	$16[bp],ax
21105                                           !BCC_EOS
21106                                           ! 3419       write_byte(0x0040, 0x0074, 0);
21107                                           ! Debug: list int = const 0 (used reg = )
21108 5F5A           31C0                       xor	ax,ax
21109 5F5C           50                         push	ax
21110                                           ! Debug: list int = const $74 (used reg = )
21111 5F5D           B8                   0074  mov	ax,*$74
21112 5F60           50                         push	ax
21113                                           ! Debug: list int = const $40 (used reg = )
21114 5F61           B8                   0040  mov	ax,*$40
21115 5F64           50                         push	ax
21116                                           ! Debug: func () void = write_byte+0 (used reg = )
21117 5F65           E8         A6BC            call	_write_byte
21118 5F68           83C4                   06  add	sp,*6
21119                                           !BCC_EOS
21120                                           ! 3420       if (status) goto int13_fail_nostatus;
21121 5F6B           8A46         DE            mov	al,-$22[bp]
21122 5F6E           84C0                       test	al,al
21123 5F70           74           08            je  	.49B
21124                       00005F72            .49C:
21125 5F72           83C4                   0E  add	sp,#..FFED-..FFEF
21126 5F75           E9         0D8B            br 	.FFED
21127                                           !BCC_EOS
21128                                           ! 3421       else goto int13_success_noah;
21129 5F78           EB           06            jmp .49D
21130                       00005F7A            .49B:
21131 5F7A           83C4                   0E  add	sp,#..FFEC-..FFEF
21132 5F7D           E9         0D99            br 	.FFEC
21133                                           !BCC_EOS
21134                                           ! 3422       break;
21135                       00005F80            .49D:
21136 5F80           E9         0D5C            br 	.496
21137                                           !BCC_EOS
21138                                           ! 3423     case 0x02:
21139                                           ! 3424     case 0x03:
21140                       00005F83            .49E:
21141                                           ! 3425     case 0x04:
21142                       00005F83            .49F:
21143                                           ! 3426       count = ( AX & 0x00ff );
21144                       00005F83            .4A0:
21145                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
21146 5F83           8A46         16            mov	al,$16[bp]
21147                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$24-$22] (used reg = )
21148 5F86           30E4                       xor	ah,ah
21149 5F88           8946         E0            mov	-$20[bp],ax
21150                                           !BCC_EOS
21151                                           ! 3427       cylinder = ( CX >> 8 );
21152                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$24+$12] (used reg = )
21153 5F8B           8B46         14            mov	ax,$14[bp]
21154 5F8E           88E0                       mov	al,ah
21155 5F90           30E4                       xor	ah,ah
21156                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$24-$A] (used reg = )
21157 5F92           8946         F8            mov	-8[bp],ax
21158                                           !BCC_EOS
21159                                           ! 3428       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
21160                                           ! Debug: and int = const $FF to unsigned short CX = [S+$24+$12] (used reg = )
21161 5F95           8A46         14            mov	al,$14[bp]
21162                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
21163 5F98           30E4                       xor	ah,ah
21164                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
21165 5F9A           D1E0                       shl	ax,*1
21166 5F9C           D1E0                       shl	ax,*1
21167                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
21168 5F9E           25                   0300  and	ax,#$300
21169                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$24-$A] (used reg = )
21170 5FA1           0B46         F8            or	ax,-8[bp]
21171 5FA4           8946         F8            mov	-8[bp],ax
21172                                           !BCC_EOS
21173                                           ! 3429       sector = (( CX & 0x00ff ) & 0x3f);
21174                                           ! Debug: and int = const $FF to unsigned short CX = [S+$24+$12] (used reg = )
21175 5FA7           8A46         14            mov	al,$14[bp]
21176                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
21177 5FAA           24                     3F  and	al,*$3F
21178                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$24-$E] (used reg = )
21179 5FAC           30E4                       xor	ah,ah
21180 5FAE           8946         F4            mov	-$C[bp],ax
21181                                           !BCC_EOS
21182                                           ! 3430       head = ( DX >> 8 );
21183                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$24+$10] (used reg = )
21184 5FB1           8B46         12            mov	ax,$12[bp]
21185 5FB4           88E0                       mov	al,ah
21186 5FB6           30E4                       xor	ah,ah
21187                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$24-$C] (used reg = )
21188 5FB8           8946         F6            mov	-$A[bp],ax
21189                                           !BCC_EOS
21190                                           ! 3431       segment = ES;
21191                                           ! Debug: eq unsigned short ES = [S+$24+4] to unsigned short segment = [S+$24-$10] (used reg = )
21192 5FBB           8B46         06            mov	ax,6[bp]
21193 5FBE           8946         F2            mov	-$E[bp],ax
21194                                           !BCC_EOS
21195                                           ! 3432       offset = BX;
21196                                           ! Debug: eq unsigned short BX = [S+$24+$E] to unsigned short offset = [S+$24-$12] (used reg = )
21197 5FC1           8B46         10            mov	ax,$10[bp]
21198 5FC4           8946         F0            mov	-$10[bp],ax
21199                                           !BCC_EOS
21200                                           ! 3433       if ( (coun
21201                                           ! 3433 t > 128) || (count == 0) ) {
21202                                           ! Debug: gt int = const $80 to unsigned short count = [S+$24-$22] (used reg = )
21203 5FC7           8B46         E0            mov	ax,-$20[bp]
21204 5FCA           3D                   0080  cmp	ax,#$80
21205 5FCD           77           07            ja  	.4A2
21206                       00005FCF            .4A3:
21207                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$24-$22] (used reg = )
21208 5FCF           8B46         E0            mov	ax,-$20[bp]
21209 5FD2           85C0                       test	ax,ax
21210 5FD4           75           1C            jne 	.4A1
21211                       00005FD6            .4A2:
21212                                           ! 3434         bios_printf(4, "int13_harddisk: function %02x, count out of range!\n",( AX >> 8 ));
21213                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
21214 5FD6           8B46         16            mov	ax,$16[bp]
21215 5FD9           88E0                       mov	al,ah
21216 5FDB           30E4                       xor	ah,ah
21217                                           ! Debug: list unsigned int = ax+0 (used reg = )
21218 5FDD           50                         push	ax
21219                                           ! Debug: list * char = .4A4+0 (used reg = )
21220 5FDE           BB                   D59C  mov	bx,#.4A4
21221 5FE1           53                         push	bx
21222                                           ! Debug: list int = const 4 (used reg = )
21223 5FE2           B8                   0004  mov	ax,*4
21224 5FE5           50                         push	ax
21225                                           ! Debug: func () void = bios_printf+0 (used reg = )
21226 5FE6           E8         A8C0            call	_bios_printf
21227 5FE9           83C4                   06  add	sp,*6
21228                                           !BCC_EOS
21229                                           ! 3435         goto int13_fail;
21230 5FEC           83C4                   0E  add	sp,#..FFF0-..FFEF
21231 5FEF           E9         0CF0            br 	.FFF0
21232                                           !BCC_EOS
21233                                           ! 3436         }
21234                                           ! 3437       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
21235                       00005FF2            .4A1:
21236                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21237 5FF2           8A46         DF            mov	al,-$21[bp]
21238 5FF5           30E4                       xor	ah,ah
21239 5FF7           B9                   001A  mov	cx,*$1A
21240 5FFA           F7E9                       imul	cx
21241 5FFC           89C3                       mov	bx,ax
21242                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
21243                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
21244 5FFE           81C3                 014E  add	bx,#$14E
21245 6002           53                         push	bx
21246                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21247 6003           FF76         FA            push	-6[bp]
21248                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21249 6006           E8         A608            call	_read_word
21250 6009           83C4                   04  add	sp,*4
21251                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$24-$1A] (used reg = )
21252 600C           8946         E8            mov	-$18[bp],ax
21253                                           !BCC_EOS
21254                                           ! 3438       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
21255                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21256 600F           8A46         DF            mov	al,-$21[bp]
21257 6012           30E4                       xor	ah,ah
21258 6014           B9                   001A  mov	cx,*$1A
21259 6017           F7E9                       imul	cx
21260 6019           89C3                       mov	bx,ax
21261                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
21262                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
21263 601B           81C3                 014C  add	bx,#$14C
21264 601F           53                         push	bx
21265                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21266 6020           FF76         FA            push	-6[bp]
21267                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21268 6023           E8         A5EB            call	_read_word
21269 6026           83C4                   04  add	sp,*4
21270                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$24-$1C] (used reg = )
21271 6029           8946         E6            mov	-$1A[bp],ax
21272                                           !BCC_EOS
21273                                           ! 3439       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
21274                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21275 602C           8A46         DF            mov	al,-$21[bp]
21276 602F           30E4                       xor	ah,ah
21277 6031           B9                   001A  mov	cx,*$1A
21278 6034           F7E9                       imul	cx
21279 6036           89C3                       mov	bx,ax
21280                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
21281                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
21282 6038           81C3                 0150  add	bx,#$150
21283 603C           53                         push	bx
21284                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21285 603D           FF76         FA            push	-6[bp]
21286                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21287 6040           E8         A5CE            call	_read_word
21288 6043           83C4                   04  add	sp,*4
21289                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$24-$1E] (used reg = )
21290 6046           8946         E4            mov	-$1C[bp],ax
21291                                           !BCC_EOS
21292                                           ! 3440       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt )) {
21293                                           ! Debug: ge unsigned short nlc = [S+$24-$1A] to unsigned short cylinder = [S+$24-$A] (used reg = )
21294 6049           8B46         F8            mov	ax,-8[bp]
21295 604C           3B46         E8            cmp	ax,-$18[bp]
21296 604F           73           10            jae 	.4A6
21297                       00006051            .4A8:
21298                                           ! Debug: ge unsigned short nlh = [S+$24-$1C] to unsigned short head = [S+$24-$C] (used reg = )
21299 6051           8B46         F6            mov	ax,-$A[bp]
21300 6054           3B46         E6            cmp	ax,-$1A[bp]
21301 6057           73           08            jae 	.4A6
21302                       00006059            .4A7:
21303                                           ! Debug: gt unsigned short nlspt = [S+$24-$1E] to unsigned short sector = [S+$24-$E] (used reg = )
21304 6059           8B46         F4            mov	ax,-$C[bp]
21305 605C           3B46         E4            cmp	ax,-$1C[bp]
21306 605F           76           25            jbe 	.4A5
21307                       00006061            .4A6:
21308                                           ! 3441         bios_printf(4, "int13_harddisk: function %02x, parameters out of range %04x/%04x/%04x!\n", ( AX >> 8 ), cylinder, head, sector);
21309                                           ! Debug: list unsigned short sector = [S+$24-$E] (used reg = )
21310 6061           FF76         F4            push	-$C[bp]
21311                                           ! Debug: list unsigned short head = [S+$26-$C] (used reg = )
21312 6064           FF76         F6            push	-$A[bp]
21313                                           ! Debug: list unsigned short cylinder = [S+$28-$A] (used reg = )
21314 6067           FF76         F8            push	-8[bp]
21315                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$2A+$14] (used reg = )
21316 606A           8B46         16            mov	ax,$16[bp]
21317 606D           88E0                       mov	al,ah
21318 606F           30E4                       xor	ah,ah
21319                                           ! Debug: list unsigned int = ax+0 (used reg = )
21320 6071           50                         push	ax
21321                                           ! Debug: list * char = .4A9+0 (used reg = )
21322 6072           BB                   D554  mov	bx,#.4A9
21323 6075           53                         push	bx
21324                                           ! Debug: list int = const 4 (used reg = )
21325 6076           B8                   0004  mov	ax,*4
21326 6079           50                         push	ax
21327                                           ! Debug: func () void = bios_printf+0 (used reg = )
21328 607A           E8         A82C            call	_bios_printf
21329 607D           83C4                   0C  add	sp,*$C
21330                                           !BCC_EOS
21331                                           ! 3442         goto int13_fail;
21332 6080           83C4                   0E  add	sp,#..FFF0-..FFEF
21333 6083           E9         0C5C            br 	.FFF0
21334                                           !BCC_EOS
21335                                           ! 3443         }
21336                                           ! 3444       if ( ( AX >> 8 ) == 0x04 ) goto int13_success;
21337                       00006086            .4A5:
21338                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
21339 6086           8B46         16            mov	ax,$16[bp]
21340 6089           88E0                       mov	al,ah
21341 608B           30E4                       xor	ah,ah
21342                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
21343 608D           3D                   0004  cmp	ax,*4
21344 6090           75           06            jne 	.4AA
21345                       00006092            .4AB:
21346 6092           83C4                   0E  add	sp,#..FFEE-..FFEF
21347 6095           E9         0C77            br 	.FFEE
21348                                           !BCC_EOS
21349                                           ! 3445       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
21350                       00006098            .4AA:
21351                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21352 6098           8A46         DF            mov	al,-$21[bp]
21353 609B           30E4                       xor	ah,ah
21354 609D           B9                   001A  mov	cx,*$1A
21355 60A0           F7E9                       imul	cx
21356 60A2           89C3                       mov	bx,ax
21357                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
21358                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
21359 60A4           81C3                 0152  add	bx,#$152
21360 60A8           53                         push	bx
21361                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21362 60A9           FF76         FA            push	-6[bp]
21363                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21364 60AC           E8         A562            call	_read_word
21365 60AF           83C4                   04  add	sp,*4
21366                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$24-$16] (used reg = )
21367 60B2           8946         EC            mov	-$14[bp],ax
21368                                           !BCC_EOS
21369                                           ! 3446       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
21370                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21371 60B5           8A46         DF            mov	al,-$21[bp]
21372 60B8           30E4                       xor	ah,ah
21373 60BA           B9                   001A  mov	cx,*$1A
21374 60BD           F7E9                       imul	cx
21375 60BF           89C3                       mov	bx,ax
21376                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
21377                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
21378 60C1           81C3                 0156  add	bx,#$156
21379 60C5           53                         push	bx
21380                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21381 60C6           FF76         FA            push	-6[bp]
21382                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21383 60C9           E8         A545            call	_read_word
21384 60CC           83C4                   04  add	sp,*4
21385                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$24-$18] (used reg = )
21386 60CF           8946         EA            mov	-$16[bp],ax
21387                                           !BCC_EOS
21388                                           ! 3447       if ( (nph != nlh) || (npspt != nlspt)) {
21389                                           ! Debug: ne unsigned short nlh = [S+$24-$1C] to unsigned short nph = [S+$24-$16] (used reg = )
21390 60D2           8B46         EC            mov	ax,-$14[bp]
21391 60D5           3B46         E6            cmp	ax,-$1A[bp]
21392 60D8           75           08            jne 	.4AD
21393                       000060DA            .4AE:
21394                                           ! Debug: ne unsigned short nlspt = [S+$24-$1E] to unsigned short npspt = [S+$24-$18] (used reg = )
21395 60DA           8B46         EA            mov	ax,-$16[bp]
21396 60DD           3B46         E4            cmp	ax,-$1C[bp]
21397 60E0           74           68            je  	.4AC
21398                       000060E2            .4AD:
21399                                           ! 3448         lba = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
21400                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$24-$E] (used reg = )
21401 60E2           8B46         F4            mov	ax,-$C[bp]
21402 60E5           31DB                       xor	bx,bx
21403 60E7           53                         push	bx
21404 60E8           50                         push	ax
21405                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$1E] (used reg = )
21406 60E9           8B46         E4            mov	ax,-$1C[bp]
21407 60EC           31DB                       xor	bx,bx
21408 60EE           53                         push	bx
21409 60EF           50                         push	ax
21410                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$2C-$C] (used reg = )
21411 60F0           8B46         F6            mov	ax,-$A[bp]
21412 60F3           31DB                       xor	bx,bx
21413 60F5           53                         push	bx
21414 60F6           50                         push	ax
21415                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$30-$1C] (used reg = )
21416 60F7           8B46         E6            mov	ax,-$1A[bp]
21417 60FA           31DB                       xor	bx,bx
21418 60FC           53                         push	bx
21419 60FD           50                         push	ax
21420                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$34-$A] (used reg = )
21421 60FE           8B46         F8            mov	ax,-8[bp]
21422 6101           31DB                       xor	bx,bx
21423                                           ! Debug: mul unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
21424 6103           8D7E         C0            lea	di,-$E+..FFEF[bp]
21425 6106           E8         9FB0            call	lmulul
21426 6109           83C4                   04  add	sp,*4
21427                                           ! Debug: add unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
21428 610C           8D7E         C4            lea	di,-$A+..FFEF[bp]
21429 610F           E8         9F81            call	laddul
21430 6112           83C4                   04  add	sp,*4
21431                                           ! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
21432 6115           8D7E         C8            lea	di,-6+..FFEF[bp]
21433 6118           E8         9F9E            call	lmulul
21434 611B           83C4                   04  add	sp,*4
21435                                           ! Debug: add unsigned long (temp) = [S+$28-$28] to unsigned long = bx+0 (used reg = )
21436 611E           8D7E         CC            lea	di,-2+..FFEF[bp]
21437 6121           E8         9F6F            call	laddul
21438 6124           83C4                   04  add	sp,*4
21439                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
21440 6127           53                         push	bx
21441 6128           50                         push	ax
21442 6129           B8                   0001  mov	ax,*1
21443 612C           31DB                       xor	bx,bx
21444 612E           53                         push	bx
21445 612F           50                         push	ax
21446 6130           8B46         CC            mov	ax,-2+..FFEF[bp]
21447 6133           8B5E         CE            mov	bx,0+..FFEF[bp]
21448 6136           8D7E         C8            lea	di,-6+..FFEF[bp]
21449 6139           E8         9F75            call	lsubul
21450 613C           83C4                   08  add	sp,*8
21451                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$24-6] (used reg = )
21452 613F           8946         FC            mov	-4[bp],ax
21453 6142           895E         FE            mov	-2[bp],bx
21454                                           !BCC_EOS
21455                                           ! 3449         sector = 0;
21456                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$24-$E] (used reg = )
21457 6145           31C0                       xor	ax,ax
21458 6147           8946         F4            mov	-$C[bp],ax
21459                                           !BCC_EOS
21460                                           ! 3450         }
21461                                           ! 3451       if ( ( AX >> 8 ) == 0x02 )
21462                       0000614A            .4AC:
21463                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
21464 614A           8B46         16            mov	ax,$16[bp]
21465 614D           88E0                       mov	al,ah
21466 614F           30E4                       xor	ah,ah
21467                                           ! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
21468 6151           3D                   0002  cmp	ax,*2
21469 6154           75           2D            jne 	.4AF
21470                       00006156            .4B0:
21471                                           ! 3452         status=ata_cmd_data_in(device, 0x20, count, cylinder, head, sector, lba, segment, offset);
21472                                           ! Debug: list unsigned short offset = [S+$24-$12] (used reg = )
21473 6156           FF76         F0            push	-$10[bp]
21474                                           ! Debug: list unsigned short segment = [S+$26-$10] (used reg = )
21475 6159           FF76         F2            push	-$E[bp]
21476                                           ! Debug: list unsigned long lba = [S+$28-6] (used reg = )
21477 615C           FF76         FE            push	-2[bp]
21478 615F           FF76         FC            push	-4[bp]
21479                                           ! Debug: list unsigned short sector = [S+$2C-$E] (used reg = )
21480 6162           FF76         F4            push	-$C[bp]
21481                                           ! Debug: list unsigned short head = [S+$2E-$C] (used reg = )
21482 6165           FF76         F6            push	-$A[bp]
21483                                           ! Debug: list unsigned short cylinder = [S+$30-$A] (used reg = )
21484 6168           FF76         F8            push	-8[bp]
21485                                           ! Debug: list unsigned short count = [S+$32-$22] (used reg = )
21486 616B           FF76         E0            push	-$20[bp]
21487                                           ! Debug: list int = const $20 (used reg = )
21488 616E           B8                   0020  mov	ax,*$20
21489 6171           50                         push	ax
21490                                           ! Debug: list unsigned char device = [S+$36-$23] (used reg = )
21491 6172           8A46         DF            mov	al,-$21[bp]
21492 6175           30E4                       xor	ah,ah
21493 6177           50                         push	ax
21494                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
21495 6178           E8         C80F            call	_ata_cmd_data_in
21496 617B           83C4                   14  add	sp,*$14
21497                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$24-$24] (used reg = )
21498 617E           8846         DE            mov	-$22[bp],al
21499                                           !BCC_EOS
21500                                           ! 3453       else
21501                                           ! 3454         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba, segment, offset);
21502 6181           EB           2B            jmp .4B1
21503                       00006183            .4AF:
21504                                           ! Debug: list unsigned short offset = [S+$24-$12] (used reg = )
21505 6183           FF76         F0            push	-$10[bp]
21506                                           ! Debug: list unsigned short segment = [S+$26-$10] (used reg = )
21507 6186           FF76         F2            push	-$E[bp]
21508                                           ! Debug: list unsigned long lba = [S+$28-6] (used reg = )
21509 6189           FF76         FE            push	-2[bp]
21510 618C           FF76         FC            push	-4[bp]
21511                                           ! Debug: list unsigned short sector = [S+$2C-$E] (used reg = )
21512 618F           FF76         F4            push	-$C[bp]
21513                                           ! Debug: list unsigned short head = [S+$2E-$C] (used reg = )
21514 6192           FF76         F6            push	-$A[bp]
21515                                           ! Debug: list unsigned short cylinder = [S+$30-$A] (used reg = )
21516 6195           FF76         F8            push	-8[bp]
21517                                           ! Debug: list unsigned short count = [S+$32-$22] (used reg = )
21518 6198           FF76         E0            push	-$20[bp]
21519                                           ! Debug: list int = const $30 (used reg = )
21520 619B           B8                   0030  mov	ax,*$30
21521 619E           50                         push	ax
21522                                           ! Debug: list unsigned char device = [S+$36-$23] (used reg = )
21523 619F           8A46         DF            mov	al,-$21[bp]
21524 61A2           30E4                       xor	ah,ah
21525 61A4           50                         push	ax
21526                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
21527 61A5           E8         CB72            call	_ata_cmd_data_out
21528 61A8           83C4                   14  add	sp,*$14
21529                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$24-$24] (used reg = )
21530 61AB           8846         DE            mov	-$22[bp],al
21531                                           !BCC_EOS
21532                                           ! 3455       AX = ((AX & 0xff00) | (read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors)));
21533                       000061AE            .4B1:
21534                                           ! Debug: list * unsigned short = const $234 (used reg = )
21535 61AE           B8                   0234  mov	ax,#$234
21536 61B1           50                         push	ax
21537                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21538 61B2           FF76         FA            push	-6[bp]
21539                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21540 61B5           E8         A459            call	_read_word
21541 61B8           83C4                   04  add	sp,*4
21542 61BB           50                         push	ax
21543                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$26+$14] (used reg = )
21544 61BC           8B46         16            mov	ax,$16[bp]
21545 61BF           30C0                       xor	al,al
21546                                           ! Debug: or unsigned short (temp) = [S+$26-$26] to unsigned int = ax+0 (used reg = )
21547 61C1           0B46         CE            or	ax,0+..FFEF[bp]
21548 61C4           44                         inc	sp
21549 61C5           44                         inc	sp
21550                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$24+$14] (used reg = )
21551 61C6           8946         16            mov	$16[bp],ax
21552                                           !BCC_EOS
21553                                           ! 3456       if (status != 0) {
21554                                           ! Debug: ne int = const 0 to unsigned char status = [S+$24-$24] (used reg = )
21555 61C9           8A46         DE            mov	al,-$22[bp]
21556 61CC           84C0                       test	al,al
21557 61CE           74           2D            je  	.4B2
21558                       000061D0            .4B3:
21559                                           ! 3457         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
21560                                           ! Debug: list unsigned char status = [S+$24-$24] (used reg = )
21561 61D0           8A46         DE            mov	al,-$22[bp]
21562 61D3           30E4                       xor	ah,ah
21563 61D5           50                         push	ax
21564                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$26+$14] (used reg = )
21565 61D6           8B46         16            mov	ax,$16[bp]
21566 61D9           88E0                       mov	al,ah
21567 61DB           30E4                       xor	ah,ah
21568                                           ! Debug: list unsigned int = ax+0 (used reg = )
21569 61DD           50                         push	ax
21570                                           ! Debug: list * char = .4B4+0 (used reg = )
21571 61DE           BB                   D527  mov	bx,#.4B4
21572 61E1           53                         push	bx
21573                                           ! Debug: list int = const 4 (used reg = )
21574 61E2           B8                   0004  mov	ax,*4
21575 61E5           50                         push	ax
21576                                           ! Debug: func () void = bios_printf+0 (used reg = )
21577 61E6           E8         A6C0            call	_bios_printf
21578 61E9           83C4                   08  add	sp,*8
21579                                           !BCC_EOS
21580                                           ! 3458         AX = ((AX & 0x00ff) | ((0x0c) << 8));
21581                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
21582 61EC           8A46         16            mov	al,$16[bp]
21583                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
21584 61EF           30E4                       xor	ah,ah
21585 61F1           0D                   0C00  or	ax,#$C00
21586                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$24+$14] (used reg = )
21587 61F4           8946         16            mov	$16[bp],ax
21588                                           !BCC_EOS
21589                                           ! 3459         goto int13_fail_noah;
21590 61F7           83C4                   0E  add	sp,#..FFEB-..FFEF
21591 61FA           E9         0AF0            br 	.FFEB
21592                                           !BCC_EOS
21593                                           ! 3460         }
21594                                           ! 3461       goto int13_success;
21595                       000061FD            .4B2:
21596 61FD           83C4                   0E  add	sp,#..FFEE-..FFEF
21597 6200           E9         0B0C            br 	.FFEE
21598                                           !BCC_EOS
21599                                           ! 3462       break;
21600 6203           E9         0AD9            br 	.496
21601                                           !BCC_EOS
21602                                           ! 3463     case 0x05:
21603                                           ! 3464       bios_printf(4, "format disk track called\n");
21604                       00006206            .4B5:
21605                                           ! Debug: list * char = .4B6+0 (used reg = )
21606 6206           BB                   D50D  mov	bx,#.4B6
21607 6209           53                         push	bx
21608                                           ! Debug: list int = const 4 (used reg = )
21609 620A           B8                   0004  mov	ax,*4
21610 620D           50                         push	ax
21611                                           ! Debug: func () void = bios_printf+0 (used reg = )
21612 620E           E8         A698            call	_bios_printf
21613 6211           83C4                   04  add	sp,*4
21614                                           !BCC_EOS
21615                                           ! 3465       goto int13_success;
21616 6214           83C4                   0E  add	sp,#..FFEE-..FFEF
21617 6217           E9         0AF5            br 	.FFEE
21618                                           !BCC_EOS
21619                                           ! 3466       return;
21620 621A           89EC                       mov	sp,bp
21621 621C           5D                         pop	bp
21622 621D           C3                         ret
21623                                           !BCC_EOS
21624                                           ! 3467       break;
21625 621E           E9         0ABE            br 	.496
21626                                           !BCC_EOS
21627                                           ! 3468     case 0x08:
21628                                           ! 3469       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
21629                       00006221            .4B7:
21630                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21631 6221           8A46         DF            mov	al,-$21[bp]
21632 6224           30E4                       xor	ah,ah
21633 6226           B9                   001A  mov	cx,*$1A
21634 6229           F7E9                       imul	cx
21635 622B           89C3                       mov	bx,ax
21636                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
21637                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
21638 622D           81C3                 014E  add	bx,#$14E
21639 6231           53                         push	bx
21640                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21641 6232           FF76         FA            push	-6[bp]
21642                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21643 6235           E8         A3D9            call	_read_word
21644 6238           83C4                   04  add	sp,*4
21645                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$24-$1A] (used reg = )
21646 623B           8946         E8            mov	-$18[bp],ax
21647                                           !BCC_EOS
21648                                           ! 3470       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
21649                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21650 623E           8A46         DF            mov	al,-$21[bp]
21651 6241           30E4                       xor	ah,ah
21652 6243           B9                   001A  mov	cx,*$1A
21653 6246           F7E9                       imul	cx
21654 6248           89C3                       mov	bx,ax
21655                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
21656                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
21657 624A           81C3                 014C  add	bx,#$14C
21658 624E           53                         push	bx
21659                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21660 624F           FF76         FA            push	-6[bp]
21661                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21662 6252           E8         A3BC            call	_read_word
21663 6255           83C4                   04  add	sp,*4
21664                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$24-$1C] (used reg = )
21665 6258           8946         E6            mov	-$1A[bp],ax
21666                                           !BCC_EOS
21667                                           ! 3471       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
21668                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21669 625B           8A46         DF            mov	al,-$21[bp]
21670 625E           30E4                       xor	ah,ah
21671 6260           B9                   001A  mov	cx,*$1A
21672 6263           F7E9                       imul	cx
21673 6265           89C3                       mov	bx,ax
21674                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
21675                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
21676 6267           81C3                 0150  add	bx,#$150
21677 626B           53                         push	bx
21678                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21679 626C           FF76         FA            push	-6[bp]
21680                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21681 626F           E8         A39F            call	_read_word
21682 6272           83C4                   04  add	sp,*4
21683                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$24-$1E] (used reg = )
21684 6275           8946         E4            mov	-$1C[bp],ax
21685                                           !BCC_EOS
21686                                           ! 3472   
21687                                           ! 3472     count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
21688                                           ! Debug: list * unsigned char = const $212 (used reg = )
21689 6278           B8                   0212  mov	ax,#$212
21690 627B           50                         push	ax
21691                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21692 627C           FF76         FA            push	-6[bp]
21693                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21694 627F           E8         A37C            call	_read_byte
21695 6282           83C4                   04  add	sp,*4
21696                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$24-$22] (used reg = )
21697 6285           30E4                       xor	ah,ah
21698 6287           8946         E0            mov	-$20[bp],ax
21699                                           !BCC_EOS
21700                                           ! 3473       nlc = nlc - 2;
21701                                           ! Debug: sub int = const 2 to unsigned short nlc = [S+$24-$1A] (used reg = )
21702 628A           8B46         E8            mov	ax,-$18[bp]
21703                                           ! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$24-$1A] (used reg = )
21704 628D           48                         dec	ax
21705 628E           48                         dec	ax
21706 628F           8946         E8            mov	-$18[bp],ax
21707                                           !BCC_EOS
21708                                           ! 3474       AX = ((AX & 0xff00) | (0));
21709                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$14] (used reg = )
21710 6292           8B46         16            mov	ax,$16[bp]
21711 6295           30C0                       xor	al,al
21712                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
21713 6297           0C                     00  or	al,*0
21714                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$24+$14] (used reg = )
21715 6299           8946         16            mov	$16[bp],ax
21716                                           !BCC_EOS
21717                                           ! 3475       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
21718                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$24-$1A] (used reg = )
21719 629C           8A46         E8            mov	al,-$18[bp]
21720                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
21721 629F           30E4                       xor	ah,ah
21722 62A1           88C4                       mov	ah,al
21723 62A3           30C0                       xor	al,al
21724 62A5           50                         push	ax
21725                                           ! Debug: and int = const $FF to unsigned short CX = [S+$26+$12] (used reg = )
21726 62A6           8A46         14            mov	al,$14[bp]
21727                                           ! Debug: or unsigned int (temp) = [S+$26-$26] to unsigned char = al+0 (used reg = )
21728 62A9           30E4                       xor	ah,ah
21729 62AB           0B46         CE            or	ax,0+..FFEF[bp]
21730 62AE           44                         inc	sp
21731 62AF           44                         inc	sp
21732                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$24+$12] (used reg = )
21733 62B0           8946         14            mov	$14[bp],ax
21734                                           !BCC_EOS
21735                                           ! 3476       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
21736                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$24-$1E] (used reg = )
21737 62B3           8A46         E4            mov	al,-$1C[bp]
21738 62B6           24                     3F  and	al,*$3F
21739 62B8           50                         push	ax
21740                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$26-$1A] (used reg = )
21741 62B9           8B46         E8            mov	ax,-$18[bp]
21742 62BC           D1E8                       shr	ax,*1
21743 62BE           D1E8                       shr	ax,*1
21744                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
21745 62C0           24                     C0  and	al,#$C0
21746                                           ! Debug: or unsigned char (temp) = [S+$26-$26] to unsigned char = al+0 (used reg = )
21747 62C2           0A46         CE            or	al,0+..FFEF[bp]
21748 62C5           44                         inc	sp
21749 62C6           44                         inc	sp
21750 62C7           50                         push	ax
21751                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$26+$12] (used reg = )
21752 62C8           8B46         14            mov	ax,$14[bp]
21753 62CB           30C0                       xor	al,al
21754                                           ! Debug: or unsigned char (temp) = [S+$26-$26] to unsigned int = ax+0 (used reg = )
21755 62CD           0A46         CE            or	al,0+..FFEF[bp]
21756 62D0           44                         inc	sp
21757 62D1           44                         inc	sp
21758                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$24+$12] (used reg = )
21759 62D2           8946         14            mov	$14[bp],ax
21760                                           !BCC_EOS
21761                                           ! 3477       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
21762                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$24-$1C] (used reg = )
21763 62D5           8B46         E6            mov	ax,-$1A[bp]
21764                                           ! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
21765 62D8           48                         dec	ax
21766 62D9           88C4                       mov	ah,al
21767 62DB           30C0                       xor	al,al
21768 62DD           50                         push	ax
21769                                           ! Debug: and int = const $FF to unsigned short DX = [S+$26+$10] (used reg = )
21770 62DE           8A46         12            mov	al,$12[bp]
21771                                           ! Debug: or unsigned int (temp) = [S+$26-$26] to unsigned char = al+0 (used reg = )
21772 62E1           30E4                       xor	ah,ah
21773 62E3           0B46         CE            or	ax,0+..FFEF[bp]
21774 62E6           44                         inc	sp
21775 62E7           44                         inc	sp
21776                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$24+$10] (used reg = )
21777 62E8           8946         12            mov	$12[bp],ax
21778                                           !BCC_EOS
21779                                           ! 3478       DX = ((DX & 0xff00) | (count));
21780                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$24+$10] (used reg = )
21781 62EB           8B46         12            mov	ax,$12[bp]
21782 62EE           30C0                       xor	al,al
21783                                           ! Debug: or unsigned short count = [S+$24-$22] to unsigned int = ax+0 (used reg = )
21784 62F0           0B46         E0            or	ax,-$20[bp]
21785                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$24+$10] (used reg = )
21786 62F3           8946         12            mov	$12[bp],ax
21787                                           !BCC_EOS
21788                                           ! 3479       goto int13_success;
21789 62F6           83C4                   0E  add	sp,#..FFEE-..FFEF
21790 62F9           E9         0A13            br 	.FFEE
21791                                           !BCC_EOS
21792                                           ! 3480       break;
21793 62FC           E9         09E0            br 	.496
21794                                           !BCC_EOS
21795                                           ! 3481     case 0x10:
21796                                           ! 3482       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
21797                       000062FF            .4B8:
21798                                           ! Debug: div int = const 2 to unsigned char device = [S+$24-$23] (used reg = )
21799 62FF           8A46         DF            mov	al,-$21[bp]
21800 6302           30E4                       xor	ah,ah
21801 6304           D1E8                       shr	ax,*1
21802                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
21803 6306           B1                     03  mov	cl,*3
21804 6308           D3E0                       shl	ax,cl
21805 630A           89C3                       mov	bx,ax
21806                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
21807                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
21808 630C           81C3                 0124  add	bx,#$124
21809 6310           53                         push	bx
21810                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21811 6311           FF76         FA            push	-6[bp]
21812                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21813 6314           E8         A2FA            call	_read_word
21814 6317           83C4                   04  add	sp,*4
21815                                           ! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
21816                                           ! Debug: list unsigned int = ax+7 (used reg = )
21817 631A           05                   0007  add	ax,*7
21818 631D           50                         push	ax
21819                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21820 631E           E8         A227            call	_inb
21821 6321           44                         inc	sp
21822 6322           44                         inc	sp
21823                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$24-$24] (used reg = )
21824 6323           8846         DE            mov	-$22[bp],al
21825                                           !BCC_EOS
21826                                           ! 3483       if ( (status & ( 0x80 | 0x40 )) == 0x40 ) {
21827                                           ! Debug: and int = const $C0 to unsigned char status = [S+$24-$24] (used reg = )
21828 6326           8A46         DE            mov	al,-$22[bp]
21829 6329           24                     C0  and	al,#$C0
21830                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
21831 632B           3C                     40  cmp	al,*$40
21832 632D           75           08            jne 	.4B9
21833                       0000632F            .4BA:
21834                                           ! 3484         goto int13_success;
21835 632F           83C4                   0E  add	sp,#..FFEE-..FFEF
21836 6332           E9         09DA            br 	.FFEE
21837                                           !BCC_EOS
21838                                           ! 3485         }
21839                                           ! 3486       else {
21840 6335           EB           11            jmp .4BB
21841                       00006337            .4B9:
21842                                           ! 3487         AX = ((AX & 0x00ff) | ((0xAA) << 8));
21843                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
21844 6337           8A46         16            mov	al,$16[bp]
21845                                           ! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
21846 633A           30E4                       xor	ah,ah
21847 633C           0D                   AA00  or	ax,#-$5600
21848                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$24+$14] (used reg = )
21849 633F           8946         16            mov	$16[bp],ax
21850                                           !BCC_EOS
21851                                           ! 3488         goto int13_fail_noah;
21852 6342           83C4                   0E  add	sp,#..FFEB-..FFEF
21853 6345           E9         09A5            br 	.FFEB
21854                                           !BCC_EOS
21855                                           ! 3489         }
21856                                           ! 3490       break;
21857                       00006348            .4BB:
21858 6348           E9         0994            br 	.496
21859                                           !BCC_EOS
21860                                           ! 3491     case 0x15:
21861                                           ! 3492       npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
21862                       0000634B            .4BC:
21863                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21864 634B           8A46         DF            mov	al,-$21[bp]
21865 634E           30E4                       xor	ah,ah
21866 6350           B9                   001A  mov	cx,*$1A
21867 6353           F7E9                       imul	cx
21868 6355           89C3                       mov	bx,ax
21869                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
21870                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
21871 6357           81C3                 0154  add	bx,#$154
21872 635B           53                         push	bx
21873                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21874 635C           FF76         FA            push	-6[bp]
21875                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21876 635F           E8         A2AF            call	_read_word
21877 6362           83C4                   04  add	sp,*4
21878                                           ! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$24-$14] (used reg = )
21879 6365           8946         EE            mov	-$12[bp],ax
21880                                           !BCC_EOS
21881                                           ! 3493       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
21882                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21883 6368           8A46         DF            mov	al,-$21[bp]
21884 636B           30E4                       xor	ah,ah
21885 636D           B9                   001A  mov	cx,*$1A
21886 6370           F7E9                       imul	cx
21887 6372           89C3                       mov	bx,ax
21888                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
21889                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
21890 6374           81C3                 0152  add	bx,#$152
21891 6378           53                         push	bx
21892                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21893 6379           FF76         FA            push	-6[bp]
21894                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21895 637C           E8         A292            call	_read_word
21896 637F           83C4                   04  add	sp,*4
21897                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$24-$16] (used reg = )
21898 6382           8946         EC            mov	-$14[bp],ax
21899                                           !BCC_EOS
21900                                           ! 3494       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
21901                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
21902 6385           8A46         DF            mov	al,-$21[bp]
21903 6388           30E4                       xor	ah,ah
21904 638A           B9                   001A  mov	cx,*$1A
21905 638D           F7E9                       imul	cx
21906 638F           89C3                       mov	bx,ax
21907                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
21908                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
21909 6391           81C3                 0156  add	bx,#$156
21910 6395           53                         push	bx
21911                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
21912 6396           FF76         FA            push	-6[bp]
21913                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
21914 6399           E8         A275            call	_read_word
21915 639C           83C4                   04  add	sp,*4
21916                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$24-$18] (used reg = )
21917 639F           8946         EA            mov	-$16[bp],ax
21918                                           !BCC_EOS
21919                                           ! 3495       lba = (Bit32u)(npc - 1) * (Bit32u)nph * (Bit32u)npspt;
21920                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$24-$18] (used reg = )
21921 63A2           8B46         EA            mov	ax,-$16[bp]
21922 63A5           31DB                       xor	bx,bx
21923 63A7           53                         push	bx
21924 63A8           50                         push	ax
21925                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$28-$16] (used reg = )
21926 63A9           8B46         EC            mov	ax,-$14[bp]
21927 63AC           31DB                       xor	bx,bx
21928 63AE           53                         push	bx
21929 63AF           50                         push	ax
21930                                           ! Debug: sub int = const 1 to unsigned short npc = [S+$2C-$14] (used reg = )
21931 63B0           8B46         EE            mov	ax,-$12[bp]
21932                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
21933 63B3           48                         dec	ax
21934 63B4           31DB                       xor	bx,bx
21935                                           ! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
21936 63B6           8D7E         C8            lea	di,-6+..FFEF[bp]
21937 63B9           E8         9CFD            call	lmulul
21938 63BC           83C4                   04  add	sp,*4
21939                                           ! Debug: mul unsigned long (temp) = [S+$28-$28] to unsigned long = bx+0 (used reg = )
21940 63BF           8D7E         CC            lea	di,-2+..FFEF[bp]
21941 63C2           E8         9CF4            call	lmulul
21942 63C5           83C4                   04  add	sp,*4
21943                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$24-6] (used reg = )
21944 63C8           8946         FC            mov	-4[bp],ax
21945 63CB           895E         FE            mov	-2[bp],bx
21946                                           !BCC_EOS
21947                                           ! 3496       CX = lba >> 16;
21948                                           ! Debug: sr int = const $10 to unsigned long lba = [S+$24-6] (used reg = )
21949 63CE           8B46         FC            mov	ax,-4[bp]
21950 63D1           8B5E         FE            mov	bx,-2[bp]
21951 63D4           93                         xchg	bx,ax
21952 63D5           31DB                       xor	bx,bx
21953                                           ! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$24+$12] (used reg = )
21954 63D7           8946         14            mov	$14[bp],ax
21955                                           !BCC_EOS
21956                                           ! 3497       DX = lba & 0xffff;
21957                                           ! Debug: and unsigned long = const $FFFF to unsigned long lba = [S+$24-6] (used reg = )
21958                                           ! Debug: expression subtree swapping
21959 63DA           B8                   FFFF  mov	ax,#$FFFF
21960 63DD           31DB                       xor	bx,bx
21961 63DF           8D7E         FC            lea	di,-4[bp]
21962 63E2           E8         9CA6            call	landul
21963                                           ! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$24+$10] (used reg = )
21964 63E5           8946         12            mov	$12[bp],ax
21965                                           !BCC_EOS
21966                                           ! 3498       AX = ((AX & 0x00ff) | ((3) << 8));
21967                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
21968 63E8           8A46         16            mov	al,$16[bp]
21969                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
21970 63EB           30E4                       xor	ah,ah
21971 63ED           0D                   0300  or	ax,#$300
21972                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$24+$14] (used reg = )
21973 63F0           8946         16            mov	$16[bp],ax
21974                                           !BCC_EOS
21975                                           ! 3499       goto int13_success_noah;
21976 63F3           83C4                   0E  add	sp,#..FFEC-..FFEF
21977 63F6           E9         0920            br 	.FFEC
21978                                           !BCC_EOS
21979                                           ! 3500       break;
21980 63F9           E9         08E3            br 	.496
21981                                           !BCC_EOS
21982                                           ! 3501     case 0x41:
21983                                           ! 3502       BX=0xaa55;
21984                       000063FC            .4BD:
21985                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$24+$E] (used reg = )
21986 63FC           B8                   AA55  mov	ax,#$AA55
21987 63FF           8946         10            mov	$10[bp],ax
21988                                           !BCC_EOS
21989                                           ! 3503       AX = ((AX & 0x00ff) | ((0x30) << 8));
21990                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
21991 6402           8A46         16            mov	al,$16[bp]
21992                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
21993 6405           30E4                       xor	ah,ah
21994 6407           0D                   3000  or	ax,#$3000
21995                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$24+$14] (used reg = )
21996 640A           8946         16            mov	$16[bp],ax
21997                                           !BCC_EOS
21998                                           ! 3504       CX=0x0007;
21999                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$24+$12] (used reg = )
22000 640D           B8                   0007  mov	ax,*7
22001 6410           8946         14            mov	$14[bp],ax
22002                                           !BCC_EOS
22003                                           ! 3505       goto int13_success_noah;
22004 6413           83C4                   0E  add	sp,#..FFEC-..FFEF
22005 6416           E9         0900            br 	.FFEC
22006                                           !BCC_EOS
22007                                           ! 3506       break;
22008 6419           E9         08C3            br 	.496
22009                                           !BCC_EOS
22010                                           ! 3507     case 0x42:
22011                                           ! 3508     case 0x43:
22012                       0000641C            .4BE:
22013                                           ! 3509     case 0x44:
22014                       0000641C            .4BF:
22015                                           ! 3510     case 0x47:
22016                       0000641C            .4C0:
22017                                           ! 3511       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
22018                       0000641C            .4C1:
22019                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+8] (used reg = )
22020 641C           8B46         0A            mov	ax,$A[bp]
22021                                           ! Debug: list unsigned int = ax+2 (used reg = )
22022 641F           40                         inc	ax
22023 6420           40                         inc	ax
22024 6421           50                         push	ax
22025                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
22026 6422           FF76         04            push	4[bp]
22027                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22028 6425           E8         A1E9            call	_read_word
22029 6428           83C4                   04  add	sp,*4
22030                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$24-$22] (used reg = )
22031 642B           8946         E0            mov	-$20[bp],ax
22032                                           !BCC_EOS
22033                                           ! 3512       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
22034                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$24+8] (used reg = )
22035 642E           8B46         0A            mov	ax,$A[bp]
22036                                           ! Debug: list unsigned int = ax+6 (used reg = )
22037 6431           05                   0006  add	ax,*6
22038 6434           50                         push	ax
22039                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
22040 6435           FF76         04            push	4[bp]
22041                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22042 6438           E8         A1D6            call	_read_word
22043 643B           83C4                   04  add	sp,*4
22044                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$24-$10] (used reg = )
22045 643E           8946         F2            mov	-$E[bp],ax
22046                                           !BCC_EOS
22047                                           ! 3513       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
22048                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$24+8] (used reg = )
22049 6441           8B46         0A            mov	ax,$A[bp]
22050                                           ! Debug: list unsigned int = ax+4 (used reg = )
22051 6444           05                   0004  add	ax,*4
22052 6447           50                         push	ax
22053                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
22054 6448           FF76         04            push	4[bp]
22055                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22056 644B           E8         A1C3            call	_read_word
22057 644E           83C4                   04  add	sp,*4
22058                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$24-$12] (used reg = )
22059 6451           8946         F0            mov	-$10[bp],ax
22060                                           !BCC_EOS
22061                                           ! 3514       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
22062                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$24+8] (used reg = )
22063 6454           8B46         0A            mov	ax,$A[bp]
22064                                           ! Debug: list unsigned int = ax+$C (used reg = )
22065 6457           05                   000C  add	ax,*$C
22066 645A           50                         push	ax
22067                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
22068 645B           FF76         04            push	4[bp]
22069                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
22070 645E           E8         9BF4            call	_read_dword
22071 6461           89D3                       mov	bx,dx
22072 6463           83C4                   04  add	sp,*4
22073                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$24-6] (used reg = )
22074 6466           8946         FC            mov	-4[bp],ax
22075 6469           895E         FE            mov	-2[bp],bx
22076                                           !BCC_EOS
22077                                           ! 3515       if (lba != 0L) {
22078                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$24-6] (used reg = )
22079                                           ! Debug: expression subtree swapping
22080 646C           31C0                       xor	ax,ax
22081 646E           31DB                       xor	bx,bx
22082 6470           53                         push	bx
22083 6471           50                         push	ax
22084 6472           8B46         FC            mov	ax,-4[bp]
22085 6475           8B5E         FE            mov	bx,-2[bp]
22086 6478           8D7E         CC            lea	di,-2+..FFEF[bp]
22087 647B           E8         9C1D            call	lcmpul
22088 647E           8D66         D0            lea	sp,2+..FFEF[bp]
22089 6481           74           1C            je  	.4C2
22090                       00006483            .4C3:
22091                                           ! 3516         bios_printf((2 | 4 | 1), "int13_harddisk: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
22092                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
22093 6483           8B46         16            mov	ax,$16[bp]
22094 6486           88E0                       mov	al,ah
22095 6488           30E4                       xor	ah,ah
22096                                           ! Debug: list unsigned int = ax+0 (used reg = )
22097 648A           50                         push	ax
22098                                           ! Debug: list * char = .4C4+0 (used reg = )
22099 648B           BB                   D4D8  mov	bx,#.4C4
22100 648E           53                         push	bx
22101                                           ! Debug: list int = const 7 (used reg = )
22102 648F           B8                   0007  mov	ax,*7
22103 6492           50                         push	ax
22104                                           ! Debug: func () void = bios_printf+0 (used reg = )
22105 6493           E8         A413            call	_bios_printf
22106 6496           83C4                   06  add	sp,*6
22107                                           !BCC_EOS
22108                                           ! 3517         goto int13_fail;
22109 6499           83C4                   0E  add	sp,#..FFF0-..FFEF
22110 649C           E9         0843            br 	.FFF0
22111                                           !BCC_EOS
22112                                           ! 3518         }
22113                                           ! 3519       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
22114                       0000649F            .4C2:
22115                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$24+8] (used reg = )
22116 649F           8B46         0A            mov	ax,$A[bp]
22117                                           ! Debug: list unsigned int = ax+8 (used reg = )
22118 64A2           05                   0008  add	ax,*8
22119 64A5           50                         push	ax
22120                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
22121 64A6           FF76         04            push	4[bp]
22122                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
22123 64A9           E8         9BA9            call	_read_dword
22124 64AC           89D3                       mov	bx,dx
22125 64AE           83C4                   04  add	sp,*4
22126                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$24-6] (used reg = )
22127 64B1           8946         FC            mov	-4[bp],ax
22128 64B4           895E         FE            mov	-2[bp],bx
22129                                           !BCC_EOS
22130                                           ! 3520       if (lba >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors) ) {
22131                                           ! Debug: ptradd unsigned char device = [S+$24-$23] to [8] struct  = const $142 (used reg = )
22132 64B7           8A46         DF            mov	al,-$21[bp]
22133 64BA           30E4                       xor	ah,ah
22134 64BC           B9                   001A  mov	cx,*$1A
22135 64BF           F7E9                       imul	cx
22136 64C1           89C3                       mov	bx,ax
22137                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
22138                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
22139 64C3           81C3                 0158  add	bx,#$158
22140 64C7           53                         push	bx
22141                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
22142 64C8           FF76         FA            push	-6[bp]
22143                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
22144 64CB           E8         9B87            call	_read_dword
22145 64CE           89D3                       mov	bx,dx
22146 64D0           83C4                   04  add	sp,*4
22147                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba = [S+$24-6] (used reg = )
22148 64D3           8D7E         FC            lea	di,-4[bp]
22149 64D6           E8         9BC2            call	lcmpul
22150 64D9           77           1C            ja  	.4C5
22151                       000064DB            .4C6:
22152                                           ! 3521         bios_printf(4, "int13_harddisk: function %02x. LBA out of range\n",( AX >> 8 ));
22153                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
22154 64DB           8B46         16            mov	ax,$16[bp]
22155 64DE           88E0                       mov	al,ah
22156 64E0           30E4                       xor	ah,ah
22157                                           ! Debug: list unsigned int = ax+0 (used reg = )
22158 64E2           50                         push	ax
22159                                           ! Debug: list * char = .4C7+0 (used reg = )
22160 64E3           BB                   D4A7  mov	bx,#.4C7
22161 64E6           53                         push	bx
22162                                           ! Debug: list int = const 4 (used reg = )
22163 64E7           B8                   0004  mov	ax,*4
22164 64EA           50                         push	ax
22165                                           ! Debug: func () void = bios_printf+0 (used reg = )
22166 64EB           E8         A3BB            call	_bios_printf
22167 64EE           83C4                   06  add	sp,*6
22168                                           !BCC_EOS
22169                                           ! 3522         goto int13_fail
22170                                           ! 3522 ;
22171 64F1           83C4                   0E  add	sp,#..FFF0-..FFEF
22172 64F4           E9         07EB            br 	.FFF0
22173                                           !BCC_EOS
22174                                           ! 3523         }
22175                                           ! 3524       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
22176                       000064F7            .4C5:
22177                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
22178 64F7           8B46         16            mov	ax,$16[bp]
22179 64FA           88E0                       mov	al,ah
22180 64FC           30E4                       xor	ah,ah
22181                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
22182 64FE           3D                   0044  cmp	ax,*$44
22183 6501           74           0C            je  	.4C9
22184                       00006503            .4CA:
22185                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
22186 6503           8B46         16            mov	ax,$16[bp]
22187 6506           88E0                       mov	al,ah
22188 6508           30E4                       xor	ah,ah
22189                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
22190 650A           3D                   0047  cmp	ax,*$47
22191 650D           75           06            jne 	.4C8
22192                       0000650F            .4C9:
22193                                           ! 3525         goto int13_success;
22194 650F           83C4                   0E  add	sp,#..FFEE-..FFEF
22195 6512           E9         07FA            br 	.FFEE
22196                                           !BCC_EOS
22197                                           ! 3526       if ( ( AX >> 8 ) == 0x42 )
22198                       00006515            .4C8:
22199                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
22200 6515           8B46         16            mov	ax,$16[bp]
22201 6518           88E0                       mov	al,ah
22202 651A           30E4                       xor	ah,ah
22203                                           ! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
22204 651C           3D                   0042  cmp	ax,*$42
22205 651F           75           2D            jne 	.4CB
22206                       00006521            .4CC:
22207                                           ! 3527         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba, segment, offset);
22208                                           ! Debug: list unsigned short offset = [S+$24-$12] (used reg = )
22209 6521           FF76         F0            push	-$10[bp]
22210                                           ! Debug: list unsigned short segment = [S+$26-$10] (used reg = )
22211 6524           FF76         F2            push	-$E[bp]
22212                                           ! Debug: list unsigned long lba = [S+$28-6] (used reg = )
22213 6527           FF76         FE            push	-2[bp]
22214 652A           FF76         FC            push	-4[bp]
22215                                           ! Debug: list int = const 0 (used reg = )
22216 652D           31C0                       xor	ax,ax
22217 652F           50                         push	ax
22218                                           ! Debug: list int = const 0 (used reg = )
22219 6530           31C0                       xor	ax,ax
22220 6532           50                         push	ax
22221                                           ! Debug: list int = const 0 (used reg = )
22222 6533           31C0                       xor	ax,ax
22223 6535           50                         push	ax
22224                                           ! Debug: list unsigned short count = [S+$32-$22] (used reg = )
22225 6536           FF76         E0            push	-$20[bp]
22226                                           ! Debug: list int = const $20 (used reg = )
22227 6539           B8                   0020  mov	ax,*$20
22228 653C           50                         push	ax
22229                                           ! Debug: list unsigned char device = [S+$36-$23] (used reg = )
22230 653D           8A46         DF            mov	al,-$21[bp]
22231 6540           30E4                       xor	ah,ah
22232 6542           50                         push	ax
22233                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
22234 6543           E8         C444            call	_ata_cmd_data_in
22235 6546           83C4                   14  add	sp,*$14
22236                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$24-$24] (used reg = )
22237 6549           8846         DE            mov	-$22[bp],al
22238                                           !BCC_EOS
22239                                           ! 3528       else
22240                                           ! 3529         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba, segment, offset);
22241 654C           EB           2B            jmp .4CD
22242                       0000654E            .4CB:
22243                                           ! Debug: list unsigned short offset = [S+$24-$12] (used reg = )
22244 654E           FF76         F0            push	-$10[bp]
22245                                           ! Debug: list unsigned short segment = [S+$26-$10] (used reg = )
22246 6551           FF76         F2            push	-$E[bp]
22247                                           ! Debug: list unsigned long lba = [S+$28-6] (used reg = )
22248 6554           FF76         FE            push	-2[bp]
22249 6557           FF76         FC            push	-4[bp]
22250                                           ! Debug: list int = const 0 (used reg = )
22251 655A           31C0                       xor	ax,ax
22252 655C           50                         push	ax
22253                                           ! Debug: list int = const 0 (used reg = )
22254 655D           31C0                       xor	ax,ax
22255 655F           50                         push	ax
22256                                           ! Debug: list int = const 0 (used reg = )
22257 6560           31C0                       xor	ax,ax
22258 6562           50                         push	ax
22259                                           ! Debug: list unsigned short count = [S+$32-$22] (used reg = )
22260 6563           FF76         E0            push	-$20[bp]
22261                                           ! Debug: list int = const $30 (used reg = )
22262 6566           B8                   0030  mov	ax,*$30
22263 6569           50                         push	ax
22264                                           ! Debug: list unsigned char device = [S+$36-$23] (used reg = )
22265 656A           8A46         DF            mov	al,-$21[bp]
22266 656D           30E4                       xor	ah,ah
22267 656F           50                         push	ax
22268                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
22269 6570           E8         C7A7            call	_ata_cmd_data_out
22270 6573           83C4                   14  add	sp,*$14
22271                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$24-$24] (used reg = )
22272 6576           8846         DE            mov	-$22[bp],al
22273                                           !BCC_EOS
22274                                           ! 3530       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
22275                       00006579            .4CD:
22276                                           ! Debug: list * unsigned short = const $234 (used reg = )
22277 6579           B8                   0234  mov	ax,#$234
22278 657C           50                         push	ax
22279                                           ! Debug: list unsigned short ebda_seg = [S+$26-8] (used reg = )
22280 657D           FF76         FA            push	-6[bp]
22281                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22282 6580           E8         A08E            call	_read_word
22283 6583           83C4                   04  add	sp,*4
22284                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$24-$22] (used reg = )
22285 6586           8946         E0            mov	-$20[bp],ax
22286                                           !BCC_EOS
22287                                           ! 3531       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
22288                                           ! Debug: list unsigned short count = [S+$24-$22] (used reg = )
22289 6589           FF76         E0            push	-$20[bp]
22290                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$26+8] (used reg = )
22291 658C           8B46         0A            mov	ax,$A[bp]
22292                                           ! Debug: list unsigned int = ax+2 (used reg = )
22293 658F           40                         inc	ax
22294 6590           40                         inc	ax
22295 6591           50                         push	ax
22296                                           ! Debug: list unsigned short DS = [S+$28+2] (used reg = )
22297 6592           FF76         04            push	4[bp]
22298                                           ! Debug: func () void = write_word+0 (used reg = )
22299 6595           E8         A0A4            call	_write_word
22300 6598           83C4                   06  add	sp,*6
22301                                           !BCC_EOS
22302                                           ! 3532       if (status != 0) {
22303                                           ! Debug: ne int = const 0 to unsigned char status = [S+$24-$24] (used reg = )
22304 659B           8A46         DE            mov	al,-$22[bp]
22305 659E           84C0                       test	al,al
22306 65A0           74           2D            je  	.4CE
22307                       000065A2            .4CF:
22308                                           ! 3533         bios_printf(4, "int13_harddisk: function %02x, error %02x !\n",( AX >> 8 ),status);
22309                                           ! Debug: list unsigned char status = [S+$24-$24] (used reg = )
22310 65A2           8A46         DE            mov	al,-$22[bp]
22311 65A5           30E4                       xor	ah,ah
22312 65A7           50                         push	ax
22313                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$26+$14] (used reg = )
22314 65A8           8B46         16            mov	ax,$16[bp]
22315 65AB           88E0                       mov	al,ah
22316 65AD           30E4                       xor	ah,ah
22317                                           ! Debug: list unsigned int = ax+0 (used reg = )
22318 65AF           50                         push	ax
22319                                           ! Debug: list * char = .4D0+0 (used reg = )
22320 65B0           BB                   D47A  mov	bx,#.4D0
22321 65B3           53                         push	bx
22322                                           ! Debug: list int = const 4 (used reg = )
22323 65B4           B8                   0004  mov	ax,*4
22324 65B7           50                         push	ax
22325                                           ! Debug: func () void = bios_printf+0 (used reg = )
22326 65B8           E8         A2EE            call	_bios_printf
22327 65BB           83C4                   08  add	sp,*8
22328                                           !BCC_EOS
22329                                           ! 3534         AX = ((AX & 0x00ff) | ((0x0c) << 8));
22330                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
22331 65BE           8A46         16            mov	al,$16[bp]
22332                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
22333 65C1           30E4                       xor	ah,ah
22334 65C3           0D                   0C00  or	ax,#$C00
22335                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$24+$14] (used reg = )
22336 65C6           8946         16            mov	$16[bp],ax
22337                                           !BCC_EOS
22338                                           ! 3535         goto int13_fail_noah;
22339 65C9           83C4                   0E  add	sp,#..FFEB-..FFEF
22340 65CC           E9         071E            br 	.FFEB
22341                                           !BCC_EOS
22342                                           ! 3536         }
22343                                           ! 3537       goto int13_success;
22344                       000065CF            .4CE:
22345 65CF           83C4                   0E  add	sp,#..FFEE-..FFEF
22346 65D2           E9         073A            br 	.FFEE
22347                                           !BCC_EOS
22348                                           ! 3538       break;
22349 65D5           E9         0707            br 	.496
22350                                           !BCC_EOS
22351                                           ! 3539     case 0x45:
22352                                           ! 3540     case 0x49:
22353                       000065D8            .4D1:
22354                                           ! 3541       goto int13_success;
22355                       000065D8            .4D2:
22356 65D8           83C4                   0E  add	sp,#..FFEE-..FFEF
22357 65DB           E9         0731            br 	.FFEE
22358                                           !BCC_EOS
22359                                           ! 3542       break;
22360 65DE           E9         06FE            br 	.496
22361                                           !BCC_EOS
22362                                           ! 3543     case 0x46:
22363                                           ! 3544       AX = ((AX & 0x00ff) | ((0xb2) << 8));
22364                       000065E1            .4D3:
22365                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
22366 65E1           8A46         16            mov	al,$16[bp]
22367                                           ! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
22368 65E4           30E4                       xor	ah,ah
22369 65E6           0D                   B200  or	ax,#-$4E00
22370                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$24+$14] (used reg = )
22371 65E9           8946         16            mov	$16[bp],ax
22372                                           !BCC_EOS
22373                                           ! 3545       goto int13_fail_noah;
22374 65EC           83C4                   0E  add	sp,#..FFEB-..FFEF
22375 65EF           E9         06FB            br 	.FFEB
22376                                           !BCC_EOS
22377                                           ! 3546       break;
22378 65F2           E9         06EA            br 	.496
22379                                           !BCC_EOS
22380                                           ! 3547     case 0x48:
22381                                           ! 3548       size=read_word(DS,SI+(Bit16u)&((dpt_t *) 0)->size);
22382                       000065F5            .4D4:
22383                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$24+8] (used reg = )
22384 65F5           8B46         0A            mov	ax,$A[bp]
22385                                           ! Debug: list unsigned int = ax+0 (used reg = )
22386 65F8           50                         push	ax
22387                                           ! Debug: list unsigned short DS = [S+$26+2] (used reg = )
22388 65F9           FF76         04            push	4[bp]
22389                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22390 65FC           E8         A012            call	_read_word
22391 65FF           83C4                   04  add	sp,*4
22392                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$24-$20] (used reg = )
22393 6602           8946         E2            mov	-$1E[bp],ax
22394                                           !BCC_EOS
22395                                           ! 3549       if(size < 0x1a)
22396                                           ! Debug: lt int = const $1A to unsigned short size = [S+$24-$20] (used reg = )
22397 6605           8B46         E2            mov	ax,-$1E[bp]
22398 6608           3D                   001A  cmp	ax,*$1A
22399 660B           73           06            jae 	.4D5
22400                       0000660D            .4D6:
22401                                           ! 3550         goto int13_fail;
22402 660D           83C4                   0E  add	sp,#..FFF0-..FFEF
22403 6610           E9         06CF            br 	.FFF0
22404                                           !BCC_EOS
22405                                           ! 3551       if(size >= 0x1a) {
22406                       00006613            .4D5:
22407                                           ! Debug: ge int = const $1A to unsigned short size = [S+$24-$20] (used reg = )
22408 6613           8B46         E2            mov	ax,-$1E[bp]
22409 6616           3D                   001A  cmp	ax,*$1A
22410 6619         0F82         013E            blo 	.4D7
22411                       0000661D            .4D8:
22412                                           ! 3552         Bit16u blksize;
22413                                           !BCC_EOS
22414                                           ! 3553         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
22415                                           ! Debug: ptradd unsigned char device = [S+$26-$23] to [8] struct  = const $142 (used reg = )
22416 661D           8A46         DF            mov	al,-$21[bp]
22417 6620           30E4                       xor	ah,ah
22418 6622           B9                   001A  mov	cx,*$1A
22419 6625           F7E9                       imul	cx
22420 6627           89C3                       mov	bx,ax
22421                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
22422                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
22423 6629           81C3                 0154  add	bx,#$154
22424 662D           53                         push	bx
22425                                           ! Debug: list unsigned short ebda_seg = [S+$28-8] (used reg = )
22426 662E           FF76         FA            push	-6[bp]
22427                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22428 6631           E8         9FDD            call	_read_word
22429 6634           83C4                   04  add	sp,*4
22430                                           ! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$26-$14] (used reg = )
22431 6637           8946         EE            mov	-$12[bp],ax
22432                                           !BCC_EOS
22433                                           ! 3554         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
22434                                           ! Debug: ptradd unsigned char device = [S+$26-$23] to [8] struct  = const $142 (used reg = )
22435 663A           8A46         DF            mov	al,-$21[bp]
22436 663D           30E4                       xor	ah,ah
22437 663F           B9                   001A  mov	cx,*$1A
22438 6642           F7E9                       imul	cx
22439 6644           89C3                       mov	bx,ax
22440                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
22441                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
22442 6646           81C3                 0152  add	bx,#$152
22443 664A           53                         push	bx
22444                                           ! Debug: list unsigned short ebda_seg = [S+$28-8] (used reg = )
22445 664B           FF76         FA            push	-6[bp]
22446                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22447 664E           E8         9FC0            call	_read_word
22448 6651           83C4                   04  add	sp,*4
22449                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$26-$16] (used reg = )
22450 6654           8946         EC            mov	-$14[bp],ax
22451                                           !BCC_EOS
22452                                           ! 3555         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
22453                                           ! Debug: ptradd unsigned char device = [S+$26-$23] to [8] struct  = const $142 (used reg = )
22454 6657           8A46         DF            mov	al,-$21[bp]
22455 665A           30E4                       xor	ah,ah
22456 665C           B9                   001A  mov	cx,*$1A
22457 665F           F7E9                       imul	cx
22458 6661           89C3                       mov	bx,ax
22459                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
22460                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
22461 6663           81C3                 0156  add	bx,#$156
22462 6667           53                         push	bx
22463                                           ! Debug: list unsigned short ebda_seg = [S+$28-8] (used reg = )
22464 6668           FF76         FA            push	-6[bp]
22465                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22466 666B           E8         9FA3            call	_read_word
22467 666E           83C4                   04  add	sp,*4
22468                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$26-$18] (used reg = )
22469 6671           8946         EA            mov	-$16[bp],ax
22470                                           !BCC_EOS
22471                                           ! 3556         lba = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors);
22472                                           ! Debug: ptradd unsigned char device = [S+$26-$23] to [8] struct  = const $142 (used reg = )
22473 6674           8A46         DF            mov	al,-$21[bp]
22474 6677           30E4                       xor	ah,ah
22475 6679           B9                   001A  mov	cx,*$1A
22476 667C           F7E9                       imul	cx
22477 667E           89C3                       mov	bx,ax
22478                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
22479                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
22480 6680           81C3                 0158  add	bx,#$158
22481 6684           53                         push	bx
22482                                           ! Debug: list unsigned short ebda_seg = [S+$28-8] (used reg = )
22483 6685           FF76         FA            push	-6[bp]
22484                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
22485 6688           E8         99CA            call	_read_dword
22486 668B           89D3                       mov	bx,dx
22487 668D           83C4                   04  add	sp,*4
22488                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$26-6] (used reg = )
22489 6690           8946         FC            mov	-4[bp],ax
22490 6693           895E         FE            mov	-2[bp],bx
22491                                           !BCC_EOS
22492                                           ! 3557         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
22493                                           ! Debug: ptradd unsigned char device = [S+$26-$23] to [8] struct  = const $142 (used reg = )
22494 6696           8A46         DF            mov	al,-$21[bp]
22495 6699           30E4                       xor	ah,ah
22496 669B           B9                   001A  mov	cx,*$1A
22497 669E           F7E9                       imul	cx
22498 66A0           89C3                       mov	bx,ax
22499                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
22500                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
22501 66A2           81C3                 0148  add	bx,#$148
22502 66A6           53                         push	bx
22503                                           ! Debug: list unsigned short ebda_seg = [S+$28-8] (used reg = )
22504 66A7           FF76         FA            push	-6[bp]
22505                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22506 66AA           E8         9F64            call	_read_word
22507 66AD           83C4                   04  add	sp,*4
22508                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$26-$26] (used reg = )
22509 66B0           8946         DC            mov	-$24[bp],ax
22510                                           !BCC_EOS
22511                                           ! 3558         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
22512                                           ! Debug: list int = const $1A (used reg = )
22513 66B3           B8                   001A  mov	ax,*$1A
22514 66B6           50                         push	ax
22515                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+8] (used reg = )
22516 66B7           8B46         0A            mov	ax,$A[bp]
22517                                           ! Debug: list unsigned int = ax+0 (used reg = )
22518 66BA           50                         push	ax
22519                                           ! Debug: list unsigned short DS = [S+$2A+2] (used reg = )
22520 66BB           FF76         04            push	4[bp]
22521                                           ! Debug: func () void = write_word+0 (used reg = )
22522 66BE           E8         9F7B            call	_write_word
22523 66C1           83C4                   06  add	sp,*6
22524                                           !BCC_EOS
22525                                           ! 3559         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
22526                                           ! Debug: list int = const 2 (used reg = )
22527 66C4           B8                   0002  mov	ax,*2
22528 66C7           50                         push	ax
22529                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+8] (used reg = )
22530 66C8           8B46         0A            mov	ax,$A[bp]
22531                                           ! Debug: list unsigned int = ax+2 (used reg = )
22532 66CB           40                         inc	ax
22533 66CC           40                         inc	ax
22534 66CD           50                         push	ax
22535                                           ! Debug: list unsigned short DS = [S+$2A+2] (used reg = )
22536 66CE           FF76         04            push	4[bp]
22537                                           ! Debug: func () void = write_word+0 (used reg = )
22538 66D1           E8         9F68            call	_write_word
22539 66D4           83C4                   06  add	sp,*6
22540                                           !BCC_EOS
22541                                           ! 3560         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
22542                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$26-$14] (used reg = )
22543 66D7           8B46         EE            mov	ax,-$12[bp]
22544 66DA           31DB                       xor	bx,bx
22545                                           ! Debug: list unsigned long = bx+0 (used reg = )
22546 66DC           53                         push	bx
22547 66DD           50                         push	ax
22548                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2A+8] (used reg = )
22549 66DE           8B46         0A            mov	ax,$A[bp]
22550                                           ! Debug: list unsigned int = ax+4 (used reg = )
22551 66E1           05                   0004  add	ax,*4
22552 66E4           50                         push	ax
22553                                           ! Debug: list unsigned short DS = [S+$2C+2] (used reg = )
22554 66E5           FF76         04            push	4[bp]
22555                                           ! Debug: func () void = write_dword+0 (used reg = )
22556 66E8           E8         9981            call	_write_dword
22557 66EB           83C4                   08  add	sp,*8
22558                                           !BCC_EOS
22559                                           ! 3561         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
22560                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$26-$16] (used reg = )
22561 66EE           8B46         EC            mov	ax,-$14[bp]
22562 66F1           31DB                       xor	bx,bx
22563                                           ! Debug: list unsigned long = bx+0 (used reg = )
22564 66F3           53                         push	bx
22565 66F4           50                         push	ax
22566                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2A+8] (used reg = )
22567 66F5           8B46         0A            mov	ax,$A[bp]
22568                                           ! Debug: list unsigned int = ax+8 (used reg = )
22569 66F8           05                   0008  add	ax,*8
22570 66FB           50                         push	ax
22571                                           ! Debug: list unsigned short DS = [S+$2C+2] (used reg = )
22572 66FC           FF76         04            push	4[bp]
22573                                           ! Debug: func () void = write_dword+0 (used reg = )
22574 66FF           E8         996A            call	_write_dword
22575 6702           83C4                   08  add	sp,*8
22576                                           !BCC_EOS
22577                                           ! 3562         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
22578                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$26-$18] (used reg = )
22579 6705           8B46         EA            mov	ax,-$16[bp]
22580 6708           31DB                       xor	bx,bx
22581                                           ! Debug: list unsigned long = bx+0 (used reg = )
22582 670A           53                         push	bx
22583 670B           50                         push	ax
22584                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2A+8] (used reg = )
22585 670C           8B46         0A            mov	ax,$A[bp]
22586                                           ! Debug: list unsigned int = ax+$C (used reg = )
22587 670F           05                   000C  add	ax,*$C
22588 6712           50                         push	ax
22589                                           ! Debug: list unsigned short DS = [S+$2C+2] (used reg = )
22590 6713           FF76         04            push	4[bp]
22591                                           ! Debug: func () void = write_dword+0 (used reg = )
22592 6716           E8         9953            call	_write_dword
22593 6719           83C4                   08  add	sp,*8
22594                                           !BCC_EOS
22595                                           ! 3563         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba);
22596                                           ! Debug: list unsigned long lba = [S+$26-6] (used reg = )
22597 671C           FF76         FE            push	-2[bp]
22598 671F           FF76         FC            push	-4[bp]
22599                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2A+8] (used reg = )
22600 6722           8B46         0A            mov	ax,$A[bp]
22601                                           ! Debug: list unsigned int = ax+$10 (used reg = )
22602 6725           05                   0010  add	ax,*$10
22603 6728           50                         push	ax
22604                                           ! Debug: list unsigned short DS = [S+$2C+2] (used reg = )
22605 6729           FF76         04            push	4[bp]
22606                                           ! Debug: func () void = write_dword+0 (used reg = )
22607 672C           E8         993D            call	_write_dword
22608 672F           83C4                   08  add	sp,*8
22609                                           !BCC_EOS
22610                                           ! 3564         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0L);
22611                                           ! Debug: list long = const 0 (used reg = )
22612 6732           31C0                       xor	ax,ax
22613 6734           31DB                       xor	bx,bx
22614 6736           53                         push	bx
22615 6737           50                         push	ax
22616                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2A+8] (used reg = )
22617 6738           8B46         0A            mov	ax,$A[bp]
22618                                           ! Debug: list unsigned int = ax+$14 (used reg = )
22619 673B           05                   0014  add	ax,*$14
22620 673E           50                         push	ax
22621                                           ! Debug: list unsigned short DS = [S+$2C+2] (used reg = )
22622 673F           FF76         04            push	4[bp]
22623                                           ! Debug: func () void = write_dword+0 (used reg = )
22624 6742           E8         9927            call	_write_dword
22625 6745           83C4                   08  add	sp,*8
22626                                           !BCC_EOS
22627                                           ! 3565         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
22628                                           ! Debug: list unsigned short blksize = [S+$26-$26] (used reg = )
22629 6748           FF76         DC            push	-$24[bp]
22630                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$28+8] (used reg = )
22631 674B           8B46         0A            mov	ax,$A[bp]
22632                                           ! Debug: list unsigned int = ax+$18 (used reg = )
22633 674E           05                   0018  add	ax,*$18
22634 6751           50                         push	ax
22635                                           ! Debug: list unsigned short DS = [S+$2A+2] (used reg = )
22636 6752           FF76         04            push	4[bp]
22637                                           ! Debug: func () void = write_word+0 (used reg = )
22638 6755           E8         9EE4            call	_write_word
22639 6758           83C4                   06  add	sp,*6
22640                                           !BCC_EOS
22641                                           ! 3566       
22642                                           ! 3566   }
22643                                           ! 3567       if(size >= 0x1e) {
22644                       0000675B            .4D7:
22645                                           ! Debug: ge int = const $1E to unsigned short size = [S+$24-$20] (used reg = )
22646 675B           8B46         E2            mov	ax,-$1E[bp]
22647 675E           3D                   001E  cmp	ax,*$1E
22648 6761         0F82         0244            blo 	.4D9
22649                       00006765            .4DA:
22650                                           ! 3568         Bit8u channel, dev, irq, mode, checksum, i, translation;
22651                                           !BCC_EOS
22652                                           ! 3569         Bit16u iobase1, iobase2, options;
22653                                           !BCC_EOS
22654                                           ! 3570         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
22655                                           ! Debug: list int = const $1E (used reg = )
22656 6765           B8                   001E  mov	ax,*$1E
22657 6768           50                         push	ax
22658                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$34+8] (used reg = )
22659 6769           8B46         0A            mov	ax,$A[bp]
22660                                           ! Debug: list unsigned int = ax+0 (used reg = )
22661 676C           50                         push	ax
22662                                           ! Debug: list unsigned short DS = [S+$36+2] (used reg = )
22663 676D           FF76         04            push	4[bp]
22664                                           ! Debug: func () void = write_word+0 (used reg = )
22665 6770           E8         9EC9            call	_write_word
22666 6773           83C4                   06  add	sp,*6
22667                                           !BCC_EOS
22668                                           ! 3571         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
22669                                           ! Debug: list unsigned short ebda_seg = [S+$32-8] (used reg = )
22670 6776           FF76         FA            push	-6[bp]
22671                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$34+8] (used reg = )
22672 6779           8B46         0A            mov	ax,$A[bp]
22673                                           ! Debug: list unsigned int = ax+$1C (used reg = )
22674 677C           05                   001C  add	ax,*$1C
22675 677F           50                         push	ax
22676                                           ! Debug: list unsigned short DS = [S+$36+2] (used reg = )
22677 6780           FF76         04            push	4[bp]
22678                                           ! Debug: func () void = write_word+0 (used reg = )
22679 6783           E8         9EB6            call	_write_word
22680 6786           83C4                   06  add	sp,*6
22681                                           !BCC_EOS
22682                                           ! 3572         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
22683                                           ! Debug: list * struct  = const $224 (used reg = )
22684 6789           B8                   0224  mov	ax,#$224
22685 678C           50                         push	ax
22686                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$34+8] (used reg = )
22687 678D           8B46         0A            mov	ax,$A[bp]
22688                                           ! Debug: list unsigned int = ax+$1A (used reg = )
22689 6790           05                   001A  add	ax,*$1A
22690 6793           50                         push	ax
22691                                           ! Debug: list unsigned short DS = [S+$36+2] (used reg = )
22692 6794           FF76         04            push	4[bp]
22693                                           ! Debug: func () void = write_word+0 (used reg = )
22694 6797           E8         9EA2            call	_write_word
22695 679A           83C4                   06  add	sp,*6
22696                                           !BCC_EOS
22697                                           ! 3573         channel = device / 2;
22698                                           ! Debug: div int = const 2 to unsigned char device = [S+$32-$23] (used reg = )
22699 679D           8A46         DF            mov	al,-$21[bp]
22700 67A0           30E4                       xor	ah,ah
22701 67A2           D1E8                       shr	ax,*1
22702                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$32-$25] (used reg = )
22703 67A4           8846         DD            mov	-$23[bp],al
22704                                           !BCC_EOS
22705                                           ! 3574         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
22706                                           ! Debug: ptradd unsigned char channel = [S+$32-$25] to [4] struct  = const $122 (used reg = )
22707 67A7           8A46         DD            mov	al,-$23[bp]
22708 67AA           30E4                       xor	ah,ah
22709 67AC           B1                     03  mov	cl,*3
22710 67AE           D3E0                       shl	ax,cl
22711 67B0           89C3                       mov	bx,ax
22712                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
22713                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
22714 67B2           81C3                 0124  add	bx,#$124
22715 67B6           53                         push	bx
22716                                           ! Debug: list unsigned short ebda_seg = [S+$34-8] (used reg = )
22717 67B7           FF76         FA            push	-6[bp]
22718                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22719 67BA           E8         9E54            call	_read_word
22720 67BD           83C4                   04  add	sp,*4
22721                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$32-$2E] (used reg = )
22722 67C0           8946         D4            mov	-$2C[bp],ax
22723                                           !BCC_EOS
22724                                           ! 3575         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
22725                                           ! Debug: ptradd unsigned char channel = [S+$32-$25] to [4] struct  = const $122 (used reg = )
22726 67C3           8A46         DD            mov	al,-$23[bp]
22727 67C6           30E4                       xor	ah,ah
22728 67C8           B1                     03  mov	cl,*3
22729 67CA           D3E0                       shl	ax,cl
22730 67CC           89C3                       mov	bx,ax
22731                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
22732                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
22733 67CE           81C3                 0126  add	bx,#$126
22734 67D2           53                         push	bx
22735                                           ! Debug: list unsigned short ebda_seg = [S+$34-8] (used reg = )
22736 67D3           FF76         FA            push	-6[bp]
22737                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22738 67D6           E8         9E38            call	_read_word
22739 67D9           83C4                   04  add	sp,*4
22740                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$32-$30] (used reg = )
22741 67DC           8946         D2            mov	-$2E[bp],ax
22742                                           !BCC_EOS
22743                                           ! 3576         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
22744                                           ! Debug: ptradd unsigned char channel = [S+$32-$25] to [4] struct  = const $122 (used reg = )
22745 67DF           8A46         DD            mov	al,-$23[bp]
22746 67E2           30E4                       xor	ah,ah
22747 67E4           B1                     03  mov	cl,*3
22748 67E6           D3E0                       shl	ax,cl
22749 67E8           89C3                       mov	bx,ax
22750                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
22751                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
22752 67EA           81C3                 0128  add	bx,#$128
22753 67EE           53                         push	bx
22754                                           ! Debug: list unsigned short ebda_seg = [S+$34-8] (used reg = )
22755 67EF           FF76         FA            push	-6[bp]
22756                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22757 67F2           E8         9E09            call	_read_byte
22758 67F5           83C4                   04  add	sp,*4
22759                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$32-$27] (used reg = )
22760 67F8           8846         DB            mov	-$25[bp],al
22761                                           !BCC_EOS
22762                                           ! 3577         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
22763                                           ! Debug: ptradd unsigned char device = [S+$32-$23] to [8] struct  = const $142 (used reg = )
22764 67FB           8A46         DF            mov	al,-$21[bp]
22765 67FE           30E4                       xor	ah,ah
22766 6800           B9                   001A  mov	cx,*$1A
22767 6803           F7E9                       imul	cx
22768 6805           89C3                       mov	bx,ax
22769                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
22770                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
22771 6807           81C3                 0146  add	bx,#$146
22772 680B           53                         push	bx
22773                                           ! Debug: list unsigned short ebda_seg = [S+$34-8] (used reg = )
22774 680C           FF76         FA            push	-6[bp]
22775                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22776 680F           E8         9DEC            call	_read_byte
22777 6812           83C4                   04  add	sp,*4
22778                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$32-$28] (used reg = )
22779 6815           8846         DA            mov	-$26[bp],al
22780                                           !BCC_EOS
22781                                           ! 3578         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
22782                                           ! Debug: ptradd unsigned char device = [S+$32-$23] to [8] struct  = const $142 (used reg = )
22783 6818           8A46         DF            mov	al,-$21[bp]
22784 681B           30E4                       xor	ah,ah
22785 681D           B9                   001A  mov	cx,*$1A
22786 6820           F7E9                       imul	cx
22787 6822           89C3                       mov	bx,ax
22788                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
22789                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
22790 6824           81C3                 014A  add	bx,#$14A
22791 6828           53                         push	bx
22792                                           ! Debug: list unsigned short ebda_seg = [S+$34-8] (used reg = )
22793 6829           FF76         FA            push	-6[bp]
22794                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22795 682C           E8         9DCF            call	_read_byte
22796 682F           83C4                   04  add	sp,*4
22797                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$32-$2B] (used reg = )
22798 6832           8846         D7            mov	-$29[bp],al
22799                                           !BCC_EOS
22800                                           ! 3579         options = (translation==0?0:1<<3);
22801                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$32-$2B] (used reg = )
22802 6835           8A46         D7            mov	al,-$29[bp]
22803 6838           84C0                       test	al,al
22804 683A           75           04            jne 	.4DB
22805                       0000683C            .4DC:
22806 683C           30C0                       xor	al,al
22807 683E           EB           02            jmp .4DD
22808                       00006840            .4DB:
22809 6840           B0                     08  mov	al,*8
22810                       00006842            .4DD:
22811                                           ! Debug: eq char = al+0 to unsigned short options = [S+$32-$32] (used reg = )
22812 6842           30E4                       xor	ah,ah
22813 6844           8946         D0            mov	-$30[bp],ax
22814                                           !BCC_EOS
22815                                           ! 3580         options |= (1<<4);
22816                                           ! Debug: orab int = const $10 to unsigned short options = [S+$32-$32] (used reg = )
22817 6847           8B46         D0            mov	ax,-$30[bp]
22818 684A           0C                     10  or	al,*$10
22819 684C           8946         D0            mov	-$30[bp],ax
22820                                           !BCC_EOS
22821                                           ! 3581         options |= (mode==0x01?1:0<<7);
22822                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$32-$28] (used reg = )
22823 684F           8A46         DA            mov	al,-$26[bp]
22824 6852           3C                     01  cmp	al,*1
22825 6854           75           04            jne 	.4DE
22826                       00006856            .4DF:
22827 6856           B0                     01  mov	al,*1
22828 6858           EB           02            jmp .4E0
22829                       0000685A            .4DE:
22830 685A           30C0                       xor	al,al
22831                       0000685C            .4E0:
22832                                           ! Debug: orab char = al+0 to unsigned short options = [S+$32-$32] (used reg = )
22833 685C           30E4                       xor	ah,ah
22834 685E           0B46         D0            or	ax,-$30[bp]
22835 6861           8946         D0            mov	-$30[bp],ax
22836                                           !BCC_EOS
22837                                           ! 3582         options |= (translation==1?1:0<<9);
22838                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$32-$2B] (used reg = )
22839 6864           8A46         D7            mov	al,-$29[bp]
22840 6867           3C                     01  cmp	al,*1
22841 6869           75           04            jne 	.4E1
22842                       0000686B            .4E2:
22843 686B           B0                     01  mov	al,*1
22844 686D           EB           02            jmp .4E3
22845                       0000686F            .4E1:
22846 686F           30C0                       xor	al,al
22847                       00006871            .4E3:
22848                                           ! Debug: orab char = al+0 to unsigned short options = [S+$32-$32] (used reg = )
22849 6871           30E4                       xor	ah,ah
22850 6873           0B46         D0            or	ax,-$30[bp]
22851 6876           8946         D0            mov	-$30[bp],ax
22852                                           !BCC_EOS
22853                                           ! 3583         options |= (translation==3?3:0<<9);
22854                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$32-$2B] (used reg = )
22855 6879           8A46         D7            mov	al,-$29[bp]
22856 687C           3C                     03  cmp	al,*3
22857 687E           75           04            jne 	.4E4
22858                       00006880            .4E5:
22859 6880           B0                     03  mov	al,*3
22860 6882           EB           02            jmp .4E6
22861                       00006884            .4E4:
22862 6884           30C0                       xor	al,al
22863                       00006886            .4E6:
22864                                           ! Debug: orab char = al+0 to unsigned short options = [S+$32-$32] (used reg = )
22865 6886           30E4                       xor	ah,ah
22866 6888           0B46         D0            or	ax,-$30[bp]
22867 688B           8946         D0            mov	-$30[bp],ax
22868                                           !BCC_EOS
22869                                           ! 3584         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
22870                                           ! Debug: list unsigned short iobase1 = [S+$32-$2E] (used reg = )
22871 688E           FF76         D4            push	-$2C[bp]
22872                                           ! Debug: list * unsigned short = const $224 (used reg = )
22873 6891           B8                   0224  mov	ax,#$224
22874 6894           50                         push	ax
22875                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
22876 6895           FF76         FA            push	-6[bp]
22877                                           ! Debug: func () void = write_word+0 (used reg = )
22878 6898           E8         9DA1            call	_write_word
22879 689B           83C4                   06  add	sp,*6
22880                                           !BCC_EOS
22881                                           ! 3585         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2);
22882                                           ! Debug: list unsigned short iobase2 = [S+$32-$30] (used reg = )
22883 689E           FF76         D2            push	-$2E[bp]
22884                                           ! Debug: list * unsigned short = const $226 (used reg = )
22885 68A1           B8                   0226  mov	ax,#$226
22886 68A4           50                         push	ax
22887                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
22888 68A5           FF76         FA            push	-6[bp]
22889                                           ! Debug: func () void = write_word+0 (used reg = )
22890 68A8           E8         9D91            call	_write_word
22891 68AB           83C4                   06  add	sp,*6
22892                                           !BCC_EOS
22893                                           ! 3586         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
22894                                           ! Debug: mod int = const 2 to unsigned char device = [S+$32-$23] (used reg = )
22895 68AE           8A46         DF            mov	al,-$21[bp]
22896 68B1           30E4                       xor	ah,ah
22897 68B3           24                     01  and	al,*1
22898                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
22899                                           ! Debug: expression subtree swapping
22900 68B5           0C                     0E  or	al,*$E
22901                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
22902 68B7           30E4                       xor	ah,ah
22903 68B9           B1                     04  mov	cl,*4
22904 68BB           D3E0                       shl	ax,cl
22905                                           ! Debug: list unsigned int = ax+0 (used reg = )
22906 68BD           50                         push	ax
22907                                           ! Debug: list * unsigned char = const $228 (used reg = )
22908 68BE           B8                   0228  mov	ax,#$228
22909 68C1           50                         push	ax
22910                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
22911 68C2           FF76         FA            push	-6[bp]
22912                                           ! Debug: func () void = write_byte+0 (used reg = )
22913 68C5           E8         9D5C            call	_write_byte
22914 68C8           83C4                   06  add	sp,*6
22915                                           !BCC_EOS
22916                                           ! 3587         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
22917                                           ! Debug: list int = const $CB (used reg = )
22918 68CB           B8                   00CB  mov	ax,#$CB
22919 68CE           50                         push	ax
22920                                           ! Debug: list * unsigned char = const $229 (used reg = )
22921 68CF           B8                   0229  mov	ax,#$229
22922 68D2           50                         push	ax
22923                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
22924 68D3           FF76         FA            push	-6[bp]
22925                                           ! Debug: func () void = write_byte+0 (used reg = )
22926 68D6           E8         9D4B            call	_write_byte
22927 68D9           83C4                   06  add	sp,*6
22928                                           !BCC_EOS
22929                                           ! 3588         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
22930                                           ! Debug: list unsigned char irq = [S+$32-$27] (used reg = )
22931 68DC           8A46         DB            mov	al,-$25[bp]
22932 68DF           30E4                       xor	ah,ah
22933 68E1           50                         push	ax
22934                                           ! Debug: list * unsigned char = const $22A (used reg = )
22935 68E2           B8                   022A  mov	ax,#$22A
22936 68E5           50                         push	ax
22937                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
22938 68E6           FF76         FA            push	-6[bp]
22939                                           ! Debug: func () void = write_byte+0 (used reg = )
22940 68E9           E8         9D38            call	_write_byte
22941 68EC           83C4                   06  add	sp,*6
22942                                           !BCC_EOS
22943                                           ! 3589         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
22944                                           ! Debug: list int = const 1 (used reg = )
22945 68EF           B8                   0001  mov	ax,*1
22946 68F2           50                         push	ax
22947                                           ! Debug: list * unsigned char = const $22B (used reg = )
22948 68F3           B8                   022B  mov	ax,#$22B
22949 68F6           50                         push	ax
22950                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
22951 68F7           FF76         FA            push	-6[bp]
22952                                           ! Debug: func () void = write_byte+0 (used reg = )
22953 68FA           E8         9D27            call	_write_byte
22954 68FD           83C4                   06  add	sp,*6
22955                                           !BCC_EOS
22956                                           ! 3590         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
22957                                           ! Debug: list int = const 0 (used reg = )
22958 6900           31C0                       xor	ax,ax
22959 6902           50                         push	ax
22960                                           ! Debug: list * unsigned char = const $22C (used reg = )
22961 6903           B8                   022C  mov	ax,#$22C
22962 6906           50                         push	ax
22963                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
22964 6907           FF76         FA            push	-6[bp]
22965                                           ! Debug: func () void = write_byte+0 (used reg = )
22966 690A           E8         9D17            call	_write_byte
22967 690D           83C4                   06  add	sp,*6
22968                                           !BCC_EOS
22969                                           ! 3591         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
22970                                           ! Debug: list int = const 0 (used reg = )
22971 6910           31C0                       xor	ax,ax
22972 6912           50                         push	ax
22973                                           ! Debug: list * unsigned char = const $22D (used reg = )
22974 6913           B8                   022D  mov	ax,#$22D
22975 6916           50                         push	ax
22976                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
22977 6917           FF76         FA            push	-6[bp]
22978                                           ! Debug: func () void = write_byte+0 (used reg = )
22979 691A           E8         9D07            call	_write_byte
22980 691D           83C4                   06  add	sp,*6
22981                                           !BCC_EOS
22982                                           ! 3592         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
22983                                           ! Debug: list unsigned short options = [S+$32-$32] (used reg = )
22984 6920           FF76         D0            push	-$30[bp]
22985                                           ! Debug: list * unsigned short = const $22E (used reg = )
22986 6923           B8                   022E  mov	ax,#$22E
22987 6926           50                         push	ax
22988                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
22989 6927           FF76         FA            push	-6[bp]
22990                                           ! Debug: func () void = write_word+0 (used reg = )
22991 692A           E8         9D0F            call	_write_word
22992 692D           83C4                   06  add	sp,*6
22993                                           !BCC_EOS
22994                                           ! 3593         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
22995                                           ! Debug: list int = const 0 (used reg = )
22996 6930           31C0                       xor	ax,ax
22997 6932           50                         push	ax
22998                                           ! Debug: list * unsigned short = const $230 (used reg = )
22999 6933           B8                   0230  mov	ax,#$230
23000 6936           50                         push	ax
23001                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
23002 6937           FF76         FA            push	-6[bp]
23003                                           ! Debug: func () void = write_word+0 (used reg = )
23004 693A           E8         9CFF            call	_write_word
23005 693D           83C4                   06  add	sp,*6
23006                                           !BCC_EOS
23007                                           ! 3594         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
23008                                           ! Debug: list int = const $11 (used reg = )
23009 6940           B8                   0011  mov	ax,*$11
23010 6943           50                         push	ax
23011                                           ! Debug: list * unsigned char = const $232 (used reg = )
23012 6944           B8                   0232  mov	ax,#$232
23013 6947           50                         push	ax
23014                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
23015 6948           FF76         FA            push	-6[bp]
23016                                           ! Debug: func () void = write_byte+0 (used reg = )
23017 694B           E8         9CD6            call	_write_byte
23018 694E           83C4                   06  add	sp,*6
23019                                           !BCC_EOS
23020                                           ! 3595         checksum=0;
23021                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$32-$29] (used reg = )
23022 6951           30C0                       xor	al,al
23023 6953           8846         D9            mov	-$27[bp],al
23024                                           !BCC_EOS
23025                                           ! 3596         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, (&((ebda_data_t *) 0)->ata.dpte) + i);
23026                                           ! Debug: eq int = const 0 to unsigned char i = [S+$32-$2A] (used reg = )
23027 6956           30C0                       xor	al,al
23028 6958           8846         D8            mov	-$28[bp],al
23029                                           !BCC_EOS
23030                                           !BCC_EOS
23031 695B           EB           28            jmp .4E9
23032                       0000695D            .4EA:
23033                                           ! Debug: ptradd unsigned char i = [S+$32-$2A] to * struct  = const $224 (used reg = )
23034 695D           8A46         D8            mov	al,-$28[bp]
23035 6960           30E4                       xor	ah,ah
23036 6962           B1                     04  mov	cl,*4
23037 6964           D3E0                       shl	ax,cl
23038                                           ! Debug: list * struct  = ax+$224 (used reg = )
23039 6966           05                   0224  add	ax,#$224
23040 6969           50                         push	ax
23041                                           ! Debug: list unsigned short ebda_seg = [S+$34-8] (used reg = )
23042 696A           FF76         FA            push	-6[bp]
23043                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23044 696D           E8         9C8E            call	_read_byte
23045 6970           83C4                   04  add	sp,*4
23046                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$32-$29] (used reg = )
23047 6973           30E4                       xor	ah,ah
23048 6975           0246         D9            add	al,-$27[bp]
23049 6978           80D4                   00  adc	ah,*0
23050 697B           8846         D9            mov	-$27[bp],al
23051                                           !BCC_EOS
23052                                           ! 3597         checksum = ~checksum;
23053                       0000697E            .4E8:
23054                                           ! Debug: postinc unsigned char i = [S+$32-$2A] (used reg = )
23055 697E           8A46         D8            mov	al,-$28[bp]
23056 6981           40                         inc	ax
23057 6982           8846         D8            mov	-$28[bp],al
23058                       00006985            .4E9:
23059                                           ! Debug: lt int = const $F to unsigned char i = [S+$32-$2A] (used reg = )
23060 6985           8A46         D8            mov	al,-$28[bp]
23061 6988           3C                     0F  cmp	al,*$F
23062 698A           72           D1            jb 	.4EA
23063                       0000698C            .4EB:
23064                       0000698C            .4E7:
23065                                           ! Debug: not unsigned char checksum = [S+$32-$29] (used reg = )
23066 698C           8A46         D9            mov	al,-$27[bp]
23067 698F           30E4                       xor	ah,ah
23068 6991           F7D0                       not	ax
23069                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$32-$29] (used reg = )
23070 6993           8846         D9            mov	-$27[bp],al
23071                                           !BCC_EOS
23072                                           ! 3598       
23073                                           ! 3598   write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
23074                                           ! Debug: list unsigned char checksum = [S+$32-$29] (used reg = )
23075 6996           8A46         D9            mov	al,-$27[bp]
23076 6999           30E4                       xor	ah,ah
23077 699B           50                         push	ax
23078                                           ! Debug: list * unsigned char = const $233 (used reg = )
23079 699C           B8                   0233  mov	ax,#$233
23080 699F           50                         push	ax
23081                                           ! Debug: list unsigned short ebda_seg = [S+$36-8] (used reg = )
23082 69A0           FF76         FA            push	-6[bp]
23083                                           ! Debug: func () void = write_byte+0 (used reg = )
23084 69A3           E8         9C7E            call	_write_byte
23085 69A6           83C4                   06  add	sp,*6
23086                                           !BCC_EOS
23087                                           ! 3599         }
23088                                           ! 3600       if(size >= 0x42) {
23089                       000069A9            .4D9:
23090                                           ! Debug: ge int = const $42 to unsigned short size = [S+$24-$20] (used reg = )
23091 69A9           8B46         E2            mov	ax,-$1E[bp]
23092 69AC           3D                   0042  cmp	ax,*$42
23093 69AF         0F82         023B            blo 	.4EC
23094                       000069B3            .4ED:
23095                                           ! 3601         Bit8u channel, iface, checksum, i;
23096                                           !BCC_EOS
23097                                           ! 3602         Bit16u iobase1;
23098                                           !BCC_EOS
23099                                           ! 3603         channel = device / 2;
23100                                           ! Debug: div int = const 2 to unsigned char device = [S+$2A-$23] (used reg = )
23101 69B3           8A46         DF            mov	al,-$21[bp]
23102 69B6           30E4                       xor	ah,ah
23103 69B8           D1E8                       shr	ax,*1
23104                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2A-$25] (used reg = )
23105 69BA           8846         DD            mov	-$23[bp],al
23106                                           !BCC_EOS
23107                                           ! 3604         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
23108                                           ! Debug: ptradd unsigned char channel = [S+$2A-$25] to [4] struct  = const $122 (used reg = )
23109 69BD           8A46         DD            mov	al,-$23[bp]
23110 69C0           30E4                       xor	ah,ah
23111 69C2           B1                     03  mov	cl,*3
23112 69C4           D3E0                       shl	ax,cl
23113 69C6           89C3                       mov	bx,ax
23114                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
23115                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
23116 69C8           81C3                 0122  add	bx,#$122
23117 69CC           53                         push	bx
23118                                           ! Debug: list unsigned short ebda_seg = [S+$2C-8] (used reg = )
23119 69CD           FF76         FA            push	-6[bp]
23120                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23121 69D0           E8         9C2B            call	_read_byte
23122 69D3           83C4                   04  add	sp,*4
23123                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2A-$26] (used reg = )
23124 69D6           8846         DC            mov	-$24[bp],al
23125                                           !BCC_EOS
23126                                           ! 3605         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
23127                                           ! Debug: ptradd unsigned char channel = [S+$2A-$25] to [4] struct  = const $122 (used reg = )
23128 69D9           8A46         DD            mov	al,-$23[bp]
23129 69DC           30E4                       xor	ah,ah
23130 69DE           B1                     03  mov	cl,*3
23131 69E0           D3E0                       shl	ax,cl
23132 69E2           89C3                       mov	bx,ax
23133                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
23134                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
23135 69E4           81C3                 0124  add	bx,#$124
23136 69E8           53                         push	bx
23137                                           ! Debug: list unsigned short ebda_seg = [S+$2C-8] (used reg = )
23138 69E9           FF76         FA            push	-6[bp]
23139                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23140 69EC           E8         9C22            call	_read_word
23141 69EF           83C4                   04  add	sp,*4
23142                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2A-$2A] (used reg = )
23143 69F2           8946         D8            mov	-$28[bp],ax
23144                                           !BCC_EOS
23145                                           ! 3606         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
23146                                           ! Debug: list int = const $42 (used reg = )
23147 69F5           B8                   0042  mov	ax,*$42
23148 69F8           50                         push	ax
23149                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+8] (used reg = )
23150 69F9           8B46         0A            mov	ax,$A[bp]
23151                                           ! Debug: list unsigned int = ax+0 (used reg = )
23152 69FC           50                         push	ax
23153                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23154 69FD           FF76         04            push	4[bp]
23155                                           ! Debug: func () void = write_word+0 (used reg = )
23156 6A00           E8         9C39            call	_write_word
23157 6A03           83C4                   06  add	sp,*6
23158                                           !BCC_EOS
23159                                           ! 3607         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
23160                                           ! Debug: list unsigned int = const $BEDD (used reg = )
23161 6A06           B8                   BEDD  mov	ax,#$BEDD
23162 6A09           50                         push	ax
23163                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2C+8] (used reg = )
23164 6A0A           8B46         0A            mov	ax,$A[bp]
23165                                           ! Debug: list unsigned int = ax+$1E (used reg = )
23166 6A0D           05                   001E  add	ax,*$1E
23167 6A10           50                         push	ax
23168                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23169 6A11           FF76         04            push	4[bp]
23170                                           ! Debug: func () void = write_word+0 (used reg = )
23171 6A14           E8         9C25            call	_write_word
23172 6A17           83C4                   06  add	sp,*6
23173                                           !BCC_EOS
23174                                           ! 3608         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
23175                                           ! Debug: list int = const $24 (used reg = )
23176 6A1A           B8                   0024  mov	ax,*$24
23177 6A1D           50                         push	ax
23178                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2C+8] (used reg = )
23179 6A1E           8B46         0A            mov	ax,$A[bp]
23180                                           ! Debug: list unsigned int = ax+$20 (used reg = )
23181 6A21           05                   0020  add	ax,*$20
23182 6A24           50                         push	ax
23183                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23184 6A25           FF76         04            push	4[bp]
23185                                           ! Debug: func () void = write_byte+0 (used reg = )
23186 6A28           E8         9BF9            call	_write_byte
23187 6A2B           83C4                   06  add	sp,*6
23188                                           !BCC_EOS
23189                                           ! 3609         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
23190                                           ! Debug: list int = const 0 (used reg = )
23191 6A2E           31C0                       xor	ax,ax
23192 6A30           50                         push	ax
23193                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2C+8] (used reg = )
23194 6A31           8B46         0A            mov	ax,$A[bp]
23195                                           ! Debug: list unsigned int = ax+$21 (used reg = )
23196 6A34           05                   0021  add	ax,*$21
23197 6A37           50                         push	ax
23198                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23199 6A38           FF76         04            push	4[bp]
23200                                           ! Debug: func () void = write_byte+0 (used reg = )
23201 6A3B           E8         9BE6            call	_write_byte
23202 6A3E           83C4                   06  add	sp,*6
23203                                           !BCC_EOS
23204                                           ! 3610         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
23205                                           ! Debug: list int = const 0 (used reg = )
23206 6A41           31C0                       xor	ax,ax
23207 6A43           50                         push	ax
23208                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2C+8] (used reg = )
23209 6A44           8B46         0A            mov	ax,$A[bp]
23210                                           ! Debug: list unsigned int = ax+$22 (used reg = )
23211 6A47           05                   0022  add	ax,*$22
23212 6A4A           50                         push	ax
23213                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23214 6A4B           FF76         04            push	4[bp]
23215                                           ! Debug: func () void = write_word+0 (used reg = )
23216 6A4E           E8         9BEB            call	_write_word
23217 6A51           83C4                   06  add	sp,*6
23218                                           !BCC_EOS
23219                                           ! 3611         if (iface==0x00) {
23220                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2A-$26] (used reg = )
23221 6A54           8A46         DC            mov	al,-$24[bp]
23222 6A57           84C0                       test	al,al
23223 6A59           75           51            jne 	.4EE
23224                       00006A5B            .4EF:
23225                                           ! 3612           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
23226                                           ! Debug: list int = const $49 (used reg = )
23227 6A5B           B8                   0049  mov	ax,*$49
23228 6A5E           50                         push	ax
23229                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2C+8] (used reg = )
23230 6A5F           8B46         0A            mov	ax,$A[bp]
23231                                           ! Debug: list unsigned int = ax+$24 (used reg = )
23232 6A62           05                   0024  add	ax,*$24
23233 6A65           50                         push	ax
23234                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23235 6A66           FF76         04            push	4[bp]
23236                                           ! Debug: func () void = write_byte+0 (used reg = )
23237 6A69           E8         9BB8            call	_write_byte
23238 6A6C           83C4                   06  add	sp,*6
23239                                           !BCC_EOS
23240                                           ! 3613           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
23241                                           ! Debug: list int = const $53 (used reg = )
23242 6A6F           B8                   0053  mov	ax,*$53
23243 6A72           50                         push	ax
23244                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2C+8] (used reg = )
23245 6A73           8B46         0A            mov	ax,$A[bp]
23246                                           ! Debug: list unsigned int = ax+$25 (used reg = )
23247 6A76           05                   0025  add	ax,*$25
23248 6A79           50                         push	ax
23249                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23250 6A7A           FF76         04            push	4[bp]
23251                                           ! Debug: func () void = write_byte+0 (used reg = )
23252 6A7D           E8         9BA4            call	_write_byte
23253 6A80           83C4                   06  add	sp,*6
23254                                           !BCC_EOS
23255                                           ! 3614           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
23256                                           ! Debug: list int = const $41 (used reg = )
23257 6A83           B8                   0041  mov	ax,*$41
23258 6A86           50                         push	ax
23259                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2C+8] (used reg = )
23260 6A87           8B46         0A            mov	ax,$A[bp]
23261                                           ! Debug: list unsigned int = ax+$26 (used reg = )
23262 6A8A           05                   0026  add	ax,*$26
23263 6A8D           50                         push	ax
23264                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23265 6A8E           FF76         04            push	4[bp]
23266                                           ! Debug: func () void = write_byte+0 (used reg = )
23267 6A91           E8         9B90            call	_write_byte
23268 6A94           83C4                   06  add	sp,*6
23269                                           !BCC_EOS
23270                                           ! 3615           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
23271                                           ! Debug: list int = const 0 (used reg = )
23272 6A97           31C0                       xor	ax,ax
23273 6A99           50                         push	ax
23274                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2C+8] (used reg = )
23275 6A9A           8B46         0A            mov	ax,$A[bp]
23276                                           ! Debug: list unsigned int = ax+$27 (used reg = )
23277 6A9D           05                   0027  add	ax,*$27
23278 6AA0           50                         push	ax
23279                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23280 6AA1           FF76         04            push	4[bp]
23281                                           ! Debug: func () void = write_byte+0 (used reg = )
23282 6AA4           E8         9B7D            call	_write_byte
23283 6AA7           83C4                   06  add	sp,*6
23284                                           !BCC_EOS
23285                                           ! 3616           }
23286                                           ! 3617         else {
23287 6AAA           EB           00            jmp .4F0
23288                       00006AAC            .4EE:
23289                                           ! 3618           }
23290                                           ! 3619         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
23291                       00006AAC            .4F0:
23292                                           ! Debug: list int = const $41 (used reg = )
23293 6AAC           B8                   0041  mov	ax,*$41
23294 6AAF           50                         push	ax
23295                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2C+8] (used reg = )
23296 6AB0           8B46         0A            mov	ax,$A[bp]
23297                                           ! Debug: list unsigned int = ax+$28 (used reg = )
23298 6AB3           05                   0028  add	ax,*$28
23299 6AB6           50                         push	ax
23300                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23301 6AB7           FF76         04            push	4[bp]
23302                                           ! Debug: func () void = write_byte+0 (used reg = )
23303 6ABA           E8         9B67            call	_write_byte
23304 6ABD           83C4                   06  add	sp,*6
23305                                           !BCC_EOS
23306                                           ! 3620         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
23307                                           ! Debug: list int = const $54 (used reg = )
23308 6AC0           B8                   0054  mov	ax,*$54
23309 6AC3           50                         push	ax
23310                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2C+8] (used reg = )
23311 6AC4           8B46         0A            mov	ax,$A[bp]
23312                                           ! Debug: list unsigned int = ax+$29 (used reg = )
23313 6AC7           05                   0029  add	ax,*$29
23314 6ACA           50                         push	ax
23315                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23316 6ACB           FF76         04            push	4[bp]
23317                                           ! Debug: func () void = write_byte+0 (used reg = )
23318 6ACE           E8         9B53            call	_write_byte
23319 6AD1           83C4                   06  add	sp,*6
23320                                           !BCC_EOS
23321                                           ! 3621         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
23322                                           ! Debug: list int = const $41 (used reg = )
23323 6AD4           B8                   0041  mov	ax,*$41
23324 6AD7           50                         push	ax
23325                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2C+8] (used reg = )
23326 6AD8           8B46         0A            mov	ax,$A[bp]
23327                                           ! Debug: list unsigned int = ax+$2A (used reg = )
23328 6ADB           05                   002A  add	ax,*$2A
23329 6ADE           50                         push	ax
23330                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23331 6ADF           FF76         04            push	4[bp]
23332                                           ! Debug: func () void = write_byte+0 (used reg = )
23333 6AE2           E8         9B3F            call	_write_byte
23334 6AE5           83C4                   06  add	sp,*6
23335                                           !BCC_EOS
23336                                           ! 3622         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
23337                                           ! Debug: list int = const 0 (used reg = )
23338 6AE8           31C0                       xor	ax,ax
23339 6AEA           50                         push	ax
23340                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2C+8] (used reg = )
23341 6AEB           8B46         0A            mov	ax,$A[bp]
23342                                           ! Debug: list unsigned int = ax+$2B (used reg = )
23343 6AEE           05                   002B  add	ax,*$2B
23344 6AF1           50                         push	ax
23345                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23346 6AF2           FF76         04            push	4[bp]
23347                                           ! Debug: func () void = write_byte+0 (used reg = )
23348 6AF5           E8         9B2C            call	_write_byte
23349 6AF8           83C4                   06  add	sp,*6
23350                                           !BCC_EOS
23351                                           ! 3623         if (iface==0x00) {
23352                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2A-$26] (used reg = )
23353 6AFB           8A46         DC            mov	al,-$24[bp]
23354 6AFE           84C0                       test	al,al
23355 6B00           75           3E            jne 	.4F1
23356                       00006B02            .4F2:
23357                                           ! 3624           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
23358                                           ! Debug: list unsigned short iobase1 = [S+$2A-$2A] (used reg = )
23359 6B02           FF76         D8            push	-$28[bp]
23360                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2C+8] (used reg = )
23361 6B05           8B46         0A            mov	ax,$A[bp]
23362                                           ! Debug: list unsigned int = ax+$30 (used reg = )
23363 6B08           05                   0030  add	ax,*$30
23364 6B0B           50                         push	ax
23365                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23366 6B0C           FF76         04            push	4[bp]
23367                                           ! Debug: func () void = write_word+0 (used reg = )
23368 6B0F           E8         9B2A            call	_write_word
23369 6B12           83C4                   06  add	sp,*6
23370                                           !BCC_EOS
23371                                           ! 3625           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
23372                                           ! Debug: list int = const 0 (used reg = )
23373 6B15           31C0                       xor	ax,ax
23374 6B17           50                         push	ax
23375                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2C+8] (used reg = )
23376 6B18           8B46         0A            mov	ax,$A[bp]
23377                                           ! Debug: list unsigned int = ax+$32 (used reg = )
23378 6B1B           05                   0032  add	ax,*$32
23379 6B1E           50                         push	ax
23380                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23381 6B1F           FF76         04            push	4[bp]
23382                                           ! Debug: func () void = write_word+0 (used reg = )
23383 6B22           E8         9B17            call	_write_word
23384 6B25           83C4                   06  add	sp,*6
23385                                           !BCC_EOS
23386                                           ! 3626           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
23387                                           ! Debug: list long = const 0 (used reg = )
23388 6B28           31C0                       xor	ax,ax
23389 6B2A           31DB                       xor	bx,bx
23390 6B2C           53                         push	bx
23391 6B2D           50                         push	ax
23392                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2E+8] (used reg = )
23393 6B2E           8B46         0A            mov	ax,$A[bp]
23394                                           ! Debug: list unsigned int = ax+$34 (used reg = )
23395 6B31           05                   0034  add	ax,*$34
23396 6B34           50                         push	ax
23397                                           ! Debug: list unsigned short DS = [S+$30+2] (used reg = )
23398 6B35           FF76         04            push	4[bp]
23399                                           ! Debug: func () void = write_dword+0 (used reg = )
23400 6B38           E8         9531            call	_write_dword
23401 6B3B           83C4                   08  add	sp,*8
23402                                           !BCC_EOS
23403                                           ! 3627           }
23404                                           ! 3628         else {
23405 6B3E           EB           00            jmp .4F3
23406                       00006B40            .4F1:
23407                                           ! 3629           }
23408                                           ! 3630         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
23409                       00006B40            .4F3:
23410                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2A-$23] (used reg = )
23411 6B40           8A46         DF            mov	al,-$21[bp]
23412 6B43           30E4                       xor	ah,ah
23413 6B45           24                     01  and	al,*1
23414                                           ! Debug: list unsigned char = al+0 (used reg = )
23415 6B47           30E4                       xor	ah,ah
23416 6B49           50                         push	ax
23417                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2C+8] (used reg = )
23418 6B4A           8B46         0A            mov	ax,$A[bp]
23419                                           ! Debug: list unsigned int = ax+$38 (used reg = )
23420 6B4D           05                   0038  add	ax,*$38
23421 6B50           50                         push	ax
23422                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23423 6B51           FF76         04            push	4[bp]
23424                                           ! Debug: func () void = write_byte+0 (used reg = )
23425 6B54           E8         9ACD            call	_write_byte
23426 6B57           83C4                   06  add	sp,*6
23427                                           !BCC_EOS
23428                                           ! 3631         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
23429                                           ! Debug: list int = const 0 (used reg = )
23430 6B5A           31C0                       xor	ax,ax
23431 6B5C           50                         push	ax
23432                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2C+8] (used reg = )
23433 6B5D           8B46         0A            mov	ax,$A[bp]
23434                                           ! Debug: list unsigned int = ax+$39 (used reg = )
23435 6B60           05                   0039  add	ax,*$39
23436 6B63           50                         push	ax
23437                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23438 6B64           FF76         04            push	4[bp]
23439                                           ! Debug: func () void = write_byte+0 (used reg = )
23440 6B67           E8         9ABA            call	_write_byte
23441 6B6A           83C4                   06  add	sp,*6
23442                                           !BCC_EOS
23443                                           ! 3632         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
23444                                           ! Debug: list int = const 0 (used reg = )
23445 6B6D           31C0                       xor	ax,ax
23446 6B6F           50                         push	ax
23447                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2C+8] (used reg = )
23448 6B70           8B46         0A            mov	ax,$A[bp]
23449                                           ! Debug: list unsigned int = ax+$3A (used reg = )
23450 6B73           05                   003A  add	ax,*$3A
23451 6B76           50                         push	ax
23452                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23453 6B77           FF76         04            push	4[bp]
23454                                           ! Debug: func () void = write_word+0 (used reg = )
23455 6B7A           E8         9ABF            call	_write_word
23456 6B7D           83C4                   06  add	sp,*6
23457                                           !BCC_EOS
23458                                           ! 3633         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
23459                                           ! Debug: list long = const 0 (used reg = )
23460 6B80           31C0                       xor	ax,ax
23461 6B82           31DB                       xor	bx,bx
23462 6B84           53                         push	bx
23463 6B85           50                         push	ax
23464                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2E+8] (used reg = )
23465 6B86           8B46         0A            mov	ax,$A[bp]
23466                                           ! Debug: list unsigned int = ax+$3C (used reg = )
23467 6B89           05                   003C  add	ax,*$3C
23468 6B8C           50                         push	ax
23469                                           ! Debug: list unsigned short DS = [S+$30+2] (used reg = )
23470 6B8D           FF76         04            push	4[bp]
23471                                           ! Debug: func () void = write_dword+0 (used reg = )
23472 6B90           E8         94D9            call	_write_dword
23473 6B93           83C4                   08  add	sp,*8
23474                                           !BCC_EOS
23475                                           ! 3634         checksum=0;
23476                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2A-$27] (used reg = )
23477 6B96           30C0                       xor	al,al
23478 6B98           8846         DB            mov	-$25[bp],al
23479                                           !BCC_EOS
23480                                           ! 3635         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
23481                                           ! Debug: eq int = const $1E to unsigned char i = [S+$2A-$28] (used reg = )
23482 6B9B           B0                     1E  mov	al,*$1E
23483 6B9D           8846         DA            mov	-$26[bp],al
23484                                           !BCC_EOS
23485                                           !BCC_EOS
23486 6BA0           EB           25            jmp .4F6
23487                       00006BA2            .4F7:
23488                                           ! Debug: add unsigned char i = [S+$2A-$28] to unsigned short SI = [S+$2A+8] (used reg = )
23489 6BA2           8B46         0A            mov	ax,$A[bp]
23490 6BA5           0246         DA            add	al,-$26[bp]
23491 6BA8           80D4                   00  adc	ah,*0
23492                                           ! Debug: list unsigned int = ax+0 (used reg = )
23493 6BAB           50                         push	ax
23494                                           ! Debug: list unsigned short DS = [S+$2C+2] (used reg = )
23495 6BAC           FF76         04            push	4[bp]
23496                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23497 6BAF           E8         9A4C            call	_read_byte
23498 6BB2           83C4                   04  add	sp,*4
23499                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2A-$27] (used reg = )
23500 6BB5           30E4                       xor	ah,ah
23501 6BB7           0246         DB            add	al,-$25[bp]
23502 6BBA           80D4                   00  adc	ah,*0
23503 6BBD           8846         DB            mov	-$25[bp],al
23504                                           !BCC_EOS
23505                                           ! 3636         checksum = ~checksum;
23506                       00006BC0            .4F5:
23507                                           ! Debug: postinc unsigned char i = [S+$2A-$28] (used reg = )
23508 6BC0           8A46         DA            mov	al,-$26[bp]
23509 6BC3           40                         inc	ax
23510 6BC4           8846         DA            mov	-$26[bp],al
23511                       00006BC7            .4F6:
23512                                           ! Debug: lt int = const $40 to unsigned char i = [S+$2A-$28] (used reg = )
23513 6BC7           8A46         DA            mov	al,-$26[bp]
23514 6BCA           3C                     40  cmp	al,*$40
23515 6BCC           72           D4            jb 	.4F7
23516                       00006BCE            .4F8:
23517                       00006BCE            .4F4:
23518                                           ! Debug: not unsigned char checksum = [S+$2A-$27] (used reg = )
23519 6BCE           8A46         DB            mov	al,-$25[bp]
23520 6BD1           30E4                       xor	ah,ah
23521 6BD3           F7D0                       not	ax
23522                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2A-$27] (used reg = )
23523 6BD5           8846         DB            mov	-$25[bp],al
23524                                           !BCC_EOS
23525                                           ! 3637         write_by
23526                                           ! 3637 te(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
23527                                           ! Debug: list unsigned char checksum = [S+$2A-$27] (used reg = )
23528 6BD8           8A46         DB            mov	al,-$25[bp]
23529 6BDB           30E4                       xor	ah,ah
23530 6BDD           50                         push	ax
23531                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2C+8] (used reg = )
23532 6BDE           8B46         0A            mov	ax,$A[bp]
23533                                           ! Debug: list unsigned int = ax+$41 (used reg = )
23534 6BE1           05                   0041  add	ax,*$41
23535 6BE4           50                         push	ax
23536                                           ! Debug: list unsigned short DS = [S+$2E+2] (used reg = )
23537 6BE5           FF76         04            push	4[bp]
23538                                           ! Debug: func () void = write_byte+0 (used reg = )
23539 6BE8           E8         9A39            call	_write_byte
23540 6BEB           83C4                   06  add	sp,*6
23541                                           !BCC_EOS
23542                                           ! 3638         }
23543                                           ! 3639       goto int13_success;
23544                       00006BEE            .4EC:
23545 6BEE           83C4                   0E  add	sp,#..FFEE-..FFEF
23546 6BF1           E9         011B            br 	.FFEE
23547                                           !BCC_EOS
23548                                           ! 3640       break;
23549 6BF4           E9         00E8            br 	.496
23550                                           !BCC_EOS
23551                                           ! 3641     case 0x4e:
23552                                           ! 3642       switch (( AX & 0x00ff )) {
23553                       00006BF7            .4F9:
23554                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
23555 6BF7           8A46         16            mov	al,$16[bp]
23556 6BFA           EB           10            jmp .4FC
23557                                           ! 3643         case 0x01:
23558                                           ! 3644         case 0x03:
23559                       00006BFC            .4FD:
23560                                           ! 3645         case 0x04:
23561                       00006BFC            .4FE:
23562                                           ! 3646         case 0x06:
23563                       00006BFC            .4FF:
23564                                           ! 3647           goto int13_success;
23565                       00006BFC            .500:
23566 6BFC           83C4                   0E  add	sp,#..FFEE-..FFEF
23567 6BFF           E9         010D            br 	.FFEE
23568                                           !BCC_EOS
23569                                           ! 3648           break;
23570 6C02           EB           1A            jmp .4FA
23571                                           !BCC_EOS
23572                                           ! 3649         default :
23573                                           ! 3650           goto int13_fail;
23574                       00006C04            .501:
23575 6C04           83C4                   0E  add	sp,#..FFF0-..FFEF
23576 6C07           E9         00D8            br 	.FFF0
23577                                           !BCC_EOS
23578                                           ! 3651         }
23579                                           ! 3652       break;
23580 6C0A           EB           12            jmp .4FA
23581                       00006C0C            .4FC:
23582 6C0C           2C                     01  sub	al,*1
23583 6C0E           74           EC            je 	.4FD
23584 6C10           2C                     02  sub	al,*2
23585 6C12           74           E8            je 	.4FE
23586 6C14           2C                     01  sub	al,*1
23587 6C16           74           E4            je 	.4FF
23588 6C18           2C                     02  sub	al,*2
23589 6C1A           74           E0            je 	.500
23590 6C1C           EB           E6            jmp	.501
23591                       00006C1E            .4FA:
23592 6C1E           E9         00BE            br 	.496
23593                                           !BCC_EOS
23594                                           ! 3653     case 0x09:
23595                                           ! 3654     case 0x0c:
23596                       00006C21            .502:
23597                                           ! 3655     case 0x0d:
23598                       00006C21            .503:
23599                                           ! 3656     case 0x11:
23600                       00006C21            .504:
23601                                           ! 3657     case 0x14:
23602                       00006C21            .505:
23603                                           ! 3658       bios_printf(4, "int13h_harddisk function %02xh unimplemented, returns success\n", ( AX >> 8 ));
23604                       00006C21            .506:
23605                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
23606 6C21           8B46         16            mov	ax,$16[bp]
23607 6C24           88E0                       mov	al,ah
23608 6C26           30E4                       xor	ah,ah
23609                                           ! Debug: list unsigned int = ax+0 (used reg = )
23610 6C28           50                         push	ax
23611                                           ! Debug: list * char = .507+0 (used reg = )
23612 6C29           BB                   D43B  mov	bx,#.507
23613 6C2C           53                         push	bx
23614                                           ! Debug: list int = const 4 (used reg = )
23615 6C2D           B8                   0004  mov	ax,*4
23616 6C30           50                         push	ax
23617                                           ! Debug: func () void = bios_printf+0 (used reg = )
23618 6C31           E8         9C75            call	_bios_printf
23619 6C34           83C4                   06  add	sp,*6
23620                                           !BCC_EOS
23621                                           ! 3659       goto int13_success;
23622 6C37           83C4                   0E  add	sp,#..FFEE-..FFEF
23623 6C3A           E9         00D2            br 	.FFEE
23624                                           !BCC_EOS
23625                                           ! 3660       break;
23626 6C3D           E9         009F            br 	.496
23627                                           !BCC_EOS
23628                                           ! 3661     case 0x0a:
23629                                           ! 3662     case 0x0b:
23630                       00006C40            .508:
23631                                           ! 3663     case 0x18:
23632                       00006C40            .509:
23633                                           ! 3664     case 0x50:
23634                       00006C40            .50A:
23635                                           ! 3665     default:
23636                       00006C40            .50B:
23637                                           ! 3666       bios_printf(4, "int13_harddisk function %02xh unsupported, returns fail\n", ( AX >> 8 ));
23638                       00006C40            .50C:
23639                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
23640 6C40           8B46         16            mov	ax,$16[bp]
23641 6C43           88E0                       mov	al,ah
23642 6C45           30E4                       xor	ah,ah
23643                                           ! Debug: list unsigned int = ax+0 (used reg = )
23644 6C47           50                         push	ax
23645                                           ! Debug: list * char = .50D+0 (used reg = )
23646 6C48           BB                   D402  mov	bx,#.50D
23647 6C4B           53                         push	bx
23648                                           ! Debug: list int = const 4 (used reg = )
23649 6C4C           B8                   0004  mov	ax,*4
23650 6C4F           50                         push	ax
23651                                           ! Debug: func () void = bios_printf+0 (used reg = )
23652 6C50           E8         9C56            call	_bios_printf
23653 6C53           83C4                   06  add	sp,*6
23654                                           !BCC_EOS
23655                                           ! 3667       goto int13_fail;
23656 6C56           83C4                   0E  add	sp,#..FFF0-..FFEF
23657 6C59           E9         0086            br 	.FFF0
23658                                           !BCC_EOS
23659                                           ! 3668       break;
23660 6C5C           E9         0080            br 	.496
23661                                           !BCC_EOS
23662                                           ! 3669     }
23663                                           ! 3670 int13_fail:
23664 6C5F           EB           7E            jmp .496
23665                       00006C61            .498:
23666 6C61           83C4                   F2  add	sp,*-$E
23667 6C64           2D                   0000  sub	ax,*0
23668 6C67           7C           D7            jl 	.50C
23669 6C69           3D                   0018  cmp	ax,*$18
23670 6C6C           77           3B            ja  	.50E
23671 6C6E           D1E0                       shl	ax,*1
23672 6C70           89C3                       mov	bx,ax
23673 6C72           2E                         seg	cs
23674 6C73           FFA7       6C77            br	.50F[bx]
23675                       00006C77            .50F:
23676 6C77                      5F1E            .word	.499
23677 6C79                      5F32            .word	.49A
23678 6C7B                      5F83            .word	.49E
23679 6C7D                      5F83            .word	.49F
23680 6C7F                      5F83            .word	.4A0
23681 6C81                      6206            .word	.4B5
23682 6C83                      6C40            .word	.50C
23683 6C85                      6C40            .word	.50C
23684 6C87                      6221            .word	.4B7
23685 6C89                      6C21            .word	.502
23686 6C8B                      6C40            .word	.508
23687 6C8D                      6C40            .word	.509
23688 6C8F                      6C21            .word	.503
23689 6C91                      6C21            .word	.504
23690 6C93                      6C40            .word	.50C
23691 6C95                      6C40            .word	.50C
23692 6C97                      62FF            .word	.4B8
23693 6C99                      6C21            .word	.505
23694 6C9B                      6C40            .word	.50C
23695 6C9D                      6C40            .word	.50C
23696 6C9F                      6C21            .word	.506
23697 6CA1                      634B            .word	.4BC
23698 6CA3                      6C40            .word	.50C
23699 6CA5                      6C40            .word	.50C
23700 6CA7                      6C40            .word	.50A
23701                       00006CA9            .50E:
23702 6CA9           2D                   0041  sub	ax,*$41
23703 6CAC           72           92            jb 	.50C
23704 6CAE           3D                   000F  cmp	ax,*$F
23705 6CB1           77           29            ja  	.510
23706 6CB3           D1E0                       shl	ax,*1
23707 6CB5           89C3                       mov	bx,ax
23708 6CB7           2E                         seg	cs
23709 6CB8           FFA7       6CBC            br	.511[bx]
23710                       00006CBC            .511:
23711 6CBC                      63FC            .word	.4BD
23712 6CBE                      641C            .word	.4BE
23713 6CC0                      641C            .word	.4BF
23714 6CC2                      641C            .word	.4C0
23715 6CC4                      65D8            .word	.4D1
23716 6CC6                      65E1            .word	.4D3
23717 6CC8                      641C            .word	.4C1
23718 6CCA                      65F5            .word	.4D4
23719 6CCC                      65D8            .word	.4D2
23720 6CCE                      6C40            .word	.50C
23721 6CD0                      6C40            .word	.50C
23722 6CD2                      6C40            .word	.50C
23723 6CD4                      6C40            .word	.50C
23724 6CD6                      6BF7            .word	.4F9
23725 6CD8                      6C40            .word	.50C
23726 6CDA                      6C40            .word	.50B
23727                       00006CDC            .510:
23728 6CDC           E9         FF61            br 	.50C
23729                       00006CDF            .496:
23730                       FFFFFFCE            ..FFEF	=	-$32
23731 6CDF           83C4                   0E  add	sp,*$E
23732                       00006CE2            .FFF0:
23733                       FFFFFFDC            ..FFF0	=	-$24
23734                                           ! 3671     AX = ((AX & 0x00ff) | ((0x01) << 8));
23735                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
23736 6CE2           8A46         16            mov	al,$16[bp]
23737                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
23738 6CE5           30E4                       xor	ah,ah
23739 6CE7           0D                   0100  or	ax,#$100
23740                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$24+$14] (used reg = )
23741 6CEA           8946         16            mov	$16[bp],ax
23742                                           !BCC_EOS
23743                                           ! 3672 int13_fail_noah:
23744                       00006CED            .FFEB:
23745                       FFFFFFDC            ..FFEB	=	-$24
23746                                           ! 3673     write_byte(0x0040, 0x0074, ( AX >> 8 ));
23747                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$14] (used reg = )
23748 6CED           8B46         16            mov	ax,$16[bp]
23749 6CF0           88E0                       mov	al,ah
23750 6CF2           30E4                       xor	ah,ah
23751                                           ! Debug: list unsigned int = ax+0 (used reg = )
23752 6CF4           50                         push	ax
23753                                           ! Debug: list int = const $74 (used reg = )
23754 6CF5           B8                   0074  mov	ax,*$74
23755 6CF8           50                         push	ax
23756                                           ! Debug: list int = const $40 (used reg = )
23757 6CF9           B8                   0040  mov	ax,*$40
23758 6CFC           50                         push	ax
23759                                           ! Debug: func () void = write_byte+0 (used reg = )
23760 6CFD           E8         9924            call	_write_byte
23761 6D00           83C4                   06  add	sp,*6
23762                                           !BCC_EOS
23763                                           ! 3674 int13_fail_nostatus:
23764                       00006D03            .FFED:
23765                       FFFFFFDC            ..FFED	=	-$24
23766                                           ! 3675     FLAGS |= 0x0001;
23767                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$24+$1A] (used reg = )
23768 6D03           8B46         1C            mov	ax,$1C[bp]
23769 6D06           0C                     01  or	al,*1
23770 6D08           8946         1C            mov	$1C[bp],ax
23771                                           !BCC_EOS
23772                                           ! 3676     return;
23773 6D0B           89EC                       mov	sp,bp
23774 6D0D           5D                         pop	bp
23775 6D0E           C3                         ret
23776                                           !BCC_EOS
23777                                           ! 3677 int13_success:
23778                       00006D0F            .FFEE:
23779                       FFFFFFDC            ..FFEE	=	-$24
23780                                           ! 3678     AX = ((AX & 0x00ff) | ((0x00) << 8));
23781                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$14] (used reg = )
23782 6D0F           8A46         16            mov	al,$16[bp]
23783                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
23784 6D12           0C                     00  or	al,*0
23785                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$24+$14] (used reg = )
23786 6D14           30E4                       xor	ah,ah
23787 6D16           8946         16            mov	$16[bp],ax
23788                                           !BCC_EOS
23789                                           ! 3679 int13_success_noah:
23790                       00006D19            .FFEC:
23791                       FFFFFFDC            ..FFEC	=	-$24
23792                                           ! 3680     write_byte(0x0040, 0x0074, 0x00);
23793                                           ! Debug: list int = const 0 (used reg = )
23794 6D19           31C0                       xor	ax,ax
23795 6D1B           50                         push	ax
23796                                           ! Debug: list int = const $74 (used reg = )
23797 6D1C           B8                   0074  mov	ax,*$74
23798 6D1F           50                         push	ax
23799                                           ! Debug: list int = const $40 (used reg = )
23800 6D20           B8                   0040  mov	ax,*$40
23801 6D23           50                         push	ax
23802                                           ! Debug: func () void = write_byte+0 (used reg = )
23803 6D24           E8         98FD            call	_write_byte
23804 6D27           83C4                   06  add	sp,*6
23805                                           !BCC_EOS
23806                                           ! 3681     FLAGS &= 0xfffe;
23807                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$24+$1A] (used reg = )
23808 6D2A           8B46         1C            mov	ax,$1C[bp]
23809 6D2D           24                     FE  and	al,#$FE
23810 6D2F           8946         1C            mov	$1C[bp],ax
23811                                           !BCC_EOS
23812                                           ! 3682     return;
23813 6D32           89EC                       mov	sp,bp
23814 6D34           5D                         pop	bp
23815 6D35           C3                         ret
23816                                           !BCC_EOS
23817                                           ! 3683 }
23818                                           ! 3684   void
23819                                           ! Register BX used in function int13_harddisk
23820                                           ! 3685 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
23821                                           ! 3686   Bit16u EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
23822                                           export	_int13_cdrom
23823                       00006D36            _int13_cdrom:
23824                                           !BCC_EOS
23825                                           ! 3687 {
23826                                           ! 3688   Bit16u ebda_seg=read_word(0x0040,0x000E);
23827 6D36           55                         push	bp
23828 6D37           89E5                       mov	bp,sp
23829 6D39           4C                         dec	sp
23830 6D3A           4C                         dec	sp
23831                                           ! Debug: list int = const $E (used reg = )
23832 6D3B           B8                   000E  mov	ax,*$E
23833 6D3E           50                         push	ax
23834                                           ! Debug: list int = const $40 (used reg = )
23835 6D3F           B8                   0040  mov	ax,*$40
23836 6D42           50                         push	ax
23837                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23838 6D43           E8         98CB            call	_read_word
23839 6D46           83C4                   04  add	sp,*4
23840                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
23841 6D49           8946         FE            mov	-2[bp],ax
23842                                           !BCC_EOS
23843                                           ! 3689   Bit8u device, status, locks;
23844                                           !BCC_EOS
23845                                           ! 3690   Bit8u atacmd[12];
23846                                           !BCC_EOS
23847                                           ! 3691   Bit32u lba;
23848                                           !BCC_EOS
23849                                           ! 3692   Bit16u count, segment, offset, i, size;
23850                                           !BCC_EOS
23851                                           ! 3693   ;
23852 6D4C           83C4                   E2  add	sp,*-$1E
23853                                           !BCC_EOS
23854                                           ! 3694   write_byte(0x0040, 0x0074, 0x00);
23855                                           ! Debug: list int = const 0 (used reg = )
23856 6D4F           31C0                       xor	ax,ax
23857 6D51           50                         push	ax
23858                                           ! Debug: list int = const $74 (used reg = )
23859 6D52           B8                   0074  mov	ax,*$74
23860 6D55           50                         push	ax
23861                                           ! Debug: list int = const $40 (used reg = )
23862 6D56           B8                   0040  mov	ax,*$40
23863 6D59           50                         push	ax
23864                                           ! Debug: func () void = write_byte+0 (used reg = )
23865 6D5A           E8         98C7            call	_write_byte
23866 6D5D           83C4                   06  add	sp,*6
23867                                           !BCC_EOS
23868                                           ! 3695   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
23869                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
23870 6D60           8A46         10            mov	al,$10[bp]
23871                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
23872 6D63           3C                     E0  cmp	al,#$E0
23873 6D65           72           07            jb  	.513
23874                       00006D67            .514:
23875                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
23876 6D67           8A46         10            mov	al,$10[bp]
23877                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
23878 6D6A           3C                     E8  cmp	al,#$E8
23879 6D6C           72           22            jb  	.512
23880                       00006D6E            .513:
23881                                           ! 3696     bios_printf(4, "int13_cdrom: function %02x, ELDL out of range %02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
23882                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
23883 6D6E           8A46         10            mov	al,$10[bp]
23884                                           ! Debug: list unsigned char = al+0 (used reg = )
23885 6D71           30E4                       xor	ah,ah
23886 6D73           50                         push	ax
23887                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
23888 6D74           8B46         18            mov	ax,$18[bp]
23889 6D77           88E0                       mov	al,ah
23890 6D79           30E4                       xor	ah,ah
23891                                           ! Debug: list unsigned int = ax+0 (used reg = )
23892 6D7B           50                         push	ax
23893                                           ! Debug: list * char = .515+0 (used reg = )
23894 6D7C           BB                   D3CE  mov	bx,#.515
23895 6D7F           53                         push	bx
23896                                           ! Debug: list int = const 4 (used reg = )
23897 6D80           B8                   0004  mov	ax,*4
23898 6D83           50                         push	ax
23899                                           ! Debug: func () void = bios_printf+0 (used reg = )
23900 6D84           E8         9B22            call	_bios_printf
23901 6D87           83C4                   08  add	sp,*8
23902                                           !BCC_EOS
23903                                           ! 3697     goto int13_fail;
23904 6D8A           83C4                   00  add	sp,#..FFEA+$22
23905 6D8D           E9         0A81            br 	.FFEA
23906                                           !BCC_EOS
23907                                           ! 3698     }
23908                                           ! 3699   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
23909                       00006D90            .512:
23910                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
23911 6D90           8A46         10            mov	al,$10[bp]
23912                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
23913 6D93           30E4                       xor	ah,ah
23914                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $21C (used reg = )
23915 6D95           05                   FF20  add	ax,#-$E0
23916 6D98           89C3                       mov	bx,ax
23917                                           ! Debug: address unsigned char = [bx+$21C] (used reg = )
23918                                           ! Debug: list * unsigned char = bx+$21C (used reg = )
23919 6D9A           81C3                 021C  add	bx,#$21C
23920 6D9E           53                         push	bx
23921                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
23922 6D9F           FF76         FE            push	-2[bp]
23923                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23924 6DA2           E8         9859            call	_read_byte
23925 6DA5           83C4                   04  add	sp,*4
23926                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
23927 6DA8           8846         FD            mov	-3[bp],al
23928                                           !BCC_EOS
23929                                           ! 3700   if (device >= (4*2)) {
23930                                           ! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
23931 6DAB           8A46         FD            mov	al,-3[bp]
23932 6DAE           3C                     08  cmp	al,*8
23933 6DB0           72           22            jb  	.516
23934                       00006DB2            .517:
23935                                           ! 3701     bios_printf(4, "int13_cdrom: function %02x, unmapped device for ELDL=%02x\n", ( AX >> 8 ), ( ELDX & 0x00ff ));
23936                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
23937 6DB2           8A46         10            mov	al,$10[bp]
23938                                           ! Debug: list unsigned char = al+0 (used reg = )
23939 6DB5           30E4                       xor	ah,ah
23940 6DB7           50                         push	ax
23941                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
23942 6DB8           8B46         18            mov	ax,$18[bp]
23943 6DBB           88E0                       mov	al,ah
23944 6DBD           30E4                       xor	ah,ah
23945                                           ! Debug: list unsigned int = ax+0 (used reg = )
23946 6DBF           50                         push	ax
23947                                           ! Debug: list * char = .518+0 (used reg = )
23948 6DC0           BB                   D393  mov	bx,#.518
23949 6DC3           53                         push	bx
23950                                           ! Debug: list int = const 4 (used reg = )
23951 6DC4           B8                   0004  mov	ax,*4
23952 6DC7           50                         push	ax
23953                                           ! Debug: func () void = bios_printf+0 (used reg = )
23954 6DC8           E8         9ADE            call	_bios_printf
23955 6DCB           83C4                   08  add	sp,*8
23956                                           !BCC_EOS
23957                                           ! 3702     goto int13_fail;
23958 6DCE           83C4                   00  add	sp,#..FFEA+$22
23959 6DD1           E9         0A3D            br 	.FFEA
23960                                           !BCC_EOS
23961                                           ! 3703     }
23962                                           ! 3704   switch (( AX >> 8 )) {
23963                       00006DD4            .516:
23964                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
23965 6DD4           8B46         18            mov	ax,$18[bp]
23966 6DD7           88E0                       mov	al,ah
23967 6DD9           30E4                       xor	ah,ah
23968 6DDB           E9         09B2            br 	.51B
23969                                           ! 3705     case 0x00:
23970                                           ! 3706     case 0x09:
23971                       00006DDE            .51C:
23972                                           ! 3707     case 0x0c:
23973                       00006DDE            .51D:
23974                                           ! 3708     case 0x0d:
23975                       00006DDE            .51E:
23976                                           ! 3709     case 0x10:
23977                       00006DDE            .51F:
23978                                           ! 3710     case 0x11:
23979                       00006DDE            .520:
23980                                           ! 3711     case 0x14:
23981                       00006DDE            .521:
23982                                           ! 3712     case 0x16:
23983                       00006DDE            .522:
23984                                           ! 3713   
23985                                           ! 3713     goto int13_success;
23986                       00006DDE            .523:
23987 6DDE           83C4                   0C  add	sp,#..FFE8-..FFE9
23988 6DE1           E9         0A5A            br 	.FFE8
23989                                           !BCC_EOS
23990                                           ! 3714       break;
23991 6DE4           E9         0A27            br 	.519
23992                                           !BCC_EOS
23993                                           ! 3715     case 0x03:
23994                                           ! 3716     case 0x05:
23995                       00006DE7            .524:
23996                                           ! 3717     case 0x43:
23997                       00006DE7            .525:
23998                                           ! 3718       AX = ((AX & 0x00ff) | ((0x03) << 8));
23999                       00006DE7            .526:
24000                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
24001 6DE7           8A46         18            mov	al,$18[bp]
24002                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
24003 6DEA           30E4                       xor	ah,ah
24004 6DEC           0D                   0300  or	ax,#$300
24005                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24006 6DEF           8946         18            mov	$18[bp],ax
24007                                           !BCC_EOS
24008                                           ! 3719       goto int13_fail_noah;
24009 6DF2           83C4                   0C  add	sp,#..FFE7-..FFE9
24010 6DF5           E9         0A24            br 	.FFE7
24011                                           !BCC_EOS
24012                                           ! 3720       break;
24013 6DF8           E9         0A13            br 	.519
24014                                           !BCC_EOS
24015                                           ! 3721     case 0x01:
24016                                           ! 3722       status = read_byte(0x0040, 0x0074);
24017                       00006DFB            .527:
24018                                           ! Debug: list int = const $74 (used reg = )
24019 6DFB           B8                   0074  mov	ax,*$74
24020 6DFE           50                         push	ax
24021                                           ! Debug: list int = const $40 (used reg = )
24022 6DFF           B8                   0040  mov	ax,*$40
24023 6E02           50                         push	ax
24024                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24025 6E03           E8         97F8            call	_read_byte
24026 6E06           83C4                   04  add	sp,*4
24027                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
24028 6E09           8846         FC            mov	-4[bp],al
24029                                           !BCC_EOS
24030                                           ! 3723       AX = ((AX & 0x00ff) | ((status) << 8));
24031                                           ! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
24032 6E0C           8A46         FC            mov	al,-4[bp]
24033 6E0F           30E4                       xor	ah,ah
24034 6E11           88C4                       mov	ah,al
24035 6E13           30C0                       xor	al,al
24036 6E15           50                         push	ax
24037                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
24038 6E16           8A46         18            mov	al,$18[bp]
24039                                           ! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
24040 6E19           30E4                       xor	ah,ah
24041 6E1B           0B46         D2            or	ax,0+..FFE9[bp]
24042 6E1E           44                         inc	sp
24043 6E1F           44                         inc	sp
24044                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24045 6E20           8946         18            mov	$18[bp],ax
24046                                           !BCC_EOS
24047                                           ! 3724       write_byte(0x0040, 0x0074, 0);
24048                                           ! Debug: list int = const 0 (used reg = )
24049 6E23           31C0                       xor	ax,ax
24050 6E25           50                         push	ax
24051                                           ! Debug: list int = const $74 (used reg = )
24052 6E26           B8                   0074  mov	ax,*$74
24053 6E29           50                         push	ax
24054                                           ! Debug: list int = const $40 (used reg = )
24055 6E2A           B8                   0040  mov	ax,*$40
24056 6E2D           50                         push	ax
24057                                           ! Debug: func () void = write_byte+0 (used reg = )
24058 6E2E           E8         97F3            call	_write_byte
24059 6E31           83C4                   06  add	sp,*6
24060                                           !BCC_EOS
24061                                           ! 3725       if (status) goto int13_fail_nostatus;
24062 6E34           8A46         FC            mov	al,-4[bp]
24063 6E37           84C0                       test	al,al
24064 6E39           74           08            je  	.528
24065                       00006E3B            .529:
24066 6E3B           83C4                   0C  add	sp,#..FFE6-..FFE9
24067 6E3E           E9         09F1            br 	.FFE6
24068                                           !BCC_EOS
24069                                           ! 3726       else goto int13_success_noah;
24070 6E41           EB           06            jmp .52A
24071                       00006E43            .528:
24072 6E43           83C4                   0C  add	sp,#..FFE5-..FFE9
24073 6E46           E9         09FF            br 	.FFE5
24074                                           !BCC_EOS
24075                                           ! 3727       break;
24076                       00006E49            .52A:
24077 6E49           E9         09C2            br 	.519
24078                                           !BCC_EOS
24079                                           ! 3728     case 0x15:
24080                                           ! 3729       AX = ((AX & 0x00ff) | ((0x02) << 8));
24081                       00006E4C            .52B:
24082                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
24083 6E4C           8A46         18            mov	al,$18[bp]
24084                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
24085 6E4F           30E4                       xor	ah,ah
24086 6E51           0D                   0200  or	ax,#$200
24087                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24088 6E54           8946         18            mov	$18[bp],ax
24089                                           !BCC_EOS
24090                                           ! 3730       goto int13_fail_noah;
24091 6E57           83C4                   0C  add	sp,#..FFE7-..FFE9
24092 6E5A           E9         09BF            br 	.FFE7
24093                                           !BCC_EOS
24094                                           ! 3731       break;
24095 6E5D           E9         09AE            br 	.519
24096                                           !BCC_EOS
24097                                           ! 3732     case 0x41:
24098                                           ! 3733       BX=0xaa55;
24099                       00006E60            .52C:
24100                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
24101 6E60           B8                   AA55  mov	ax,#$AA55
24102 6E63           8946         12            mov	$12[bp],ax
24103                                           !BCC_EOS
24104                                           ! 3734       AX = ((AX & 0x00ff) | ((0x30) << 8));
24105                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
24106 6E66           8A46         18            mov	al,$18[bp]
24107                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
24108 6E69           30E4                       xor	ah,ah
24109 6E6B           0D                   3000  or	ax,#$3000
24110                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24111 6E6E           8946         18            mov	$18[bp],ax
24112                                           !BCC_EOS
24113                                           ! 3735       CX=0x0007;
24114                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
24115 6E71           B8                   0007  mov	ax,*7
24116 6E74           8946         16            mov	$16[bp],ax
24117                                           !BCC_EOS
24118                                           ! 3736       goto int13_success_noah;
24119 6E77           83C4                   0C  add	sp,#..FFE5-..FFE9
24120 6E7A           E9         09CB            br 	.FFE5
24121                                           !BCC_EOS
24122                                           ! 3737       break;
24123 6E7D           E9         098E            br 	.519
24124                                           !BCC_EOS
24125                                           ! 3738     case 0x42:
24126                                           ! 3739     case 0x44:
24127                       00006E80            .52D:
24128                                           ! 3740     case 0x47:
24129                       00006E80            .52E:
24130                                           ! 3741       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
24131                       00006E80            .52F:
24132                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
24133 6E80           8B46         0C            mov	ax,$C[bp]
24134                                           ! Debug: list unsigned int = ax+2 (used reg = )
24135 6E83           40                         inc	ax
24136 6E84           40                         inc	ax
24137 6E85           50                         push	ax
24138                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
24139 6E86           FF76         06            push	6[bp]
24140                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24141 6E89           E8         9785            call	_read_word
24142 6E8C           83C4                   04  add	sp,*4
24143                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
24144 6E8F           8946         E8            mov	-$18[bp],ax
24145                                           !BCC_EOS
24146                                           ! 3742       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
24147                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
24148 6E92           8B46         0C            mov	ax,$C[bp]
24149                                           ! Debug: list unsigned int = ax+6 (used reg = )
24150 6E95           05                   0006  add	ax,*6
24151 6E98           50                         push	ax
24152                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
24153 6E99           FF76         06            push	6[bp]
24154                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24155 6E9C           E8         9772            call	_read_word
24156 6E9F           83C4                   04  add	sp,*4
24157                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
24158 6EA2           8946         E6            mov	-$1A[bp],ax
24159                                           !BCC_EOS
24160                                           ! 3743       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
24161                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
24162 6EA5           8B46         0C            mov	ax,$C[bp]
24163                                           ! Debug: list unsigned int = ax+4 (used reg = )
24164 6EA8           05                   0004  add	ax,*4
24165 6EAB           50                         push	ax
24166                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
24167 6EAC           FF76         06            push	6[bp]
24168                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24169 6EAF           E8         975F            call	_read_word
24170 6EB2           83C4                   04  add	sp,*4
24171                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
24172 6EB5           8946         E4            mov	-$1C[bp],ax
24173                                           !BCC_EOS
24174                                           ! 3744       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
24175                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
24176 6EB8           8B46         0C            mov	ax,$C[bp]
24177                                           ! Debug: list unsigned int = ax+$C (used reg = )
24178 6EBB           05                   000C  add	ax,*$C
24179 6EBE           50                         push	ax
24180                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
24181 6EBF           FF76         06            push	6[bp]
24182                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24183 6EC2           E8         9190            call	_read_dword
24184 6EC5           89D3                       mov	bx,dx
24185 6EC7           83C4                   04  add	sp,*4
24186                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
24187 6ECA           8946         EA            mov	-$16[bp],ax
24188 6ECD           895E         EC            mov	-$14[bp],bx
24189                                           !BCC_EOS
24190                                           ! 3745       if (lba != 0L) {
24191                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
24192                                           ! Debug: expression subtree swapping
24193 6ED0           31C0                       xor	ax,ax
24194 6ED2           31DB                       xor	bx,bx
24195 6ED4           53                         push	bx
24196 6ED5           50                         push	ax
24197 6ED6           8B46         EA            mov	ax,-$16[bp]
24198 6ED9           8B5E         EC            mov	bx,-$14[bp]
24199 6EDC           8D7E         D0            lea	di,-2+..FFE9[bp]
24200 6EDF           E8         91B9            call	lcmpul
24201 6EE2           8D66         D4            lea	sp,2+..FFE9[bp]
24202 6EE5           74           1C            je  	.530
24203                       00006EE7            .531:
24204                                           ! 3746         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
24205                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
24206 6EE7           8B46         18            mov	ax,$18[bp]
24207 6EEA           88E0                       mov	al,ah
24208 6EEC           30E4                       xor	ah,ah
24209                                           ! Debug: list unsigned int = ax+0 (used reg = )
24210 6EEE           50                         push	ax
24211                                           ! Debug: list * char = .532+0 (used reg = )
24212 6EEF           BB                   D361  mov	bx,#.532
24213 6EF2           53                         push	bx
24214                                           ! Debug: list int = const 7 (used reg = )
24215 6EF3           B8                   0007  mov	ax,*7
24216 6EF6           50                         push	ax
24217                                           ! Debug: func () void = bios_printf+0 (used reg = )
24218 6EF7           E8         99AF            call	_bios_printf
24219 6EFA           83C4                   06  add	sp,*6
24220                                           !BCC_EOS
24221                                           ! 3747         goto int13_fail;
24222 6EFD           83C4                   0C  add	sp,#..FFEA-..FFE9
24223 6F00           E9         090E            br 	.FFEA
24224                                           !BCC_EOS
24225                                           ! 3748         }
24226                                           ! 3749       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
24227                       00006F03            .530:
24228                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
24229 6F03           8B46         0C            mov	ax,$C[bp]
24230                                           ! Debug: list unsigned int = ax+8 (used reg = )
24231 6F06           05                   0008  add	ax,*8
24232 6F09           50                         push	ax
24233                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
24234 6F0A           FF76         06            push	6[bp]
24235                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24236 6F0D           E8         9145            call	_read_dword
24237 6F10           89D3                       mov	bx,dx
24238 6F12           83C4                   04  add	sp,*4
24239                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
24240 6F15           8946         EA            mov	-$16[bp],ax
24241 6F18           895E         EC            mov	-$14[bp],bx
24242                                           !BCC_EOS
24243                                           ! 3750       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
24244                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
24245 6F1B           8B46         18            mov	ax,$18[bp]
24246 6F1E           88E0                       mov	al,ah
24247 6F20           30E4                       xor	ah,ah
24248                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
24249 6F22           3D                   0044  cmp	ax,*$44
24250 6F25           74           0C            je  	.534
24251                       00006F27            .535:
24252                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
24253 6F27           8B46         18            mov	ax,$18[bp]
24254 6F2A           88E0                       mov	al,ah
24255 6F2C           30E4                       xor	ah,ah
24256                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
24257 6F2E           3D                   0047  cmp	ax,*$47
24258 6F31           75           06            jne 	.533
24259                       00006F33            .534:
24260                                           ! 3751         goto int13_success;
24261 6F33           83C4                   0C  add	sp,#..FFE8-..FFE9
24262 6F36           E9         0905            br 	.FFE8
24263                                           !BCC_EOS
24264                                           ! 3752       memsetb(get_SS(),atacmd,0,12);
24265                       00006F39            .533:
24266                                           ! Debug: list int = const $C (used reg = )
24267 6F39           B8                   000C  mov	ax,*$C
24268 6F3C           50                         push	ax
24269                                           ! Debug: list int = const 0 (used reg = )
24270 6F3D           31C0                       xor	ax,ax
24271 6F3F           50                         push	ax
24272                                           ! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
24273 6F40           8D5E         EF            lea	bx,-$11[bp]
24274 6F43           53                         push	bx
24275                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
24276 6F44           E8         9710            call	_get_SS
24277                                           ! Debug: list unsigned short = ax+0 (used reg = )
24278 6F47           50                         push	ax
24279                                           ! Debug: func () void = memsetb+0 (used reg = )
24280 6F48           E8         90B5            call	_memsetb
24281 6F4B           83C4                   08  add	sp,*8
24282                                           !BCC_EOS
24283                                           ! 3753       atacmd[0]=0x28;
24284                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
24285 6F4E           B0                     28  mov	al,*$28
24286 6F50           8846         EF            mov	-$11[bp],al
24287                                           !BCC_EOS
24288                                           ! 3754       atacmd[7]=(count & 0xff00) >> 8;
24289                                           ! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
24290 6F53           8B46         E8            mov	ax,-$18[bp]
24291 6F56           30C0                       xor	al,al
24292                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
24293 6F58           88E0                       mov	al,ah
24294 6F5A           30E4                       xor	ah,ah
24295                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
24296 6F5C           8846         F6            mov	-$A[bp],al
24297                                           !BCC_EOS
24298                                           ! 3755       atacmd[8]=(count & 0x00ff);
24299                                           ! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
24300 6F5F           8A46         E8            mov	al,-$18[bp]
24301                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
24302 6F62           8846         F7            mov	-9[bp],al
24303                                           !BCC_EOS
24304                                           ! 3756       atacmd[2]=(lba & 0xff000000) >> 24;
24305                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
24306                                           ! Debug: expression subtree swapping
24307 6F65           31C0                       xor	ax,ax
24308 6F67           BB                   FF00  mov	bx,#$FF00
24309 6F6A           8D7E         EA            lea	di,-$16[bp]
24310 6F6D           E8         911B            call	landul
24311                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
24312 6F70           93                         xchg	bx,ax
24313 6F71           88E0                       mov	al,ah
24314 6F73           30E4                       xor	ah,ah
24315 6F75           31DB                       xor	bx,bx
24316                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
24317 6F77           8846         F1            mov	-$F[bp],al
24318                                           !BCC_EOS
24319                                           ! 3757       atacmd[3]=(lba & 0x00ff0000) >> 16;
24320                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
24321                                           ! Debug: expression subtree swapping
24322 6F7A           31C0                       xor	ax,ax
24323 6F7C           BB                   00FF  mov	bx,#$FF
24324 6F7F           8D7E         EA            lea	di,-$16[bp]
24325 6F82           E8         9106            call	landul
24326                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
24327 6F85           93                         xchg	bx,ax
24328 6F86           31DB                       xor	bx,bx
24329                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
24330 6F88           8846         F2            mov	-$E[bp],al
24331                                           !BCC_EOS
24332                                           ! 3758       atacmd[4]=(lba & 0x0000ff00) >> 8;
24333                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
24334                                           ! Debug: expression subtree swapping
24335 6F8B           B8                   FF00  mov	ax,#$FF00
24336 6F8E           31DB                       xor	bx,bx
24337 6F90           8D7E         EA            lea	di,-$16[bp]
24338 6F93           E8         90F5            call	landul
24339                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
24340 6F96           88E0                       mov	al,ah
24341 6F98           88DC                       mov	ah,bl
24342 6F9A           88FB                       mov	bl,bh
24343 6F9C           28FF                       sub	bh,bh
24344                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
24345 6F9E           8846         F3            mov	-$D[bp],al
24346                                           !BCC_EOS
24347                                           ! 3759       atacmd[5]=(lba & 0x000000ff);
24348                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
24349                                           ! Debug: expression subtree swapping
24350 6FA1           B8                   00FF  mov	ax,#$FF
24351 6FA4           31DB                       xor	bx,bx
24352 6FA6           8D7E         EA            lea	di,-$16[bp]
24353 6FA9           E8         90DF            call	landul
24354                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
24355 6FAC           8846         F4            mov	-$C[bp],al
24356                                           !BCC_EOS
24357                                           ! 3760       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
24358                                           ! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
24359 6FAF           FF76         E4            push	-$1C[bp]
24360                                           ! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
24361 6FB2           FF76         E6            push	-$1A[bp]
24362                                           ! Debug: list int = const 1 (used reg = )
24363 6FB5           B8                   0001  mov	ax,*1
24364 6FB8           50                         push	ax
24365                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
24366 6FB9           8B46         E8            mov	ax,-$18[bp]
24367 6FBC           31DB                       xor	bx,bx
24368                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
24369 6FBE           53                         push	bx
24370 6FBF           50                         push	ax
24371 6FC0           B8                   0800  mov	ax,#$800
24372 6FC3           31DB                       xor	bx,bx
24373 6FC5           53                         push	bx
24374 6FC6           50                         push	ax
24375 6FC7           8B46         CA            mov	ax,-8+..FFE9[bp]
24376 6FCA           8B5E         CC            mov	bx,-6+..FFE9[bp]
24377 6FCD           8D7E         C6            lea	di,-$C+..FFE9[bp]
24378 6FD0           E8         90E6            call	lmulul
24379 6FD3           83C4                   08  add	sp,*8
24380                                           ! Debug: list unsigned long = bx+0 (used reg = )
24381 6FD6           53                         push	bx
24382 6FD7           50                         push	ax
24383                                           ! Debug: list int = const 0 (used reg = )
24384 6FD8           31C0                       xor	ax,ax
24385 6FDA           50                         push	ax
24386                                           ! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
24387 6FDB           8D5E         EF            lea	bx,-$11[bp]
24388 6FDE           53                         push	bx
24389                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
24390 6FDF           E8         9675            call	_get_SS
24391                                           ! Debug: list unsigned short = ax+0 (used reg = )
24392 6FE2           50                         push	ax
24393                                           ! Debug: list int = const $C (used reg = )
24394 6FE3           B8                   000C  mov	ax,*$C
24395 6FE6           50                         push	ax
24396                                           ! Debug: list unsigned char device = [S+$34-5] (used reg = )
24397 6FE7           8A46         FD            mov	al,-3[bp]
24398 6FEA           30E4                       xor	ah,ah
24399 6FEC           50                         push	ax
24400                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
24401 6FED           E8         C0BC            call	_ata_cmd_packet
24402 6FF0           83C4                   14  add	sp,*$14
24403                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
24404 6FF3           8846         FC            mov	-4[bp],al
24405                                           !BCC_EOS
24406                                           ! 3761       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
24407                                           ! Debug: list * unsigned long = const $236 (used reg = )
24408 6FF6           B8                   0236  mov	ax,#$236
24409 6FF9           50                         push	ax
24410                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
24411 6FFA           FF76         FE            push	-2[bp]
24412                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24413 6FFD           E8         9055            call	_read_dword
24414 7000           89D3                       mov	bx,dx
24415 7002           83C4                   04  add	sp,*4
24416                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
24417 7005           88E0                       mov	al,ah
24418 7007           88DC                       mov	ah,bl
24419 7009           88FB                       mov	bl,bh
24420 700B           28FF                       sub	bh,bh
24421 700D           BF                   0003  mov	di,*3
24422 7010           E8         90E6            call	lsrul
24423                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
24424                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
24425 7013           8946         E8            mov	-$18[bp],ax
24426                                           !BCC_EOS
24427                                           ! 3762       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
24428                                           ! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
24429 7016           FF76         E8            push	-$18[bp]
24430                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
24431 7019           8B46         0C            mov	ax,$C[bp]
24432                                           ! Debug: list unsigned int = ax+2 (used reg = )
24433 701C           40                         inc	ax
24434 701D           40                         inc	ax
24435 701E           50                         push	ax
24436                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
24437 701F           FF76         06            push	6[bp]
24438                                           ! Debug: func () void = write_word+0 (used reg = )
24439 7022           E8         9617            call	_write_word
24440 7025           83C4                   06  add	sp,*6
24441                                           !BCC_EOS
24442                                           ! 3763       if (status != 0) {
24443                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
24444 7028           8A46         FC            mov	al,-4[bp]
24445 702B           84C0                       test	al,al
24446 702D           74           2D            je  	.536
24447                       0000702F            .537:
24448                                           ! 3764         bios_printf(4, "int13_cdrom: function %02x, status %02x !\n",( AX >> 8 ),status);
24449                                           ! Debug: list unsigned char status = [S+$22-6] (used reg = )
24450 702F           8A46         FC            mov	al,-4[bp]
24451 7032           30E4                       xor	ah,ah
24452 7034           50                         push	ax
24453                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$24+$16] (used reg = )
24454 7035           8B46         18            mov	ax,$18[bp]
24455 7038           88E0                       mov	al,ah
24456 703A           30E4                       xor	ah,ah
24457                                           ! Debug: list unsigned int = ax+0 (used reg = )
24458 703C           50                         push	ax
24459                                           ! Debug: list * char = .538+0 (used reg = )
24460 703D           BB                   D336  mov	bx,#.538
24461 7040           53                         push	bx
24462                                           ! Debug: list int = const 4 (used reg = )
24463 7041           B8                   0004  mov	ax,*4
24464 7044           50                         push	ax
24465                                           ! Debug: func () void = bios_printf+0 (used reg = )
24466 7045           E8         9861            call	_bios_printf
24467 7048           83C4                   08  add	sp,*8
24468                                           !BCC_EOS
24469                                           ! 3765         AX = ((AX & 0x00ff) | ((0x0c) << 8));
24470                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
24471 704B           8A46         18            mov	al,$18[bp]
24472                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
24473 704E           30E4                       xor	ah,ah
24474 7050           0D                   0C00  or	ax,#$C00
24475                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24476 7053           8946         18            mov	$18[bp],ax
24477                                           !BCC_EOS
24478                                           ! 3766         goto int13_fail_noah;
24479 7056           83C4                   0C  add	sp,#..FFE7-..FFE9
24480 7059           E9         07C0            br 	.FFE7
24481                                           !BCC_EOS
24482                                           ! 3767         }
24483                                           ! 3768       goto int13_success;
24484                       0000705C            .536:
24485 705C           83C4                   0C  add	sp,#..FFE8-..FFE9
24486 705F           E9         07DC            br 	.FFE8
24487                                           !BCC_EOS
24488                                           ! 3769       brea
24489                                           ! 3769 k;
24490 7062           E9         07A9            br 	.519
24491                                           !BCC_EOS
24492                                           ! 3770     case 0x45:
24493                                           ! 3771       if (( AX & 0x00ff ) > 2) goto int13_fail;
24494                       00007065            .539:
24495                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
24496 7065           8A46         18            mov	al,$18[bp]
24497                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
24498 7068           3C                     02  cmp	al,*2
24499 706A           76           06            jbe 	.53A
24500                       0000706C            .53B:
24501 706C           83C4                   0C  add	sp,#..FFEA-..FFE9
24502 706F           E9         079F            br 	.FFEA
24503                                           !BCC_EOS
24504                                           ! 3772       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
24505                       00007072            .53A:
24506                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
24507 7072           8A46         FD            mov	al,-3[bp]
24508 7075           30E4                       xor	ah,ah
24509 7077           B9                   001A  mov	cx,*$1A
24510 707A           F7E9                       imul	cx
24511 707C           89C3                       mov	bx,ax
24512                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24513                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
24514 707E           81C3                 0145  add	bx,#$145
24515 7082           53                         push	bx
24516                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
24517 7083           FF76         FE            push	-2[bp]
24518                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24519 7086           E8         9575            call	_read_byte
24520 7089           83C4                   04  add	sp,*4
24521                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
24522 708C           8846         FB            mov	-5[bp],al
24523                                           !BCC_EOS
24524                                           ! 3773       switch (( AX & 0x00ff )) {
24525                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
24526 708F           8A46         18            mov	al,$18[bp]
24527 7092           E9         00D5            br 	.53E
24528                                           ! 3774         case 0 :
24529                                           ! 3775           if (locks == 0xff) {
24530                       00007095            .53F:
24531                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
24532 7095           8A46         FB            mov	al,-5[bp]
24533 7098           3C                     FF  cmp	al,#$FF
24534 709A           75           1B            jne 	.540
24535                       0000709C            .541:
24536                                           ! 3776             AX = ((AX & 0x00ff) | ((0xb4) << 8));
24537                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
24538 709C           8A46         18            mov	al,$18[bp]
24539                                           ! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
24540 709F           30E4                       xor	ah,ah
24541 70A1           0D                   B400  or	ax,#-$4C00
24542                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24543 70A4           8946         18            mov	$18[bp],ax
24544                                           !BCC_EOS
24545                                           ! 3777             AX = ((AX & 0xff00) | (1));
24546                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
24547 70A7           8B46         18            mov	ax,$18[bp]
24548 70AA           30C0                       xor	al,al
24549                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
24550 70AC           0C                     01  or	al,*1
24551                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24552 70AE           8946         18            mov	$18[bp],ax
24553                                           !BCC_EOS
24554                                           ! 3778             goto int13_fail_noah;
24555 70B1           83C4                   0C  add	sp,#..FFE7-..FFE9
24556 70B4           E9         0765            br 	.FFE7
24557                                           !BCC_EOS
24558                                           ! 3779             }
24559                                           ! 3780           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, ++locks);
24560                       000070B7            .540:
24561                                           ! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
24562 70B7           8A46         FB            mov	al,-5[bp]
24563 70BA           40                         inc	ax
24564 70BB           8846         FB            mov	-5[bp],al
24565                                           ! Debug: list unsigned char = al+0 (used reg = )
24566 70BE           30E4                       xor	ah,ah
24567 70C0           50                         push	ax
24568                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
24569 70C1           8A46         FD            mov	al,-3[bp]
24570 70C4           30E4                       xor	ah,ah
24571 70C6           B9                   001A  mov	cx,*$1A
24572 70C9           F7E9                       imul	cx
24573 70CB           89C3                       mov	bx,ax
24574                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24575                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
24576 70CD           81C3                 0145  add	bx,#$145
24577 70D1           53                         push	bx
24578                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
24579 70D2           FF76         FE            push	-2[bp]
24580                                           ! Debug: func () void = write_byte+0 (used reg = )
24581 70D5           E8         954C            call	_write_byte
24582 70D8           83C4                   06  add	sp,*6
24583                                           !BCC_EOS
24584                                           ! 3781           AX = ((AX & 0xff00) | (1));
24585                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
24586 70DB           8B46         18            mov	ax,$18[bp]
24587 70DE           30C0                       xor	al,al
24588                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
24589 70E0           0C                     01  or	al,*1
24590                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24591 70E2           8946         18            mov	$18[bp],ax
24592                                           !BCC_EOS
24593                                           ! 3782           break;
24594 70E5           E9         0092            br 	.53C
24595                                           !BCC_EOS
24596                                           ! 3783         case 1 :
24597                                           ! 3784           if (locks == 0x00) {
24598                       000070E8            .542:
24599                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
24600 70E8           8A46         FB            mov	al,-5[bp]
24601 70EB           84C0                       test	al,al
24602 70ED           75           1B            jne 	.543
24603                       000070EF            .544:
24604                                           ! 3785             AX = ((AX & 0x00ff) | ((0xb0) << 8));
24605                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
24606 70EF           8A46         18            mov	al,$18[bp]
24607                                           ! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
24608 70F2           30E4                       xor	ah,ah
24609 70F4           0D                   B000  or	ax,#-$5000
24610                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24611 70F7           8946         18            mov	$18[bp],ax
24612                                           !BCC_EOS
24613                                           ! 3786             AX = ((AX & 0xff00) | (0));
24614                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
24615 70FA           8B46         18            mov	ax,$18[bp]
24616 70FD           30C0                       xor	al,al
24617                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
24618 70FF           0C                     00  or	al,*0
24619                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24620 7101           8946         18            mov	$18[bp],ax
24621                                           !BCC_EOS
24622                                           ! 3787             goto int13_fail_noah;
24623 7104           83C4                   0C  add	sp,#..FFE7-..FFE9
24624 7107           E9         0712            br 	.FFE7
24625                                           !BCC_EOS
24626                                           ! 3788             }
24627                                           ! 3789           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
24628                       0000710A            .543:
24629                                           ! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
24630 710A           8A46         FB            mov	al,-5[bp]
24631 710D           48                         dec	ax
24632 710E           8846         FB            mov	-5[bp],al
24633                                           ! Debug: list unsigned char = al+0 (used reg = )
24634 7111           30E4                       xor	ah,ah
24635 7113           50                         push	ax
24636                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
24637 7114           8A46         FD            mov	al,-3[bp]
24638 7117           30E4                       xor	ah,ah
24639 7119           B9                   001A  mov	cx,*$1A
24640 711C           F7E9                       imul	cx
24641 711E           89C3                       mov	bx,ax
24642                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24643                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
24644 7120           81C3                 0145  add	bx,#$145
24645 7124           53                         push	bx
24646                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
24647 7125           FF76         FE            push	-2[bp]
24648                                           ! Debug: func () void = write_byte+0 (used reg = )
24649 7128           E8         94F9            call	_write_byte
24650 712B           83C4                   06  add	sp,*6
24651                                           !BCC_EOS
24652                                           ! 3790           AX = ((AX & 0xff00) | (locks==0?0:1));
24653                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
24654 712E           8A46         FB            mov	al,-5[bp]
24655 7131           84C0                       test	al,al
24656 7133           75           04            jne 	.545
24657                       00007135            .546:
24658 7135           30C0                       xor	al,al
24659 7137           EB           02            jmp .547
24660                       00007139            .545:
24661 7139           B0                     01  mov	al,*1
24662                       0000713B            .547:
24663 713B           50                         push	ax
24664                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
24665 713C           8B46         18            mov	ax,$18[bp]
24666 713F           30C0                       xor	al,al
24667                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
24668 7141           0A46         D2            or	al,0+..FFE9[bp]
24669 7144           44                         inc	sp
24670 7145           44                         inc	sp
24671                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24672 7146           8946         18            mov	$18[bp],ax
24673                                           !BCC_EOS
24674                                           ! 3791           break;
24675 7149           EB           2F            jmp .53C
24676                                           !BCC_EOS
24677                                           ! 3792         case 2 :
24678                                           ! 3793           AX = ((AX & 0xff00) | (locks==0?0:1));
24679                       0000714B            .548:
24680                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
24681 714B           8A46         FB            mov	al,-5[bp]
24682 714E           84C0                       test	al,al
24683 7150           75           04            jne 	.549
24684                       00007152            .54A:
24685 7152           30C0                       xor	al,al
24686 7154           EB           02            jmp .54B
24687                       00007156            .549:
24688 7156           B0                     01  mov	al,*1
24689                       00007158            .54B:
24690 7158           50                         push	ax
24691                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
24692 7159           8B46         18            mov	ax,$18[bp]
24693 715C           30C0                       xor	al,al
24694                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
24695 715E           0A46         D2            or	al,0+..FFE9[bp]
24696 7161           44                         inc	sp
24697 7162           44                         inc	sp
24698                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24699 7163           8946         18            mov	$18[bp],ax
24700                                           !BCC_EOS
24701                                           ! 3794           break;
24702 7166           EB           12            jmp .53C
24703                                           !BCC_EOS
24704                                           ! 3795         }
24705                                           ! 3796       goto int13_success;
24706 7168           EB           10            jmp .53C
24707                       0000716A            .53E:
24708 716A           2C                     00  sub	al,*0
24709 716C         0F84         FF25            beq 	.53F
24710 7170           2C                     01  sub	al,*1
24711 7172         0F84         FF72            beq 	.542
24712 7176           2C                     01  sub	al,*1
24713 7178           74           D1            je 	.548
24714                       0000717A            .53C:
24715 717A           83C4                   0C  add	sp,#..FFE8-..FFE9
24716 717D           E9         06BE            br 	.FFE8
24717                                           !BCC_EOS
24718                                           ! 3797       break;
24719 7180           E9         068B            br 	.519
24720                                           !BCC_EOS
24721                                           ! 3798     case 0x46:
24722                                           ! 3799       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
24723                       00007183            .54C:
24724                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
24725 7183           8A46         FD            mov	al,-3[bp]
24726 7186           30E4                       xor	ah,ah
24727 7188           B9                   001A  mov	cx,*$1A
24728 718B           F7E9                       imul	cx
24729 718D           89C3                       mov	bx,ax
24730                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
24731                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
24732 718F           81C3                 0145  add	bx,#$145
24733 7193           53                         push	bx
24734                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
24735 7194           FF76         FE            push	-2[bp]
24736                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24737 7197           E8         9464            call	_read_byte
24738 719A           83C4                   04  add	sp,*4
24739                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
24740 719D           8846         FB            mov	-5[bp],al
24741                                           !BCC_EOS
24742                                           ! 3800       if (locks != 0) {
24743                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
24744 71A0           8A46         FB            mov	al,-5[bp]
24745 71A3           84C0                       test	al,al
24746 71A5           74           11            je  	.54D
24747                       000071A7            .54E:
24748                                           ! 3801         AX = ((AX & 0x00ff) | ((0xb1) << 8));
24749                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
24750 71A7           8A46         18            mov	al,$18[bp]
24751                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
24752 71AA           30E4                       xor	ah,ah
24753 71AC           0D                   B100  or	ax,#-$4F00
24754                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24755 71AF           8946         18            mov	$18[bp],ax
24756                                           !BCC_EOS
24757                                           ! 3802         goto int13_fail_noah;
24758 71B2           83C4                   0C  add	sp,#..FFE7-..FFE9
24759 71B5           E9         0664            br 	.FFE7
24760                                           !BCC_EOS
24761                                           ! 3803         }
24762                                           ! 3804 #asm
24763                       000071B8            .54D:
24764                                           !BCC_EOS
24765                                           !BCC_ASM
24766                       0000002E            _int13_cdrom.BP	set	$2E
24767                       0000000E            .int13_cdrom.BP	set	$E
24768                       00000024            _int13_cdrom.EHBX	set	$24
24769                       00000004            .int13_cdrom.EHBX	set	4
24770                       0000003C            _int13_cdrom.CS	set	$3C
24771                       0000001C            .int13_cdrom.CS	set	$1C
24772                       00000008            _int13_cdrom.count	set	8
24773                       FFFFFFE8            .int13_cdrom.count	set	-$18
24774                       00000036            _int13_cdrom.CX	set	$36
24775                       00000016            .int13_cdrom.CX	set	$16
24776                       00000006            _int13_cdrom.segment	set	6
24777                       FFFFFFE6            .int13_cdrom.segment	set	-$1A
24778                       0000002A            _int13_cdrom.DI	set	$2A
24779                       0000000A            .int13_cdrom.DI	set	$A
24780                       0000003E            _int13_cdrom.FLAGS	set	$3E
24781                       0000001E            .int13_cdrom.FLAGS	set	$1E
24782                       00000026            _int13_cdrom.DS	set	$26
24783                       00000006            .int13_cdrom.DS	set	6
24784                       00000030            _int13_cdrom.ELDX	set	$30
24785                       00000010            .int13_cdrom.ELDX	set	$10
24786                       00000034            _int13_cdrom.DX	set	$34
24787                       00000014            .int13_cdrom.DX	set	$14
24788                       00000000            _int13_cdrom.size	set	0
24789                       FFFFFFE0            .int13_cdrom.size	set	-$20
24790                       00000002            _int13_cdrom.i	set	2
24791                       FFFFFFE2            .int13_cdrom.i	set	-$1E
24792                       0000001D            _int13_cdrom.device	set	$1D
24793                       FFFFFFFD            .int13_cdrom.device	set	-3
24794                       00000028            _int13_cdrom.ES	set	$28
24795                       00000008            .int13_cdrom.ES	set	8
24796                       0000001E            _int13_cdrom.ebda_seg	set	$1E
24797                       FFFFFFFE            .int13_cdrom.ebda_seg	set	-2
24798                       0000002C            _int13_cdrom.SI	set	$2C
24799                       0000000C            .int13_cdrom.SI	set	$C
24800                       0000003A            _int13_cdrom.IP	set	$3A
24801                       0000001A            .int13_cdrom.IP	set	$1A
24802                       0000000A            _int13_cdrom.lba	set	$A
24803                       FFFFFFEA            .int13_cdrom.lba	set	-$16
24804                       0000001C            _int13_cdrom.status	set	$1C
24805                       FFFFFFFC            .int13_cdrom.status	set	-4
24806                       0000000F            _int13_cdrom.atacmd	set	$F
24807                       FFFFFFEF            .int13_cdrom.atacmd	set	-$11
24808                       00000038            _int13_cdrom.AX	set	$38
24809                       00000018            .int13_cdrom.AX	set	$18
24810                       00000004            _int13_cdrom.offset	set	4
24811                       FFFFFFE4            .int13_cdrom.offset	set	-$1C
24812                       00000032            _int13_cdrom.BX	set	$32
24813                       00000012            .int13_cdrom.BX	set	$12
24814                       0000001B            _int13_cdrom.locks	set	$1B
24815                       FFFFFFFB            .int13_cdrom.locks	set	-5
24816 71B8           55                                 push bp
24817 71B9           89E5                               mov bp, sp
24818 71BB           B4                     52          mov ah, #0x52
24819 71BD           CD                     0F          int 15
24820 71BF           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
24821 71C2           73           06                    jnc int13_cdrom_rme_end
24822 71C4           C706       001C      0001          mov _int13_cdrom.status, #1
24823                       000071CA            int13_cdrom_rme_end:
24824 71CA           5D                                 pop bp
24825                                           ! 3814 endasm
24826                                           !BCC_ENDASM
24827                                           !BCC_EOS
24828                                           ! 3815       if (status != 0) {
24829                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
24830 71CB           8A46         FC            mov	al,-4[bp]
24831 71CE           84C0                       test	al,al
24832 71D0           74           11            je  	.54F
24833                       000071D2            .550:
24834                                           ! 3816         AX = ((AX & 0x00ff) | ((0xb1) << 8));
24835                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
24836 71D2           8A46         18            mov	al,$18[bp]
24837                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
24838 71D5           30E4                       xor	ah,ah
24839 71D7           0D                   B100  or	ax,#-$4F00
24840                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
24841 71DA           8946         18            mov	$18[bp],ax
24842                                           !BCC_EOS
24843                                           ! 3817         goto int13_fail_noah;
24844 71DD           83C4                   0C  add	sp,#..FFE7-..FFE9
24845 71E0           E9         0639            br 	.FFE7
24846                                           !BCC_EOS
24847                                           ! 3818       }
24848                                           ! 3819       goto int13_success;
24849                       000071E3            .54F:
24850 71E3           83C4                   0C  add	sp,#..FFE8-..FFE9
24851 71E6           E9         0655            br 	.FFE8
24852                                           !BCC_EOS
24853                                           ! 3820       break;
24854 71E9           E9         0622            br 	.519
24855                                           !BCC_EOS
24856                                           ! 3821     case 0x48:
24857                                           ! 3822       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
24858                       000071EC            .551:
24859                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
24860 71EC           8B46         0C            mov	ax,$C[bp]
24861                                           ! Debug: list unsigned int = ax+0 (used reg = )
24862 71EF           50                         push	ax
24863                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
24864 71F0           FF76         06            push	6[bp]
24865                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24866 71F3           E8         941B            call	_read_word
24867 71F6           83C4                   04  add	sp,*4
24868                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
24869 71F9           8946         E0            mov	-$20[bp],ax
24870                                           !BCC_EOS
24871                                           ! 3823       if(size < 0x1a)
24872                                           ! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
24873 71FC           8B46         E0            mov	ax,-$20[bp]
24874 71FF           3D                   001A  cmp	ax,*$1A
24875 7202           73           06            jae 	.552
24876                       00007204            .553:
24877                                           ! 3824         goto int13_fail;
24878 7204           83C4                   0C  add	sp,#..FFEA-..FFE9
24879 7207           E9         0607            br 	.FFEA
24880                                           !BCC_EOS
24881                                           ! 3825       if(size >= 0x1a) {
24882                       0000720A            .552:
24883                                           ! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
24884 720A           8B46         E0            mov	ax,-$20[bp]
24885 720D           3D                   001A  cmp	ax,*$1A
24886 7210         0F82         00CC            blo 	.554
24887                       00007214            .555:
24888                                           ! 3826         Bit16u cylinders, heads, spt, blksize;
24889                                           !BCC_EOS
24890                                           ! 3827         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
24891                                           ! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
24892 7214           8A46         FD            mov	al,-3[bp]
24893 7217           30E4                       xor	ah,ah
24894 7219           B9                   001A  mov	cx,*$1A
24895 721C           F7E9                       imul	cx
24896 721E           89C3                       mov	bx,ax
24897                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
24898                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
24899 7220           81C3                 0148  add	bx,#$148
24900 7224           53                         push	bx
24901                                           ! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
24902 7225           FF76         FE            push	-2[bp]
24903                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24904 7228           E8         93E6            call	_read_word
24905 722B           83C4                   04  add	sp,*4
24906                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
24907 722E           8946         D8            mov	-$28[bp],ax
24908                                           !BCC_EOS
24909                                           ! 3828         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
24910                                           ! Debug: list int = const $1A (used reg = )
24911 7231           B8                   001A  mov	ax,*$1A
24912 7234           50                         push	ax
24913                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
24914 7235           8B46         0C            mov	ax,$C[bp]
24915                                           ! Debug: list unsigned int = ax+0 (used reg = )
24916 7238           50                         push	ax
24917                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24918 7239           FF76         06            push	6[bp]
24919                                           ! Debug: func () void = write_word+0 (used reg = )
24920 723C           E8         93FD            call	_write_word
24921 723F           83C4                   06  add	sp,*6
24922                                           !BCC_EOS
24923                                           ! 3829         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
24924                                           ! Debug: list int = const $74 (used reg = )
24925 7242           B8                   0074  mov	ax,*$74
24926 7245           50                         push	ax
24927                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
24928 7246           8B46         0C            mov	ax,$C[bp]
24929                                           ! Debug: list unsigned int = ax+2 (used reg = )
24930 7249           40                         inc	ax
24931 724A           40                         inc	ax
24932 724B           50                         push	ax
24933                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24934 724C           FF76         06            push	6[bp]
24935                                           ! Debug: func () void = write_word+0 (used reg = )
24936 724F           E8         93EA            call	_write_word
24937 7252           83C4                   06  add	sp,*6
24938                                           !BCC_EOS
24939                                           ! 3830         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinde
24940                                           ! 3830 rs, 0xffffffff);
24941                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
24942 7255           B8                   FFFF  mov	ax,#$FFFF
24943 7258           BB                   FFFF  mov	bx,#$FFFF
24944 725B           53                         push	bx
24945 725C           50                         push	ax
24946                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
24947 725D           8B46         0C            mov	ax,$C[bp]
24948                                           ! Debug: list unsigned int = ax+4 (used reg = )
24949 7260           05                   0004  add	ax,*4
24950 7263           50                         push	ax
24951                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24952 7264           FF76         06            push	6[bp]
24953                                           ! Debug: func () void = write_dword+0 (used reg = )
24954 7267           E8         8E02            call	_write_dword
24955 726A           83C4                   08  add	sp,*8
24956                                           !BCC_EOS
24957                                           ! 3831         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
24958                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
24959 726D           B8                   FFFF  mov	ax,#$FFFF
24960 7270           BB                   FFFF  mov	bx,#$FFFF
24961 7273           53                         push	bx
24962 7274           50                         push	ax
24963                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
24964 7275           8B46         0C            mov	ax,$C[bp]
24965                                           ! Debug: list unsigned int = ax+8 (used reg = )
24966 7278           05                   0008  add	ax,*8
24967 727B           50                         push	ax
24968                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24969 727C           FF76         06            push	6[bp]
24970                                           ! Debug: func () void = write_dword+0 (used reg = )
24971 727F           E8         8DEA            call	_write_dword
24972 7282           83C4                   08  add	sp,*8
24973                                           !BCC_EOS
24974                                           ! 3832         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
24975                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
24976 7285           B8                   FFFF  mov	ax,#$FFFF
24977 7288           BB                   FFFF  mov	bx,#$FFFF
24978 728B           53                         push	bx
24979 728C           50                         push	ax
24980                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
24981 728D           8B46         0C            mov	ax,$C[bp]
24982                                           ! Debug: list unsigned int = ax+$C (used reg = )
24983 7290           05                   000C  add	ax,*$C
24984 7293           50                         push	ax
24985                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24986 7294           FF76         06            push	6[bp]
24987                                           ! Debug: func () void = write_dword+0 (used reg = )
24988 7297           E8         8DD2            call	_write_dword
24989 729A           83C4                   08  add	sp,*8
24990                                           !BCC_EOS
24991                                           ! 3833         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
24992                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
24993 729D           B8                   FFFF  mov	ax,#$FFFF
24994 72A0           BB                   FFFF  mov	bx,#$FFFF
24995 72A3           53                         push	bx
24996 72A4           50                         push	ax
24997                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
24998 72A5           8B46         0C            mov	ax,$C[bp]
24999                                           ! Debug: list unsigned int = ax+$10 (used reg = )
25000 72A8           05                   0010  add	ax,*$10
25001 72AB           50                         push	ax
25002                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25003 72AC           FF76         06            push	6[bp]
25004                                           ! Debug: func () void = write_dword+0 (used reg = )
25005 72AF           E8         8DBA            call	_write_dword
25006 72B2           83C4                   08  add	sp,*8
25007                                           !BCC_EOS
25008                                           ! 3834         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
25009                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
25010 72B5           B8                   FFFF  mov	ax,#$FFFF
25011 72B8           BB                   FFFF  mov	bx,#$FFFF
25012 72BB           53                         push	bx
25013 72BC           50                         push	ax
25014                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
25015 72BD           8B46         0C            mov	ax,$C[bp]
25016                                           ! Debug: list unsigned int = ax+$14 (used reg = )
25017 72C0           05                   0014  add	ax,*$14
25018 72C3           50                         push	ax
25019                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25020 72C4           FF76         06            push	6[bp]
25021                                           ! Debug: func () void = write_dword+0 (used reg = )
25022 72C7           E8         8DA2            call	_write_dword
25023 72CA           83C4                   08  add	sp,*8
25024                                           !BCC_EOS
25025                                           ! 3835         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
25026                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
25027 72CD           FF76         D8            push	-$28[bp]
25028                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
25029 72D0           8B46         0C            mov	ax,$C[bp]
25030                                           ! Debug: list unsigned int = ax+$18 (used reg = )
25031 72D3           05                   0018  add	ax,*$18
25032 72D6           50                         push	ax
25033                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25034 72D7           FF76         06            push	6[bp]
25035                                           ! Debug: func () void = write_word+0 (used reg = )
25036 72DA           E8         935F            call	_write_word
25037 72DD           83C4                   06  add	sp,*6
25038                                           !BCC_EOS
25039                                           ! 3836         }
25040                                           ! 3837       if(size >= 0x1e) {
25041                       000072E0            .554:
25042                                           ! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
25043 72E0           8B46         E0            mov	ax,-$20[bp]
25044 72E3           3D                   001E  cmp	ax,*$1E
25045 72E6         0F82         01F9            blo 	.556
25046                       000072EA            .557:
25047                                           ! 3838         Bit8u channel, dev, irq, mode, checksum, i;
25048                                           !BCC_EOS
25049                                           ! 3839         Bit16u iobase1, iobase2, options;
25050                                           !BCC_EOS
25051                                           ! 3840         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
25052                                           ! Debug: list int = const $1E (used reg = )
25053 72EA           B8                   001E  mov	ax,*$1E
25054 72ED           50                         push	ax
25055                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
25056 72EE           8B46         0C            mov	ax,$C[bp]
25057                                           ! Debug: list unsigned int = ax+0 (used reg = )
25058 72F1           50                         push	ax
25059                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25060 72F2           FF76         06            push	6[bp]
25061                                           ! Debug: func () void = write_word+0 (used reg = )
25062 72F5           E8         9344            call	_write_word
25063 72F8           83C4                   06  add	sp,*6
25064                                           !BCC_EOS
25065                                           ! 3841         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
25066                                           ! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
25067 72FB           FF76         FE            push	-2[bp]
25068                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
25069 72FE           8B46         0C            mov	ax,$C[bp]
25070                                           ! Debug: list unsigned int = ax+$1C (used reg = )
25071 7301           05                   001C  add	ax,*$1C
25072 7304           50                         push	ax
25073                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25074 7305           FF76         06            push	6[bp]
25075                                           ! Debug: func () void = write_word+0 (used reg = )
25076 7308           E8         9331            call	_write_word
25077 730B           83C4                   06  add	sp,*6
25078                                           !BCC_EOS
25079                                           ! 3842         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
25080                                           ! Debug: list * struct  = const $224 (used reg = )
25081 730E           B8                   0224  mov	ax,#$224
25082 7311           50                         push	ax
25083                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
25084 7312           8B46         0C            mov	ax,$C[bp]
25085                                           ! Debug: list unsigned int = ax+$1A (used reg = )
25086 7315           05                   001A  add	ax,*$1A
25087 7318           50                         push	ax
25088                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25089 7319           FF76         06            push	6[bp]
25090                                           ! Debug: func () void = write_word+0 (used reg = )
25091 731C           E8         931D            call	_write_word
25092 731F           83C4                   06  add	sp,*6
25093                                           !BCC_EOS
25094                                           ! 3843         channel = device / 2;
25095                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
25096 7322           8A46         FD            mov	al,-3[bp]
25097 7325           30E4                       xor	ah,ah
25098 7327           D1E8                       shr	ax,*1
25099                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
25100 7329           8846         DF            mov	-$21[bp],al
25101                                           !BCC_EOS
25102                                           ! 3844         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25103                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
25104 732C           8A46         DF            mov	al,-$21[bp]
25105 732F           30E4                       xor	ah,ah
25106 7331           B1                     03  mov	cl,*3
25107 7333           D3E0                       shl	ax,cl
25108 7335           89C3                       mov	bx,ax
25109                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25110                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25111 7337           81C3                 0124  add	bx,#$124
25112 733B           53                         push	bx
25113                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
25114 733C           FF76         FE            push	-2[bp]
25115                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25116 733F           E8         92CF            call	_read_word
25117 7342           83C4                   04  add	sp,*4
25118                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
25119 7345           8946         D8            mov	-$28[bp],ax
25120                                           !BCC_EOS
25121                                           ! 3845         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
25122                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
25123 7348           8A46         DF            mov	al,-$21[bp]
25124 734B           30E4                       xor	ah,ah
25125 734D           B1                     03  mov	cl,*3
25126 734F           D3E0                       shl	ax,cl
25127 7351           89C3                       mov	bx,ax
25128                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
25129                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
25130 7353           81C3                 0126  add	bx,#$126
25131 7357           53                         push	bx
25132                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
25133 7358           FF76         FE            push	-2[bp]
25134                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25135 735B           E8         92B3            call	_read_word
25136 735E           83C4                   04  add	sp,*4
25137                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
25138 7361           8946         D6            mov	-$2A[bp],ax
25139                                           !BCC_EOS
25140                                           ! 3846         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
25141                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
25142 7364           8A46         DF            mov	al,-$21[bp]
25143 7367           30E4                       xor	ah,ah
25144 7369           B1                     03  mov	cl,*3
25145 736B           D3E0                       shl	ax,cl
25146 736D           89C3                       mov	bx,ax
25147                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
25148                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
25149 736F           81C3                 0128  add	bx,#$128
25150 7373           53                         push	bx
25151                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
25152 7374           FF76         FE            push	-2[bp]
25153                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25154 7377           E8         9284            call	_read_byte
25155 737A           83C4                   04  add	sp,*4
25156                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
25157 737D           8846         DD            mov	-$23[bp],al
25158                                           !BCC_EOS
25159                                           ! 3847         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
25160                                           ! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
25161 7380           8A46         FD            mov	al,-3[bp]
25162 7383           30E4                       xor	ah,ah
25163 7385           B9                   001A  mov	cx,*$1A
25164 7388           F7E9                       imul	cx
25165 738A           89C3                       mov	bx,ax
25166                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
25167                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
25168 738C           81C3                 0146  add	bx,#$146
25169 7390           53                         push	bx
25170                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
25171 7391           FF76         FE            push	-2[bp]
25172                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25173 7394           E8         9267            call	_read_byte
25174 7397           83C4                   04  add	sp,*4
25175                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
25176 739A           8846         DC            mov	-$24[bp],al
25177                                           !BCC_EOS
25178                                           ! 3848         options = (1<<4);
25179                                           ! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
25180 739D           B8                   0010  mov	ax,*$10
25181 73A0           8946         D4            mov	-$2C[bp],ax
25182                                           !BCC_EOS
25183                                           ! 3849         options |= (1<<5);
25184                                           ! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
25185 73A3           8B46         D4            mov	ax,-$2C[bp]
25186 73A6           0C                     20  or	al,*$20
25187 73A8           8946         D4            mov	-$2C[bp],ax
25188                                           !BCC_EOS
25189                                           ! 3850         options |= (1<<6);
25190                                           ! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
25191 73AB           8B46         D4            mov	ax,-$2C[bp]
25192 73AE           0C                     40  or	al,*$40
25193 73B0           8946         D4            mov	-$2C[bp],ax
25194                                           !BCC_EOS
25195                                           ! 3851         options |= (mode==0x01?1:0<<7);
25196                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
25197 73B3           8A46         DC            mov	al,-$24[bp]
25198 73B6           3C                     01  cmp	al,*1
25199 73B8           75           04            jne 	.558
25200                       000073BA            .559:
25201 73BA           B0                     01  mov	al,*1
25202 73BC           EB           02            jmp .55A
25203                       000073BE            .558:
25204 73BE           30C0                       xor	al,al
25205                       000073C0            .55A:
25206                                           ! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
25207 73C0           30E4                       xor	ah,ah
25208 73C2           0B46         D4            or	ax,-$2C[bp]
25209 73C5           8946         D4            mov	-$2C[bp],ax
25210                                           !BCC_EOS
25211                                           ! 3852         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
25212                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
25213 73C8           FF76         D8            push	-$28[bp]
25214                                           ! Debug: list * unsigned short = const $224 (used reg = )
25215 73CB           B8                   0224  mov	ax,#$224
25216 73CE           50                         push	ax
25217                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25218 73CF           FF76         FE            push	-2[bp]
25219                                           ! Debug: func () void = write_word+0 (used reg = )
25220 73D2           E8         9267            call	_write_word
25221 73D5           83C4                   06  add	sp,*6
25222                                           !BCC_EOS
25223                                           ! 3853         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2);
25224                                           ! Debug: list unsigned short iobase2 = [S+$2E-$2C] (used reg = )
25225 73D8           FF76         D6            push	-$2A[bp]
25226                                           ! Debug: list * unsigned short = const $226 (used reg = )
25227 73DB           B8                   0226  mov	ax,#$226
25228 73DE           50                         push	ax
25229                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25230 73DF           FF76         FE            push	-2[bp]
25231                                           ! Debug: func () void = write_word+0 (used reg = )
25232 73E2           E8         9257            call	_write_word
25233 73E5           83C4                   06  add	sp,*6
25234                                           !BCC_EOS
25235                                           ! 3854         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
25236                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
25237 73E8           8A46         FD            mov	al,-3[bp]
25238 73EB           30E4                       xor	ah,ah
25239 73ED           24                     01  and	al,*1
25240                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
25241                                           ! Debug: expression subtree swapping
25242 73EF           0C                     0E  or	al,*$E
25243                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
25244 73F1           30E4                       xor	ah,ah
25245 73F3           B1                     04  mov	cl,*4
25246 73F5           D3E0                       shl	ax,cl
25247                                           ! Debug: list unsigned int = ax+0 (used reg = )
25248 73F7           50                         push	ax
25249                                           ! Debug: list * unsigned char = const $228 (used reg = )
25250 73F8           B8                   0228  mov	ax,#$228
25251 73FB           50                         push	ax
25252                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25253 73FC           FF76         FE            push	-2[bp]
25254                                           ! Debug: func () void = write_byte+0 (used reg = )
25255 73FF           E8         9222            call	_write_byte
25256 7402           83C4                   06  add	sp,*6
25257                                           !BCC_EOS
25258                                           ! 3855         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
25259                                           ! Debug: list int = const $CB (used reg = )
25260 7405           B8                   00CB  mov	ax,#$CB
25261 7408           50                         push	ax
25262                                           ! Debug: list * unsigned char = const $229 (used reg = )
25263 7409           B8                   0229  mov	ax,#$229
25264 740C           50                         push	ax
25265                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25266 740D           FF76         FE            push	-2[bp]
25267                                           ! Debug: func () void = write_byte+0 (used reg = )
25268 7410           E8         9211            call	_write_byte
25269 7413           83C4                   06  add	sp,*6
25270                                           !BCC_EOS
25271                                           ! 3856         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
25272                                           ! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
25273 7416           8A46         DD            mov	al,-$23[bp]
25274 7419           30E4                       xor	ah,ah
25275 741B           50                         push	ax
25276                                           ! Debug: list * unsigned char = const $22A (used reg = )
25277 741C           B8                   022A  mov	ax,#$22A
25278 741F           50                         push	ax
25279                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25280 7420           FF76         FE            push	-2[bp]
25281                                           ! Debug: func () void = write_byte+0 (used reg = )
25282 7423           E8         91FE            call	_write_byte
25283 7426           83C4                   06  add	sp,*6
25284                                           !BCC_EOS
25285                                           ! 3857         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
25286                                           ! Debug: list int = const 1 (used reg = )
25287 7429           B8                   0001  mov	ax,*1
25288 742C           50                         push	ax
25289                                           ! Debug: list * unsigned char = const $22B (used reg = )
25290 742D           B8                   022B  mov	ax,#$22B
25291 7430           50                         push	ax
25292                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25293 7431           FF76         FE            push	-2[bp]
25294                                           ! Debug: func () void = write_byte+0 (used reg = )
25295 7434           E8         91ED            call	_write_byte
25296 7437           83C4                   06  add	sp,*6
25297                                           !BCC_EOS
25298                                           ! 3858         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
25299                                           ! Debug: list int = const 0 (used reg = )
25300 743A           31C0                       xor	ax,ax
25301 743C           50                         push	ax
25302                                           ! Debug: list * unsigned char = const $22C (used reg = )
25303 743D           B8                   022C  mov	ax,#$22C
25304 7440           50                         push	ax
25305                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25306 7441           FF76         FE            push	-2[bp]
25307                                           ! Debug: func () void = write_byte+0 (used reg = )
25308 7444           E8         91DD            call	_write_byte
25309 7447           83C4                   06  add	sp,*6
25310                                           !BCC_EOS
25311                                           ! 3859         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
25312                                           ! Debug: list int = const 0 (used reg = )
25313 744A           31C0                       xor	ax,ax
25314 744C           50                         push	ax
25315                                           ! Debug: list * unsigned char = const $22D (used reg = )
25316 744D           B8                   022D  mov	ax,#$22D
25317 7450           50                         push	ax
25318                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25319 7451           FF76         FE            push	-2[bp]
25320                                           ! Debug: func () void = write_byte+0 (used reg = )
25321 7454           E8         91CD            call	_write_byte
25322 7457           83C4                   06  add	sp,*6
25323                                           !BCC_EOS
25324                                           ! 3860         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
25325                                           ! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
25326 745A           FF76         D4            push	-$2C[bp]
25327                                           ! Debug: list * unsigned short = const $22E (used reg = )
25328 745D           B8                   022E  mov	ax,#$22E
25329 7460           50                         push	ax
25330                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25331 7461           FF76         FE            push	-2[bp]
25332                                           ! Debug: func () void = write_word+0 (used reg = )
25333 7464           E8         91D5            call	_write_word
25334 7467           83C4                   06  add	sp,*6
25335                                           !BCC_EOS
25336                                           ! 3861         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
25337                                           ! Debug: list int = const 0 (used reg = )
25338 746A           31C0                       xor	ax,ax
25339 746C           50                         push	ax
25340                                           ! Debug: list * unsigned short = const $230 (used reg = )
25341 746D           B8                   0230  mov	ax,#$230
25342 7470           50                         push	ax
25343                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25344 7471           FF76         FE            push	-2[bp]
25345                                           ! Debug: func () void = write_word+0 (used reg = )
25346 7474           E8         91C5            call	_write_word
25347 7477           83C4                   06  add	sp,*6
25348                                           !BCC_EOS
25349                                           ! 3862         write_byte(ebda_seg, &
25350                                           ! 3862 ((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
25351                                           ! Debug: list int = const $11 (used reg = )
25352 747A           B8                   0011  mov	ax,*$11
25353 747D           50                         push	ax
25354                                           ! Debug: list * unsigned char = const $232 (used reg = )
25355 747E           B8                   0232  mov	ax,#$232
25356 7481           50                         push	ax
25357                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25358 7482           FF76         FE            push	-2[bp]
25359                                           ! Debug: func () void = write_byte+0 (used reg = )
25360 7485           E8         919C            call	_write_byte
25361 7488           83C4                   06  add	sp,*6
25362                                           !BCC_EOS
25363                                           ! 3863         checksum=0;
25364                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
25365 748B           30C0                       xor	al,al
25366 748D           8846         DB            mov	-$25[bp],al
25367                                           !BCC_EOS
25368                                           ! 3864         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, (&((ebda_data_t *) 0)->ata.dpte) + i);
25369                                           ! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
25370 7490           30C0                       xor	al,al
25371 7492           8846         DA            mov	-$26[bp],al
25372                                           !BCC_EOS
25373                                           !BCC_EOS
25374 7495           EB           28            jmp .55D
25375                       00007497            .55E:
25376                                           ! Debug: ptradd unsigned char i = [S+$2E-$28] to * struct  = const $224 (used reg = )
25377 7497           8A46         DA            mov	al,-$26[bp]
25378 749A           30E4                       xor	ah,ah
25379 749C           B1                     04  mov	cl,*4
25380 749E           D3E0                       shl	ax,cl
25381                                           ! Debug: list * struct  = ax+$224 (used reg = )
25382 74A0           05                   0224  add	ax,#$224
25383 74A3           50                         push	ax
25384                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
25385 74A4           FF76         FE            push	-2[bp]
25386                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25387 74A7           E8         9154            call	_read_byte
25388 74AA           83C4                   04  add	sp,*4
25389                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
25390 74AD           30E4                       xor	ah,ah
25391 74AF           0246         DB            add	al,-$25[bp]
25392 74B2           80D4                   00  adc	ah,*0
25393 74B5           8846         DB            mov	-$25[bp],al
25394                                           !BCC_EOS
25395                                           ! 3865         checksum = ~checksum;
25396                       000074B8            .55C:
25397                                           ! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
25398 74B8           8A46         DA            mov	al,-$26[bp]
25399 74BB           40                         inc	ax
25400 74BC           8846         DA            mov	-$26[bp],al
25401                       000074BF            .55D:
25402                                           ! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
25403 74BF           8A46         DA            mov	al,-$26[bp]
25404 74C2           3C                     0F  cmp	al,*$F
25405 74C4           72           D1            jb 	.55E
25406                       000074C6            .55F:
25407                       000074C6            .55B:
25408                                           ! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
25409 74C6           8A46         DB            mov	al,-$25[bp]
25410 74C9           30E4                       xor	ah,ah
25411 74CB           F7D0                       not	ax
25412                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
25413 74CD           8846         DB            mov	-$25[bp],al
25414                                           !BCC_EOS
25415                                           ! 3866         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
25416                                           ! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
25417 74D0           8A46         DB            mov	al,-$25[bp]
25418 74D3           30E4                       xor	ah,ah
25419 74D5           50                         push	ax
25420                                           ! Debug: list * unsigned char = const $233 (used reg = )
25421 74D6           B8                   0233  mov	ax,#$233
25422 74D9           50                         push	ax
25423                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
25424 74DA           FF76         FE            push	-2[bp]
25425                                           ! Debug: func () void = write_byte+0 (used reg = )
25426 74DD           E8         9144            call	_write_byte
25427 74E0           83C4                   06  add	sp,*6
25428                                           !BCC_EOS
25429                                           ! 3867         }
25430                                           ! 3868       if(size >= 0x42) {
25431                       000074E3            .556:
25432                                           ! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
25433 74E3           8B46         E0            mov	ax,-$20[bp]
25434 74E6           3D                   0042  cmp	ax,*$42
25435 74E9         0F82         023B            blo 	.560
25436                       000074ED            .561:
25437                                           ! 3869         Bit8u channel, iface, checksum, i;
25438                                           !BCC_EOS
25439                                           ! 3870         Bit16u iobase1;
25440                                           !BCC_EOS
25441                                           ! 3871         channel = device / 2;
25442                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
25443 74ED           8A46         FD            mov	al,-3[bp]
25444 74F0           30E4                       xor	ah,ah
25445 74F2           D1E8                       shr	ax,*1
25446                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
25447 74F4           8846         DF            mov	-$21[bp],al
25448                                           !BCC_EOS
25449                                           ! 3872         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
25450                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
25451 74F7           8A46         DF            mov	al,-$21[bp]
25452 74FA           30E4                       xor	ah,ah
25453 74FC           B1                     03  mov	cl,*3
25454 74FE           D3E0                       shl	ax,cl
25455 7500           89C3                       mov	bx,ax
25456                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
25457                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
25458 7502           81C3                 0122  add	bx,#$122
25459 7506           53                         push	bx
25460                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
25461 7507           FF76         FE            push	-2[bp]
25462                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25463 750A           E8         90F1            call	_read_byte
25464 750D           83C4                   04  add	sp,*4
25465                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
25466 7510           8846         DE            mov	-$22[bp],al
25467                                           !BCC_EOS
25468                                           ! 3873         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25469                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
25470 7513           8A46         DF            mov	al,-$21[bp]
25471 7516           30E4                       xor	ah,ah
25472 7518           B1                     03  mov	cl,*3
25473 751A           D3E0                       shl	ax,cl
25474 751C           89C3                       mov	bx,ax
25475                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25476                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25477 751E           81C3                 0124  add	bx,#$124
25478 7522           53                         push	bx
25479                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
25480 7523           FF76         FE            push	-2[bp]
25481                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25482 7526           E8         90E8            call	_read_word
25483 7529           83C4                   04  add	sp,*4
25484                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
25485 752C           8946         DA            mov	-$26[bp],ax
25486                                           !BCC_EOS
25487                                           ! 3874         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
25488                                           ! Debug: list int = const $42 (used reg = )
25489 752F           B8                   0042  mov	ax,*$42
25490 7532           50                         push	ax
25491                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
25492 7533           8B46         0C            mov	ax,$C[bp]
25493                                           ! Debug: list unsigned int = ax+0 (used reg = )
25494 7536           50                         push	ax
25495                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25496 7537           FF76         06            push	6[bp]
25497                                           ! Debug: func () void = write_word+0 (used reg = )
25498 753A           E8         90FF            call	_write_word
25499 753D           83C4                   06  add	sp,*6
25500                                           !BCC_EOS
25501                                           ! 3875         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
25502                                           ! Debug: list unsigned int = const $BEDD (used reg = )
25503 7540           B8                   BEDD  mov	ax,#$BEDD
25504 7543           50                         push	ax
25505                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
25506 7544           8B46         0C            mov	ax,$C[bp]
25507                                           ! Debug: list unsigned int = ax+$1E (used reg = )
25508 7547           05                   001E  add	ax,*$1E
25509 754A           50                         push	ax
25510                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25511 754B           FF76         06            push	6[bp]
25512                                           ! Debug: func () void = write_word+0 (used reg = )
25513 754E           E8         90EB            call	_write_word
25514 7551           83C4                   06  add	sp,*6
25515                                           !BCC_EOS
25516                                           ! 3876         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
25517                                           ! Debug: list int = const $24 (used reg = )
25518 7554           B8                   0024  mov	ax,*$24
25519 7557           50                         push	ax
25520                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
25521 7558           8B46         0C            mov	ax,$C[bp]
25522                                           ! Debug: list unsigned int = ax+$20 (used reg = )
25523 755B           05                   0020  add	ax,*$20
25524 755E           50                         push	ax
25525                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25526 755F           FF76         06            push	6[bp]
25527                                           ! Debug: func () void = write_byte+0 (used reg = )
25528 7562           E8         90BF            call	_write_byte
25529 7565           83C4                   06  add	sp,*6
25530                                           !BCC_EOS
25531                                           ! 3877         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
25532                                           ! Debug: list int = const 0 (used reg = )
25533 7568           31C0                       xor	ax,ax
25534 756A           50                         push	ax
25535                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
25536 756B           8B46         0C            mov	ax,$C[bp]
25537                                           ! Debug: list unsigned int = ax+$21 (used reg = )
25538 756E           05                   0021  add	ax,*$21
25539 7571           50                         push	ax
25540                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25541 7572           FF76         06            push	6[bp]
25542                                           ! Debug: func () void = write_byte+0 (used reg = )
25543 7575           E8         90AC            call	_write_byte
25544 7578           83C4                   06  add	sp,*6
25545                                           !BCC_EOS
25546                                           ! 3878         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
25547                                           ! Debug: list int = const 0 (used reg = )
25548 757B           31C0                       xor	ax,ax
25549 757D           50                         push	ax
25550                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
25551 757E           8B46         0C            mov	ax,$C[bp]
25552                                           ! Debug: list unsigned int = ax+$22 (used reg = )
25553 7581           05                   0022  add	ax,*$22
25554 7584           50                         push	ax
25555                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25556 7585           FF76         06            push	6[bp]
25557                                           ! Debug: func () void = write_word+0 (used reg = )
25558 7588           E8         90B1            call	_write_word
25559 758B           83C4                   06  add	sp,*6
25560                                           !BCC_EOS
25561                                           ! 3879         if (iface==0x00) {
25562                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
25563 758E           8A46         DE            mov	al,-$22[bp]
25564 7591           84C0                       test	al,al
25565 7593           75           51            jne 	.562
25566                       00007595            .563:
25567                                           ! 3880           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
25568                                           ! Debug: list int = const $49 (used reg = )
25569 7595           B8                   0049  mov	ax,*$49
25570 7598           50                         push	ax
25571                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
25572 7599           8B46         0C            mov	ax,$C[bp]
25573                                           ! Debug: list unsigned int = ax+$24 (used reg = )
25574 759C           05                   0024  add	ax,*$24
25575 759F           50                         push	ax
25576                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25577 75A0           FF76         06            push	6[bp]
25578                                           ! Debug: func () void = write_byte+0 (used reg = )
25579 75A3           E8         907E            call	_write_byte
25580 75A6           83C4                   06  add	sp,*6
25581                                           !BCC_EOS
25582                                           ! 3881           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
25583                                           ! Debug: list int = const $53 (used reg = )
25584 75A9           B8                   0053  mov	ax,*$53
25585 75AC           50                         push	ax
25586                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
25587 75AD           8B46         0C            mov	ax,$C[bp]
25588                                           ! Debug: list unsigned int = ax+$25 (used reg = )
25589 75B0           05                   0025  add	ax,*$25
25590 75B3           50                         push	ax
25591                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25592 75B4           FF76         06            push	6[bp]
25593                                           ! Debug: func () void = write_byte+0 (used reg = )
25594 75B7           E8         906A            call	_write_byte
25595 75BA           83C4                   06  add	sp,*6
25596                                           !BCC_EOS
25597                                           ! 3882           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
25598                                           ! Debug: list int = const $41 (used reg = )
25599 75BD           B8                   0041  mov	ax,*$41
25600 75C0           50                         push	ax
25601                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
25602 75C1           8B46         0C            mov	ax,$C[bp]
25603                                           ! Debug: list unsigned int = ax+$26 (used reg = )
25604 75C4           05                   0026  add	ax,*$26
25605 75C7           50                         push	ax
25606                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25607 75C8           FF76         06            push	6[bp]
25608                                           ! Debug: func () void = write_byte+0 (used reg = )
25609 75CB           E8         9056            call	_write_byte
25610 75CE           83C4                   06  add	sp,*6
25611                                           !BCC_EOS
25612                                           ! 3883           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
25613                                           ! Debug: list int = const 0 (used reg = )
25614 75D1           31C0                       xor	ax,ax
25615 75D3           50                         push	ax
25616                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
25617 75D4           8B46         0C            mov	ax,$C[bp]
25618                                           ! Debug: list unsigned int = ax+$27 (used reg = )
25619 75D7           05                   0027  add	ax,*$27
25620 75DA           50                         push	ax
25621                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25622 75DB           FF76         06            push	6[bp]
25623                                           ! Debug: func () void = write_byte+0 (used reg = )
25624 75DE           E8         9043            call	_write_byte
25625 75E1           83C4                   06  add	sp,*6
25626                                           !BCC_EOS
25627                                           ! 3884           }
25628                                           ! 3885         else {
25629 75E4           EB           00            jmp .564
25630                       000075E6            .562:
25631                                           ! 3886           }
25632                                           ! 3887         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
25633                       000075E6            .564:
25634                                           ! Debug: list int = const $41 (used reg = )
25635 75E6           B8                   0041  mov	ax,*$41
25636 75E9           50                         push	ax
25637                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
25638 75EA           8B46         0C            mov	ax,$C[bp]
25639                                           ! Debug: list unsigned int = ax+$28 (used reg = )
25640 75ED           05                   0028  add	ax,*$28
25641 75F0           50                         push	ax
25642                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25643 75F1           FF76         06            push	6[bp]
25644                                           ! Debug: func () void = write_byte+0 (used reg = )
25645 75F4           E8         902D            call	_write_byte
25646 75F7           83C4                   06  add	sp,*6
25647                                           !BCC_EOS
25648                                           ! 3888         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
25649                                           ! Debug: list int = const $54 (used reg = )
25650 75FA           B8                   0054  mov	ax,*$54
25651 75FD           50                         push	ax
25652                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
25653 75FE           8B46         0C            mov	ax,$C[bp]
25654                                           ! Debug: list unsigned int = ax+$29 (used reg = )
25655 7601           05                   0029  add	ax,*$29
25656 7604           50                         push	ax
25657                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25658 7605           FF76         06            push	6[bp]
25659                                           ! Debug: func () void = write_byte+0 (used reg = )
25660 7608           E8         9019            call	_write_byte
25661 760B           83C4                   06  add	sp,*6
25662                                           !BCC_EOS
25663                                           ! 3889         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
25664                                           ! Debug: list int = const $41 (used reg = )
25665 760E           B8                   0041  mov	ax,*$41
25666 7611           50                         push	ax
25667                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
25668 7612           8B46         0C            mov	ax,$C[bp]
25669                                           ! Debug: list unsigned int = ax+$2A (used reg = )
25670 7615           05                   002A  add	ax,*$2A
25671 7618           50                         push	ax
25672                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25673 7619           FF76         06            push	6[bp]
25674                                           ! Debug: func () void = write_byte+0 (used reg = )
25675 761C           E8         9005            call	_write_byte
25676 761F           83C4                   06  add	sp,*6
25677                                           !BCC_EOS
25678                                           ! 3890         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
25679                                           ! Debug: list int = const 0 (used reg = )
25680 7622           31C0                       xor	ax,ax
25681 7624           50                         push	ax
25682                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
25683 7625           8B46         0C            mov	ax,$C[bp]
25684                                           ! Debug: list unsigned int = ax+$2B (used reg = )
25685 7628           05                   002B  add	ax,*$2B
25686 762B           50                         push	ax
25687                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25688 762C           FF76         06            push	6[bp]
25689                                           ! Debug: func () void = write_byte+0 (used reg = )
25690 762F           E8         8FF2            call	_write_byte
25691 7632           83C4                   06  add	sp,*6
25692                                           !BCC_EOS
25693                                           ! 3891         if (iface==0x00) {
25694                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
25695 7635           8A46         DE            mov	al,-$22[bp]
25696 7638           84C0                       test	al,al
25697 763A           75           3E            jne 	.565
25698                       0000763C            .566:
25699                                           ! 3892           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
25700                                           ! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
25701 763C           FF76         DA            push	-$26[bp]
25702                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
25703 763F           8B46         0C            mov	ax,$C[bp]
25704                                           ! Debug: list unsigned int = ax+$30 (used reg = )
25705 7642           05                   0030  add	ax,*$30
25706 7645           50                         push	ax
25707                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25708 7646           FF76         06            push	6[bp]
25709                                           ! Debug: func () void = write_word+0 (used reg = )
25710 7649           E8         8FF0            call	_write_word
25711 764C           83C4                   06  add	sp,*6
25712                                           !BCC_EOS
25713                                           ! 3893           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
25714                                           ! Debug: list int = const 0 (used reg = )
25715 764F           31C0                       xor	ax,ax
25716 7651           50                         push	ax
25717                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
25718 7652           8B46         0C            mov	ax,$C[bp]
25719                                           ! Debug: list unsigned int = ax+$32 (used reg = )
25720 7655           05                   0032  add	ax,*$32
25721 7658           50                         push	ax
25722                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25723 7659           FF76         06            push	6[bp]
25724                                           ! Debug: func () void = write_word+0 (used reg = )
25725 765C           E8         8FDD            call	_write_word
25726 765F           83C4                   06  add	sp,*6
25727                                           !BCC_EOS
25728                                           ! 3894           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
25729                                           ! Debug: list long = const 0 (used reg = )
25730 7662           31C0                       xor	ax,ax
25731 7664           31DB                       xor	bx,bx
25732 7666           53                         push	bx
25733 7667           50                         push	ax
25734                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
25735 7668           8B46         0C            mov	ax,$C[bp]
25736                                           ! Debug: list unsigned int = ax+$34 (used reg = )
25737 766B           05                   0034  add	ax,*$34
25738 766E           50                         push	ax
25739                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25740 766F           FF76         06            push	6[bp]
25741                                           ! Debug: func () void = write_dword+0 (used reg = )
25742 7672           E8         89F7            call	_write_dword
25743 7675           83C4                   08  add	sp,*8
25744                                           !BCC_EOS
25745                                           ! 3895           }
25746                                           ! 3896         else {
25747 7678           EB           00            jmp .567
25748                       0000767A            .565:
25749                                           ! 3897           }
25750                                           ! 3898         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
25751                       0000767A            .567:
25752                                           ! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
25753 767A           8A46         FD            mov	al,-3[bp]
25754 767D           30E4                       xor	ah,ah
25755 767F           24                     01  and	al,*1
25756                                           ! Debug: list unsigned char = al+0 (used reg = )
25757 7681           30E4                       xor	ah,ah
25758 7683           50                         push	ax
25759                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
25760 7684           8B46         0C            mov	ax,$C[bp]
25761                                           ! Debug: list unsigned int = ax+$38 (used reg = )
25762 7687           05                   0038  add	ax,*$38
25763 768A           50                         push	ax
25764                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25765 768B           FF76         06            push	6[bp]
25766                                           ! Debug: func () void = write_byte+0 (used reg = )
25767 768E           E8         8F93            call	_write_byte
25768 7691           83C4                   06  add	sp,*6
25769                                           !BCC_EOS
25770                                           ! 3899         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
25771                                           ! Debug: list int = const 0 (used reg = )
25772 7694           31C0                       xor	ax,ax
25773 7696           50                         push	ax
25774                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
25775 7697           8B46         0C            mov	ax,$C[bp]
25776                                           ! Debug: list unsigned int = ax+$39 (used reg = )
25777 769A           05                   0039  add	ax,*$39
25778 769D           50                         push	ax
25779                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25780 769E           FF76         06            push	6[bp]
25781                                           ! Debug: func () void = write_byte+0 (used reg = )
25782 76A1           E8         8F80            call	_write_byte
25783 76A4           83C4                   06  add	sp,*6
25784                                           !BCC_EOS
25785                                           ! 3900         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
25786                                           ! Debug: list int = const 0 (used reg = )
25787 76A7           31C0                       xor	ax,ax
25788 76A9           50                         push	ax
25789                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
25790 76AA           8B46         0C            mov	ax,$C[bp]
25791                                           ! Debug: list unsigned int = ax+$3A (used reg = )
25792 76AD           05                   003A  add	ax,*$3A
25793 76B0           50                         push	ax
25794                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25795 76B1           FF76         06            push	6[bp]
25796                                           ! Debug: func () void = write_word+0 (used reg = )
25797 76B4           E8         8F85            call	_write_word
25798 76B7           83C4                   06  add	sp,*6
25799                                           !BCC_EOS
25800                                           ! 3901 
25801                                           ! 3901         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
25802                                           ! Debug: list long = const 0 (used reg = )
25803 76BA           31C0                       xor	ax,ax
25804 76BC           31DB                       xor	bx,bx
25805 76BE           53                         push	bx
25806 76BF           50                         push	ax
25807                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
25808 76C0           8B46         0C            mov	ax,$C[bp]
25809                                           ! Debug: list unsigned int = ax+$3C (used reg = )
25810 76C3           05                   003C  add	ax,*$3C
25811 76C6           50                         push	ax
25812                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
25813 76C7           FF76         06            push	6[bp]
25814                                           ! Debug: func () void = write_dword+0 (used reg = )
25815 76CA           E8         899F            call	_write_dword
25816 76CD           83C4                   08  add	sp,*8
25817                                           !BCC_EOS
25818                                           ! 3902         checksum=0;
25819                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
25820 76D0           30C0                       xor	al,al
25821 76D2           8846         DD            mov	-$23[bp],al
25822                                           !BCC_EOS
25823                                           ! 3903         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
25824                                           ! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
25825 76D5           B0                     1E  mov	al,*$1E
25826 76D7           8846         DC            mov	-$24[bp],al
25827                                           !BCC_EOS
25828                                           !BCC_EOS
25829 76DA           EB           25            jmp .56A
25830                       000076DC            .56B:
25831                                           ! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
25832 76DC           8B46         0C            mov	ax,$C[bp]
25833 76DF           0246         DC            add	al,-$24[bp]
25834 76E2           80D4                   00  adc	ah,*0
25835                                           ! Debug: list unsigned int = ax+0 (used reg = )
25836 76E5           50                         push	ax
25837                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
25838 76E6           FF76         06            push	6[bp]
25839                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25840 76E9           E8         8F12            call	_read_byte
25841 76EC           83C4                   04  add	sp,*4
25842                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
25843 76EF           30E4                       xor	ah,ah
25844 76F1           0246         DD            add	al,-$23[bp]
25845 76F4           80D4                   00  adc	ah,*0
25846 76F7           8846         DD            mov	-$23[bp],al
25847                                           !BCC_EOS
25848                                           ! 3904         checksum = ~checksum;
25849                       000076FA            .569:
25850                                           ! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
25851 76FA           8A46         DC            mov	al,-$24[bp]
25852 76FD           40                         inc	ax
25853 76FE           8846         DC            mov	-$24[bp],al
25854                       00007701            .56A:
25855                                           ! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
25856 7701           8A46         DC            mov	al,-$24[bp]
25857 7704           3C                     40  cmp	al,*$40
25858 7706           72           D4            jb 	.56B
25859                       00007708            .56C:
25860                       00007708            .568:
25861                                           ! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
25862 7708           8A46         DD            mov	al,-$23[bp]
25863 770B           30E4                       xor	ah,ah
25864 770D           F7D0                       not	ax
25865                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
25866 770F           8846         DD            mov	-$23[bp],al
25867                                           !BCC_EOS
25868                                           ! 3905         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
25869                                           ! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
25870 7712           8A46         DD            mov	al,-$23[bp]
25871 7715           30E4                       xor	ah,ah
25872 7717           50                         push	ax
25873                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
25874 7718           8B46         0C            mov	ax,$C[bp]
25875                                           ! Debug: list unsigned int = ax+$41 (used reg = )
25876 771B           05                   0041  add	ax,*$41
25877 771E           50                         push	ax
25878                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
25879 771F           FF76         06            push	6[bp]
25880                                           ! Debug: func () void = write_byte+0 (used reg = )
25881 7722           E8         8EFF            call	_write_byte
25882 7725           83C4                   06  add	sp,*6
25883                                           !BCC_EOS
25884                                           ! 3906         }
25885                                           ! 3907       goto int13_success;
25886                       00007728            .560:
25887 7728           83C4                   0C  add	sp,#..FFE8-..FFE9
25888 772B           E9         0110            br 	.FFE8
25889                                           !BCC_EOS
25890                                           ! 3908       break;
25891 772E           E9         00DD            br 	.519
25892                                           !BCC_EOS
25893                                           ! 3909     case 0x49:
25894                                           ! 3910       AX = ((AX & 0x00ff) | ((06) << 8));
25895                       00007731            .56D:
25896                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
25897 7731           8A46         18            mov	al,$18[bp]
25898                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
25899 7734           30E4                       xor	ah,ah
25900 7736           0D                   0600  or	ax,#$600
25901                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
25902 7739           8946         18            mov	$18[bp],ax
25903                                           !BCC_EOS
25904                                           ! 3911       goto int13_fail_nostatus;
25905 773C           83C4                   0C  add	sp,#..FFE6-..FFE9
25906 773F           E9         00F0            br 	.FFE6
25907                                           !BCC_EOS
25908                                           ! 3912       break;
25909 7742           E9         00C9            br 	.519
25910                                           !BCC_EOS
25911                                           ! 3913     case 0x4e:
25912                                           ! 3914       switch (( AX & 0x00ff )) {
25913                       00007745            .56E:
25914                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
25915 7745           8A46         18            mov	al,$18[bp]
25916 7748           EB           10            jmp .571
25917                                           ! 3915         case 0x01:
25918                                           ! 3916         case 0x03:
25919                       0000774A            .572:
25920                                           ! 3917         case 0x04:
25921                       0000774A            .573:
25922                                           ! 3918         case 0x06:
25923                       0000774A            .574:
25924                                           ! 3919           goto int13_success;
25925                       0000774A            .575:
25926 774A           83C4                   0C  add	sp,#..FFE8-..FFE9
25927 774D           E9         00EE            br 	.FFE8
25928                                           !BCC_EOS
25929                                           ! 3920           break;
25930 7750           EB           1A            jmp .56F
25931                                           !BCC_EOS
25932                                           ! 3921         default :
25933                                           ! 3922           goto int13_fail;
25934                       00007752            .576:
25935 7752           83C4                   0C  add	sp,#..FFEA-..FFE9
25936 7755           E9         00B9            br 	.FFEA
25937                                           !BCC_EOS
25938                                           ! 3923         }
25939                                           ! 3924       break;
25940 7758           EB           12            jmp .56F
25941                       0000775A            .571:
25942 775A           2C                     01  sub	al,*1
25943 775C           74           EC            je 	.572
25944 775E           2C                     02  sub	al,*2
25945 7760           74           E8            je 	.573
25946 7762           2C                     01  sub	al,*1
25947 7764           74           E4            je 	.574
25948 7766           2C                     02  sub	al,*2
25949 7768           74           E0            je 	.575
25950 776A           EB           E6            jmp	.576
25951                       0000776C            .56F:
25952 776C           E9         009F            br 	.519
25953                                           !BCC_EOS
25954                                           ! 3925     case 0x02:
25955                                           ! 3926     case 0x04:
25956                       0000776F            .577:
25957                                           ! 3927     case 0x08:
25958                       0000776F            .578:
25959                                           ! 3928     case 0x0a:
25960                       0000776F            .579:
25961                                           ! 3929     case 0x0b:
25962                       0000776F            .57A:
25963                                           ! 3930     case 0x18:
25964                       0000776F            .57B:
25965                                           ! 3931     case 0x50:
25966                       0000776F            .57C:
25967                                           ! 3932     default:
25968                       0000776F            .57D:
25969                                           ! 3933       bios_printf(4, "int13_cdrom: unsupported AH=%02x\n", ( AX >> 8 ));
25970                       0000776F            .57E:
25971                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
25972 776F           8B46         18            mov	ax,$18[bp]
25973 7772           88E0                       mov	al,ah
25974 7774           30E4                       xor	ah,ah
25975                                           ! Debug: list unsigned int = ax+0 (used reg = )
25976 7776           50                         push	ax
25977                                           ! Debug: list * char = .57F+0 (used reg = )
25978 7777           BB                   D314  mov	bx,#.57F
25979 777A           53                         push	bx
25980                                           ! Debug: list int = const 4 (used reg = )
25981 777B           B8                   0004  mov	ax,*4
25982 777E           50                         push	ax
25983                                           ! Debug: func () void = bios_printf+0 (used reg = )
25984 777F           E8         9127            call	_bios_printf
25985 7782           83C4                   06  add	sp,*6
25986                                           !BCC_EOS
25987                                           ! 3934       goto int13_fail;
25988 7785           83C4                   0C  add	sp,#..FFEA-..FFE9
25989 7788           E9         0086            br 	.FFEA
25990                                           !BCC_EOS
25991                                           ! 3935       break;
25992 778B           E9         0080            br 	.519
25993                                           !BCC_EOS
25994                                           ! 3936     }
25995                                           ! 3937 int13_fail:
25996 778E           EB           7E            jmp .519
25997                       00007790            .51B:
25998 7790           83C4                   F4  add	sp,*-$C
25999 7793           2D                   0000  sub	ax,*0
26000 7796           7C           D7            jl 	.57E
26001 7798           3D                   0018  cmp	ax,*$18
26002 779B           77           3B            ja  	.580
26003 779D           D1E0                       shl	ax,*1
26004 779F           89C3                       mov	bx,ax
26005 77A1           2E                         seg	cs
26006 77A2           FFA7       77A6            br	.581[bx]
26007                       000077A6            .581:
26008 77A6                      6DDE            .word	.51C
26009 77A8                      6DFB            .word	.527
26010 77AA                      776F            .word	.577
26011 77AC                      6DE7            .word	.524
26012 77AE                      776F            .word	.578
26013 77B0                      6DE7            .word	.525
26014 77B2                      776F            .word	.57E
26015 77B4                      776F            .word	.57E
26016 77B6                      776F            .word	.579
26017 77B8                      6DDE            .word	.51D
26018 77BA                      776F            .word	.57A
26019 77BC                      776F            .word	.57B
26020 77BE                      6DDE            .word	.51E
26021 77C0                      6DDE            .word	.51F
26022 77C2                      776F            .word	.57E
26023 77C4                      776F            .word	.57E
26024 77C6                      6DDE            .word	.520
26025 77C8                      6DDE            .word	.521
26026 77CA                      776F            .word	.57E
26027 77CC                      776F            .word	.57E
26028 77CE                      6DDE            .word	.522
26029 77D0                      6E4C            .word	.52B
26030 77D2                      6DDE            .word	.523
26031 77D4                      776F            .word	.57E
26032 77D6                      776F            .word	.57C
26033                       000077D8            .580:
26034 77D8           2D                   0041  sub	ax,*$41
26035 77DB           72           92            jb 	.57E
26036 77DD           3D                   000F  cmp	ax,*$F
26037 77E0           77           29            ja  	.582
26038 77E2           D1E0                       shl	ax,*1
26039 77E4           89C3                       mov	bx,ax
26040 77E6           2E                         seg	cs
26041 77E7           FFA7       77EB            br	.583[bx]
26042                       000077EB            .583:
26043 77EB                      6E60            .word	.52C
26044 77ED                      6E80            .word	.52D
26045 77EF                      6DE7            .word	.526
26046 77F1                      6E80            .word	.52E
26047 77F3                      7065            .word	.539
26048 77F5                      7183            .word	.54C
26049 77F7                      6E80            .word	.52F
26050 77F9                      71EC            .word	.551
26051 77FB                      7731            .word	.56D
26052 77FD                      776F            .word	.57E
26053 77FF                      776F            .word	.57E
26054 7801                      776F            .word	.57E
26055 7803                      776F            .word	.57E
26056 7805                      7745            .word	.56E
26057 7807                      776F            .word	.57E
26058 7809                      776F            .word	.57D
26059                       0000780B            .582:
26060 780B           E9         FF61            br 	.57E
26061                       0000780E            .519:
26062                       FFFFFFD2            ..FFE9	=	-$2E
26063 780E           83C4                   0C  add	sp,*$C
26064                       00007811            .FFEA:
26065                       FFFFFFDE            ..FFEA	=	-$22
26066                                           ! 3938     AX = ((AX & 0x00ff) | ((0x01) << 8));
26067                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26068 7811           8A46         18            mov	al,$18[bp]
26069                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
26070 7814           30E4                       xor	ah,ah
26071 7816           0D                   0100  or	ax,#$100
26072                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26073 7819           8946         18            mov	$18[bp],ax
26074                                           !BCC_EOS
26075                                           ! 3939 int13_fail_noah:
26076                       0000781C            .FFE7:
26077                       FFFFFFDE            ..FFE7	=	-$22
26078                                           ! 3940     write_byte(0x0040, 0x0074, ( AX >> 8 ));
26079                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26080 781C           8B46         18            mov	ax,$18[bp]
26081 781F           88E0                       mov	al,ah
26082 7821           30E4                       xor	ah,ah
26083                                           ! Debug: list unsigned int = ax+0 (used reg = )
26084 7823           50                         push	ax
26085                                           ! Debug: list int = const $74 (used reg = )
26086 7824           B8                   0074  mov	ax,*$74
26087 7827           50                         push	ax
26088                                           ! Debug: list int = const $40 (used reg = )
26089 7828           B8                   0040  mov	ax,*$40
26090 782B           50                         push	ax
26091                                           ! Debug: func () void = write_byte+0 (used reg = )
26092 782C           E8         8DF5            call	_write_byte
26093 782F           83C4                   06  add	sp,*6
26094                                           !BCC_EOS
26095                                           ! 3941 int13_fail_nostatus:
26096                       00007832            .FFE6:
26097                       FFFFFFDE            ..FFE6	=	-$22
26098                                           ! 3942     FLAGS |= 0x0001;
26099                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
26100 7832           8B46         1E            mov	ax,$1E[bp]
26101 7835           0C                     01  or	al,*1
26102 7837           8946         1E            mov	$1E[bp],ax
26103                                           !BCC_EOS
26104                                           ! 3943     return;
26105 783A           89EC                       mov	sp,bp
26106 783C           5D                         pop	bp
26107 783D           C3                         ret
26108                                           !BCC_EOS
26109                                           ! 3944 int13_success:
26110                       0000783E            .FFE8:
26111                       FFFFFFDE            ..FFE8	=	-$22
26112                                           ! 3945     AX = ((AX & 0x00ff) | ((0x00) << 8));
26113                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26114 783E           8A46         18            mov	al,$18[bp]
26115                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
26116 7841           0C                     00  or	al,*0
26117                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
26118 7843           30E4                       xor	ah,ah
26119 7845           8946         18            mov	$18[bp],ax
26120                                           !BCC_EOS
26121                                           ! 3946 int13_success_noah:
26122                       00007848            .FFE5:
26123                       FFFFFFDE            ..FFE5	=	-$22
26124                                           ! 3947     write_byte(0x0040, 0x0074, 0x00);
26125                                           ! Debug: list int = const 0 (used reg = )
26126 7848           31C0                       xor	ax,ax
26127 784A           50                         push	ax
26128                                           ! Debug: list int = const $74 (used reg = )
26129 784B           B8                   0074  mov	ax,*$74
26130 784E           50                         push	ax
26131                                           ! Debug: list int = const $40 (used reg = )
26132 784F           B8                   0040  mov	ax,*$40
26133 7852           50                         push	ax
26134                                           ! Debug: func () void = write_byte+0 (used reg = )
26135 7853           E8         8DCE            call	_write_byte
26136 7856           83C4                   06  add	sp,*6
26137                                           !BCC_EOS
26138                                           ! 3948     FLAGS &= 0xfffe;
26139                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
26140 7859           8B46         1E            mov	ax,$1E[bp]
26141 785C           24                     FE  and	al,#$FE
26142 785E           8946         1E            mov	$1E[bp],ax
26143                                           !BCC_EOS
26144                                           ! 3949     return;
26145 7861           89EC                       mov	sp,bp
26146 7863           5D                         pop	bp
26147 7864           C3                         ret
26148                                           !BCC_EOS
26149                                           ! 3950 }
26150                                           ! 3951   void
26151                                           ! Register BX used in function int13_cdrom
26152                                           ! 3952 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
26153                                           ! 3953   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
26154                                           export	_int13_eltorito
26155                       00007865            _int13_eltorito:
26156                                           !BCC_EOS
26157                                           ! 3954 {
26158                                           ! 3955   Bit16u ebda_seg=read_word(0x0040,0x000E);
26159 7865           55                         push	bp
26160 7866           89E5                       mov	bp,sp
26161 7868           4C                         dec	sp
26162 7869           4C                         dec	sp
26163                                           ! Debug: list int = const $E (used reg = )
26164 786A           B8                   000E  mov	ax,*$E
26165 786D           50                         push	ax
26166                                           ! Debug: list int = const $40 (used reg = )
26167 786E           B8                   0040  mov	ax,*$40
26168 7871           50                         push	ax
26169                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26170 7872           E8         8D9C            call	_read_word
26171 7875           83C4                   04  add	sp,*4
26172                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
26173 7878           8946         FE            mov	-2[bp],ax
26174                                           !BCC_EOS
26175                                           ! 3956   ;
26176                                           !BCC_EOS
26177                                           ! 3957   switch (( AX >> 8 )) {
26178                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
26179 787B           8B46         16            mov	ax,$16[bp]
26180 787E           88E0                       mov	al,ah
26181 7880           30E4                       xor	ah,ah
26182 7882           E9         01BE            br 	.586
26183                                           ! 3958     case 0x4a:
26184                                           ! 3959     case 0x4c:
26185                       00007885            .587:
26186                                           ! 3960     case 0x4d:
26187                       00007885            .588:
26188                                           ! 3961       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. Please report\n",AX);
26189                       00007885            .589:
26190                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
26191 7885           FF76         16            push	$16[bp]
26192                                           ! Debug: list * char = .58A+0 (used reg = )
26193 7888           BB                   D2E3  mov	bx,#.58A
26194 788B           53                         push	bx
26195                                           ! Debug: list int = const 7 (used reg = )
26196 788C           B8                   0007  mov	ax,*7
26197 788F           50                         push	ax
26198                                           ! Debug: func () void = bios_printf+0 (used reg = )
26199 7890           E8         9016            call	_bios_printf
26200 7893           83C4                   06  add	sp,*6
26201                                           !BCC_EOS
26202                                           ! 3962       goto int13_fail;
26203 7896           83C4                   00  add	sp,#..FFE3-..FFE4
26204 7899           E9         01C5            br 	.FFE3
26205                                           !BCC_EOS
26206                                           ! 3963       break;
26207 789C           E9         01C2            br 	.584
26208                                           !BCC_EOS
26209                                           ! 3964     case 0x4b:
26210                                           ! 3965       write_byte(DS,SI+0x00,0x13);
26211                       0000789F            .58B:
26212                                           ! Debug: list int = const $13 (used reg = )
26213 789F           B8                   0013  mov	ax,*$13
26214 78A2           50                         push	ax
26215                                           ! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
26216 78A3           8B46         0A            mov	ax,$A[bp]
26217                                           ! Debug: list unsigned int = ax+0 (used reg = )
26218 78A6           50                         push	ax
26219                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26220 78A7           FF76         04            push	4[bp]
26221                                           ! Debug: func () void = write_byte+0 (used reg = )
26222 78AA           E8         8D77            call	_write_byte
26223 78AD           83C4                   06  add	sp,*6
26224                                           !BCC_EOS
26225                                           ! 3966       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
26226                                           ! Debug: list * unsigned char = const $23B (used reg = )
26227 78B0           B8                   023B  mov	ax,#$23B
26228 78B3           50                         push	ax
26229                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26230 78B4           FF76         FE            push	-2[bp]
26231                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26232 78B7           E8         8D44            call	_read_byte
26233 78BA           83C4                   04  add	sp,*4
26234                                           ! Debug: list unsigned char = al+0 (used reg = )
26235 78BD           30E4                       xor	ah,ah
26236 78BF           50                         push	ax
26237                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
26238 78C0           8B46         0A            mov	ax,$A[bp]
26239                                           ! Debug: list unsigned int = ax+1 (used reg = )
26240 78C3           40                         inc	ax
26241 78C4           50                         push	ax
26242                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26243 78C5           FF76         04            push	4[bp]
26244                                           ! Debug: func () void = write_byte+0 (used reg = )
26245 78C8           E8         8D59            call	_write_byte
26246 78CB           83C4                   06  add	sp,*6
26247                                           !BCC_EOS
26248                                           ! 3967       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
26249                                           ! Debug: list * unsigned char = const $23C (used reg = )
26250 78CE           B8                   023C  mov	ax,#$23C
26251 78D1           50                         push	ax
26252                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26253 78D2           FF76         FE            push	-2[bp]
26254                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26255 78D5           E8         8D26            call	_read_byte
26256 78D8           83C4                   04  add	sp,*4
26257                                           ! Debug: list unsigned char = al+0 (used reg = )
26258 78DB           30E4                       xor	ah,ah
26259 78DD           50                         push	ax
26260                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
26261 78DE           8B46         0A            mov	ax,$A[bp]
26262                                           ! Debug: list unsigned int = ax+2 (used reg = )
26263 78E1           40                         inc	ax
26264 78E2           40                         inc	ax
26265 78E3           50                         push	ax
26266                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26267 78E4           FF76         04            push	4[bp]
26268                                           ! Debug: func () void = write_byte+0 (used reg = )
26269 78E7           E8         8D3A            call	_write_byte
26270 78EA           83C4                   06  add	sp,*6
26271                                           !BCC_EOS
26272                                           ! 3968       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
26273                                           ! Debug: list * unsigned char = const $23D (used reg = )
26274 78ED           B8                   023D  mov	ax,#$23D
26275 78F0           50                         push	ax
26276                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26277 78F1           FF76         FE            push	-2[bp]
26278                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26279 78F4           E8         8D07            call	_read_byte
26280 78F7           83C4                   04  add	sp,*4
26281                                           ! Debug: list unsigned char = al+0 (used reg = )
26282 78FA           30E4                       xor	ah,ah
26283 78FC           50                         push	ax
26284                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
26285 78FD           8B46         0A            mov	ax,$A[bp]
26286                                           ! Debug: list unsigned int = ax+3 (used reg = )
26287 7900           05                   0003  add	ax,*3
26288 7903           50                         push	ax
26289                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26290 7904           FF76         04            push	4[bp]
26291                                           ! Debug: func () void = write_byte+0 (used reg = )
26292 7907           E8         8D1A            call	_write_byte
26293 790A           83C4                   06  add	sp,*6
26294                                           !BCC_EOS
26295                                           ! 3969       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
26296                                           ! Debug: list * unsigned long = const $240 (used reg = )
26297 790D           B8                   0240  mov	ax,#$240
26298 7910           50                         push	ax
26299                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26300 7911           FF76         FE            push	-2[bp]
26301                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26302 7914           E8         873E            call	_read_dword
26303 7917           89D3                       mov	bx,dx
26304 7919           83C4                   04  add	sp,*4
26305                                           ! Debug: list unsigned long = bx+0 (used reg = )
26306 791C           53                         push	bx
26307 791D           50                         push	ax
26308                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
26309 791E           8B46         0A            mov	ax,$A[bp]
26310                                           ! Debug: list unsigned int = ax+4 (used reg = )
26311 7921           05                   0004  add	ax,*4
26312 7924           50                         push	ax
26313                                           ! Debug: list unsigned short DS = [S+$A+2] (used reg = )
26314 7925           FF76         04            push	4[bp]
26315                                           ! Debug: func () void = write_dword+0 (used reg = )
26316 7928           E8         8741            call	_write_dword
26317 792B           83C4                   08  add	sp,*8
26318                                           !BCC_EOS
26319                                           ! 3970       write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_da
26320                                           ! 3970 ta_t *) 0)->cdemu.device_spec));
26321                                           ! Debug: list * unsigned short = const $23E (used reg = )
26322 792E           B8                   023E  mov	ax,#$23E
26323 7931           50                         push	ax
26324                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26325 7932           FF76         FE            push	-2[bp]
26326                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26327 7935           E8         8CD9            call	_read_word
26328 7938           83C4                   04  add	sp,*4
26329                                           ! Debug: list unsigned short = ax+0 (used reg = )
26330 793B           50                         push	ax
26331                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
26332 793C           8B46         0A            mov	ax,$A[bp]
26333                                           ! Debug: list unsigned int = ax+8 (used reg = )
26334 793F           05                   0008  add	ax,*8
26335 7942           50                         push	ax
26336                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26337 7943           FF76         04            push	4[bp]
26338                                           ! Debug: func () void = write_word+0 (used reg = )
26339 7946           E8         8CF3            call	_write_word
26340 7949           83C4                   06  add	sp,*6
26341                                           !BCC_EOS
26342                                           ! 3971       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
26343                                           ! Debug: list * unsigned short = const $244 (used reg = )
26344 794C           B8                   0244  mov	ax,#$244
26345 794F           50                         push	ax
26346                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26347 7950           FF76         FE            push	-2[bp]
26348                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26349 7953           E8         8CBB            call	_read_word
26350 7956           83C4                   04  add	sp,*4
26351                                           ! Debug: list unsigned short = ax+0 (used reg = )
26352 7959           50                         push	ax
26353                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
26354 795A           8B46         0A            mov	ax,$A[bp]
26355                                           ! Debug: list unsigned int = ax+$A (used reg = )
26356 795D           05                   000A  add	ax,*$A
26357 7960           50                         push	ax
26358                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26359 7961           FF76         04            push	4[bp]
26360                                           ! Debug: func () void = write_word+0 (used reg = )
26361 7964           E8         8CD5            call	_write_word
26362 7967           83C4                   06  add	sp,*6
26363                                           !BCC_EOS
26364                                           ! 3972       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
26365                                           ! Debug: list * unsigned short = const $246 (used reg = )
26366 796A           B8                   0246  mov	ax,#$246
26367 796D           50                         push	ax
26368                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26369 796E           FF76         FE            push	-2[bp]
26370                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26371 7971           E8         8C9D            call	_read_word
26372 7974           83C4                   04  add	sp,*4
26373                                           ! Debug: list unsigned short = ax+0 (used reg = )
26374 7977           50                         push	ax
26375                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
26376 7978           8B46         0A            mov	ax,$A[bp]
26377                                           ! Debug: list unsigned int = ax+$C (used reg = )
26378 797B           05                   000C  add	ax,*$C
26379 797E           50                         push	ax
26380                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26381 797F           FF76         04            push	4[bp]
26382                                           ! Debug: func () void = write_word+0 (used reg = )
26383 7982           E8         8CB7            call	_write_word
26384 7985           83C4                   06  add	sp,*6
26385                                           !BCC_EOS
26386                                           ! 3973       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
26387                                           ! Debug: list * unsigned short = const $248 (used reg = )
26388 7988           B8                   0248  mov	ax,#$248
26389 798B           50                         push	ax
26390                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26391 798C           FF76         FE            push	-2[bp]
26392                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26393 798F           E8         8C7F            call	_read_word
26394 7992           83C4                   04  add	sp,*4
26395                                           ! Debug: list unsigned short = ax+0 (used reg = )
26396 7995           50                         push	ax
26397                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
26398 7996           8B46         0A            mov	ax,$A[bp]
26399                                           ! Debug: list unsigned int = ax+$E (used reg = )
26400 7999           05                   000E  add	ax,*$E
26401 799C           50                         push	ax
26402                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26403 799D           FF76         04            push	4[bp]
26404                                           ! Debug: func () void = write_word+0 (used reg = )
26405 79A0           E8         8C99            call	_write_word
26406 79A3           83C4                   06  add	sp,*6
26407                                           !BCC_EOS
26408                                           ! 3974       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
26409                                           ! Debug: list * unsigned short = const $24C (used reg = )
26410 79A6           B8                   024C  mov	ax,#$24C
26411 79A9           50                         push	ax
26412                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26413 79AA           FF76         FE            push	-2[bp]
26414                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26415 79AD           E8         8C4E            call	_read_byte
26416 79B0           83C4                   04  add	sp,*4
26417                                           ! Debug: list unsigned char = al+0 (used reg = )
26418 79B3           30E4                       xor	ah,ah
26419 79B5           50                         push	ax
26420                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
26421 79B6           8B46         0A            mov	ax,$A[bp]
26422                                           ! Debug: list unsigned int = ax+$10 (used reg = )
26423 79B9           05                   0010  add	ax,*$10
26424 79BC           50                         push	ax
26425                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26426 79BD           FF76         04            push	4[bp]
26427                                           ! Debug: func () void = write_byte+0 (used reg = )
26428 79C0           E8         8C61            call	_write_byte
26429 79C3           83C4                   06  add	sp,*6
26430                                           !BCC_EOS
26431                                           ! 3975       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
26432                                           ! Debug: list * unsigned short = const $24E (used reg = )
26433 79C6           B8                   024E  mov	ax,#$24E
26434 79C9           50                         push	ax
26435                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26436 79CA           FF76         FE            push	-2[bp]
26437                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26438 79CD           E8         8C2E            call	_read_byte
26439 79D0           83C4                   04  add	sp,*4
26440                                           ! Debug: list unsigned char = al+0 (used reg = )
26441 79D3           30E4                       xor	ah,ah
26442 79D5           50                         push	ax
26443                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
26444 79D6           8B46         0A            mov	ax,$A[bp]
26445                                           ! Debug: list unsigned int = ax+$11 (used reg = )
26446 79D9           05                   0011  add	ax,*$11
26447 79DC           50                         push	ax
26448                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26449 79DD           FF76         04            push	4[bp]
26450                                           ! Debug: func () void = write_byte+0 (used reg = )
26451 79E0           E8         8C41            call	_write_byte
26452 79E3           83C4                   06  add	sp,*6
26453                                           !BCC_EOS
26454                                           ! 3976       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
26455                                           ! Debug: list * unsigned short = const $24A (used reg = )
26456 79E6           B8                   024A  mov	ax,#$24A
26457 79E9           50                         push	ax
26458                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
26459 79EA           FF76         FE            push	-2[bp]
26460                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26461 79ED           E8         8C0E            call	_read_byte
26462 79F0           83C4                   04  add	sp,*4
26463                                           ! Debug: list unsigned char = al+0 (used reg = )
26464 79F3           30E4                       xor	ah,ah
26465 79F5           50                         push	ax
26466                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
26467 79F6           8B46         0A            mov	ax,$A[bp]
26468                                           ! Debug: list unsigned int = ax+$12 (used reg = )
26469 79F9           05                   0012  add	ax,*$12
26470 79FC           50                         push	ax
26471                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
26472 79FD           FF76         04            push	4[bp]
26473                                           ! Debug: func () void = write_byte+0 (used reg = )
26474 7A00           E8         8C21            call	_write_byte
26475 7A03           83C4                   06  add	sp,*6
26476                                           !BCC_EOS
26477                                           ! 3977       if(( AX & 0x00ff ) == 0x00) {
26478                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
26479 7A06           8A46         16            mov	al,$16[bp]
26480                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
26481 7A09           84C0                       test	al,al
26482 7A0B           75           10            jne 	.58C
26483                       00007A0D            .58D:
26484                                           ! 3978         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
26485                                           ! Debug: list int = const 0 (used reg = )
26486 7A0D           31C0                       xor	ax,ax
26487 7A0F           50                         push	ax
26488                                           ! Debug: list * unsigned char = const $23A (used reg = )
26489 7A10           B8                   023A  mov	ax,#$23A
26490 7A13           50                         push	ax
26491                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
26492 7A14           FF76         FE            push	-2[bp]
26493                                           ! Debug: func () void = write_byte+0 (used reg = )
26494 7A17           E8         8C0A            call	_write_byte
26495 7A1A           83C4                   06  add	sp,*6
26496                                           !BCC_EOS
26497                                           ! 3979         }
26498                                           ! 3980       goto int13_success;
26499                       00007A1D            .58C:
26500 7A1D           83C4                   00  add	sp,#..FFE2-..FFE4
26501 7A20           EB           6C            jmp .FFE2
26502                                           !BCC_EOS
26503                                           ! 3981       break;
26504 7A22           EB           3D            jmp .584
26505                                           !BCC_EOS
26506                                           ! 3982     default:
26507                                           ! 3983       bios_printf(4, "int13_eltorito: unsupported AH=%02x\n", ( AX >> 8 ));
26508                       00007A24            .58E:
26509                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
26510 7A24           8B46         16            mov	ax,$16[bp]
26511 7A27           88E0                       mov	al,ah
26512 7A29           30E4                       xor	ah,ah
26513                                           ! Debug: list unsigned int = ax+0 (used reg = )
26514 7A2B           50                         push	ax
26515                                           ! Debug: list * char = .58F+0 (used reg = )
26516 7A2C           BB                   D2BE  mov	bx,#.58F
26517 7A2F           53                         push	bx
26518                                           ! Debug: list int = const 4 (used reg = )
26519 7A30           B8                   0004  mov	ax,*4
26520 7A33           50                         push	ax
26521                                           ! Debug: func () void = bios_printf+0 (used reg = )
26522 7A34           E8         8E72            call	_bios_printf
26523 7A37           83C4                   06  add	sp,*6
26524                                           !BCC_EOS
26525                                           ! 3984       goto int13_fail;
26526 7A3A           83C4                   00  add	sp,#..FFE3-..FFE4
26527 7A3D           EB           22            jmp .FFE3
26528                                           !BCC_EOS
26529                                           ! 3985       break;
26530 7A3F           EB           20            jmp .584
26531                                           !BCC_EOS
26532                                           ! 3986     }
26533                                           ! 3987 int13_fail:
26534 7A41           EB           1E            jmp .584
26535                       00007A43            .586:
26536 7A43           2D                   004A  sub	ax,*$4A
26537 7A46         0F84         FE3B            beq 	.587
26538 7A4A           2D                   0001  sub	ax,*1
26539 7A4D         0F84         FE4E            beq 	.58B
26540 7A51           2D                   0001  sub	ax,*1
26541 7A54         0F84         FE2D            beq 	.588
26542 7A58           2D                   0001  sub	ax,*1
26543 7A5B         0F84         FE26            beq 	.589
26544 7A5F           EB           C3            jmp	.58E
26545                       00007A61            .584:
26546                       FFFFFFFC            ..FFE4	=	-4
26547                       00007A61            .FFE3:
26548                       FFFFFFFC            ..FFE3	=	-4
26549                                           ! 3988     AX = ((AX & 0x00ff) | ((0x01) << 8));
26550                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
26551 7A61           8A46         16            mov	al,$16[bp]
26552                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
26553 7A64           30E4                       xor	ah,ah
26554 7A66           0D                   0100  or	ax,#$100
26555                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
26556 7A69           8946         16            mov	$16[bp],ax
26557                                           !BCC_EOS
26558                                           ! 3989     write_byte(0x0040, 0x0074, ( AX >> 8 ));
26559                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
26560 7A6C           8B46         16            mov	ax,$16[bp]
26561 7A6F           88E0                       mov	al,ah
26562 7A71           30E4                       xor	ah,ah
26563                                           ! Debug: list unsigned int = ax+0 (used reg = )
26564 7A73           50                         push	ax
26565                                           ! Debug: list int = const $74 (used reg = )
26566 7A74           B8                   0074  mov	ax,*$74
26567 7A77           50                         push	ax
26568                                           ! Debug: list int = const $40 (used reg = )
26569 7A78           B8                   0040  mov	ax,*$40
26570 7A7B           50                         push	ax
26571                                           ! Debug: func () void = write_byte+0 (used reg = )
26572 7A7C           E8         8BA5            call	_write_byte
26573 7A7F           83C4                   06  add	sp,*6
26574                                           !BCC_EOS
26575                                           ! 3990     FLAGS |= 0x0001;
26576                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
26577 7A82           8B46         1C            mov	ax,$1C[bp]
26578 7A85           0C                     01  or	al,*1
26579 7A87           8946         1C            mov	$1C[bp],ax
26580                                           !BCC_EOS
26581                                           ! 3991     return;
26582 7A8A           89EC                       mov	sp,bp
26583 7A8C           5D                         pop	bp
26584 7A8D           C3                         ret
26585                                           !BCC_EOS
26586                                           ! 3992 int13_success:
26587                       00007A8E            .FFE2:
26588                       FFFFFFFC            ..FFE2	=	-4
26589                                           ! 3993     AX = ((AX & 0x00ff) | ((0x00) << 8));
26590                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
26591 7A8E           8A46         16            mov	al,$16[bp]
26592                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
26593 7A91           0C                     00  or	al,*0
26594                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
26595 7A93           30E4                       xor	ah,ah
26596 7A95           8946         16            mov	$16[bp],ax
26597                                           !BCC_EOS
26598                                           ! 3994     write_byte(0x0040, 0x0074, 0x00);
26599                                           ! Debug: list int = const 0 (used reg = )
26600 7A98           31C0                       xor	ax,ax
26601 7A9A           50                         push	ax
26602                                           ! Debug: list int = const $74 (used reg = )
26603 7A9B           B8                   0074  mov	ax,*$74
26604 7A9E           50                         push	ax
26605                                           ! Debug: list int = const $40 (used reg = )
26606 7A9F           B8                   0040  mov	ax,*$40
26607 7AA2           50                         push	ax
26608                                           ! Debug: func () void = write_byte+0 (used reg = )
26609 7AA3           E8         8B7E            call	_write_byte
26610 7AA6           83C4                   06  add	sp,*6
26611                                           !BCC_EOS
26612                                           ! 3995     FLAGS &= 0xfffe;
26613                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
26614 7AA9           8B46         1C            mov	ax,$1C[bp]
26615 7AAC           24                     FE  and	al,#$FE
26616 7AAE           8946         1C            mov	$1C[bp],ax
26617                                           !BCC_EOS
26618                                           ! 3996     return;
26619 7AB1           89EC                       mov	sp,bp
26620 7AB3           5D                         pop	bp
26621 7AB4           C3                         ret
26622                                           !BCC_EOS
26623                                           ! 3997 }
26624                                           ! 3998   void
26625                                           ! Register BX used in function int13_eltorito
26626                                           ! 3999 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
26627                                           ! 4000   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
26628                                           export	_int13_cdemu
26629                       00007AB5            _int13_cdemu:
26630                                           !BCC_EOS
26631                                           ! 4001 {
26632                                           ! 4002   Bit16u ebda_seg=read_word(0x0040,0x000E);
26633 7AB5           55                         push	bp
26634 7AB6           89E5                       mov	bp,sp
26635 7AB8           4C                         dec	sp
26636 7AB9           4C                         dec	sp
26637                                           ! Debug: list int = const $E (used reg = )
26638 7ABA           B8                   000E  mov	ax,*$E
26639 7ABD           50                         push	ax
26640                                           ! Debug: list int = const $40 (used reg = )
26641 7ABE           B8                   0040  mov	ax,*$40
26642 7AC1           50                         push	ax
26643                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26644 7AC2           E8         8B4C            call	_read_word
26645 7AC5           83C4                   04  add	sp,*4
26646                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
26647 7AC8           8946         FE            mov	-2[bp],ax
26648                                           !BCC_EOS
26649                                           ! 4003   Bit8u device, status;
26650                                           !BCC_EOS
26651                                           ! 4004   Bit16u vheads, vspt, vcylinders;
26652                                           !BCC_EOS
26653                                           ! 4005   Bit16u head, sector, cylinder, nbsectors;
26654                                           !BCC_EOS
26655                                           ! 4006   Bit32u vlba, ilba, slba, elba;
26656                                           !BCC_EOS
26657                                           ! 4007   Bit16u before, segment, offset;
26658                                           !BCC_EOS
26659                                           ! 4008   Bit8u atacmd[12];
26660                                           !BCC_EOS
26661                                           ! 4009   ;
26662 7ACB           83C4                   CE  add	sp,*-$32
26663                                           !BCC_EOS
26664                                           ! 4010   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
26665                                           ! Debug: list * unsigned char = const $23D (used reg = )
26666 7ACE           B8                   023D  mov	ax,#$23D
26667 7AD1           50                         push	ax
26668                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
26669 7AD2           FF76         FE            push	-2[bp]
26670                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26671 7AD5           E8         8B26            call	_read_byte
26672 7AD8           83C4                   04  add	sp,*4
26673                                           ! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
26674 7ADB           30E4                       xor	ah,ah
26675 7ADD           D1E0                       shl	ax,*1
26676                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
26677 7ADF           8846         FD            mov	-3[bp],al
26678                                           !BCC_EOS
26679                                           ! 4011   device += read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
26680                                           ! Debug: list * unsigned short = const $23E (used reg = )
26681 7AE2           B8                   023E  mov	ax,#$23E
26682 7AE5           50                         push	ax
26683                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
26684 7AE6           FF76         FE            push	-2[bp]
26685                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26686 7AE9           E8         8B12            call	_read_byte
26687 7AEC           83C4                   04  add	sp,*4
26688                                           ! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
26689 7AEF           30E4                       xor	ah,ah
26690 7AF1           0246         FD            add	al,-3[bp]
26691 7AF4           80D4                   00  adc	ah,*0
26692 7AF7           8846         FD            mov	-3[bp],al
26693                                           !BCC_EOS
26694                                           ! 4012   write_byte(0x0040, 0x0074, 0x00);
26695                                           ! Debug: list int = const 0 (used reg = )
26696 7AFA           31C0                       xor	ax,ax
26697 7AFC           50                         push	ax
26698                                           ! Debug: list int = const $74 (used reg = )
26699 7AFD           B8                   0074  mov	ax,*$74
26700 7B00           50                         push	ax
26701                                           ! Debug: list int = const $40 (used reg = )
26702 7B01           B8                   0040  mov	ax,*$40
26703 7B04           50                         push	ax
26704                                           ! Debug: func () void = write_byte+0 (used reg = )
26705 7B05           E8         8B1C            call	_write_byte
26706 7B08           83C4                   06  add	sp,*6
26707                                           !BCC_EOS
26708                                           ! 4013   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0 )
26709                                           ! 4014    || (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
26710                                           ! Debug: list * unsigned char = const $23A (used reg = )
26711 7B0B           B8                   023A  mov	ax,#$23A
26712 7B0E           50                         push	ax
26713                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
26714 7B0F           FF76         FE            push	-2[bp]
26715                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26716 7B12           E8         8AE9            call	_read_byte
26717 7B15           83C4                   04  add	sp,*4
26718                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
26719 7B18           84C0                       test	al,al
26720 7B1A           74           19            je  	.591
26721                       00007B1C            .592:
26722                                           ! Debug: expression subtree swapping
26723                                           ! Debug: list * unsigned char = const $23C (used reg = )
26724 7B1C           B8                   023C  mov	ax,#$23C
26725 7B1F           50                         push	ax
26726                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
26727 7B20           FF76         FE            push	-2[bp]
26728                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26729 7B23           E8         8AD8            call	_read_byte
26730 7B26           83C4                   04  add	sp,*4
26731 7B29           50                         push	ax
26732                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
26733 7B2A           8A46         12            mov	al,$12[bp]
26734                                           ! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
26735 7B2D           3A46         CA            cmp	al,-$36[bp]
26736 7B30           8D66         CC            lea	sp,-$34[bp]
26737 7B33           74           22            je  	.590
26738                       00007B35            .591:
26739                                           ! 4015     bios_printf(4, "int13_cdemu: function %02x, emulation not active for DL= %02x\n", ( AX >> 8 ), ( DX & 0x00ff ));
26740                                           ! Debug: and int = const $FF to unsigned short DX = [S+$36+$10] (used reg = )
26741 7B35           8A46         12            mov	al,$12[bp]
26742                                           ! Debug: list unsigned char = al+0 (used reg = )
26743 7B38           30E4                       xor	ah,ah
26744 7B3A           50                         push	ax
26745                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
26746 7B3B           8B46         16            mov	ax,$16[bp]
26747 7B3E           88E0                       mov	al,ah
26748 7B40           30E4                       xor	ah,ah
26749                                           ! Debug: list unsigned int = ax+0 (used reg = )
26750 7B42           50                         push	ax
26751                                           ! Debug: list * char = .593+0 (used reg = )
26752 7B43           BB                   D27F  mov	bx,#.593
26753 7B46           53                         push	bx
26754                                           ! Debug: list int = const 4 (used reg = )
26755 7B47           B8                   0004  mov	ax,*4
26756 7B4A           50                         push	ax
26757                                           ! Debug: func () void = bios_printf+0 (used reg = )
26758 7B4B           E8         8D5B            call	_bios_printf
26759 7B4E           83C4                   08  add	sp,*8
26760                                           !BCC_EOS
26761                                           ! 4016     goto int13_fail;
26762 7B51           83C4                   00  add	sp,#..FFE1+$36
26763 7B54           E9         0563            br 	.FFE1
26764                                           !BCC_EOS
26765                                           ! 4017     }
26766                                           ! 4018   switch (( AX >> 8 )) {
26767                       00007B57            .590:
26768                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
26769 7B57           8B46         16            mov	ax,$16[bp]
26770 7B5A           88E0                       mov	al,ah
26771 7B5C           30E4                       xor	ah,ah
26772 7B5E           E9         04DE            br 	.596
26773                                           ! 4019     case 0x00:
26774                                           ! 4019 
26775                                           ! 4020     case 0x09:
26776                       00007B61            .597:
26777                                           ! 4021     case 0x0c:
26778                       00007B61            .598:
26779                                           ! 4022     case 0x0d:
26780                       00007B61            .599:
26781                                           ! 4023     case 0x10:
26782                       00007B61            .59A:
26783                                           ! 4024     case 0x11:
26784                       00007B61            .59B:
26785                                           ! 4025     case 0x14:
26786                       00007B61            .59C:
26787                                           ! 4026     case 0x16:
26788                       00007B61            .59D:
26789                                           ! 4027       goto int13_success;
26790                       00007B61            .59E:
26791 7B61           83C4                   00  add	sp,#..FFDF-..FFE0
26792 7B64           E9         0580            br 	.FFDF
26793                                           !BCC_EOS
26794                                           ! 4028       break;
26795 7B67           E9         0550            br 	.594
26796                                           !BCC_EOS
26797                                           ! 4029     case 0x03:
26798                                           ! 4030     case 0x05:
26799                       00007B6A            .59F:
26800                                           ! 4031       AX = ((AX & 0x00ff) | ((0x03) << 8));
26801                       00007B6A            .5A0:
26802                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
26803 7B6A           8A46         16            mov	al,$16[bp]
26804                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
26805 7B6D           30E4                       xor	ah,ah
26806 7B6F           0D                   0300  or	ax,#$300
26807                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
26808 7B72           8946         16            mov	$16[bp],ax
26809                                           !BCC_EOS
26810                                           ! 4032       goto int13_fail_noah;
26811 7B75           83C4                   00  add	sp,#..FFDE-..FFE0
26812 7B78           E9         054A            br 	.FFDE
26813                                           !BCC_EOS
26814                                           ! 4033       break;
26815 7B7B           E9         053C            br 	.594
26816                                           !BCC_EOS
26817                                           ! 4034     case 0x01:
26818                                           ! 4035       status=read_byte(0x0040, 0x0074);
26819                       00007B7E            .5A1:
26820                                           ! Debug: list int = const $74 (used reg = )
26821 7B7E           B8                   0074  mov	ax,*$74
26822 7B81           50                         push	ax
26823                                           ! Debug: list int = const $40 (used reg = )
26824 7B82           B8                   0040  mov	ax,*$40
26825 7B85           50                         push	ax
26826                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26827 7B86           E8         8A75            call	_read_byte
26828 7B89           83C4                   04  add	sp,*4
26829                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
26830 7B8C           8846         FC            mov	-4[bp],al
26831                                           !BCC_EOS
26832                                           ! 4036       AX = ((AX & 0x00ff) | ((status) << 8));
26833                                           ! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
26834 7B8F           8A46         FC            mov	al,-4[bp]
26835 7B92           30E4                       xor	ah,ah
26836 7B94           88C4                       mov	ah,al
26837 7B96           30C0                       xor	al,al
26838 7B98           50                         push	ax
26839                                           ! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
26840 7B99           8A46         16            mov	al,$16[bp]
26841                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
26842 7B9C           30E4                       xor	ah,ah
26843 7B9E           0B46         CA            or	ax,0+..FFE0[bp]
26844 7BA1           44                         inc	sp
26845 7BA2           44                         inc	sp
26846                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
26847 7BA3           8946         16            mov	$16[bp],ax
26848                                           !BCC_EOS
26849                                           ! 4037       write_byte(0x0040, 0x0074, 0);
26850                                           ! Debug: list int = const 0 (used reg = )
26851 7BA6           31C0                       xor	ax,ax
26852 7BA8           50                         push	ax
26853                                           ! Debug: list int = const $74 (used reg = )
26854 7BA9           B8                   0074  mov	ax,*$74
26855 7BAC           50                         push	ax
26856                                           ! Debug: list int = const $40 (used reg = )
26857 7BAD           B8                   0040  mov	ax,*$40
26858 7BB0           50                         push	ax
26859                                           ! Debug: func () void = write_byte+0 (used reg = )
26860 7BB1           E8         8A70            call	_write_byte
26861 7BB4           83C4                   06  add	sp,*6
26862                                           !BCC_EOS
26863                                           ! 4038       if (status) goto int13_fail_nostatus;
26864 7BB7           8A46         FC            mov	al,-4[bp]
26865 7BBA           84C0                       test	al,al
26866 7BBC           74           08            je  	.5A2
26867                       00007BBE            .5A3:
26868 7BBE           83C4                   00  add	sp,#..FFDD-..FFE0
26869 7BC1           E9         0517            br 	.FFDD
26870                                           !BCC_EOS
26871                                           ! 4039       else goto int13_success_noah;
26872 7BC4           EB           06            jmp .5A4
26873                       00007BC6            .5A2:
26874 7BC6           83C4                   00  add	sp,#..FFDC-..FFE0
26875 7BC9           E9         0525            br 	.FFDC
26876                                           !BCC_EOS
26877                                           ! 4040       break;
26878                       00007BCC            .5A4:
26879 7BCC           E9         04EB            br 	.594
26880                                           !BCC_EOS
26881                                           ! 4041     case 0x02:
26882                                           ! 4042     case 0x04:
26883                       00007BCF            .5A5:
26884                                           ! 4043       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
26885                       00007BCF            .5A6:
26886                                           ! Debug: list * unsigned short = const $24E (used reg = )
26887 7BCF           B8                   024E  mov	ax,#$24E
26888 7BD2           50                         push	ax
26889                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
26890 7BD3           FF76         FE            push	-2[bp]
26891                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26892 7BD6           E8         8A38            call	_read_word
26893 7BD9           83C4                   04  add	sp,*4
26894                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
26895 7BDC           8946         F8            mov	-8[bp],ax
26896                                           !BCC_EOS
26897                                           ! 4044       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
26898                                           ! Debug: list * unsigned short = const $24C (used reg = )
26899 7BDF           B8                   024C  mov	ax,#$24C
26900 7BE2           50                         push	ax
26901                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
26902 7BE3           FF76         FE            push	-2[bp]
26903                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26904 7BE6           E8         8A28            call	_read_word
26905 7BE9           83C4                   04  add	sp,*4
26906                                           ! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
26907 7BEC           8946         F6            mov	-$A[bp],ax
26908                                           !BCC_EOS
26909                                           ! 4045       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
26910                                           ! Debug: list * unsigned short = const $24A (used reg = )
26911 7BEF           B8                   024A  mov	ax,#$24A
26912 7BF2           50                         push	ax
26913                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
26914 7BF3           FF76         FE            push	-2[bp]
26915                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26916 7BF6           E8         8A18            call	_read_word
26917 7BF9           83C4                   04  add	sp,*4
26918                                           ! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
26919 7BFC           8946         FA            mov	-6[bp],ax
26920                                           !BCC_EOS
26921                                           ! 4046       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
26922                                           ! Debug: list * unsigned long = const $240 (used reg = )
26923 7BFF           B8                   0240  mov	ax,#$240
26924 7C02           50                         push	ax
26925                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
26926 7C03           FF76         FE            push	-2[bp]
26927                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26928 7C06           E8         844C            call	_read_dword
26929 7C09           89D3                       mov	bx,dx
26930 7C0B           83C4                   04  add	sp,*4
26931                                           ! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
26932 7C0E           8946         E6            mov	-$1A[bp],ax
26933 7C11           895E         E8            mov	-$18[bp],bx
26934                                           !BCC_EOS
26935                                           ! 4047       sector = ( CX & 0x00ff ) & 0x003f;
26936                                           ! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
26937 7C14           8A46         14            mov	al,$14[bp]
26938                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
26939 7C17           24                     3F  and	al,*$3F
26940                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
26941 7C19           30E4                       xor	ah,ah
26942 7C1B           8946         F2            mov	-$E[bp],ax
26943                                           !BCC_EOS
26944                                           ! 4048       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
26945                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
26946 7C1E           8B46         14            mov	ax,$14[bp]
26947 7C21           88E0                       mov	al,ah
26948 7C23           30E4                       xor	ah,ah
26949 7C25           50                         push	ax
26950                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
26951 7C26           8A46         14            mov	al,$14[bp]
26952                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
26953 7C29           24                     C0  and	al,#$C0
26954                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
26955 7C2B           30E4                       xor	ah,ah
26956 7C2D           D1E0                       shl	ax,*1
26957 7C2F           D1E0                       shl	ax,*1
26958                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
26959 7C31           0B46         CA            or	ax,0+..FFE0[bp]
26960 7C34           44                         inc	sp
26961 7C35           44                         inc	sp
26962                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
26963 7C36           8946         F0            mov	-$10[bp],ax
26964                                           !BCC_EOS
26965                                           ! 4049       head = ( DX >> 8 );
26966                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
26967 7C39           8B46         12            mov	ax,$12[bp]
26968 7C3C           88E0                       mov	al,ah
26969 7C3E           30E4                       xor	ah,ah
26970                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
26971 7C40           8946         F4            mov	-$C[bp],ax
26972                                           !BCC_EOS
26973                                           ! 4050       nbsectors = ( AX & 0x00ff );
26974                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
26975 7C43           8A46         16            mov	al,$16[bp]
26976                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
26977 7C46           30E4                       xor	ah,ah
26978 7C48           8946         EE            mov	-$12[bp],ax
26979                                           !BCC_EOS
26980                                           ! 4051       segment = ES;
26981                                           ! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
26982 7C4B           8B46         06            mov	ax,6[bp]
26983 7C4E           8946         DA            mov	-$26[bp],ax
26984                                           !BCC_EOS
26985                                           ! 4052       offset = BX;
26986                                           ! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
26987 7C51           8B46         10            mov	ax,$10[bp]
26988 7C54           8946         D8            mov	-$28[bp],ax
26989                                           !BCC_EOS
26990                                           ! 4053       if(nbsectors==0) goto int13_success;
26991                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
26992 7C57           8B46         EE            mov	ax,-$12[bp]
26993 7C5A           85C0                       test	ax,ax
26994 7C5C           75           06            jne 	.5A7
26995                       00007C5E            .5A8:
26996 7C5E           83C4                   00  add	sp,#..FFDF-..FFE0
26997 7C61           E9         0483            br 	.FFDF
26998                                           !BCC_EOS
26999                                           ! 4054       if ((sector > vspt)
27000                       00007C64            .5A7:
27001                                           ! 4055        || (cylinder >= vcylinders)
27002                                           ! 4056        || (head >= vheads)) {
27003                                           ! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
27004 7C64           8B46         F2            mov	ax,-$E[bp]
27005 7C67           3B46         F8            cmp	ax,-8[bp]
27006 7C6A           77           10            ja  	.5AA
27007                       00007C6C            .5AC:
27008                                           ! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
27009 7C6C           8B46         F0            mov	ax,-$10[bp]
27010 7C6F           3B46         F6            cmp	ax,-$A[bp]
27011 7C72           73           08            jae 	.5AA
27012                       00007C74            .5AB:
27013                                           ! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
27014 7C74           8B46         F4            mov	ax,-$C[bp]
27015 7C77           3B46         FA            cmp	ax,-6[bp]
27016 7C7A           72           06            jb  	.5A9
27017                       00007C7C            .5AA:
27018                                           ! 4057         goto int13_fail;
27019 7C7C           83C4                   00  add	sp,#..FFE1-..FFE0
27020 7C7F           E9         0438            br 	.FFE1
27021                                           !BCC_EOS
27022                                           ! 4058         }
27023                                           ! 4059       if (( AX >> 8 ) == 0x04) goto int13_success;
27024                       00007C82            .5A9:
27025                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
27026 7C82           8B46         16            mov	ax,$16[bp]
27027 7C85           88E0                       mov	al,ah
27028 7C87           30E4                       xor	ah,ah
27029                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
27030 7C89           3D                   0004  cmp	ax,*4
27031 7C8C           75           06            jne 	.5AD
27032                       00007C8E            .5AE:
27033 7C8E           83C4                   00  add	sp,#..FFDF-..FFE0
27034 7C91           E9         0453            br 	.FFDF
27035                                           !BCC_EOS
27036                                           ! 4060       segment = ES+(BX / 16);
27037                       00007C94            .5AD:
27038                                           ! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
27039 7C94           8B46         10            mov	ax,$10[bp]
27040 7C97           B1                     04  mov	cl,*4
27041 7C99           D3E8                       shr	ax,cl
27042                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
27043                                           ! Debug: expression subtree swapping
27044 7C9B           0346         06            add	ax,6[bp]
27045                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
27046 7C9E           8946         DA            mov	-$26[bp],ax
27047                                           !BCC_EOS
27048                                           ! 4061       offset = BX % 16;
27049                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
27050 7CA1           8B46         10            mov	ax,$10[bp]
27051 7CA4           24                     0F  and	al,*$F
27052                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
27053 7CA6           30E4                       xor	ah,ah
27054 7CA8           8946         D8            mov	-$28[bp],ax
27055                                           !BCC_EOS
27056                                           ! 4062       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
27057                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
27058 7CAB           8B46         F2            mov	ax,-$E[bp]
27059                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
27060 7CAE           48                         dec	ax
27061 7CAF           31DB                       xor	bx,bx
27062 7CB1           53                         push	bx
27063 7CB2           50                         push	ax
27064                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
27065 7CB3           8B46         F8            mov	ax,-8[bp]
27066 7CB6           31DB                       xor	bx,bx
27067 7CB8           53                         push	bx
27068 7CB9           50                         push	ax
27069                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
27070 7CBA           8B46         F4            mov	ax,-$C[bp]
27071 7CBD           31DB                       xor	bx,bx
27072 7CBF           53                         push	bx
27073 7CC0           50                         push	ax
27074                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
27075 7CC1           8B46         FA            mov	ax,-6[bp]
27076 7CC4           31DB                       xor	bx,bx
27077 7CC6           53                         push	bx
27078 7CC7           50                         push	ax
27079                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
27080 7CC8           8B46         F0            mov	ax,-$10[bp]
27081 7CCB           31DB                       xor	bx,bx
27082                                           ! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
27083 7CCD           8D7E         BC            lea	di,-$E+..FFE0[bp]
27084 7CD0           E8         83E6            call	lmulul
27085 7CD3           83C4                   04  add	sp,*4
27086                                           ! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
27087 7CD6           8D7E         C0            lea	di,-$A+..FFE0[bp]
27088 7CD9           E8         83B7            call	laddul
27089 7CDC           83C4                   04  add	sp,*4
27090                                           ! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
27091 7CDF           8D7E         C4            lea	di,-6+..FFE0[bp]
27092 7CE2           E8         83D4            call	lmulul
27093 7CE5           83C4                   04  add	sp,*4
27094                                           ! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
27095 7CE8           8D7E         C8            lea	di,-2+..FFE0[bp]
27096 7CEB           E8         83A5            call	laddul
27097 7CEE           83C4                   04  add	sp,*4
27098                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
27099 7CF1           8946         EA            mov	-$16[bp],ax
27100 7CF4           895E         EC            mov	-$14[bp],bx
27101                                           !BCC_EOS
27102                                           ! 4063       AX = ((AX & 0xff00) | (nbsectors));
27103                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
27104 7CF7           8B46         16            mov	ax,$16[bp]
27105 7CFA           30C0                       xor	al,al
27106                                           ! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
27107 7CFC           0B46         EE            or	ax,-$12[bp]
27108                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
27109 7CFF           8946         16            mov	$16[bp],ax
27110                                           !BCC_EOS
27111                                           ! 4064       slba = (Bit32u)vlba/4;
27112                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
27113 7D02           B8                   0004  mov	ax,*4
27114 7D05           31DB                       xor	bx,bx
27115 7D07           53                         push	bx
27116 7D08           50                         push	ax
27117 7D09           8B46         EA            mov	ax,-$16[bp]
27118 7D0C           8B5E         EC            mov	bx,-$14[bp]
27119 7D0F           8D7E         C8            lea	di,-2+..FFE0[bp]
27120 7D12           E8         8429            call	ldivul
27121 7D15           83C4                   04  add	sp,*4
27122                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
27123 7D18           8946         E2            mov	-$1E[bp],ax
27124 7D1B           895E         E4            mov	-$1C[bp],bx
27125                                           !BCC_EOS
27126                                           ! 4065       before= (Bit16u)vlba%4;
27127                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
27128 7D1E           8B46         EA            mov	ax,-$16[bp]
27129 7D21           24                     03  and	al,*3
27130                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
27131 7D23           30E4                       xor	ah,ah
27132 7D25           8946         DC            mov	-$24[bp],ax
27133                                           !BCC_EOS
27134                                           ! 4066       elba = (Bit32u)(vlba+nbsectors-1)/4;
27135                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
27136 7D28           8B46         EE            mov	ax,-$12[bp]
27137 7D2B           31DB                       xor	bx,bx
27138                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
27139                                           ! Debug: expression subtree swapping
27140 7D2D           8D7E         EA            lea	di,-$16[bp]
27141 7D30           E8         8360            call	laddul
27142                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
27143 7D33           53                         push	bx
27144 7D34           50                         push	ax
27145 7D35           B8                   0001  mov	ax,*1
27146 7D38           31DB                       xor	bx,bx
27147 7D3A           53                         push	bx
27148 7D3B           50                         push	ax
27149 7D3C           8B46         C8            mov	ax,-2+..FFE0[bp]
27150 7D3F           8B5E         CA            mov	bx,0+..FFE0[bp]
27151 7D42           8D7E         C4            lea	di,-6+..FFE0[bp]
27152 7D45           E8         8369            call	lsubul
27153 7D48           83C4                   08  add	sp,*8
27154                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
27155                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
27156 7D4B           53                         push	bx
27157 7D4C           50                         push	ax
27158 7D4D           B8                   0004  mov	ax,*4
27159 7D50           31DB                       xor	bx,bx
27160 7D52           53                         push	bx
27161 7D53           50                         push	ax
27162 7D54           8B46         C8            mov	ax,-2+..FFE0[bp]
27163 7D57           8B5E         CA            mov	bx,0+..FFE0[bp]
27164 7D5A           8D7E         C4            lea	di,-6+..FFE0[bp]
27165 7D5D           E8         83DE            call	ldivul
27166 7D60           83C4                   08  add	sp,*8
27167                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
27168 7D63           8946         DE            mov	-$22[bp],ax
27169 7D66           895E         E0            mov	-$20[bp],bx
27170                                           !BCC_EOS
27171                                           ! 4067       memsetb(get_SS(),atacmd,0,12);
27172                                           ! Debug: list int = const $C (used reg = )
27173 7D69           B8                   000C  mov	ax,*$C
27174 7D6C           50                         push	ax
27175                                           ! Debug: list int = const 0 (used reg = )
27176 7D6D           31C0                       xor	ax,ax
27177 7D6F           50                         push	ax
27178                                           ! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
27179 7D70           8D5E         CC            lea	bx,-$34[bp]
27180 7D73           53                         push	bx
27181                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
27182 7D74           E8         88E0            call	_get_SS
27183                                           ! Debug: list unsigned short = ax+0 (used reg = )
27184 7D77           50                         push	ax
27185                                           ! Debug: func () void = memsetb+0 (used reg = )
27186 7D78           E8         8285            call	_memsetb
27187 7D7B           83C4                   08  add	sp,*8
27188                                           !BCC_EOS
27189                                           ! 4068       atacmd[0]=0x28;
27190                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
27191 7D7E           B0                     28  mov	al,*$28
27192 7D80           8846         CC            mov	-$34[bp],al
27193                                           !BCC_EOS
27194                                           ! 4069       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
27195                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
27196 7D83           8B46         DE            mov	ax,-$22[bp]
27197 7D86           8B5E         E0            mov	bx,-$20[bp]
27198 7D89           8D7E         E2            lea	di,-$1E[bp]
27199 7D8C           E8         8322            call	lsubul
27200                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
27201 7D8F           53                         push	bx
27202 7D90           50                         push	ax
27203 7D91           B8                   0001  mov	ax,*1
27204 7D94           31DB                       xor	bx,bx
27205 7D96           53                         push	bx
27206 7D97           50                         push	ax
27207 7D98           8B46         C8            mov	ax,-2+..FFE0[bp]
27208 7D9B           8B5E         CA            mov	bx,0+..FFE0[bp]
27209 7D9E           8D7E         C4            lea	di,-6+..FFE0[bp]
27210 7DA1           E8         82EF            call	laddul
27211 7DA4           83C4                   08  add	sp,*8
27212                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
27213                                           ! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
27214 7DA7           30C0                       xor	al,al
27215                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
27216 7DA9           88E0                       mov	al,ah
27217 7DAB           30E4                       xor	ah,ah
27218                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
27219 7DAD           8846         D3            mov	-$2D[bp],al
27220                                           !BCC_EOS
27221                                           ! 4070       atacmd[8]=((Bit16u)(elba-slba+1) & 0x00ff);
27222                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
27223 7DB0           8B46         DE            mov	ax,-$22[bp]
27224 7DB3           8B5E         E0            mov	bx,-$20[bp]
27225 7DB6           8D7E         E2            lea	di,-$1E[bp]
27226 7DB9           E8         82F5            call	lsubul
27227                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
27228 7DBC           53                         push	bx
27229 7DBD           50                         push	ax
27230 7DBE           B8                   0001  mov	ax,*1
27231 7DC1           31DB                       xor	bx,bx
27232 7DC3           53                         push	bx
27233 7DC4           50                         push	ax
27234 7DC5           8B46         C8            mov	ax,-2+..FFE0[bp]
27235 7DC8           8B5E         CA            mov	bx,0+..FFE0[bp]
27236 7DCB           8D7E         C4            lea	di,-6+..FFE0[bp]
27237 7DCE           E8         82C2            call	laddul
27238 7DD1           83C4                   08  add	sp,*8
27239                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
27240                                           ! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
27241                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
27242 7DD4           8846         D4            mov	-$2C[bp],al
27243                                           !BCC_EOS
27244                                           ! 4071       atacmd[2]=(ilba+slba & 0xff000000) >> 24;
27245                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
27246 7DD7           8B46         E6            mov	ax,-$1A[bp]
27247 7DDA           8B5E         E8            mov	bx,-$18[bp]
27248 7DDD           8D7E         E2            lea	di,-$1E[bp]
27249 7DE0           E8         82B0            call	laddul
27250                                           ! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
27251 7DE3           53                         push	bx
27252 7DE4           50                         push	ax
27253 7DE5           31C0                       xor	ax,ax
27254 7DE7           BB                   FF00  mov	bx,#$FF00
27255 7DEA           53                         push	bx
27256 7DEB           50                         push	ax
27257 7DEC           8B46         C8            mov	ax,-2+..FFE0[bp]
27258 7DEF           8B5E         CA            mov	bx,0+..FFE0[bp]
27259 7DF2           8D7E         C4            lea	di,-6+..FFE0[bp]
27260 7DF5           E8         8293            call	landul
27261 7DF8           83C4                   08  add	sp,*8
27262                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
27263 7DFB           93                         xchg	bx,ax
27264 7DFC           88E0                       mov	al,ah
27265 7DFE           30E4                       xor	ah,ah
27266 7E00           31DB                       xor	bx,bx
27267                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
27268 7E02           8846         CE            mov	-$32[bp],al
27269                                           !BCC_EOS
27270                                           ! 4072       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
27271                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
27272 7E05           8B46         E6            mov	ax,-$1A[bp]
27273 7E08           8B5E         E8            mov	bx,-$18[bp]
27274 7E0B           8D7E         E2            lea	di,-$1E[bp]
27275 7E0E           E8         8282            call	laddul
27276                                           ! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
27277 7E11           53                         push	bx
27278 7E12           50                         push	ax
27279 7E13           31C0                       xor	ax,ax
27280 7E15           BB                   00FF  mov	bx,#$FF
27281 7E18           53                         push	bx
27282 7E19           50                         push	ax
27283 7E1A           8B46         C8            mov	ax,-2+..FFE0[bp]
27284 7E1D           8B5E         CA            mov	bx,0+..FFE0[bp]
27285 7E20           8D7E         C4            lea	di,-6+..FFE0[bp]
27286 7E23           E8         8265            call	landul
27287 7E26           83C4                   08  add	sp,*8
27288                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
27289 7E29           93                         xchg	bx,ax
27290 7E2A           31DB                       xor	bx,bx
27291                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
27292 7E2C           8846         CF            mov	-$31[bp],al
27293                                           !BCC_EOS
27294                                           ! 4073       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
27295                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
27296 7E2F           8B46         E6            mov	ax,-$1A[bp]
27297 7E32           8B5E         E8            mov	bx,-$18[bp]
27298 7E35           8D7E         E2            lea	di,-$1E[bp]
27299 7E38           E8         8258            call	laddul
27300                                           ! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
27301 7E3B           53                         push	bx
27302 7E3C           50                         push	ax
27303 7E3D           B8                   FF00  mov	ax,#$FF00
27304 7E40           31DB                       xor	bx,bx
27305 7E42           53                         push	bx
27306 7E43           50                         push	ax
27307 7E44           8B46         C8            mov	ax,-2+..FFE0[bp]
27308 7E47           8B5E         CA            mov	bx,0+..FFE0[bp]
27309 7E4A           8D7E         C4            lea	di,-6+..FFE0[bp]
27310 7E4D           E8         823B            call	landul
27311 7E50           83C4                   08  add	sp,*8
27312                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
27313 7E53           88E0                       mov	al,ah
27314 7E55           88DC                       mov	ah,bl
27315 7E57           88FB                       mov	bl,bh
27316 7E59           28FF                       sub	bh,bh
27317                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
27318 7E5B           8846         D0            mov	-$30[bp],al
27319                                           !BCC_EOS
27320                                           ! 4074       atacmd[5]=(ilba+slba & 0x000000ff);
27321                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
27322 7E5E           8B46         E6            mov	ax,-$1A[bp]
27323 7E61           8B5E         E8            mov	bx,-$18[bp]
27324 7E64           8D7E         E2            lea	di,-$1E[bp]
27325 7E67           E8         8229            call	laddul
27326                                           ! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
27327 7E6A           53                         push	bx
27328 7E6B           50                         push	ax
27329 7E6C           B8                   00FF  mov	ax,#$FF
27330 7E6F           31DB                       xor	bx,bx
27331 7E71           53                         push	bx
27332 7E72           50                         push	ax
27333 7E73           8B46         C8            mov	ax,-2+..FFE0[bp]
27334 7E76           8B5E         CA            mov	bx,0+..FFE0[bp]
27335 7E79           8D7E         C4            lea	di,-6+..FFE0[bp]
27336 7E7C           E8         820C            call	landul
27337 7E7F           83C4                   08  add	sp,*8
27338                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
27339 7E82           8846         D1            mov	-$2F[bp],al
27340                                           !BCC_EOS
27341                                           ! 4075       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
27342                                           ! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
27343 7E85           FF76         D8            push	-$28[bp]
27344                                           ! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
27345 7E88           FF76         DA            push	-$26[bp]
27346                                           ! Debug: list int = const 1 (used reg = )
27347 7E8B           B8                   0001  mov	ax,*1
27348 7E8E           50                         push	ax
27349                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
27350 7E8F           8B46         EE            mov	ax,-$12[bp]
27351 7E92           31DB                       xor	bx,bx
27352                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
27353 7E94           53                         push	bx
27354 7E95           50                         push	ax
27355 7E96           B8                   0200  mov	ax,#$200
27356 7E99           31DB                       xor	bx,bx
27357 7E9B           53                         push	bx
27358 7E9C           50                         push	ax
27359 7E9D           8B46         C2            mov	ax,-8+..FFE0[bp]
27360 7EA0           8B5E         C4            mov	bx,-6+..FFE0[bp]
27361 7EA3           8D7E         BE            lea	di,-$C+..FFE0[bp]
27362 7EA6           E8         8210            call	lmulul
27363 7EA9           83C4                   08  add	sp,*8
27364                                           ! Debug: list unsigned long = bx+0 (used reg = )
27365 7EAC           53                         push	bx
27366 7EAD           50                         push	ax
27367                                           ! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
27368 7EAE           8B46         DC            mov	ax,-$24[bp]
27369 7EB1           B9                   0200  mov	cx,#$200
27370 7EB4           F7E9                       imul	cx
27371                                           ! Debug: list unsigned int = ax+0 (used reg = )
27372 7EB6           50                         push	ax
27373                                           ! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
27374 7EB7           8D5E         CC            lea	bx,-$34[bp]
27375 7EBA           53                         push	bx
27376                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
27377 7EBB           E8         8799            call	_get_SS
27378                                           ! Debug: list unsigned short = ax+0 (used reg = )
27379 7EBE           50                         push	ax
27380                                           ! Debug: list int = const $C (used reg = )
27381 7EBF           B8                   000C  mov	ax,*$C
27382 7EC2           50                         push	ax
27383                                           ! Debug: list unsigned char device = [S+$48-5] (used reg = )
27384 7EC3           8A46         FD            mov	al,-3[bp]
27385 7EC6           30E4                       xor	ah,ah
27386 7EC8           50                         push	ax
27387                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
27388 7EC9           E8         B1E0            call	_ata_cmd_packet
27389 7ECC           83C4                   14  add	sp,*$14
27390                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
27391 7ECF           8846         FC            mov	-4[bp],al
27392                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
27393 7ED2           84C0                       test	al,al
27394 7ED4           74           37            je  	.5AF
27395                       00007ED6            .5B0:
27396                                           ! 4076         bios_printf(4, "int13
27397                                           ! 4076 _cdemu: function %02x, error %02x !\n",( AX >> 8 ),status);
27398                                           ! Debug: list unsigned char status = [S+$36-6] (used reg = )
27399 7ED6           8A46         FC            mov	al,-4[bp]
27400 7ED9           30E4                       xor	ah,ah
27401 7EDB           50                         push	ax
27402                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$38+$14] (used reg = )
27403 7EDC           8B46         16            mov	ax,$16[bp]
27404 7EDF           88E0                       mov	al,ah
27405 7EE1           30E4                       xor	ah,ah
27406                                           ! Debug: list unsigned int = ax+0 (used reg = )
27407 7EE3           50                         push	ax
27408                                           ! Debug: list * char = .5B1+0 (used reg = )
27409 7EE4           BB                   D255  mov	bx,#.5B1
27410 7EE7           53                         push	bx
27411                                           ! Debug: list int = const 4 (used reg = )
27412 7EE8           B8                   0004  mov	ax,*4
27413 7EEB           50                         push	ax
27414                                           ! Debug: func () void = bios_printf+0 (used reg = )
27415 7EEC           E8         89BA            call	_bios_printf
27416 7EEF           83C4                   08  add	sp,*8
27417                                           !BCC_EOS
27418                                           ! 4077         AX = ((AX & 0x00ff) | ((0x02) << 8));
27419                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
27420 7EF2           8A46         16            mov	al,$16[bp]
27421                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
27422 7EF5           30E4                       xor	ah,ah
27423 7EF7           0D                   0200  or	ax,#$200
27424                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
27425 7EFA           8946         16            mov	$16[bp],ax
27426                                           !BCC_EOS
27427                                           ! 4078         AX = ((AX & 0xff00) | (0));
27428                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
27429 7EFD           8B46         16            mov	ax,$16[bp]
27430 7F00           30C0                       xor	al,al
27431                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
27432 7F02           0C                     00  or	al,*0
27433                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
27434 7F04           8946         16            mov	$16[bp],ax
27435                                           !BCC_EOS
27436                                           ! 4079         goto int13_fail_noah;
27437 7F07           83C4                   00  add	sp,#..FFDE-..FFE0
27438 7F0A           E9         01B8            br 	.FFDE
27439                                           !BCC_EOS
27440                                           ! 4080         }
27441                                           ! 4081       goto int13_success;
27442                       00007F0D            .5AF:
27443 7F0D           83C4                   00  add	sp,#..FFDF-..FFE0
27444 7F10           E9         01D4            br 	.FFDF
27445                                           !BCC_EOS
27446                                           ! 4082       break;
27447 7F13           E9         01A4            br 	.594
27448                                           !BCC_EOS
27449                                           ! 4083     case 0x08:
27450                                           ! 4084       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
27451                       00007F16            .5B2:
27452                                           ! Debug: list * unsigned short = const $24E (used reg = )
27453 7F16           B8                   024E  mov	ax,#$24E
27454 7F19           50                         push	ax
27455                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
27456 7F1A           FF76         FE            push	-2[bp]
27457                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27458 7F1D           E8         86F1            call	_read_word
27459 7F20           83C4                   04  add	sp,*4
27460                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
27461 7F23           8946         F8            mov	-8[bp],ax
27462                                           !BCC_EOS
27463                                           ! 4085       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders) - 1;
27464                                           ! Debug: list * unsigned short = const $24C (used reg = )
27465 7F26           B8                   024C  mov	ax,#$24C
27466 7F29           50                         push	ax
27467                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
27468 7F2A           FF76         FE            push	-2[bp]
27469                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27470 7F2D           E8         86E1            call	_read_word
27471 7F30           83C4                   04  add	sp,*4
27472                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
27473                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
27474 7F33           48                         dec	ax
27475 7F34           8946         F6            mov	-$A[bp],ax
27476                                           !BCC_EOS
27477                                           ! 4086       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
27478                                           ! Debug: list * unsigned short = const $24A (used reg = )
27479 7F37           B8                   024A  mov	ax,#$24A
27480 7F3A           50                         push	ax
27481                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
27482 7F3B           FF76         FE            push	-2[bp]
27483                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27484 7F3E           E8         86D0            call	_read_word
27485 7F41           83C4                   04  add	sp,*4
27486                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
27487                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
27488 7F44           48                         dec	ax
27489 7F45           8946         FA            mov	-6[bp],ax
27490                                           !BCC_EOS
27491                                           ! 4087       AX = ((AX & 0xff00) | (0x00));
27492                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
27493 7F48           8B46         16            mov	ax,$16[bp]
27494 7F4B           30C0                       xor	al,al
27495                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
27496 7F4D           0C                     00  or	al,*0
27497                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
27498 7F4F           8946         16            mov	$16[bp],ax
27499                                           !BCC_EOS
27500                                           ! 4088       BX = ((BX & 0xff00) | (0x00));
27501                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
27502 7F52           8B46         10            mov	ax,$10[bp]
27503 7F55           30C0                       xor	al,al
27504                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
27505 7F57           0C                     00  or	al,*0
27506                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
27507 7F59           8946         10            mov	$10[bp],ax
27508                                           !BCC_EOS
27509                                           ! 4089       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
27510                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
27511 7F5C           8A46         F6            mov	al,-$A[bp]
27512                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
27513 7F5F           30E4                       xor	ah,ah
27514 7F61           88C4                       mov	ah,al
27515 7F63           30C0                       xor	al,al
27516 7F65           50                         push	ax
27517                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
27518 7F66           8A46         14            mov	al,$14[bp]
27519                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
27520 7F69           30E4                       xor	ah,ah
27521 7F6B           0B46         CA            or	ax,0+..FFE0[bp]
27522 7F6E           44                         inc	sp
27523 7F6F           44                         inc	sp
27524                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
27525 7F70           8946         14            mov	$14[bp],ax
27526                                           !BCC_EOS
27527                                           ! 4090       CX = ((CX & 0xff00) | ((( vcylinders >> 2) & 0xc0) | ( vspt & 0x3f )));
27528                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
27529 7F73           8A46         F8            mov	al,-8[bp]
27530 7F76           24                     3F  and	al,*$3F
27531 7F78           50                         push	ax
27532                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
27533 7F79           8B46         F6            mov	ax,-$A[bp]
27534 7F7C           D1E8                       shr	ax,*1
27535 7F7E           D1E8                       shr	ax,*1
27536                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
27537 7F80           24                     C0  and	al,#$C0
27538                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
27539 7F82           0A46         CA            or	al,0+..FFE0[bp]
27540 7F85           44                         inc	sp
27541 7F86           44                         inc	sp
27542 7F87           50                         push	ax
27543                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
27544 7F88           8B46         14            mov	ax,$14[bp]
27545 7F8B           30C0                       xor	al,al
27546                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
27547 7F8D           0A46         CA            or	al,0+..FFE0[bp]
27548 7F90           44                         inc	sp
27549 7F91           44                         inc	sp
27550                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
27551 7F92           8946         14            mov	$14[bp],ax
27552                                           !BCC_EOS
27553                                           ! 4091       DX = ((DX & 0x00ff) | ((vheads) << 8));
27554                                           ! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
27555 7F95           8B46         FA            mov	ax,-6[bp]
27556 7F98           88C4                       mov	ah,al
27557 7F9A           30C0                       xor	al,al
27558 7F9C           50                         push	ax
27559                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
27560 7F9D           8A46         12            mov	al,$12[bp]
27561                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
27562 7FA0           30E4                       xor	ah,ah
27563 7FA2           0B46         CA            or	ax,0+..FFE0[bp]
27564 7FA5           44                         inc	sp
27565 7FA6           44                         inc	sp
27566                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
27567 7FA7           8946         12            mov	$12[bp],ax
27568                                           !BCC_EOS
27569                                           ! 4092       DX = ((DX & 0xff00) | (0x02));
27570                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
27571 7FAA           8B46         12            mov	ax,$12[bp]
27572 7FAD           30C0                       xor	al,al
27573                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
27574 7FAF           0C                     02  or	al,*2
27575                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
27576 7FB1           8946         12            mov	$12[bp],ax
27577                                           !BCC_EOS
27578                                           ! 4093       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
27579                                           ! Debug: list * unsigned char = const $23B (used reg = )
27580 7FB4           B8                   023B  mov	ax,#$23B
27581 7FB7           50                         push	ax
27582                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
27583 7FB8           FF76         FE            push	-2[bp]
27584                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27585 7FBB           E8         8640            call	_read_byte
27586 7FBE           83C4                   04  add	sp,*4
27587 7FC1           EB           26            jmp .5B5
27588                                           ! 4094         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
27589                       00007FC3            .5B6:
27590                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
27591 7FC3           8B46         10            mov	ax,$10[bp]
27592 7FC6           30C0                       xor	al,al
27593                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
27594 7FC8           0C                     02  or	al,*2
27595                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
27596 7FCA           8946         10            mov	$10[bp],ax
27597                                           !BCC_EOS
27598 7FCD           EB           26            jmp .5B3
27599                                           !BCC_EOS
27600                                           ! 4095         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
27601                       00007FCF            .5B7:
27602                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
27603 7FCF           8B46         10            mov	ax,$10[bp]
27604 7FD2           30C0                       xor	al,al
27605                                           ! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
27606 7FD4           0C                     04  or	al,*4
27607                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
27608 7FD6           8946         10            mov	$10[bp],ax
27609                                           !BCC_EOS
27610 7FD9           EB           1A            jmp .5B3
27611                                           !BCC_EOS
27612                                           ! 4096         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
27613                       00007FDB            .5B8:
27614                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
27615 7FDB           8B46         10            mov	ax,$10[bp]
27616 7FDE           30C0                       xor	al,al
27617                                           ! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
27618 7FE0           0C                     06  or	al,*6
27619                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
27620 7FE2           8946         10            mov	$10[bp],ax
27621                                           !BCC_EOS
27622 7FE5           EB           0E            jmp .5B3
27623                                           !BCC_EOS
27624                                           ! 4097         }
27625                                           ! 4098 #asm
27626 7FE7           EB           0C            jmp .5B3
27627                       00007FE9            .5B5:
27628 7FE9           2C                     01  sub	al,*1
27629 7FEB           74           D6            je 	.5B6
27630 7FED           2C                     01  sub	al,*1
27631 7FEF           74           DE            je 	.5B7
27632 7FF1           2C                     01  sub	al,*1
27633 7FF3           74           E6            je 	.5B8
27634                       00007FF5            .5B3:
27635                                           !BCC_EOS
27636                                           !BCC_ASM
27637                       00000040            _int13_cdemu.BP	set	$40
27638                       0000000C            .int13_cdemu.BP	set	$C
27639                       0000004E            _int13_cdemu.CS	set	$4E
27640                       0000001A            .int13_cdemu.CS	set	$1A
27641                       00000022            _int13_cdemu.nbsectors	set	$22
27642                       FFFFFFEE            .int13_cdemu.nbsectors	set	-$12
27643                       00000048            _int13_cdemu.CX	set	$48
27644                       00000014            .int13_cdemu.CX	set	$14
27645                       00000012            _int13_cdemu.elba	set	$12
27646                       FFFFFFDE            .int13_cdemu.elba	set	-$22
27647                       0000000E            _int13_cdemu.segment	set	$E
27648                       FFFFFFDA            .int13_cdemu.segment	set	-$26
27649                       0000003C            _int13_cdemu.DI	set	$3C
27650                       00000008            .int13_cdemu.DI	set	8
27651                       00000050            _int13_cdemu.FLAGS	set	$50
27652                       0000001C            .int13_cdemu.FLAGS	set	$1C
27653                       0000002A            _int13_cdemu.vcylinders	set	$2A
27654                       FFFFFFF6            .int13_cdemu.vcylinders	set	-$A
27655                       00000026            _int13_cdemu.sector	set	$26
27656                       FFFFFFF2            .int13_cdemu.sector	set	-$E
27657                       00000038            _int13_cdemu.DS	set	$38
27658                       00000004            .int13_cdemu.DS	set	4
27659                       00000028            _int13_cdemu.head	set	$28
27660                       FFFFFFF4            .int13_cdemu.head	set	-$C
27661                       00000024            _int13_cdemu.cylinder	set	$24
27662                       FFFFFFF0            .int13_cdemu.cylinder	set	-$10
27663                       00000046            _int13_cdemu.DX	set	$46
27664                       00000012            .int13_cdemu.DX	set	$12
27665                       00000031            _int13_cdemu.device	set	$31
27666                       FFFFFFFD            .int13_cdemu.device	set	-3
27667                       0000003A            _int13_cdemu.ES	set	$3A
27668                       00000006            .int13_cdemu.ES	set	6
27669                       0000002C            _int13_cdemu.vspt	set	$2C
27670                       FFFFFFF8            .int13_cdemu.vspt	set	-8
27671                       0000001E            _int13_cdemu.vlba	set	$1E
27672                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
27673                       00000032            _int13_cdemu.ebda_seg	set	$32
27674                       FFFFFFFE            .int13_cdemu.ebda_seg	set	-2
27675                       0000003E            _int13_cdemu.SI	set	$3E
27676                       0000000A            .int13_cdemu.SI	set	$A
27677                       0000004C            _int13_cdemu.IP	set	$4C
27678                       00000018            .int13_cdemu.IP	set	$18
27679                       00000030            _int13_cdemu.status	set	$30
27680                       FFFFFFFC            .int13_cdemu.status	set	-4
27681                       00000000            _int13_cdemu.atacmd	set	0
27682                       FFFFFFCC            .int13_cdemu.atacmd	set	-$34
27683                       0000004A            _int13_cdemu.AX	set	$4A
27684                       00000016            .int13_cdemu.AX	set	$16
27685                       0000001A            _int13_cdemu.ilba	set	$1A
27686                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
27687                       00000010            _int13_cdemu.before	set	$10
27688                       FFFFFFDC            .int13_cdemu.before	set	-$24
27689                       0000000C            _int13_cdemu.offset	set	$C
27690                       FFFFFFD8            .int13_cdemu.offset	set	-$28
27691                       00000016            _int13_cdemu.slba	set	$16
27692                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
27693                       00000042            _int13_cdemu.SP	set	$42
27694                       0000000E            .int13_cdemu.SP	set	$E
27695                       0000002E            _int13_cdemu.vheads	set	$2E
27696                       FFFFFFFA            .int13_cdemu.vheads	set	-6
27697                       00000044            _int13_cdemu.BX	set	$44
27698                       00000010            .int13_cdemu.BX	set	$10
27699 7FF5           55                               push bp
27700 7FF6           89E5                             mov bp, sp
27701 7FF8           B8                   EFDF        mov ax, #diskette_param_table2
27702 7FFB           8946         3E                  mov _int13_cdemu.DI+2[bp], ax
27703 7FFE           8C4E         3C                  mov _int13_cdemu.ES+2[bp], cs
27704 8001           5D                               pop bp
27705                                           ! 4105 endasm
27706                                           !BCC_ENDASM
27707                                           !BCC_EOS
27708                                           ! 4106       goto int13_success;
27709 8002           83C4                   00  add	sp,#..FFDF-..FFE0
27710 8005           E9         00DF            br 	.FFDF
27711                                           !BCC_EOS
27712                                           ! 4107       break;
27713 8008           E9         00AF            br 	.594
27714                                           !BCC_EOS
27715                                           ! 4108     case 0x15:
27716                                           ! 4109       AX = ((AX & 0x00ff) | ((0x03) << 8));
27717                       0000800B            .5B9:
27718                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
27719 800B           8A46         16            mov	al,$16[bp]
27720                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
27721 800E           30E4                       xor	ah,ah
27722 8010           0D                   0300  or	ax,#$300
27723                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
27724 8013           8946         16            mov	$16[bp],ax
27725                                           !BCC_EOS
27726                                           ! 4110       goto int13_success_noah;
27727 8016           83C4                   00  add	sp,#..FFDC-..FFE0
27728 8019           E9         00D5            br 	.FFDC
27729                                           !BCC_EOS
27730                                           ! 4111       break;
27731 801C           E9         009B            br 	.594
27732                                           !BCC_EOS
27733                                           ! 4112     case 0x0a:
27734                                           ! 4113     case 0x0b:
27735                       0000801F            .5BA:
27736                                           ! 4114     case 0x18:
27737                       0000801F            .5BB:
27738                                           ! 4115     case 0x41:
27739                       0000801F            .5BC:
27740                                           ! 4116     case 0x42:
27741                       0000801F            .5BD:
27742                                           ! 4117     case 0x43:
27743                       0000801F            .5BE:
27744                                           ! 4118     case 0x44:
27745                       0000801F            .5BF:
27746                                           ! 4119     case 0x45:
27747                       0000801F            .5C0:
27748                                           ! 4120     case 0x46:
27749                       0000801F            .5C1:
27750                                           ! 4121     case 0x47:
27751                       0000801F            .5C2:
27752                                           ! 4122     case 0x48:
27753                       0000801F            .5C3:
27754                                           ! 4123     case 0x49:
27755                       0000801F            .5C4:
27756                                           ! 4124     case 0x4e:
27757                       0000801F            .5C5:
27758                                           ! 4125     case 0x50:
27759                       0000801F            .5C6:
27760                                           ! 4126     default:
27761                       0000801F            .5C7:
27762                                           ! 4127       bios_printf(4, "int13_cdemu function AH=%02x unsupported, returns fail\n", ( AX >> 8 ));
27763                       0000801F            .5C8:
27764                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
27765 801F           8B46         16            mov	ax,$16[bp]
27766 8022           88E0                       mov	al,ah
27767 8024           30E4                       xor	ah,ah
27768                                           ! Debug: list unsigned int = ax+0 (used reg = )
27769 8026           50                         push	ax
27770                                           ! Debug: list * char = .5C9+0 (used reg = )
27771 8027           BB                   D21D  mov	bx,#.5C9
27772 802A           53                         push	bx
27773                                           ! Debug: list int = const 4 (used reg = )
27774 802B           B8                   0004  mov	ax,*4
27775 802E           50                         push	ax
27776                                           ! Debug: func () void = bios_printf+0 (used reg = )
27777 802F           E8         8877            call	_bios_printf
27778 8032           83C4                   06  add	sp,*6
27779                                           !BCC_EOS
27780                                           ! 4128       goto int13_fail;
27781 8035           83C4                   00  add	sp,#..FFE1-..FFE0
27782 8038           E9         007F            jmp .FFE1
27783                                           !BCC_EOS
27784                                           ! 4129       break;
27785 803B           EB           7D            jmp .594
27786                                           !BCC_EOS
27787                                           ! 4130     }
27788                                           ! 4131 int13_fail:
27789 803D           EB           7B            jmp .594
27790                       0000803F            .596:
27791 803F           2D                   0000  sub	ax,*0
27792 8042           7C           DB            jl 	.5C8
27793 8044           3D                   0018  cmp	ax,*$18
27794 8047           77           3B            ja  	.5CA
27795 8049           D1E0                       shl	ax,*1
27796 804B           89C3                       mov	bx,ax
27797 804D           2E                         seg	cs
27798 804E           FFA7       8052            br	.5CB[bx]
27799                       00008052            .5CB:
27800 8052                      7B61            .word	.597
27801 8054                      7B7E            .word	.5A1
27802 8056                      7BCF            .word	.5A5
27803 8058                      7B6A            .word	.59F
27804 805A                      7BCF            .word	.5A6
27805 805C                      7B6A            .word	.5A0
27806 805E                      801F            .word	.5C8
27807 8060                      801F            .word	.5C8
27808 8062                      7F16            .word	.5B2
27809 8064                      7B61            .word	.598
27810 8066                      801F            .word	.5BA
27811 8068                      801F            .word	.5BB
27812 806A                      7B61            .word	.599
27813 806C                      7B61            .word	.59A
27814 806E                      801F            .word	.5C8
27815 8070                      801F            .word	.5C8
27816 8072                      7B61            .word	.59B
27817 8074                      7B61            .word	.59C
27818 8076                      801F            .word	.5C8
27819 8078                      801F            .word	.5C8
27820 807A                      7B61            .word	.59D
27821 807C                      800B            .word	.5B9
27822 807E                      7B61            .word	.59E
27823 8080                      801F            .word	.5C8
27824 8082                      801F            .word	.5BC
27825                       00008084            .5CA:
27826 8084           2D                   0041  sub	ax,*$41
27827 8087           72           96            jb 	.5C8
27828 8089           3D                   000F  cmp	ax,*$F
27829 808C           77           29            ja  	.5CC
27830 808E           D1E0                       shl	ax,*1
27831 8090           89C3                       mov	bx,ax
27832 8092           2E                         seg	cs
27833 8093           FFA7       8097            br	.5CD[bx]
27834                       00008097            .5CD:
27835 8097                      801F            .word	.5BD
27836 8099                      801F            .word	.5BE
27837 809B                      801F            .word	.5BF
27838 809D                      801F            .word	.5C0
27839 809F                      801F            .word	.5C1
27840 80A1                      801F            .word	.5C2
27841 80A3                      801F            .word	.5C3
27842 80A5                      801F            .word	.5C4
27843 80A7                      801F            .word	.5C5
27844 80A9                      801F            .word	.5C8
27845 80AB                      801F            .word	.5C8
27846 80AD                      801F            .word	.5C8
27847 80AF                      801F            .word	.5C8
27848 80B1                      801F            .word	.5C6
27849 80B3                      801F            .word	.5C8
27850 80B5                      801F            .word	.5C7
27851                       000080B7            .5CC:
27852 80B7           E9         FF65            br 	.5C8
27853                       000080BA            .594:
27854                       FFFFFFCA            ..FFE0	=	-$36
27855                       000080BA            .FFE1:
27856                       FFFFFFCA            ..FFE1	=	-$36
27857                                           ! 4132     AX = ((AX & 0x00ff) | ((0x01) << 8));
27858                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
27859 80BA           8A46         16            mov	al,$16[bp]
27860                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
27861 80BD           30E4                       xor	ah,ah
27862 80BF           0D                   0100  or	ax,#$100
27863                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
27864 80C2           8946         16            mov	$16[bp],ax
27865                                           !BCC_EOS
27866                                           ! 4133 int13_fail_noah:
27867                       000080C5            .FFDE:
27868                       FFFFFFCA            ..FFDE	=	-$36
27869                                           ! 4134     write_byte(0x0040, 0x0074, ( AX >> 8 ));
27870                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
27871 80C5           8B46         16            mov	ax,$16[bp]
27872 80C8           88E0                       mov	al,ah
27873 80CA           30E4                       xor	ah,ah
27874                                           ! Debug: list unsigned int = ax+0 (used reg = )
27875 80CC           50                         push	ax
27876                                           ! Debug: list int = const $74 (used reg = )
27877 80CD           B8                   0074  mov	ax,*$74
27878 80D0           50                         push	ax
27879                                           ! Debug: list int = const $40 (used reg = )
27880 80D1           B8                   0040  mov	ax,*$40
27881 80D4           50                         push	ax
27882                                           ! Debug: func () void = write_byte+0 (used reg = )
27883 80D5           E8         854C            call	_write_byte
27884 80D8           83C4                   06  add	sp,*6
27885                                           !BCC_EOS
27886                                           ! 4135 int13_fail_nostatus:
27887                       000080DB            .FFDD:
27888                       FFFFFFCA            ..FFDD	=	-$36
27889                                           ! 4136     FLAGS |= 0x0001;
27890                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
27891 80DB           8B46         1C            mov	ax,$1C[bp]
27892 80DE           0C                     01  or	al,*1
27893 80E0           8946         1C            mov	$1C[bp],ax
27894                                           !BCC_EOS
27895                                           ! 4137     return;
27896 80E3           89EC                       mov	sp,bp
27897 80E5           5D                         pop	bp
27898 80E6           C3                         ret
27899                                           !BCC_EOS
27900                                           ! 4138 int13_success:
27901                       000080E7            .FFDF:
27902                       FFFFFFCA            ..FFDF	=	-$36
27903                                           ! 4139     AX = ((AX & 0x00ff) | ((0x00) << 8));
27904                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
27905 80E7           8A46         16            mov	al,$16[bp]
27906                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
27907 80EA           0C                     00  or	al,*0
27908                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
27909 80EC           30E4                       xor	ah,ah
27910 80EE           8946         16            mov	$16[bp],ax
27911                                           !BCC_EOS
27912                                           ! 4140 int13_success_noah:
27913                       000080F1            .FFDC:
27914                       FFFFFFCA            ..FFDC	=	-$36
27915                                           ! 4141     write_byte(0x0040, 0x0074, 0x00);
27916                                           ! Debug: list int = const 0 (used reg = )
27917 80F1           31C0                       xor	ax,ax
27918 80F3           50                         push	ax
27919                                           ! Debug: list int = const $74 (used reg = )
27920 80F4           B8                   0074  mov	ax,*$74
27921 80F7           50                         push	ax
27922                                           ! Debug: list int = const $40 (used reg = )
27923 80F8           B8                   0040  mov	ax,*$40
27924 80FB           50                         push	ax
27925                                           ! Debug: func () void = write_byte+0 (used reg = )
27926 80FC           E8         8525            call	_write_byte
27927 80FF           83C4                   06  add	sp,*6
27928                                           !BCC_EOS
27929                                           ! 4142     FLAGS &= 0xfffe;
27930                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
27931 8102           8B46         1C            mov	ax,$1C[bp]
27932 8105           24                     FE  and	al,#$FE
27933 8107           8946         1C            mov	$1C[bp],ax
27934                                           !BCC_EOS
27935                                           ! 4143     return;
27936 810A           89EC                       mov	sp,bp
27937 810C           5D                         pop	bp
27938 810D           C3                         ret
27939                                           !BCC_EOS
27940                                           ! 4144 }
27941                                           ! 4145   bx_bool
27942                                           ! Register BX used in function int13_cdemu
27943                                           ! 4146 floppy_media_known(drive)
27944                                           ! 4147   Bit
27945                                           ! 4147 16u drive;
27946                                           export	_floppy_media_known
27947                       0000810E            _floppy_media_known:
27948                                           !BCC_EOS
27949                                           ! 4148 {
27950                                           ! 4149   Bit8u val8;
27951                                           !BCC_EOS
27952                                           ! 4150   Bit16u media_state_offset;
27953                                           !BCC_EOS
27954                                           ! 4151   val8 = read_byte(0x0040, 0x003e);
27955 810E           55                         push	bp
27956 810F           89E5                       mov	bp,sp
27957 8111           83C4                   FC  add	sp,*-4
27958                                           ! Debug: list int = const $3E (used reg = )
27959 8114           B8                   003E  mov	ax,*$3E
27960 8117           50                         push	ax
27961                                           ! Debug: list int = const $40 (used reg = )
27962 8118           B8                   0040  mov	ax,*$40
27963 811B           50                         push	ax
27964                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27965 811C           E8         84DF            call	_read_byte
27966 811F           83C4                   04  add	sp,*4
27967                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
27968 8122           8846         FF            mov	-1[bp],al
27969                                           !BCC_EOS
27970                                           ! 4152   if (drive)
27971 8125           8B46         04            mov	ax,4[bp]
27972 8128           85C0                       test	ax,ax
27973 812A           74           0A            je  	.5CE
27974                       0000812C            .5CF:
27975                                           ! 4153     val8 >>= 1;
27976                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
27977 812C           8A46         FF            mov	al,-1[bp]
27978 812F           30E4                       xor	ah,ah
27979 8131           D1E8                       shr	ax,*1
27980 8133           8846         FF            mov	-1[bp],al
27981                                           !BCC_EOS
27982                                           ! 4154   val8 &= 0x01;
27983                       00008136            .5CE:
27984                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
27985 8136           8A46         FF            mov	al,-1[bp]
27986 8139           24                     01  and	al,*1
27987 813B           8846         FF            mov	-1[bp],al
27988                                           !BCC_EOS
27989                                           ! 4155   if (val8 == 0)
27990                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
27991 813E           8A46         FF            mov	al,-1[bp]
27992 8141           84C0                       test	al,al
27993 8143           75           06            jne 	.5D0
27994                       00008145            .5D1:
27995                                           ! 4156     return(0);
27996 8145           31C0                       xor	ax,ax
27997 8147           89EC                       mov	sp,bp
27998 8149           5D                         pop	bp
27999 814A           C3                         ret
28000                                           !BCC_EOS
28001                                           ! 4157   media_state_offset = 0x0090;
28002                       0000814B            .5D0:
28003                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
28004 814B           B8                   0090  mov	ax,#$90
28005 814E           8946         FC            mov	-4[bp],ax
28006                                           !BCC_EOS
28007                                           ! 4158   if (drive)
28008 8151           8B46         04            mov	ax,4[bp]
28009 8154           85C0                       test	ax,ax
28010 8156           74           07            je  	.5D2
28011                       00008158            .5D3:
28012                                           ! 4159     media_state_offset += 1;
28013                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
28014 8158           8B46         FC            mov	ax,-4[bp]
28015 815B           40                         inc	ax
28016 815C           8946         FC            mov	-4[bp],ax
28017                                           !BCC_EOS
28018                                           ! 4160   val8 = read_byte(0x0040, media_state_offset);
28019                       0000815F            .5D2:
28020                                           ! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
28021 815F           FF76         FC            push	-4[bp]
28022                                           ! Debug: list int = const $40 (used reg = )
28023 8162           B8                   0040  mov	ax,*$40
28024 8165           50                         push	ax
28025                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28026 8166           E8         8495            call	_read_byte
28027 8169           83C4                   04  add	sp,*4
28028                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
28029 816C           8846         FF            mov	-1[bp],al
28030                                           !BCC_EOS
28031                                           ! 4161   val8 = (val8 >> 4) & 0x01;
28032                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
28033 816F           8A46         FF            mov	al,-1[bp]
28034 8172           30E4                       xor	ah,ah
28035 8174           B1                     04  mov	cl,*4
28036 8176           D3E8                       shr	ax,cl
28037                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
28038 8178           24                     01  and	al,*1
28039                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
28040 817A           8846         FF            mov	-1[bp],al
28041                                           !BCC_EOS
28042                                           ! 4162   if (val8 == 0)
28043                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
28044 817D           8A46         FF            mov	al,-1[bp]
28045 8180           84C0                       test	al,al
28046 8182           75           06            jne 	.5D4
28047                       00008184            .5D5:
28048                                           ! 4163     return(0);
28049 8184           31C0                       xor	ax,ax
28050 8186           89EC                       mov	sp,bp
28051 8188           5D                         pop	bp
28052 8189           C3                         ret
28053                                           !BCC_EOS
28054                                           ! 4164   return(1);
28055                       0000818A            .5D4:
28056 818A           B8                   0001  mov	ax,*1
28057 818D           89EC                       mov	sp,bp
28058 818F           5D                         pop	bp
28059 8190           C3                         ret
28060                                           !BCC_EOS
28061                                           ! 4165 }
28062                                           ! 4166   bx_bool
28063                                           ! 4167 floppy_media_sense(drive)
28064                                           ! 4168   Bit16u drive;
28065                                           export	_floppy_media_sense
28066                       00008191            _floppy_media_sense:
28067                                           !BCC_EOS
28068                                           ! 4169 {
28069                                           ! 4170   bx_bool retval;
28070                                           !BCC_EOS
28071                                           ! 4171   Bit16u media_state_offset;
28072                                           !BCC_EOS
28073                                           ! 4172   Bit8u drive_type, config_data, media_state;
28074                                           !BCC_EOS
28075                                           ! 4173   if (floppy_drive_recal(drive) == 0) {
28076 8191           55                         push	bp
28077 8192           89E5                       mov	bp,sp
28078 8194           83C4                   F8  add	sp,*-8
28079                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
28080 8197           FF76         04            push	4[bp]
28081                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
28082 819A           E8         0154            call	_floppy_drive_recal
28083 819D           44                         inc	sp
28084 819E           44                         inc	sp
28085                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
28086 819F           85C0                       test	ax,ax
28087 81A1           75           06            jne 	.5D6
28088                       000081A3            .5D7:
28089                                           ! 4174     return(0);
28090 81A3           31C0                       xor	ax,ax
28091 81A5           89EC                       mov	sp,bp
28092 81A7           5D                         pop	bp
28093 81A8           C3                         ret
28094                                           !BCC_EOS
28095                                           ! 4175     }
28096                                           ! 4176   drive_type = inb_cmos(0x10);
28097                       000081A9            .5D6:
28098                                           ! Debug: list int = const $10 (used reg = )
28099 81A9           B8                   0010  mov	ax,*$10
28100 81AC           50                         push	ax
28101                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
28102 81AD           E8         83DD            call	_inb_cmos
28103 81B0           44                         inc	sp
28104 81B1           44                         inc	sp
28105                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
28106 81B2           8846         FB            mov	-5[bp],al
28107                                           !BCC_EOS
28108                                           ! 4177   if (drive == 0)
28109                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
28110 81B5           8B46         04            mov	ax,4[bp]
28111 81B8           85C0                       test	ax,ax
28112 81BA           75           0E            jne 	.5D8
28113                       000081BC            .5D9:
28114                                           ! 4178     drive_type >>= 4;
28115                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
28116 81BC           8A46         FB            mov	al,-5[bp]
28117 81BF           30E4                       xor	ah,ah
28118 81C1           B1                     04  mov	cl,*4
28119 81C3           D3E8                       shr	ax,cl
28120 81C5           8846         FB            mov	-5[bp],al
28121                                           !BCC_EOS
28122                                           ! 4179   else
28123                                           ! 4180     drive_type &= 0x0f;
28124 81C8           EB           08            jmp .5DA
28125                       000081CA            .5D8:
28126                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
28127 81CA           8A46         FB            mov	al,-5[bp]
28128 81CD           24                     0F  and	al,*$F
28129 81CF           8846         FB            mov	-5[bp],al
28130                                           !BCC_EOS
28131                                           ! 4181   if ( drive_type == 1 ) {
28132                       000081D2            .5DA:
28133                                           ! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
28134 81D2           8A46         FB            mov	al,-5[bp]
28135 81D5           3C                     01  cmp	al,*1
28136 81D7           75           13            jne 	.5DB
28137                       000081D9            .5DC:
28138                                           ! 4182     config_data = 0x00;
28139                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
28140 81D9           30C0                       xor	al,al
28141 81DB           8846         FA            mov	-6[bp],al
28142                                           !BCC_EOS
28143                                           ! 4183     media_state = 0x25;
28144                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
28145 81DE           B0                     25  mov	al,*$25
28146 81E0           8846         F9            mov	-7[bp],al
28147                                           !BCC_EOS
28148                                           ! 4184     retval = 1;
28149                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
28150 81E3           B8                   0001  mov	ax,*1
28151 81E6           8946         FE            mov	-2[bp],ax
28152                                           !BCC_EOS
28153                                           ! 4185     }
28154                                           ! 4186   else if ( drive_type == 2 ) {
28155 81E9           E9         00C2            br 	.5DD
28156                       000081EC            .5DB:
28157                                           ! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
28158 81EC           8A46         FB            mov	al,-5[bp]
28159 81EF           3C                     02  cmp	al,*2
28160 81F1           75           13            jne 	.5DE
28161                       000081F3            .5DF:
28162                                           ! 4187     config_data = 0x00;
28163                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
28164 81F3           30C0                       xor	al,al
28165 81F5           8846         FA            mov	-6[bp],al
28166                                           !BCC_EOS
28167                                           ! 4188     media_state = 0x25;
28168                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
28169 81F8           B0                     25  mov	al,*$25
28170 81FA           8846         F9            mov	-7[bp],al
28171                                           !BCC_EOS
28172                                           ! 4189     retval = 1;
28173                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
28174 81FD           B8                   0001  mov	ax,*1
28175 8200           8946         FE            mov	-2[bp],ax
28176                                           !BCC_EOS
28177                                           ! 4190     }
28178                                           ! 4191   else if ( drive_type == 3 ) {
28179 8203           E9         00A8            br 	.5E0
28180                       00008206            .5DE:
28181                                           ! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
28182 8206           8A46         FB            mov	al,-5[bp]
28183 8209           3C                     03  cmp	al,*3
28184 820B           75           13            jne 	.5E1
28185                       0000820D            .5E2:
28186                                           ! 4192     config_data = 0x00;
28187                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
28188 820D           30C0                       xor	al,al
28189 820F           8846         FA            mov	-6[bp],al
28190                                           !BCC_EOS
28191                                           ! 4193     media_state = 0x17;
28192                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
28193 8212           B0                     17  mov	al,*$17
28194 8214           8846         F9            mov	-7[bp],al
28195                                           !BCC_EOS
28196                                           ! 4194     retval = 1;
28197                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
28198 8217           B8                   0001  mov	ax,*1
28199 821A           8946         FE            mov	-2[bp],ax
28200                                           !BCC_EOS
28201                                           ! 4195     }
28202                                           ! 4196   else if ( drive_type == 4 ) {
28203 821D           E9         008E            br 	.5E3
28204                       00008220            .5E1:
28205                                           ! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
28206 8220           8A46         FB            mov	al,-5[bp]
28207 8223           3C                     04  cmp	al,*4
28208 8225         0F85         0012            bne 	.5E4
28209                       00008229            .5E5:
28210                                           ! 4197     config_data = 0x00;
28211                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
28212 8229           30C0                       xor	al,al
28213 822B           8846         FA            mov	-6[bp],al
28214                                           !BCC_EOS
28215                                           ! 4198     media_state = 0x17;
28216                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
28217 822E           B0                     17  mov	al,*$17
28218 8230           8846         F9            mov	-7[bp],al
28219                                           !BCC_EOS
28220                                           ! 4199     retval = 1;
28221                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
28222 8233           B8                   0001  mov	ax,*1
28223 8236           8946         FE            mov	-2[bp],ax
28224                                           !BCC_EOS
28225                                           ! 4200     }
28226                                           ! 4201   else if ( drive_type == 5 ) {
28227 8239           EB           73            jmp .5E6
28228                       0000823B            .5E4:
28229                                           ! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
28230 823B           8A46         FB            mov	al,-5[bp]
28231 823E           3C                     05  cmp	al,*5
28232 8240           75           12            jne 	.5E7
28233                       00008242            .5E8:
28234                                           ! 4202     config_data = 0xCC;
28235                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
28236 8242           B0                     CC  mov	al,#$CC
28237 8244           8846         FA            mov	-6[bp],al
28238                                           !BCC_EOS
28239                                           ! 4203     media_state = 0xD7;
28240                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
28241 8247           B0                     D7  mov	al,#$D7
28242 8249           8846         F9            mov	-7[bp],al
28243                                           !BCC_EOS
28244                                           ! 4204     retval = 1;
28245                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
28246 824C           B8                   0001  mov	ax,*1
28247 824F           8946         FE            mov	-2[bp],ax
28248                                           !BCC_EOS
28249                                           ! 4205     }
28250                                           ! 4206   else if ( drive_type == 6 ) {
28251 8252           EB           5A            jmp .5E9
28252                       00008254            .5E7:
28253                                           ! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
28254 8254           8A46         FB            mov	al,-5[bp]
28255 8257           3C                     06  cmp	al,*6
28256 8259           75           12            jne 	.5EA
28257                       0000825B            .5EB:
28258                                           ! 4207     config_data = 0x00;
28259                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
28260 825B           30C0                       xor	al,al
28261 825D           8846         FA            mov	-6[bp],al
28262                                           !BCC_EOS
28263                                           ! 4208     media_state = 0x27;
28264                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
28265 8260           B0                     27  mov	al,*$27
28266 8262           8846         F9            mov	-7[bp],al
28267                                           !BCC_EOS
28268                                           ! 4209     retval = 1;
28269                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
28270 8265           B8                   0001  mov	ax,*1
28271 8268           8946         FE            mov	-2[bp],ax
28272                                           !BCC_EOS
28273                                           ! 4210     }
28274                                           ! 4211   else if ( drive_type == 7 ) {
28275 826B           EB           41            jmp .5EC
28276                       0000826D            .5EA:
28277                                           ! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
28278 826D           8A46         FB            mov	al,-5[bp]
28279 8270           3C                     07  cmp	al,*7
28280 8272           75           12            jne 	.5ED
28281                       00008274            .5EE:
28282                                           ! 4212     config_data = 0x00;
28283                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
28284 8274           30C0                       xor	al,al
28285 8276           8846         FA            mov	-6[bp],al
28286                                           !BCC_EOS
28287                                           ! 4213     media_state = 0x27;
28288                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
28289 8279           B0                     27  mov	al,*$27
28290 827B           8846         F9            mov	-7[bp],al
28291                                           !BCC_EOS
28292                                           ! 4214     retval = 1;
28293                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
28294 827E           B8                   0001  mov	ax,*1
28295 8281           8946         FE            mov	-2[bp],ax
28296                                           !BCC_EOS
28297                                           ! 4215     }
28298                                           ! 4216   else if ( drive_type == 8 ) {
28299 8284           EB           28            jmp .5EF
28300                       00008286            .5ED:
28301                                           ! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
28302 8286           8A46         FB            mov	al,-5[bp]
28303 8289           3C                     08  cmp	al,*8
28304 828B           75           12            jne 	.5F0
28305                       0000828D            .5F1:
28306                                           ! 4217     config_data = 0x00;
28307                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
28308 828D           30C0                       xor	al,al
28309 828F           8846         FA            mov	-6[bp],al
28310                                           !BCC_EOS
28311                                           ! 4218     media_state = 0x27;
28312                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
28313 8292           B0                     27  mov	al,*$27
28314 8294           8846         F9            mov	-7[bp],al
28315                                           !BCC_EOS
28316                                           ! 4219     retval = 1;
28317                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
28318 8297           B8                   0001  mov	ax,*1
28319 829A           8946         FE            mov	-2[bp],ax
28320                                           !BCC_EOS
28321                                           ! 4220     }
28322                                           ! 4221   else {
28323 829D           EB           0F            jmp .5F2
28324                       0000829F            .5F0:
28325                                           ! 4222     config_data = 0x00;
28326                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
28327 829F           30C0                       xor	al,al
28328 82A1           8846         FA            mov	-6[bp],al
28329                                           !BCC_EOS
28330                                           ! 4223     media_state = 0x00;
28331                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
28332 82A4           30C0                       xor	al,al
28333 82A6           8846         F9            mov	-7[bp],al
28334                                           !BCC_EOS
28335                                           ! 4224     retval = 0;
28336                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
28337 82A9           31C0                       xor	ax,ax
28338 82AB           8946         FE            mov	-2[bp],ax
28339                                           !BCC_EOS
28340                                           ! 4225     }
28341                                           ! 4226   if (drive == 0)
28342                       000082AE            .5F2:
28343                       000082AE            .5EF:
28344                       000082AE            .5EC:
28345                       000082AE            .5E9:
28346                       000082AE            .5E6:
28347                       000082AE            .5E3:
28348                       000082AE            .5E0:
28349                       000082AE            .5DD:
28350                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
28351 82AE           8B46         04            mov	ax,4[bp]
28352 82B1           85C0                       test	ax,ax
28353 82B3           75           08            jne 	.5F3
28354                       000082B5            .5F4:
28355                                           ! 4227     media_state_offset = 0x90;
28356                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
28357 82B5           B8                   0090  mov	ax,#$90
28358 82B8           8946         FC            mov	-4[bp],ax
28359                                           !BCC_EOS
28360                                           ! 4228   else
28361                                           ! 4229     media_state_offset = 0x91;
28362 82BB           EB           06            jmp .5F5
28363                       000082BD            .5F3:
28364                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
28365 82BD           B8                   0091  mov	ax,#$91
28366 82C0           8946         FC            mov	-4[bp],ax
28367                                           !BCC_EOS
28368                                           ! 4230   write_byte(0x0040, 0x008B, config_data);
28369                       000082C3            .5F5:
28370                                           ! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
28371 82C3           8A46         FA            mov	al,-6[bp]
28372 82C6           30E4                       xor	ah,ah
28373 82C8           50                         push	ax
28374                                           ! Debug: list int = const $8B (used reg = )
28375 82C9           B8                   008B  mov	ax,#$8B
28376 82CC           50                         push	ax
28377                                           ! Debug: list int = const $40 (used reg = )
28378 82CD           B8                   0040  mov	ax,*$40
28379 82D0           50                         push	ax
28380                                           ! Debug: func () void = write_byte+0 (used reg = )
28381 82D1           E8         8350            call	_write_byte
28382 82D4           83C4                   06  add	sp,*6
28383                                           !BCC_EOS
28384                                           ! 4231   write_byte(0x0040, media_state_offset, media_state);
28385                                           ! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
28386 82D7           8A46         F9            mov	al,-7[bp]
28387 82DA           30E4                       xor	ah,ah
28388 82DC           50                         push	ax
28389                                           ! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
28390 82DD           FF76         FC            push	-4[bp]
28391                                           ! Debug: list int = const $40 (used reg = )
28392 82E0           B8                   0040  mov	ax,*$40
28393 82E3           50                         push	ax
28394                                           ! Debug: func () void = write_byte+0 (used reg = )
28395 82E4           E8         833D            call	_write_byte
28396 82E7           83C4                   06  add	sp,*6
28397                                           !BCC_EOS
28398                                           ! 4232   return(retval);
28399 82EA           8B46         FE            mov	ax,-2[bp]
28400 82ED           89EC                       mov	sp,bp
28401 82EF           5D                         pop	bp
28402 82F0           C3                         ret
28403                                           !BCC_EOS
28404                                           ! 4233 }
28405                                           ! 4234   bx_bool
28406                                           ! 4235 floppy_drive_recal(drive)
28407                                           ! 4236   Bit16u drive;
28408                                           export	_floppy_drive_recal
28409                       000082F1            _floppy_drive_recal:
28410                                           !BCC_EOS
28411                                           ! 4237 {
28412                                           ! 4238   Bit8u val8, dor;
28413                                           !BCC_EOS
28414                                           ! 4239   Bit16u curr_cyl_offset;
28415                                           !BCC_EOS
28416                                           ! 4240   val8 = read_byte(0x0000, 0x043e);
28417 82F1           55                         push	bp
28418 82F2           89E5                       mov	bp,sp
28419 82F4           83C4                   FC  add	sp,*-4
28420                                           ! Debug: list int = const $43E (used reg = )
28421 82F7           B8                   043E  mov	ax,#$43E
28422 82FA           50                         push	ax
28423                                           ! Debug: list int = const 0 (used reg = )
28424 82FB           31C0                       xor	ax,ax
28425 82FD           50                         push	ax
28426                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28427 82FE           E8         82FD            call	_read_byte
28428 8301           83C4                   04  add	sp,*4
28429                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
28430 8304           8846         FF            mov	-1[bp],al
28431                                           !BCC_EOS
28432                                           ! 4241   val8 &= 0x7f;
28433                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
28434 8307           8A46         FF            mov	al,-1[bp]
28435 830A           24                     7F  and	al,*$7F
28436 830C           8846         FF            mov	-1[bp],al
28437                                           !BCC_EOS
28438                                           ! 4242   write_byte(0x0000, 0x043e, val8);
28439                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
28440 830F           8A46         FF            mov	al,-1[bp]
28441 8312           30E4                       xor	ah,ah
28442 8314           50                         push	ax
28443                                           ! Debug: list int = const $43E (used reg = )
28444 8315           B8                   043E  mov	ax,#$43E
28445 8318           50                         push	ax
28446                                           ! Debug: list int = const 0 (used reg = )
28447 8319           31C0                       xor	ax,ax
28448 831B           50                         push	ax
28449                                           ! Debug: func () void = write_byte+0 (used reg = )
28450 831C           E8         8305            call	_write_byte
28451 831F           83C4                   06  add	sp,*6
28452                                           !BCC_EOS
28453                                           ! 4243   if (drive)
28454 8322           8B46         04            mov	ax,4[bp]
28455 8325           85C0                       test	ax,ax
28456 8327           74           07            je  	.5F6
28457                       00008329            .5F7:
28458                                           ! 4244     dor = 0x20;
28459                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
28460 8329           B0                     20  mov	al,*$20
28461 832B           8846         FE            mov	-2[bp],al
28462                                           !BCC_EOS
28463                                           ! 4245   else
28464                                           ! 4246     dor = 0x10;
28465 832E           EB           05            jmp .5F8
28466                       00008330            .5F6:
28467                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
28468 8330           B0                     10  mov	al,*$10
28469 8332           8846         FE            mov	-2[bp],al
28470                                           !BCC_EOS
28471                                           ! 4247   dor |= 0x0c;
28472                       00008335            .5F8:
28473                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
28474 8335           8A46         FE            mov	al,-2[bp]
28475 8338           0C                     0C  or	al,*$C
28476 833A           8846         FE            mov	-2[bp],al
28477                                           !BCC_EOS
28478                                           ! 4248   dor |= drive;
28479                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
28480 833D           8B46         04            mov	ax,4[bp]
28481 8340           0A46         FE            or	al,-2[bp]
28482 8343           8846         FE            mov	-2[bp],al
28483                                           !BCC_EOS
28484                                           ! 4249   outb(
28485                                           ! 4249 0x03f2, dor);
28486                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
28487 8346           8A46         FE            mov	al,-2[bp]
28488 8349           30E4                       xor	ah,ah
28489 834B           50                         push	ax
28490                                           ! Debug: list int = const $3F2 (used reg = )
28491 834C           B8                   03F2  mov	ax,#$3F2
28492 834F           50                         push	ax
28493                                           ! Debug: func () void = outb+0 (used reg = )
28494 8350           E8         820B            call	_outb
28495 8353           83C4                   04  add	sp,*4
28496                                           !BCC_EOS
28497                                           ! 4250   write_byte(0x40,0x40, 37);
28498                                           ! Debug: list int = const $25 (used reg = )
28499 8356           B8                   0025  mov	ax,*$25
28500 8359           50                         push	ax
28501                                           ! Debug: list int = const $40 (used reg = )
28502 835A           B8                   0040  mov	ax,*$40
28503 835D           50                         push	ax
28504                                           ! Debug: list int = const $40 (used reg = )
28505 835E           B8                   0040  mov	ax,*$40
28506 8361           50                         push	ax
28507                                           ! Debug: func () void = write_byte+0 (used reg = )
28508 8362           E8         82BF            call	_write_byte
28509 8365           83C4                   06  add	sp,*6
28510                                           !BCC_EOS
28511                                           ! 4251   val8 = inb(0x3f4);
28512                                           ! Debug: list int = const $3F4 (used reg = )
28513 8368           B8                   03F4  mov	ax,#$3F4
28514 836B           50                         push	ax
28515                                           ! Debug: func () unsigned char = inb+0 (used reg = )
28516 836C           E8         81D9            call	_inb
28517 836F           44                         inc	sp
28518 8370           44                         inc	sp
28519                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
28520 8371           8846         FF            mov	-1[bp],al
28521                                           !BCC_EOS
28522                                           ! 4252   if ( (val8 & 0xf0) != 0x80 )
28523                                           ! Debug: and int = const $F0 to unsigned char val8 = [S+6-3] (used reg = )
28524 8374           8A46         FF            mov	al,-1[bp]
28525 8377           24                     F0  and	al,#$F0
28526                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
28527 8379           3C                     80  cmp	al,#$80
28528 837B           74           0E            je  	.5F9
28529                       0000837D            .5FA:
28530                                           ! 4253     bios_printf((2 | 4 | 1), "floppy recal:f07: ctrl not ready\n");
28531                                           ! Debug: list * char = .5FB+0 (used reg = )
28532 837D           BB                   D1FB  mov	bx,#.5FB
28533 8380           53                         push	bx
28534                                           ! Debug: list int = const 7 (used reg = )
28535 8381           B8                   0007  mov	ax,*7
28536 8384           50                         push	ax
28537                                           ! Debug: func () void = bios_printf+0 (used reg = )
28538 8385           E8         8521            call	_bios_printf
28539 8388           83C4                   04  add	sp,*4
28540                                           !BCC_EOS
28541                                           ! 4254   outb(0x03f5, 0x07);
28542                       0000838B            .5F9:
28543                                           ! Debug: list int = const 7 (used reg = )
28544 838B           B8                   0007  mov	ax,*7
28545 838E           50                         push	ax
28546                                           ! Debug: list int = const $3F5 (used reg = )
28547 838F           B8                   03F5  mov	ax,#$3F5
28548 8392           50                         push	ax
28549                                           ! Debug: func () void = outb+0 (used reg = )
28550 8393           E8         81C8            call	_outb
28551 8396           83C4                   04  add	sp,*4
28552                                           !BCC_EOS
28553                                           ! 4255   outb(0x03f5, drive);
28554                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
28555 8399           FF76         04            push	4[bp]
28556                                           ! Debug: list int = const $3F5 (used reg = )
28557 839C           B8                   03F5  mov	ax,#$3F5
28558 839F           50                         push	ax
28559                                           ! Debug: func () void = outb+0 (used reg = )
28560 83A0           E8         81BB            call	_outb
28561 83A3           83C4                   04  add	sp,*4
28562                                           !BCC_EOS
28563                                           ! 4256 #asm
28564                                           !BCC_EOS
28565                                           !BCC_ASM
28566                       00000002            _floppy_drive_recal.dor	set	2
28567                       FFFFFFFE            .floppy_drive_recal.dor	set	-2
28568                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
28569                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
28570                       00000003            _floppy_drive_recal.val8	set	3
28571                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
28572                       00000008            _floppy_drive_recal.drive	set	8
28573                       00000004            .floppy_drive_recal.drive	set	4
28574 83A6           FB                           sti
28575                                           ! 4258 endasm
28576                                           !BCC_ENDASM
28577                                           !BCC_EOS
28578                                           ! 4259   val8 = (read_byte(0x0000, 0x043e) & 0x80);
28579                                           ! Debug: list int = const $43E (used reg = )
28580 83A7           B8                   043E  mov	ax,#$43E
28581 83AA           50                         push	ax
28582                                           ! Debug: list int = const 0 (used reg = )
28583 83AB           31C0                       xor	ax,ax
28584 83AD           50                         push	ax
28585                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28586 83AE           E8         824D            call	_read_byte
28587 83B1           83C4                   04  add	sp,*4
28588                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
28589 83B4           24                     80  and	al,#$80
28590                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
28591 83B6           8846         FF            mov	-1[bp],al
28592                                           !BCC_EOS
28593                                           ! 4260   while ( val8 == 0 ) {
28594 83B9           EB           12            jmp .5FD
28595                       000083BB            .5FE:
28596                                           ! 4261     val8 = (read_byte(0x0000, 0x043e) & 0x80);
28597                                           ! Debug: list int = const $43E (used reg = )
28598 83BB           B8                   043E  mov	ax,#$43E
28599 83BE           50                         push	ax
28600                                           ! Debug: list int = const 0 (used reg = )
28601 83BF           31C0                       xor	ax,ax
28602 83C1           50                         push	ax
28603                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28604 83C2           E8         8239            call	_read_byte
28605 83C5           83C4                   04  add	sp,*4
28606                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
28607 83C8           24                     80  and	al,#$80
28608                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
28609 83CA           8846         FF            mov	-1[bp],al
28610                                           !BCC_EOS
28611                                           ! 4262     }
28612                                           ! 4263  val8 = 0;
28613                       000083CD            .5FD:
28614                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
28615 83CD           8A46         FF            mov	al,-1[bp]
28616 83D0           84C0                       test	al,al
28617 83D2           74           E7            je 	.5FE
28618                       000083D4            .5FF:
28619                       000083D4            .5FC:
28620                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
28621 83D4           30C0                       xor	al,al
28622 83D6           8846         FF            mov	-1[bp],al
28623                                           !BCC_EOS
28624                                           ! 4264 #asm
28625                                           !BCC_EOS
28626                                           !BCC_ASM
28627                       00000002            _floppy_drive_recal.dor	set	2
28628                       FFFFFFFE            .floppy_drive_recal.dor	set	-2
28629                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
28630                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
28631                       00000003            _floppy_drive_recal.val8	set	3
28632                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
28633                       00000008            _floppy_drive_recal.drive	set	8
28634                       00000004            .floppy_drive_recal.drive	set	4
28635 83D9           FA                           cli
28636                                           ! 4266 endasm
28637                                           !BCC_ENDASM
28638                                           !BCC_EOS
28639                                           ! 4267   val8 = read_byte(0x0000, 0x043e);
28640                                           ! Debug: list int = const $43E (used reg = )
28641 83DA           B8                   043E  mov	ax,#$43E
28642 83DD           50                         push	ax
28643                                           ! Debug: list int = const 0 (used reg = )
28644 83DE           31C0                       xor	ax,ax
28645 83E0           50                         push	ax
28646                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28647 83E1           E8         821A            call	_read_byte
28648 83E4           83C4                   04  add	sp,*4
28649                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
28650 83E7           8846         FF            mov	-1[bp],al
28651                                           !BCC_EOS
28652                                           ! 4268   val8 &= 0x7f;
28653                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
28654 83EA           8A46         FF            mov	al,-1[bp]
28655 83ED           24                     7F  and	al,*$7F
28656 83EF           8846         FF            mov	-1[bp],al
28657                                           !BCC_EOS
28658                                           ! 4269   if (drive) {
28659 83F2           8B46         04            mov	ax,4[bp]
28660 83F5           85C0                       test	ax,ax
28661 83F7           74           10            je  	.600
28662                       000083F9            .601:
28663                                           ! 4270     val8 |= 0x02;
28664                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
28665 83F9           8A46         FF            mov	al,-1[bp]
28666 83FC           0C                     02  or	al,*2
28667 83FE           8846         FF            mov	-1[bp],al
28668                                           !BCC_EOS
28669                                           ! 4271     curr_cyl_offset = 0x0095;
28670                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
28671 8401           B8                   0095  mov	ax,#$95
28672 8404           8946         FC            mov	-4[bp],ax
28673                                           !BCC_EOS
28674                                           ! 4272     }
28675                                           ! 4273   else {
28676 8407           EB           0E            jmp .602
28677                       00008409            .600:
28678                                           ! 4274     val8 |= 0x01;
28679                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
28680 8409           8A46         FF            mov	al,-1[bp]
28681 840C           0C                     01  or	al,*1
28682 840E           8846         FF            mov	-1[bp],al
28683                                           !BCC_EOS
28684                                           ! 4275     curr_cyl_offset = 0x0094;
28685                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
28686 8411           B8                   0094  mov	ax,#$94
28687 8414           8946         FC            mov	-4[bp],ax
28688                                           !BCC_EOS
28689                                           ! 4276     }
28690                                           ! 4277   write_byte(0x0040, 0x003e, val8);
28691                       00008417            .602:
28692                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
28693 8417           8A46         FF            mov	al,-1[bp]
28694 841A           30E4                       xor	ah,ah
28695 841C           50                         push	ax
28696                                           ! Debug: list int = const $3E (used reg = )
28697 841D           B8                   003E  mov	ax,*$3E
28698 8420           50                         push	ax
28699                                           ! Debug: list int = const $40 (used reg = )
28700 8421           B8                   0040  mov	ax,*$40
28701 8424           50                         push	ax
28702                                           ! Debug: func () void = write_byte+0 (used reg = )
28703 8425           E8         81FC            call	_write_byte
28704 8428           83C4                   06  add	sp,*6
28705                                           !BCC_EOS
28706                                           ! 4278   write_byte(0x0040, curr_cyl_offset, 0);
28707                                           ! Debug: list int = const 0 (used reg = )
28708 842B           31C0                       xor	ax,ax
28709 842D           50                         push	ax
28710                                           ! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
28711 842E           FF76         FC            push	-4[bp]
28712                                           ! Debug: list int = const $40 (used reg = )
28713 8431           B8                   0040  mov	ax,*$40
28714 8434           50                         push	ax
28715                                           ! Debug: func () void = write_byte+0 (used reg = )
28716 8435           E8         81EC            call	_write_byte
28717 8438           83C4                   06  add	sp,*6
28718                                           !BCC_EOS
28719                                           ! 4279   return(1);
28720 843B           B8                   0001  mov	ax,*1
28721 843E           89EC                       mov	sp,bp
28722 8440           5D                         pop	bp
28723 8441           C3                         ret
28724                                           !BCC_EOS
28725                                           ! 4280 }
28726                                           ! 4281   bx_bool
28727                                           ! Register BX used in function floppy_drive_recal
28728                                           ! 4282 floppy_drive_exists(drive)
28729                                           ! 4283   Bit16u drive;
28730                                           export	_floppy_drive_exists
28731                       00008442            _floppy_drive_exists:
28732                                           !BCC_EOS
28733                                           ! 4284 {
28734                                           ! 4285   Bit8u drive_type;
28735                                           !BCC_EOS
28736                                           ! 4286   drive_type = inb_cmos(0x10);
28737 8442           55                         push	bp
28738 8443           89E5                       mov	bp,sp
28739 8445           4C                         dec	sp
28740 8446           4C                         dec	sp
28741                                           ! Debug: list int = const $10 (used reg = )
28742 8447           B8                   0010  mov	ax,*$10
28743 844A           50                         push	ax
28744                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
28745 844B           E8         813F            call	_inb_cmos
28746 844E           44                         inc	sp
28747 844F           44                         inc	sp
28748                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
28749 8450           8846         FF            mov	-1[bp],al
28750                                           !BCC_EOS
28751                                           ! 4287   if (drive == 0)
28752                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
28753 8453           8B46         04            mov	ax,4[bp]
28754 8456           85C0                       test	ax,ax
28755 8458           75           0E            jne 	.603
28756                       0000845A            .604:
28757                                           ! 4288     drive_type >>= 4;
28758                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
28759 845A           8A46         FF            mov	al,-1[bp]
28760 845D           30E4                       xor	ah,ah
28761 845F           B1                     04  mov	cl,*4
28762 8461           D3E8                       shr	ax,cl
28763 8463           8846         FF            mov	-1[bp],al
28764                                           !BCC_EOS
28765                                           ! 4289   else
28766                                           ! 4290     drive_type &= 0x0f;
28767 8466           EB           08            jmp .605
28768                       00008468            .603:
28769                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
28770 8468           8A46         FF            mov	al,-1[bp]
28771 846B           24                     0F  and	al,*$F
28772 846D           8846         FF            mov	-1[bp],al
28773                                           !BCC_EOS
28774                                           ! 4291   if ( drive_type == 0 )
28775                       00008470            .605:
28776                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
28777 8470           8A46         FF            mov	al,-1[bp]
28778 8473           84C0                       test	al,al
28779 8475           75           08            jne 	.606
28780                       00008477            .607:
28781                                           ! 4292     return(0);
28782 8477           31C0                       xor	ax,ax
28783 8479           89EC                       mov	sp,bp
28784 847B           5D                         pop	bp
28785 847C           C3                         ret
28786                                           !BCC_EOS
28787                                           ! 4293   else
28788                                           ! 4294     return(1);
28789 847D           EB           07            jmp .608
28790                       0000847F            .606:
28791 847F           B8                   0001  mov	ax,*1
28792 8482           89EC                       mov	sp,bp
28793 8484           5D                         pop	bp
28794 8485           C3                         ret
28795                                           !BCC_EOS
28796                                           ! 4295 }
28797                       00008486            .608:
28798 8486           89EC                       mov	sp,bp
28799 8488           5D                         pop	bp
28800 8489           C3                         ret
28801                                           ! 4296   void
28802                                           ! 4297 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
28803                                           ! 4298   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
28804                                           export	_int13_diskette_function
28805                       0000848A            _int13_diskette_function:
28806                                           !BCC_EOS
28807                                           ! 4299 {
28808                                           ! 4300   Bit8u drive, num_sectors, track, sector, head, status;
28809                                           !BCC_EOS
28810                                           ! 4301   Bit16u base_address, base_count, base_es;
28811                                           !BCC_EOS
28812                                           ! 4302   Bit8u page, mode_register, val8, dor;
28813                                           !BCC_EOS
28814                                           ! 4303   Bit8u return_status[7];
28815                                           !BCC_EOS
28816                                           ! 4304   Bit8u drive_type, num_floppies, ah;
28817                                           !BCC_EOS
28818                                           ! 4305   Bit16u es, last_addr;
28819                                           !BCC_EOS
28820                                           ! 4306   ;
28821 848A           55                         push	bp
28822 848B           89E5                       mov	bp,sp
28823 848D           83C4                   E2  add	sp,*-$1E
28824                                           !BCC_EOS
28825                                           ! 4307   ah = ( AX >> 8 );
28826                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
28827 8490           8B46         16            mov	ax,$16[bp]
28828 8493           88E0                       mov	al,ah
28829 8495           30E4                       xor	ah,ah
28830                                           ! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
28831 8497           8846         E6            mov	-$1A[bp],al
28832                                           !BCC_EOS
28833                                           ! 4308   switch ( ah ) {
28834 849A           8A46         E6            mov	al,-$1A[bp]
28835 849D           E9         11C2            br 	.60B
28836                                           ! 4309     case 0x00:
28837                                           ! 4310 ;
28838                       000084A0            .60C:
28839                                           !BCC_EOS
28840                                           ! 4311       drive = ( ELDX & 0x00ff );
28841                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
28842 84A0           8A46         0E            mov	al,$E[bp]
28843                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
28844 84A3           8846         FF            mov	-1[bp],al
28845                                           !BCC_EOS
28846                                           ! 4312       if (drive > 1) {
28847                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
28848 84A6           8A46         FF            mov	al,-1[bp]
28849 84A9           3C                     01  cmp	al,*1
28850 84AB           76           20            jbe 	.60D
28851                       000084AD            .60E:
28852                                           ! 4313         AX = ((AX & 0x00ff) | ((1) << 8));
28853                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
28854 84AD           8A46         16            mov	al,$16[bp]
28855                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
28856 84B0           30E4                       xor	ah,ah
28857 84B2           0D                   0100  or	ax,#$100
28858                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
28859 84B5           8946         16            mov	$16[bp],ax
28860                                           !BCC_EOS
28861                                           ! 4314         set_diskette_ret_status(1);
28862                                           ! Debug: list int = const 1 (used reg = )
28863 84B8           B8                   0001  mov	ax,*1
28864 84BB           50                         push	ax
28865                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28866 84BC           E8         11E6            call	_set_diskette_ret_status
28867 84BF           44                         inc	sp
28868 84C0           44                         inc	sp
28869                                           !BCC_EOS
28870                                           ! 4315         FLAGS |= 0x0001;
28871                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
28872 84C1           8B46         1C            mov	ax,$1C[bp]
28873 84C4           0C                     01  or	al,*1
28874 84C6           8946         1C            mov	$1C[bp],ax
28875                                           !BCC_EOS
28876                                           ! 4316         return;
28877 84C9           89EC                       mov	sp,bp
28878 84CB           5D                         pop	bp
28879 84CC           C3                         ret
28880                                           !BCC_EOS
28881                                           ! 4317         }
28882                                           ! 4318       drive_type = inb_cmos(0x10);
28883                       000084CD            .60D:
28884                                           ! Debug: list int = const $10 (used reg = )
28885 84CD           B8                   0010  mov	ax,*$10
28886 84D0           50                         push	ax
28887                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
28888 84D1           E8         80B9            call	_inb_cmos
28889 84D4           44                         inc	sp
28890 84D5           44                         inc	sp
28891                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
28892 84D6           8846         E8            mov	-$18[bp],al
28893                                           !BCC_EOS
28894                                           ! 4319       if (drive == 0)
28895                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
28896 84D9           8A46         FF            mov	al,-1[bp]
28897 84DC           84C0                       test	al,al
28898 84DE           75           0E            jne 	.60F
28899                       000084E0            .610:
28900                                           ! 4320         drive_type >>= 4;
28901                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
28902 84E0           8A46         E8            mov	al,-$18[bp]
28903 84E3           30E4                       xor	ah,ah
28904 84E5           B1                     04  mov	cl,*4
28905 84E7           D3E8                       shr	ax,cl
28906 84E9           8846         E8            mov	-$18[bp],al
28907                                           !BCC_EOS
28908                                           ! 4321       else
28909                                           ! 4322         drive_type &= 0x0f;
28910 84EC           EB           08            jmp .611
28911                       000084EE            .60F:
28912                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
28913 84EE           8A46         E8            mov	al,-$18[bp]
28914 84F1           24                     0F  and	al,*$F
28915 84F3           8846         E8            mov	-$18[bp],al
28916                                           !BCC_EOS
28917                                           ! 4323       if (drive_type == 0) {
28918                       000084F6            .611:
28919                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
28920 84F6           8A46         E8            mov	al,-$18[bp]
28921 84F9           84C0                       test	al,al
28922 84FB           75           20            jne 	.612
28923                       000084FD            .613:
28924                                           ! 4324         AX = ((AX & 0x00ff) | ((0x80) << 8));
28925                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
28926 84FD           8A46         16            mov	al,$16[bp]
28927                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
28928 8500           30E4                       xor	ah,ah
28929 8502           0D                   8000  or	ax,#-$8000
28930                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
28931 8505           8946         16            mov	$16[bp],ax
28932                                           !BCC_EOS
28933                                           ! 4325         set_diskette_ret_status(0x80);
28934                                           ! Debug: list int = const $80 (used reg = )
28935 8508           B8                   0080  mov	ax,#$80
28936 850B           50                         push	ax
28937                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28938 850C           E8         1196            call	_set_diskette_ret_status
28939 850F           44                         inc	sp
28940 8510           44                         inc	sp
28941                                           !BCC_EOS
28942                                           ! 4326         FLAGS |= 0x0001;
28943                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
28944 8511           8B46         1C            mov	ax,$1C[bp]
28945 8514           0C                     01  or	al,*1
28946 8516           8946         1C            mov	$1C[bp],ax
28947                                           !BCC_EOS
28948                                           ! 4327         return;
28949 8519           89EC                       mov	sp,bp
28950 851B           5D                         pop	bp
28951 851C           C3                         ret
28952                                           !BCC_EOS
28953                                           ! 4328         }
28954                                           ! 4329       AX = ((AX & 0x00ff) | ((0) << 8));
28955                       0000851D            .612:
28956                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
28957 851D           8A46         16            mov	al,$16[bp]
28958                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
28959 8520           0C                     00  or	al,*0
28960                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
28961 8522           30E4                       xor	ah,ah
28962 8524           8946         16            mov	$16[bp],ax
28963                                           !BCC_EOS
28964                                           ! 4330       set_diskette_ret_status(0);
28965                                           ! Debug: list int = const 0 (used reg = )
28966 8527           31C0                       xor	ax,ax
28967 8529           50                         push	ax
28968                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
28969 852A           E8         1178            call	_set_diskette_ret_status
28970 852D           44                         inc	sp
28971 852E           44                         inc	sp
28972                                           !BCC_EOS
28973                                           ! 4331       FLAGS &= 0xfffe;
28974                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
28975 852F           8B46         1C            mov	ax,$1C[bp]
28976 8532           24                     FE  and	al,#$FE
28977 8534           8946         1C            mov	$1C[bp],ax
28978                                           !BCC_EOS
28979                                           ! 4332       set_diskette_current_cyl(drive, 0);
28980                                           ! Debug: list int = const 0 (used reg = )
28981 8537           31C0                       xor	ax,ax
28982 8539           50                         push	ax
28983                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
28984 853A           8A46         FF            mov	al,-1[bp]
28985 853D           30E4                       xor	ah,ah
28986 853F           50                         push	ax
28987                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
28988 8540           E8         117A            call	_set_diskette_current_cyl
28989 8543           83C4                   04  add	sp,*4
28990                                           !BCC_EOS
28991                                           ! 4333       return;
28992 8546           89EC                       mov	sp,bp
28993 8548           5D                         pop	bp
28994 8549           C3                         ret
28995                                           !BCC_EOS
28996                                           ! 4334     case 0x01:
28997                                           ! 4335       FLAGS &= 0xfffe;
28998                       0000854A            .614:
28999                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
29000 854A           8B46         1C            mov	ax,$1C[bp]
29001 854D           24                     FE  and	al,#$FE
29002 854F           8946         1C            mov	$1C[bp],ax
29003                                           !BCC_EOS
29004                                           ! 4336       val8 = read_byte(0x0000, 0x0441);
29005                                           ! Debug: list int = const $441 (used reg = )
29006 8552           B8                   0441  mov	ax,#$441
29007 8555           50                         push	ax
29008                                           ! Debug: list int = const 0 (used reg = )
29009 8556           31C0                       xor	ax,ax
29010 8558           50                         push	ax
29011                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29012 8559           E8         80A2            call	_read_byte
29013 855C           83C4                   04  add	sp,*4
29014                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
29015 855F           8846         F1            mov	-$F[bp],al
29016                                           !BCC_EOS
29017                                           ! 4337   
29018                                           ! 4337     AX = ((AX & 0x00ff) | ((val8) << 8));
29019                                           ! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
29020 8562           8A46         F1            mov	al,-$F[bp]
29021 8565           30E4                       xor	ah,ah
29022 8567           88C4                       mov	ah,al
29023 8569           30C0                       xor	al,al
29024 856B           50                         push	ax
29025                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
29026 856C           8A46         16            mov	al,$16[bp]
29027                                           ! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
29028 856F           30E4                       xor	ah,ah
29029 8571           0B46         E0            or	ax,0+..FFDB[bp]
29030 8574           44                         inc	sp
29031 8575           44                         inc	sp
29032                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
29033 8576           8946         16            mov	$16[bp],ax
29034                                           !BCC_EOS
29035                                           ! 4338       if (val8) {
29036 8579           8A46         F1            mov	al,-$F[bp]
29037 857C           84C0                       test	al,al
29038 857E           74           08            je  	.615
29039                       00008580            .616:
29040                                           ! 4339         FLAGS |= 0x0001;
29041                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
29042 8580           8B46         1C            mov	ax,$1C[bp]
29043 8583           0C                     01  or	al,*1
29044 8585           8946         1C            mov	$1C[bp],ax
29045                                           !BCC_EOS
29046                                           ! 4340         }
29047                                           ! 4341       return;
29048                       00008588            .615:
29049 8588           89EC                       mov	sp,bp
29050 858A           5D                         pop	bp
29051 858B           C3                         ret
29052                                           !BCC_EOS
29053                                           ! 4342     case 0x02:
29054                                           ! 4343     case 0x03:
29055                       0000858C            .617:
29056                                           ! 4344     case 0x04:
29057                       0000858C            .618:
29058                                           ! 4345       num_sectors = ( AX & 0x00ff );
29059                       0000858C            .619:
29060                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
29061 858C           8A46         16            mov	al,$16[bp]
29062                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
29063 858F           8846         FE            mov	-2[bp],al
29064                                           !BCC_EOS
29065                                           ! 4346       track = ( CX >> 8 );
29066                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
29067 8592           8B46         14            mov	ax,$14[bp]
29068 8595           88E0                       mov	al,ah
29069 8597           30E4                       xor	ah,ah
29070                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
29071 8599           8846         FD            mov	-3[bp],al
29072                                           !BCC_EOS
29073                                           ! 4347       sector = ( CX & 0x00ff );
29074                                           ! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
29075 859C           8A46         14            mov	al,$14[bp]
29076                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
29077 859F           8846         FC            mov	-4[bp],al
29078                                           !BCC_EOS
29079                                           ! 4348       head = ( DX >> 8 );
29080                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
29081 85A2           8B46         12            mov	ax,$12[bp]
29082 85A5           88E0                       mov	al,ah
29083 85A7           30E4                       xor	ah,ah
29084                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
29085 85A9           8846         FB            mov	-5[bp],al
29086                                           !BCC_EOS
29087                                           ! 4349       drive = ( ELDX & 0x00ff );
29088                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
29089 85AC           8A46         0E            mov	al,$E[bp]
29090                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
29091 85AF           8846         FF            mov	-1[bp],al
29092                                           !BCC_EOS
29093                                           ! 4350       if ( (drive > 1) || (head > 1) ||
29094                                           ! 4351            (num_sectors == 0) || (num_sectors > 72) ) {
29095                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
29096 85B2           8A46         FF            mov	al,-1[bp]
29097 85B5           3C                     01  cmp	al,*1
29098 85B7           77           15            ja  	.61B
29099                       000085B9            .61E:
29100                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
29101 85B9           8A46         FB            mov	al,-5[bp]
29102 85BC           3C                     01  cmp	al,*1
29103 85BE           77           0E            ja  	.61B
29104                       000085C0            .61D:
29105                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
29106 85C0           8A46         FE            mov	al,-2[bp]
29107 85C3           84C0                       test	al,al
29108 85C5           74           07            je  	.61B
29109                       000085C7            .61C:
29110                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
29111 85C7           8A46         FE            mov	al,-2[bp]
29112 85CA           3C                     48  cmp	al,*$48
29113 85CC           76           38            jbe 	.61A
29114                       000085CE            .61B:
29115                                           ! 4352 bios_printf(4, "floppy: drive>1 || head>1 ...\n");
29116                                           ! Debug: list * char = .61F+0 (used reg = )
29117 85CE           BB                   D1DC  mov	bx,#.61F
29118 85D1           53                         push	bx
29119                                           ! Debug: list int = const 4 (used reg = )
29120 85D2           B8                   0004  mov	ax,*4
29121 85D5           50                         push	ax
29122                                           ! Debug: func () void = bios_printf+0 (used reg = )
29123 85D6           E8         82D0            call	_bios_printf
29124 85D9           83C4                   04  add	sp,*4
29125                                           !BCC_EOS
29126                                           ! 4353         AX = ((AX & 0x00ff) | ((1) << 8));
29127                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
29128 85DC           8A46         16            mov	al,$16[bp]
29129                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
29130 85DF           30E4                       xor	ah,ah
29131 85E1           0D                   0100  or	ax,#$100
29132                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
29133 85E4           8946         16            mov	$16[bp],ax
29134                                           !BCC_EOS
29135                                           ! 4354         set_diskette_ret_status(1);
29136                                           ! Debug: list int = const 1 (used reg = )
29137 85E7           B8                   0001  mov	ax,*1
29138 85EA           50                         push	ax
29139                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29140 85EB           E8         10B7            call	_set_diskette_ret_status
29141 85EE           44                         inc	sp
29142 85EF           44                         inc	sp
29143                                           !BCC_EOS
29144                                           ! 4355         AX = ((AX & 0xff00) | (0));
29145                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
29146 85F0           8B46         16            mov	ax,$16[bp]
29147 85F3           30C0                       xor	al,al
29148                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29149 85F5           0C                     00  or	al,*0
29150                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
29151 85F7           8946         16            mov	$16[bp],ax
29152                                           !BCC_EOS
29153                                           ! 4356         FLAGS |= 0x0001;
29154                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
29155 85FA           8B46         1C            mov	ax,$1C[bp]
29156 85FD           0C                     01  or	al,*1
29157 85FF           8946         1C            mov	$1C[bp],ax
29158                                           !BCC_EOS
29159                                           ! 4357         return;
29160 8602           89EC                       mov	sp,bp
29161 8604           5D                         pop	bp
29162 8605           C3                         ret
29163                                           !BCC_EOS
29164                                           ! 4358         }
29165                                           ! 4359       if (floppy_drive_exists(drive) == 0) {
29166                       00008606            .61A:
29167                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
29168 8606           8A46         FF            mov	al,-1[bp]
29169 8609           30E4                       xor	ah,ah
29170 860B           50                         push	ax
29171                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
29172 860C           E8         FE33            call	_floppy_drive_exists
29173 860F           44                         inc	sp
29174 8610           44                         inc	sp
29175                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
29176 8611           85C0                       test	ax,ax
29177 8613           75           2A            jne 	.620
29178                       00008615            .621:
29179                                           ! 4360         AX = ((AX & 0x00ff) | ((0x80) << 8));
29180                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
29181 8615           8A46         16            mov	al,$16[bp]
29182                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
29183 8618           30E4                       xor	ah,ah
29184 861A           0D                   8000  or	ax,#-$8000
29185                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
29186 861D           8946         16            mov	$16[bp],ax
29187                                           !BCC_EOS
29188                                           ! 4361         set_diskette_ret_status(0x80);
29189                                           ! Debug: list int = const $80 (used reg = )
29190 8620           B8                   0080  mov	ax,#$80
29191 8623           50                         push	ax
29192                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29193 8624           E8         107E            call	_set_diskette_ret_status
29194 8627           44                         inc	sp
29195 8628           44                         inc	sp
29196                                           !BCC_EOS
29197                                           ! 4362         AX = ((AX & 0xff00) | (0));
29198                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
29199 8629           8B46         16            mov	ax,$16[bp]
29200 862C           30C0                       xor	al,al
29201                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29202 862E           0C                     00  or	al,*0
29203                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
29204 8630           8946         16            mov	$16[bp],ax
29205                                           !BCC_EOS
29206                                           ! 4363         FLAGS |= 0x0001;
29207                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
29208 8633           8B46         1C            mov	ax,$1C[bp]
29209 8636           0C                     01  or	al,*1
29210 8638           8946         1C            mov	$1C[bp],ax
29211                                           !BCC_EOS
29212                                           ! 4364         return;
29213 863B           89EC                       mov	sp,bp
29214 863D           5D                         pop	bp
29215 863E           C3                         ret
29216                                           !BCC_EOS
29217                                           ! 4365         }
29218                                           ! 4366       if (floppy_media_known(drive) == 0) {
29219                       0000863F            .620:
29220                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
29221 863F           8A46         FF            mov	al,-1[bp]
29222 8642           30E4                       xor	ah,ah
29223 8644           50                         push	ax
29224                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
29225 8645           E8         FAC6            call	_floppy_media_known
29226 8648           44                         inc	sp
29227 8649           44                         inc	sp
29228                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
29229 864A           85C0                       test	ax,ax
29230 864C           75           39            jne 	.622
29231                       0000864E            .623:
29232                                           ! 4367         if (floppy_media_sense(drive) == 0) {
29233                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
29234 864E           8A46         FF            mov	al,-1[bp]
29235 8651           30E4                       xor	ah,ah
29236 8653           50                         push	ax
29237                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
29238 8654           E8         FB3A            call	_floppy_media_sense
29239 8657           44                         inc	sp
29240 8658           44                         inc	sp
29241                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
29242 8659           85C0                       test	ax,ax
29243 865B           75           2A            jne 	.624
29244                       0000865D            .625:
29245                                           ! 4368           AX = ((AX & 0x00ff) | ((0x0C) << 8));
29246                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
29247 865D           8A46         16            mov	al,$16[bp]
29248                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
29249 8660           30E4                       xor	ah,ah
29250 8662           0D                   0C00  or	ax,#$C00
29251                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
29252 8665           8946         16            mov	$16[bp],ax
29253                                           !BCC_EOS
29254                                           ! 4369           set_diskette_ret_status(0x0C);
29255                                           ! Debug: list int = const $C (used reg = )
29256 8668           B8                   000C  mov	ax,*$C
29257 866B           50                         push	ax
29258                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29259 866C           E8         1036            call	_set_diskette_ret_status
29260 866F           44                         inc	sp
29261 8670           44                         inc	sp
29262                                           !BCC_EOS
29263                                           ! 4370           AX = ((AX & 0xff00) | (0));
29264                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
29265 8671           8B46         16            mov	ax,$16[bp]
29266 8674           30C0                       xor	al,al
29267                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29268 8676           0C                     00  or	al,*0
29269                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
29270 8678           8946         16            mov	$16[bp],ax
29271                                           !BCC_EOS
29272                                           ! 4371           FLAGS |= 0x0001;
29273                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
29274 867B           8B46         1C            mov	ax,$1C[bp]
29275 867E           0C                     01  or	al,*1
29276 8680           8946         1C            mov	$1C[bp],ax
29277                                           !BCC_EOS
29278                                           ! 4372           return;
29279 8683           89EC                       mov	sp,bp
29280 8685           5D                         pop	bp
29281 8686           C3                         ret
29282                                           !BCC_EOS
29283                                           ! 4373           }
29284                                           ! 4374         }
29285                       00008687            .624:
29286                                           ! 4375       if (ah == 0x02) {
29287                       00008687            .622:
29288                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
29289 8687           8A46         E6            mov	al,-$1A[bp]
29290 868A           3C                     02  cmp	al,*2
29291 868C         0F85         0409            bne 	.626
29292                       00008690            .627:
29293                                           ! 4376         page = (ES >> 12);
29294                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
29295 8690           8B46         06            mov	ax,6[bp]
29296 8693           88E0                       mov	al,ah
29297 8695           30E4                       xor	ah,ah
29298 8697           B1                     04  mov	cl,*4
29299 8699           D3E8                       shr	ax,cl
29300                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
29301 869B           8846         F3            mov	-$D[bp],al
29302                                           !BCC_EOS
29303                                           ! 4377         base_es = (ES << 4);
29304                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
29305 869E           8B46         06            mov	ax,6[bp]
29306 86A1           B1                     04  mov	cl,*4
29307 86A3           D3E0                       shl	ax,cl
29308                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
29309 86A5           8946         F4            mov	-$C[bp],ax
29310                                           !BCC_EOS
29311                                           ! 4378         base_address = base_es + BX;
29312                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
29313 86A8           8B46         F4            mov	ax,-$C[bp]
29314 86AB           0346         10            add	ax,$10[bp]
29315                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
29316 86AE           8946         F8            mov	-8[bp],ax
29317                                           !BCC_EOS
29318                                           ! 4379         if ( base_address < base_es ) {
29319                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
29320 86B1           8B46         F8            mov	ax,-8[bp]
29321 86B4           3B46         F4            cmp	ax,-$C[bp]
29322 86B7           73           07            jae 	.628
29323                       000086B9            .629:
29324                                           ! 4380           page++;
29325                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
29326 86B9           8A46         F3            mov	al,-$D[bp]
29327 86BC           40                         inc	ax
29328 86BD           8846         F3            mov	-$D[bp],al
29329                                           !BCC_EOS
29330                                           ! 4381           }
29331                                           ! 4382         base_count = (num_sectors * 512) - 1;
29332                       000086C0            .628:
29333                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
29334 86C0           8A46         FE            mov	al,-2[bp]
29335 86C3           30E4                       xor	ah,ah
29336 86C5           B9                   0200  mov	cx,#$200
29337 86C8           F7E9                       imul	cx
29338                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
29339                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
29340 86CA           48                         dec	ax
29341 86CB           8946         F6            mov	-$A[bp],ax
29342                                           !BCC_EOS
29343                                           ! 4383         last_addr = base_address + base_count;
29344                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
29345 86CE           8B46         F8            mov	ax,-8[bp]
29346 86D1           0346         F6            add	ax,-$A[bp]
29347                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
29348 86D4           8946         E2            mov	-$1E[bp],ax
29349                                           !BCC_EOS
29350                                           ! 4384         if (last_addr < base_address) {
29351                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
29352 86D7           8B46         E2            mov	ax,-$1E[bp]
29353 86DA           3B46         F8            cmp	ax,-8[bp]
29354 86DD           73           2A            jae 	.62A
29355                       000086DF            .62B:
29356                                           ! 4385           AX = ((AX & 0x00ff) | ((0x09) << 8));
29357                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
29358 86DF           8A46         16            mov	al,$16[bp]
29359                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
29360 86E2           30E4                       xor	ah,ah
29361 86E4           0D                   0900  or	ax,#$900
29362                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
29363 86E7           8946         16            mov	$16[bp],ax
29364                                           !BCC_EOS
29365                                           ! 4386           set_diskette_ret_status(0x09);
29366                                           ! Debug: list int = const 9 (used reg = )
29367 86EA           B8                   0009  mov	ax,*9
29368 86ED           50                         push	ax
29369                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
29370 86EE           E8         0FB4            call	_set_diskette_ret_status
29371 86F1           44                         inc	sp
29372 86F2           44                         inc	sp
29373                                           !BCC_EOS
29374                                           ! 4387           AX = ((AX & 0xff00) | (0));
29375                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
29376 86F3           8B46         16            mov	ax,$16[bp]
29377 86F6           30C0                       xor	al,al
29378                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29379 86F8           0C                     00  or	al,*0
29380                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
29381 86FA           8946         16            mov	$16[bp],ax
29382                                           !BCC_EOS
29383                                           ! 4388           FLAGS |= 0x0001;
29384                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
29385 86FD           8B46         1C            mov	ax,$1C[bp]
29386 8700           0C                     01  or	al,*1
29387 8702           8946         1C            mov	$1C[bp],ax
29388                                           !BCC_EOS
29389                                           ! 4389           return;
29390 8705           89EC                       mov	sp,bp
29391 8707           5D                         pop	bp
29392 8708           C3                         ret
29393                                           !BCC_EOS
29394                                           ! 4390           }
29395                                           ! 4391         ;
29396                       00008709            .62A:
29397                                           !BCC_EOS
29398                                           ! 4392         outb(0x000a, 0x06);
29399                                           ! Debug: list int = const 6 (used reg = )
29400 8709           B8                   0006  mov	ax,*6
29401 870C           50                         push	ax
29402                                           ! Debug: list int = const $A (used reg = )
29403 870D           B8                   000A  mov	ax,*$A
29404 8710           50                         push	ax
29405                                           ! Debug: func () void = outb+0 (used reg = )
29406 8711           E8         7E4A            call	_outb
29407 8714           83C4                   04  add	sp,*4
29408                                           !BCC_EOS
29409                                           ! 4393   ;
29410                                           !BCC_EOS
29411                                           ! 4394         outb(0x000c, 0x00);
29412                                           ! Debug: list int = const 0 (used reg = )
29413 8717           31C0                       xor	ax,ax
29414 8719           50                         push	ax
29415                                           ! Debug: list int = const $C (used reg = )
29416 871A           B8                   000C  mov	ax,*$C
29417 871D           50                         push	ax
29418                                           ! Debug: func () void = outb+0 (used reg = )
29419 871E           E8         7E3D            call	_outb
29420 8721           83C4                   04  add	sp,*4
29421                                           !BCC_EOS
29422                                           ! 4395         outb(0x0004, base_address);
29423                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
29424 8724           FF76         F8            push	-8[bp]
29425                                           ! Debug: list int = const 4 (used reg = )
29426 8727           B8                   0004  mov	ax,*4
29427 872A           50                         push	ax
29428                                           ! Debug: func () void = outb+0 (used reg = )
29429 872B           E8         7E30            call	_outb
29430 872E           83C4                   04  add	sp,*4
29431                                           !BCC_EOS
29432                                           ! 4396         outb(0x0004, base_address>>8);
29433                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
29434 8731           8B46         F8            mov	ax,-8[bp]
29435 8734           88E0                       mov	al,ah
29436 8736           30E4                       xor	ah,ah
29437                                           ! Debug: list unsigned int = ax+0 (used reg = )
29438 8738           50                         push	ax
29439                                           ! Debug: list int = const 4 (used reg = )
29440 8739           B8                   0004  mov	ax,*4
29441 873C           50                         push	ax
29442                                           ! Debug: func () void = outb+0 (used reg = )
29443 873D           E8         7E1E            call	_outb
29444 8740           83C4                   04  add	sp,*4
29445                                           !BCC_EOS
29446                                           ! 4397   ;
29447                                           !BCC_EOS
29448                                           ! 4398         outb(0x000c, 0x00);
29449                                           ! Debug: list int = const 0 (used reg = )
29450 8743           31C0                       xor	ax,ax
29451 8745           50                         push	ax
29452                                           ! Debug: list int = const $C (used reg = )
29453 8746           B8                   000C  mov	ax,*$C
29454 8749           50                         push	ax
29455                                           ! Debug: func () void = outb+0 (used reg = )
29456 874A           E8         7E11            call	_outb
29457 874D           83C4                   04  add	sp,*4
29458                                           !BCC_EOS
29459                                           ! 4399         outb(0x0005, base_count);
29460                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
29461 8750           FF76         F6            push	-$A[bp]
29462                                           ! Debug: list int = const 5 (used reg = )
29463 8753           B8                   0005  mov	ax,*5
29464 8756           50                         push	ax
29465                                           ! Debug: func () void = outb+0 (used reg = )
29466 8757           E8         7E04            call	_outb
29467 875A           83C4                   04  add	sp,*4
29468                                           !BCC_EOS
29469                                           ! 4400         outb(0x0005, base_count>>8);
29470                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
29471 875D           8B46         F6            mov	ax,-$A[bp]
29472 8760           88E0                       mov	al,ah
29473 8762           30E4                       xor	ah,ah
29474                                           ! Debug: list unsigned int = ax+0 (used reg = )
29475 8764           50                         push	ax
29476                                           ! Debug: list int = const 5 (used reg = )
29477 8765           B8                   0005  mov	ax,*5
29478 8768           50                         push	ax
29479                                           ! Debug: func () void = outb+0 (used reg = )
29480 8769           E8         7DF2            call	_outb
29481 876C           83C4                   04  add	sp,*4
29482                                           !BCC_EOS
29483                                           ! 4401         mode_register = 0x46;
29484                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
29485 876F           B0                     46  mov	al,*$46
29486 8771           8846         F2            mov	-$E[bp],al
29487                                           !BCC_EOS
29488                                           ! 4402   ;
29489                                           !BCC_EOS
29490                                           ! 4403         outb(0x000b, mode_register);
29491                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
29492 8774           8A46         F2            mov	al,-$E[bp]
29493 8777           30E4                       xor	ah,ah
29494 8779           50                         push	ax
29495                                           ! Debug: list int = const $B (used reg = )
29496 877A           B8                   000B  mov	ax,*$B
29497 877D           50                         push	ax
29498                                           ! Debug: func () void = outb+0 (used reg = )
29499 877E           E8         7DDD            call	_outb
29500 8781           83C4                   04  add	sp,*4
29501                                           !BCC_EOS
29502                                           ! 4404   ;
29503                                           !BCC_EOS
29504                                           ! 4405         outb(0x0081, page);
29505                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
29506 8784           8A46         F3            mov	al,-$D[bp]
29507 8787           30E4                       xor	ah,ah
29508 8789           50                         push	ax
29509                                           ! Debug: list int = const $81 (used reg = )
29510 878A           B8                   0081  mov	ax,#$81
29511 878D           50                         push	ax
29512                                           ! Debug: func () void = outb+0 (used reg = )
29513 878E           E8         7DCD            call	_outb
29514 8791           83C4                   04  add	sp,*4
29515                                           !BCC_EOS
29516                                           ! 4406   ;
29517                                           !BCC_EOS
29518                                           ! 4407         outb(0x000a, 0x02);
29519                                           ! Debug: list int = const 2 (used reg = )
29520 8794           B8                   0002  mov	ax,*2
29521 8797           50                         push	ax
29522                                           ! Debug: list int = const $A (used reg = )
29523 8798           B8                   000A  mov	ax,*$A
29524 879B           50                         push	ax
29525                                           ! Debug: func () void = outb+0 (used reg = )
29526 879C           E8         7DBF            call	_outb
29527 879F           83C4                   04  add	sp,*4
29528                                           !BCC_EOS
29529                                           ! 4408         ;
29530                                           !BCC_EOS
29531                                           ! 4409         outb(0x000a, 0x02);
29532                                           ! Debug: list int = const 2 (used reg = )
29533 87A2           B8                   0002  mov	ax,*2
29534 87A5           50                         push	ax
29535                                           ! Debug: list int = const $A (used reg = )
29536 87A6           B8                   000A  mov	ax,*$A
29537 87A9           50                         push	ax
29538                                           ! Debug: func () void = outb+0 (used reg = )
29539 87AA           E8         7DB1            call	_outb
29540 87AD           83C4                   04  add	sp,*4
29541                                           !BCC_EOS
29542                                           ! 4410 
29543                                           ! 4410         val8 = read_byte(0x0000, 0x043e);
29544                                           ! Debug: list int = const $43E (used reg = )
29545 87B0           B8                   043E  mov	ax,#$43E
29546 87B3           50                         push	ax
29547                                           ! Debug: list int = const 0 (used reg = )
29548 87B4           31C0                       xor	ax,ax
29549 87B6           50                         push	ax
29550                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29551 87B7           E8         7E44            call	_read_byte
29552 87BA           83C4                   04  add	sp,*4
29553                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
29554 87BD           8846         F1            mov	-$F[bp],al
29555                                           !BCC_EOS
29556                                           ! 4411         val8 &= 0x7f;
29557                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
29558 87C0           8A46         F1            mov	al,-$F[bp]
29559 87C3           24                     7F  and	al,*$7F
29560 87C5           8846         F1            mov	-$F[bp],al
29561                                           !BCC_EOS
29562                                           ! 4412         write_byte(0x0000, 0x043e, val8);
29563                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
29564 87C8           8A46         F1            mov	al,-$F[bp]
29565 87CB           30E4                       xor	ah,ah
29566 87CD           50                         push	ax
29567                                           ! Debug: list int = const $43E (used reg = )
29568 87CE           B8                   043E  mov	ax,#$43E
29569 87D1           50                         push	ax
29570                                           ! Debug: list int = const 0 (used reg = )
29571 87D2           31C0                       xor	ax,ax
29572 87D4           50                         push	ax
29573                                           ! Debug: func () void = write_byte+0 (used reg = )
29574 87D5           E8         7E4C            call	_write_byte
29575 87D8           83C4                   06  add	sp,*6
29576                                           !BCC_EOS
29577                                           ! 4413         if (drive)
29578 87DB           8A46         FF            mov	al,-1[bp]
29579 87DE           84C0                       test	al,al
29580 87E0           74           07            je  	.62C
29581                       000087E2            .62D:
29582                                           ! 4414           dor = 0x20;
29583                                           ! Debug: eq int = const $20 to unsigned char dor = [S+$20-$12] (used reg = )
29584 87E2           B0                     20  mov	al,*$20
29585 87E4           8846         F0            mov	-$10[bp],al
29586                                           !BCC_EOS
29587                                           ! 4415         else
29588                                           ! 4416           dor = 0x10;
29589 87E7           EB           05            jmp .62E
29590                       000087E9            .62C:
29591                                           ! Debug: eq int = const $10 to unsigned char dor = [S+$20-$12] (used reg = )
29592 87E9           B0                     10  mov	al,*$10
29593 87EB           8846         F0            mov	-$10[bp],al
29594                                           !BCC_EOS
29595                                           ! 4417         dor |= 0x0c;
29596                       000087EE            .62E:
29597                                           ! Debug: orab int = const $C to unsigned char dor = [S+$20-$12] (used reg = )
29598 87EE           8A46         F0            mov	al,-$10[bp]
29599 87F1           0C                     0C  or	al,*$C
29600 87F3           8846         F0            mov	-$10[bp],al
29601                                           !BCC_EOS
29602                                           ! 4418         dor |= drive;
29603                                           ! Debug: orab unsigned char drive = [S+$20-3] to unsigned char dor = [S+$20-$12] (used reg = )
29604 87F6           8A46         F0            mov	al,-$10[bp]
29605 87F9           0A46         FF            or	al,-1[bp]
29606 87FC           8846         F0            mov	-$10[bp],al
29607                                           !BCC_EOS
29608                                           ! 4419         outb(0x03f2, dor);
29609                                           ! Debug: list unsigned char dor = [S+$20-$12] (used reg = )
29610 87FF           8A46         F0            mov	al,-$10[bp]
29611 8802           30E4                       xor	ah,ah
29612 8804           50                         push	ax
29613                                           ! Debug: list int = const $3F2 (used reg = )
29614 8805           B8                   03F2  mov	ax,#$3F2
29615 8808           50                         push	ax
29616                                           ! Debug: func () void = outb+0 (used reg = )
29617 8809           E8         7D52            call	_outb
29618 880C           83C4                   04  add	sp,*4
29619                                           !BCC_EOS
29620                                           ! 4420         write_byte(0x40,0x40, 37);
29621                                           ! Debug: list int = const $25 (used reg = )
29622 880F           B8                   0025  mov	ax,*$25
29623 8812           50                         push	ax
29624                                           ! Debug: list int = const $40 (used reg = )
29625 8813           B8                   0040  mov	ax,*$40
29626 8816           50                         push	ax
29627                                           ! Debug: list int = const $40 (used reg = )
29628 8817           B8                   0040  mov	ax,*$40
29629 881A           50                         push	ax
29630                                           ! Debug: func () void = write_byte+0 (used reg = )
29631 881B           E8         7E06            call	_write_byte
29632 881E           83C4                   06  add	sp,*6
29633                                           !BCC_EOS
29634                                           ! 4421         val8 = inb(0x3f4);
29635                                           ! Debug: list int = const $3F4 (used reg = )
29636 8821           B8                   03F4  mov	ax,#$3F4
29637 8824           50                         push	ax
29638                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29639 8825           E8         7D20            call	_inb
29640 8828           44                         inc	sp
29641 8829           44                         inc	sp
29642                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
29643 882A           8846         F1            mov	-$F[bp],al
29644                                           !BCC_EOS
29645                                           ! 4422         if ( (val8 & 0xf0) != 0x80 )
29646                                           ! Debug: and int = const $F0 to unsigned char val8 = [S+$20-$11] (used reg = )
29647 882D           8A46         F1            mov	al,-$F[bp]
29648 8830           24                     F0  and	al,#$F0
29649                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
29650 8832           3C                     80  cmp	al,#$80
29651 8834           74           0E            je  	.62F
29652                       00008836            .630:
29653                                           ! 4423           bios_printf((2 | 4 | 1), "int13_diskette:f02: ctrl not ready\n");
29654                                           ! Debug: list * char = .631+0 (used reg = )
29655 8836           BB                   D1B8  mov	bx,#.631
29656 8839           53                         push	bx
29657                                           ! Debug: list int = const 7 (used reg = )
29658 883A           B8                   0007  mov	ax,*7
29659 883D           50                         push	ax
29660                                           ! Debug: func () void = bios_printf+0 (used reg = )
29661 883E           E8         8068            call	_bios_printf
29662 8841           83C4                   04  add	sp,*4
29663                                           !BCC_EOS
29664                                           ! 4424         outb(0x03f5, 0xe6);
29665                       00008844            .62F:
29666                                           ! Debug: list int = const $E6 (used reg = )
29667 8844           B8                   00E6  mov	ax,#$E6
29668 8847           50                         push	ax
29669                                           ! Debug: list int = const $3F5 (used reg = )
29670 8848           B8                   03F5  mov	ax,#$3F5
29671 884B           50                         push	ax
29672                                           ! Debug: func () void = outb+0 (used reg = )
29673 884C           E8         7D0F            call	_outb
29674 884F           83C4                   04  add	sp,*4
29675                                           !BCC_EOS
29676                                           ! 4425         outb(0x03f5, (head << 2) | drive);
29677                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
29678 8852           8A46         FB            mov	al,-5[bp]
29679 8855           30E4                       xor	ah,ah
29680 8857           D1E0                       shl	ax,*1
29681 8859           D1E0                       shl	ax,*1
29682                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
29683 885B           0A46         FF            or	al,-1[bp]
29684                                           ! Debug: list unsigned int = ax+0 (used reg = )
29685 885E           50                         push	ax
29686                                           ! Debug: list int = const $3F5 (used reg = )
29687 885F           B8                   03F5  mov	ax,#$3F5
29688 8862           50                         push	ax
29689                                           ! Debug: func () void = outb+0 (used reg = )
29690 8863           E8         7CF8            call	_outb
29691 8866           83C4                   04  add	sp,*4
29692                                           !BCC_EOS
29693                                           ! 4426         outb(0x03f5, track);
29694                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
29695 8869           8A46         FD            mov	al,-3[bp]
29696 886C           30E4                       xor	ah,ah
29697 886E           50                         push	ax
29698                                           ! Debug: list int = const $3F5 (used reg = )
29699 886F           B8                   03F5  mov	ax,#$3F5
29700 8872           50                         push	ax
29701                                           ! Debug: func () void = outb+0 (used reg = )
29702 8873           E8         7CE8            call	_outb
29703 8876           83C4                   04  add	sp,*4
29704                                           !BCC_EOS
29705                                           ! 4427         outb(0x03f5, head);
29706                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
29707 8879           8A46         FB            mov	al,-5[bp]
29708 887C           30E4                       xor	ah,ah
29709 887E           50                         push	ax
29710                                           ! Debug: list int = const $3F5 (used reg = )
29711 887F           B8                   03F5  mov	ax,#$3F5
29712 8882           50                         push	ax
29713                                           ! Debug: func () void = outb+0 (used reg = )
29714 8883           E8         7CD8            call	_outb
29715 8886           83C4                   04  add	sp,*4
29716                                           !BCC_EOS
29717                                           ! 4428         outb(0x03f5, sector);
29718                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
29719 8889           8A46         FC            mov	al,-4[bp]
29720 888C           30E4                       xor	ah,ah
29721 888E           50                         push	ax
29722                                           ! Debug: list int = const $3F5 (used reg = )
29723 888F           B8                   03F5  mov	ax,#$3F5
29724 8892           50                         push	ax
29725                                           ! Debug: func () void = outb+0 (used reg = )
29726 8893           E8         7CC8            call	_outb
29727 8896           83C4                   04  add	sp,*4
29728                                           !BCC_EOS
29729                                           ! 4429         outb(0x03f5, 2);
29730                                           ! Debug: list int = const 2 (used reg = )
29731 8899           B8                   0002  mov	ax,*2
29732 889C           50                         push	ax
29733                                           ! Debug: list int = const $3F5 (used reg = )
29734 889D           B8                   03F5  mov	ax,#$3F5
29735 88A0           50                         push	ax
29736                                           ! Debug: func () void = outb+0 (used reg = )
29737 88A1           E8         7CBA            call	_outb
29738 88A4           83C4                   04  add	sp,*4
29739                                           !BCC_EOS
29740                                           ! 4430         outb(0x03f5, sector + num_sectors - 1);
29741                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
29742 88A7           8A46         FC            mov	al,-4[bp]
29743 88AA           30E4                       xor	ah,ah
29744 88AC           0246         FE            add	al,-2[bp]
29745 88AF           80D4                   00  adc	ah,*0
29746                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
29747                                           ! Debug: list unsigned int = ax-1 (used reg = )
29748 88B2           48                         dec	ax
29749 88B3           50                         push	ax
29750                                           ! Debug: list int = const $3F5 (used reg = )
29751 88B4           B8                   03F5  mov	ax,#$3F5
29752 88B7           50                         push	ax
29753                                           ! Debug: func () void = outb+0 (used reg = )
29754 88B8           E8         7CA3            call	_outb
29755 88BB           83C4                   04  add	sp,*4
29756                                           !BCC_EOS
29757                                           ! 4431         outb(0x03f5, 0);
29758                                           ! Debug: list int = const 0 (used reg = )
29759 88BE           31C0                       xor	ax,ax
29760 88C0           50                         push	ax
29761                                           ! Debug: list int = const $3F5 (used reg = )
29762 88C1           B8                   03F5  mov	ax,#$3F5
29763 88C4           50                         push	ax
29764                                           ! Debug: func () void = outb+0 (used reg = )
29765 88C5           E8         7C96            call	_outb
29766 88C8           83C4                   04  add	sp,*4
29767                                           !BCC_EOS
29768                                           ! 4432         outb(0x03f5, 0xff);
29769                                           ! Debug: list int = const $FF (used reg = )
29770 88CB           B8                   00FF  mov	ax,#$FF
29771 88CE           50                         push	ax
29772                                           ! Debug: list int = const $3F5 (used reg = )
29773 88CF           B8                   03F5  mov	ax,#$3F5
29774 88D2           50                         push	ax
29775                                           ! Debug: func () void = outb+0 (used reg = )
29776 88D3           E8         7C88            call	_outb
29777 88D6           83C4                   04  add	sp,*4
29778                                           !BCC_EOS
29779                                           ! 4433 #asm
29780                                           !BCC_EOS
29781                                           !BCC_ASM
29782                       0000002A            _int13_diskette_function.BP	set	$2A
29783                       0000000C            .int13_diskette_function.BP	set	$C
29784                       00000038            _int13_diskette_function.CS	set	$38
29785                       0000001A            .int13_diskette_function.CS	set	$1A
29786                       00000032            _int13_diskette_function.CX	set	$32
29787                       00000014            .int13_diskette_function.CX	set	$14
29788                       00000016            _int13_diskette_function.base_address	set	$16
29789                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29790                       00000026            _int13_diskette_function.DI	set	$26
29791                       00000008            .int13_diskette_function.DI	set	8
29792                       0000003A            _int13_diskette_function.FLAGS	set	$3A
29793                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29794                       00000014            _int13_diskette_function.base_count	set	$14
29795                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29796                       0000001A            _int13_diskette_function.sector	set	$1A
29797                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29798                       00000022            _int13_diskette_function.DS	set	$22
29799                       00000004            .int13_diskette_function.DS	set	4
29800                       00000019            _int13_diskette_function.head	set	$19
29801                       FFFFFFFB            .int13_diskette_function.head	set	-5
29802                       0000002C            _int13_diskette_function.ELDX	set	$2C
29803                       0000000E            .int13_diskette_function.ELDX	set	$E
29804                       0000000E            _int13_diskette_function.dor	set	$E
29805                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29806                       00000030            _int13_diskette_function.DX	set	$30
29807                       00000012            .int13_diskette_function.DX	set	$12
29808                       00000007            _int13_diskette_function.return_status	set	7
29809                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29810                       00000002            _int13_diskette_function.es	set	2
29811                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
29812                       00000010            _int13_diskette_function.mode_register	set	$10
29813                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29814                       00000024            _int13_diskette_function.ES	set	$24
29815                       00000006            .int13_diskette_function.ES	set	6
29816                       00000012            _int13_diskette_function.base_es	set	$12
29817                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29818                       0000001B            _int13_diskette_function.track	set	$1B
29819                       FFFFFFFD            .int13_diskette_function.track	set	-3
29820                       00000028            _int13_diskette_function.SI	set	$28
29821                       0000000A            .int13_diskette_function.SI	set	$A
29822                       00000006            _int13_diskette_function.drive_type	set	6
29823                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29824                       0000001C            _int13_diskette_function.num_sectors	set	$1C
29825                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29826                       00000036            _int13_diskette_function.IP	set	$36
29827                       00000018            .int13_diskette_function.IP	set	$18
29828                       00000018            _int13_diskette_function.status	set	$18
29829                       FFFFFFFA            .int13_diskette_function.status	set	-6
29830                       00000034            _int13_diskette_function.AX	set	$34
29831                       00000016            .int13_diskette_function.AX	set	$16
29832                       0000000F            _int13_diskette_function.val8	set	$F
29833                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29834                       00000000            _int13_diskette_function.last_addr	set	0
29835                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
29836                       00000011            _int13_diskette_function.page	set	$11
29837                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29838                       00000004            _int13_diskette_function.ah	set	4
29839                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29840                       0000001D            _int13_diskette_function.drive	set	$1D
29841                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29842                       00000005            _int13_diskette_function.num_floppies	set	5
29843                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29844                       0000002E            _int13_diskette_function.BX	set	$2E
29845                       00000010            .int13_diskette_function.BX	set	$10
29846 88D9           FB                                 sti
29847                                           ! 4435 endasm
29848                                           !BCC_ENDASM
29849                                           !BCC_EOS
29850                                           ! 4436         val8 = (read_byte(0x0000, 0x043e) & 0x80);
29851                                           ! Debug: list int = const $43E (used reg = )
29852 88DA           B8                   043E  mov	ax,#$43E
29853 88DD           50                         push	ax
29854                                           ! Debug: list int = const 0 (used reg = )
29855 88DE           31C0                       xor	ax,ax
29856 88E0           50                         push	ax
29857                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29858 88E1           E8         7D1A            call	_read_byte
29859 88E4           83C4                   04  add	sp,*4
29860                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
29861 88E7           24                     80  and	al,#$80
29862                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
29863 88E9           8846         F1            mov	-$F[bp],al
29864                                           !BCC_EOS
29865                                           ! 4437         while ( val8 == 0 ) {
29866 88EC           EB           12            jmp .633
29867                       000088EE            .634:
29868                                           ! 4438           val8 = (read_byte(0x0000, 0x043e) & 0x80);
29869                                           ! Debug: list int = const $43E (used reg = )
29870 88EE           B8                   043E  mov	ax,#$43E
29871 88F1           50                         push	ax
29872                                           ! Debug: list int = const 0 (used reg = )
29873 88F2           31C0                       xor	ax,ax
29874 88F4           50                         push	ax
29875                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29876 88F5           E8         7D06            call	_read_byte
29877 88F8           83C4                   04  add	sp,*4
29878                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
29879 88FB           24                     80  and	al,#$80
29880                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
29881 88FD           8846         F1            mov	-$F[bp],al
29882                                           !BCC_EOS
29883                                           ! 4439           }
29884                                           ! 4440        val8 = 0;
29885                       00008900            .633:
29886                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
29887 8900           8A46         F1            mov	al,-$F[bp]
29888 8903           84C0                       test	al,al
29889 8905           74           E7            je 	.634
29890                       00008907            .635:
29891                       00008907            .632:
29892                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
29893 8907           30C0                       xor	al,al
29894 8909           8846         F1            mov	-$F[bp],al
29895                                           !BCC_EOS
29896                                           ! 4441 #asm
29897                                           !BCC_EOS
29898                                           !BCC_ASM
29899                       0000002A            _int13_diskette_function.BP	set	$2A
29900                       0000000C            .int13_diskette_function.BP	set	$C
29901                       00000038            _int13_diskette_function.CS	set	$38
29902                       0000001A            .int13_diskette_function.CS	set	$1A
29903                       00000032            _int13_diskette_function.CX	set	$32
29904                       00000014            .int13_diskette_function.CX	set	$14
29905                       00000016            _int13_diskette_function.base_address	set	$16
29906                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
29907                       00000026            _int13_diskette_function.DI	set	$26
29908                       00000008            .int13_diskette_function.DI	set	8
29909                       0000003A            _int13_diskette_function.FLAGS	set	$3A
29910                       0000001C            .int13_diskette_function.FLAGS	set	$1C
29911                       00000014            _int13_diskette_function.base_count	set	$14
29912                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
29913                       0000001A            _int13_diskette_function.sector	set	$1A
29914                       FFFFFFFC            .int13_diskette_function.sector	set	-4
29915                       00000022            _int13_diskette_function.DS	set	$22
29916                       00000004            .int13_diskette_function.DS	set	4
29917                       00000019            _int13_diskette_function.head	set	$19
29918                       FFFFFFFB            .int13_diskette_function.head	set	-5
29919                       0000002C            _int13_diskette_function.ELDX	set	$2C
29920                       0000000E            .int13_diskette_function.ELDX	set	$E
29921                       0000000E            _int13_diskette_function.dor	set	$E
29922                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
29923                       00000030            _int13_diskette_function.DX	set	$30
29924                       00000012            .int13_diskette_function.DX	set	$12
29925                       00000007            _int13_diskette_function.return_status	set	7
29926                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
29927                       00000002            _int13_diskette_function.es	set	2
29928                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
29929                       00000010            _int13_diskette_function.mode_register	set	$10
29930                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
29931                       00000024            _int13_diskette_function.ES	set	$24
29932                       00000006            .int13_diskette_function.ES	set	6
29933                       00000012            _int13_diskette_function.base_es	set	$12
29934                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
29935                       0000001B            _int13_diskette_function.track	set	$1B
29936                       FFFFFFFD            .int13_diskette_function.track	set	-3
29937                       00000028            _int13_diskette_function.SI	set	$28
29938                       0000000A            .int13_diskette_function.SI	set	$A
29939                       00000006            _int13_diskette_function.drive_type	set	6
29940                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
29941                       0000001C            _int13_diskette_function.num_sectors	set	$1C
29942                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
29943                       00000036            _int13_diskette_function.IP	set	$36
29944                       00000018            .int13_diskette_function.IP	set	$18
29945                       00000018            _int13_diskette_function.status	set	$18
29946                       FFFFFFFA            .int13_diskette_function.status	set	-6
29947                       00000034            _int13_diskette_function.AX	set	$34
29948                       00000016            .int13_diskette_function.AX	set	$16
29949                       0000000F            _int13_diskette_function.val8	set	$F
29950                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
29951                       00000000            _int13_diskette_function.last_addr	set	0
29952                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
29953                       00000011            _int13_diskette_function.page	set	$11
29954                       FFFFFFF3            .int13_diskette_function.page	set	-$D
29955                       00000004            _int13_diskette_function.ah	set	4
29956                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
29957                       0000001D            _int13_diskette_function.drive	set	$1D
29958                       FFFFFFFF            .int13_diskette_function.drive	set	-1
29959                       00000005            _int13_diskette_function.num_floppies	set	5
29960                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
29961                       0000002E            _int13_diskette_function.BX	set	$2E
29962                       00000010            .int13_diskette_function.BX	set	$10
29963 890C           FA                                 cli
29964                                           ! 4443 endasm
29965                                           !BCC_ENDASM
29966                                           !BCC_EOS
29967                                           ! 4444         val8 = read_byte(0x0000, 0x043e);
29968                                           ! Debug: list int = const $43E (used reg = )
29969 890D           B8                   043E  mov	ax,#$43E
29970 8910           50                         push	ax
29971                                           ! Debug: list int = const 0 (used reg = )
29972 8911           31C0                       xor	ax,ax
29973 8913           50                         push	ax
29974                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29975 8914           E8         7CE7            call	_read_byte
29976 8917           83C4                   04  add	sp,*4
29977                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
29978 891A           8846         F1            mov	-$F[bp],al
29979                                           !BCC_EOS
29980                                           ! 4445         val8 &= 0x7f;
29981                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
29982 891D           8A46         F1            mov	al,-$F[bp]
29983 8920           24                     7F  and	al,*$7F
29984 8922           8846         F1            mov	-$F[bp],al
29985                                           !BCC_EOS
29986                                           ! 4446         write_byte(0x0000, 0x043e, val8);
29987                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
29988 8925           8A46         F1            mov	al,-$F[bp]
29989 8928           30E4                       xor	ah,ah
29990 892A           50                         push	ax
29991                                           ! Debug: list int = const $43E (used reg = )
29992 892B           B8                   043E  mov	ax,#$43E
29993 892E           50                         push	ax
29994                                           ! Debug: list int = const 0 (used reg = )
29995 892F           31C0                       xor	ax,ax
29996 8931           50                         push	ax
29997                                           ! Debug: func () void = write_byte+0 (used reg = )
29998 8932           E8         7CEF            call	_write_byte
29999 8935           83C4                   06  add	sp,*6
30000                                           !BCC_EOS
30001                                           ! 4447         val8 = inb(0x3f4);
30002                                           ! Debug: list int = const $3F4 (used reg = )
30003 8938           B8                   03F4  mov	ax,#$3F4
30004 893B           50                         push	ax
30005                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30006 893C           E8         7C09            call	_inb
30007 893F           44                         inc	sp
30008 8940           44                         inc	sp
30009                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
30010 8941           8846         F1            mov	-$F[bp],al
30011                                           !BCC_EOS
30012                                           ! 4448         if ( (val8 & 0xc0) != 0xc0 )
30013                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
30014 8944           8A46         F1            mov	al,-$F[bp]
30015 8947           24                     C0  and	al,#$C0
30016                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
30017 8949           3C                     C0  cmp	al,#$C0
30018 894B           74           0E            je  	.636
30019                       0000894D            .637:
30020                                           ! 4449           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
30021                                           ! Debug: list * char = .638+0 (used reg = )
30022 894D           BB                   D198  mov	bx,#.638
30023 8950           53                         push	bx
30024                                           ! Debug: list int = const 7 (used reg = )
30025 8951           B8                   0007  mov	ax,*7
30026 8954           50                         push	ax
30027                                           ! Debug: func () void = bios_printf+0 (used reg = )
30028 8955           E8         7F51            call	_bios_printf
30029 8958           83C4                   04  add	sp,*4
30030                                           !BCC_EOS
30031                                           ! 4450         return_status[0] = inb(0x3f5);
30032                       0000895B            .636:
30033                                           ! Debug: list int = const $3F5 (used reg = )
30034 895B           B8                   03F5  mov	ax,#$3F5
30035 895E           50                         push	ax
30036                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30037 895F           E8         7BE6            call	_inb
30038 8962           44                         inc	sp
30039 8963           44                         inc	sp
30040                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
30041 8964           8846         E9            mov	-$17[bp],al
30042                                           !BCC_EOS
30043                                           ! 4451         return_status[1] = inb(0x3f5);
30044                                           ! Debug: list int = const $3F5 (used reg = )
30045 8967           B8                   03F5  mov	ax,#$3F5
30046 896A           50                         push	ax
30047                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30048 896B           E8         7BDA            call	_inb
30049 896E           44                         inc	sp
30050 896F           44                         inc	sp
30051                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
30052 8970           8846         EA            mov	-$16[bp],al
30053                                           !BCC_EOS
30054                                           ! 4452         return_status[2] = inb(0x3f5);
30055                                           ! Debug: list int = const $3F5 (used reg = )
30056 8973           B8                   03F5  mov	ax,#$3F5
30057 8976           50                         push	ax
30058                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30059 8977           E8         7BCE            call	_inb
30060 897A           44                         inc	sp
30061 897B           44                         inc	sp
30062                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
30063 897C           8846         EB            mov	-$15[bp],al
30064                                           !BCC_EOS
30065                                           ! 4453         return_status[3] = inb(0x3f5);
30066                                           ! Debug: list int = const $3F5 (used reg = )
30067 897F           B8                   03F5  mov	ax,#$3F5
30068 8982           50                         push	ax
30069                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30070 8983           E8         7BC2            call	_inb
30071 8986           44                         inc	sp
30072 8987           44                         inc	sp
30073                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
30074 8988           8846         EC            mov	-$14[bp],al
30075                                           !BCC_EOS
30076                                           ! 4454         return_status[4] = inb(0x3f5);
30077                                           ! Debug: list int = const $3F5 (used reg = )
30078 898B           B8                   03F5  mov	ax,#$3F5
30079 898E           50                         push	ax
30080                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30081 898F           E8         7BB6            call	_inb
30082 8992           44                         inc	sp
30083 8993           44                         inc	sp
30084                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
30085 8994           8846         ED            mov	-$13[bp],al
30086                                           !BCC_EOS
30087                                           ! 4455         return_status[5] = inb(0x3f5);
30088                                           ! Debug: list int = const $3F5 (used reg = )
30089 8997           B8                   03F5  mov	ax,#$3F5
30090 899A           50                         push	ax
30091                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30092 899B           E8         7BAA            call	_inb
30093 899E           44                         inc	sp
30094 899F           44                         inc	sp
30095                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
30096 89A0           8846         EE            mov	-$12[bp],al
30097                                           !BCC_EOS
30098                                           ! 4456         return_status[6] = inb(0x3f5);
30099                                           ! Debug: list int = const $3F5 (used reg = )
30100 89A3           B8                   03F5  mov	ax,#$3F5
30101 89A6           50                         push	ax
30102                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30103 89A7           E8         7B9E            call	_inb
30104 89AA           44                         inc	sp
30105 89AB           44                         inc	sp
30106                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
30107 89AC           8846         EF            mov	-$11[bp],al
30108                                           !BCC_EOS
30109                                           ! 4457         write_byte(0x0040, 0x0042, return_status[0]);
30110                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
30111 89AF           8A46         E9            mov	al,-$17[bp]
30112 89B2           30E4                       xor	ah,ah
30113 89B4           50                         push	ax
30114                                           ! Debug: list int = const $42 (used reg = )
30115 89B5           B8                   0042  mov	ax,*$42
30116 89B8           50                         push	ax
30117                                           ! Debug: list int = const $40 (used reg = )
30118 89B9           B8                   0040  mov	ax,*$40
30119 89BC           50                         push	ax
30120                                           ! Debug: func () void = write_byte+0 (used reg = )
30121 89BD           E8         7C64            call	_write_byte
30122 89C0           83C4                   06  add	sp,*6
30123                                           !BCC_EOS
30124                                           ! 4458         write_byte(0x0040, 0x0043, return_status[1]);
30125                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
30126 89C3           8A46         EA            mov	al,-$16[bp]
30127 89C6           30E4                       xor	ah,ah
30128 89C8           50                         push	ax
30129                                           ! Debug: list int = const $43 (used reg = )
30130 89C9           B8                   0043  mov	ax,*$43
30131 89CC           50                         push	ax
30132                                           ! Debug: list int = const $40 (used reg = )
30133 89CD           B8                   0040  mov	ax,*$40
30134 89D0           50                         push	ax
30135                                           ! Debug: func () void = write_byte+0 (used reg = )
30136 89D1           E8         7C50            call	_write_byte
30137 89D4           83C4                   06  add	sp,*6
30138                                           !BCC_EOS
30139                                           ! 4459         write_byte(0x0040, 0x0044, return_status[2]);
30140                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
30141 89D7           8A46         EB            mov	al,-$15[bp]
30142 89DA           30E4                       xor	ah,ah
30143 89DC           50                         push	ax
30144                                           ! Debug: list int = const $44 (used reg = )
30145 89DD           B8                   0044  mov	ax,*$44
30146 89E0           50                         push	ax
30147                                           ! Debug: list int = const $40 (used reg = )
30148 89E1           B8                   0040  mov	ax,*$40
30149 89E4           50                         push	ax
30150                                           ! Debug: func () void = write_byte+0 (used reg = )
30151 89E5           E8         7C3C            call	_write_byte
30152 89E8           83C4                   06  add	sp,*6
30153                                           !BCC_EOS
30154                                           ! 4460         write_byte(0x0040, 0x0045, return_status[3]);
30155                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
30156 89EB           8A46         EC            mov	al,-$14[bp]
30157 89EE           30E4                       xor	ah,ah
30158 89F0           50                         push	ax
30159                                           ! Debug: list int = const $45 (used reg = )
30160 89F1           B8                   0045  mov	ax,*$45
30161 89F4           50                         push	ax
30162                                           ! Debug: list int = const $40 (used reg = )
30163 89F5           B8                   0040  mov	ax,*$40
30164 89F8           50                         push	ax
30165                                           ! Debug: func () void = write_byte+0 (used reg = )
30166 89F9           E8         7C28            call	_write_byte
30167 89FC           83C4                   06  add	sp,*6
30168                                           !BCC_EOS
30169                                           ! 4461         write_byte(0x0040, 0x0046, return_status[4]);
30170                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
30171 89FF           8A46         ED            mov	al,-$13[bp]
30172 8A02           30E4                       xor	ah,ah
30173 8A04           50                         push	ax
30174                                           ! Debug: list int = const $46 (used reg = )
30175 8A05           B8                   0046  mov	ax,*$46
30176 8A08           50                         push	ax
30177                                           ! Debug: list int = const $40 (used reg = )
30178 8A09           B8                   0040  mov	ax,*$40
30179 8A0C           50                         push	ax
30180                                           ! Debug: func () void = write_byte+0 (used reg = )
30181 8A0D           E8         7C14            call	_write_byte
30182 8A10           83C4                   06  add	sp,*6
30183                                           !BCC_EOS
30184                                           ! 4462         write_byte(0x0040, 0x0047, return_status[5]);
30185                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
30186 8A13           8A46         EE            mov	al,-$12[bp]
30187 8A16           30E4                       xor	ah,ah
30188 8A18           50                         push	ax
30189                                           ! Debug: list int = const $47 (used reg = )
30190 8A19           B8                   0047  mov	ax,*$47
30191 8A1C           50                         push	ax
30192                                           ! Debug: list int = const $40 (used reg = )
30193 8A1D           B8                   0040  mov	ax,*$40
30194 8A20           50                         push	ax
30195                                           ! Debug: func () void = write_byte+0 (used reg = )
30196 8A21           E8         7C00            call	_write_byte
30197 8A24           83C4                   06  add	sp,*6
30198                                           !BCC_EOS
30199                                           ! 4463         write_byte(0x0040, 0x0048, return_status[6]);
30200                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
30201 8A27           8A46         EF            mov	al,-$11[bp]
30202 8A2A           30E4                       xor	ah,ah
30203 8A2C           50                         push	ax
30204                                           ! Debug: list int = const $48 (used reg = )
30205 8A2D           B8                   0048  mov	ax,*$48
30206 8A30           50                         push	ax
30207                                           ! Debug: list int = const $40 (used reg = )
30208 8A31           B8                   0040  mov	ax,*$40
30209 8A34           50                         push	ax
30210                                           ! Debug: func () void = write_byte+0 (used reg = )
30211 8A35           E8         7BEC            call	_write_byte
30212 8A38           83C4                   06  add	sp,*6
30213                                           !BCC_EOS
30214                                           ! 4464         if ( (return_status[0] & 0xc0) != 0 ) {
30215                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
30216 8A3B           8A46         E9            mov	al,-$17[bp]
30217 8A3E           24                     C0  and	al,#$C0
30218                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
30219 8A40           84C0                       test	al,al
30220 8A42           74           2A            je  	.639
30221                       00008A44            .63A:
30222                                           ! 4465           AX = ((AX & 0x00ff) | ((0x20) << 8));
30223                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30224 8A44           8A46         16            mov	al,$16[bp]
30225                                           ! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
30226 8A47           30E4                       xor	ah,ah
30227 8A49           0D                   2000  or	ax,#$2000
30228                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30229 8A4C           8946         16            mov	$16[bp],ax
30230                                           !BCC_EOS
30231                                           ! 4466           set_diskette_ret_status(0x20);
30232                                           ! Debug: list int = const $20 (used reg = )
30233 8A4F           B8                   0020  mov	ax,*$20
30234 8A52           50                         push	ax
30235                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30236 8A53           E8         0C4F            call	_set_diskette_ret_status
30237 8A56           44                         inc	sp
30238 8A57           44                         inc	sp
30239                                           !BCC_EOS
30240                                           ! 4467           AX = ((AX & 0xff00) | (0));
30241                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
30242 8A58           8B46         16            mov	ax,$16[bp]
30243 8A5B           30C0                       xor	al,al
30244                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
30245 8A5D           0C                     00  or	al,*0
30246                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30247 8A5F           8946         16            mov	$16[bp],ax
30248                                           !BCC_EOS
30249                                           ! 4468           FLAGS |= 0x0001;
30250                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30251 8A62           8B46         1C            mov	ax,$1C[bp]
30252 8A65           0C                     01  or	al,*1
30253 8A67           8946         1C            mov	$1C[bp],ax
30254                                           !BCC_EOS
30255                                           ! 4469           return;
30256 8A6A           89EC                       mov	sp,bp
30257 8A6C           5D                         pop	bp
30258 8A6D           C3                         ret
30259                                           !BCC_EOS
30260                                           ! 4470           }
30261                                           ! 4470 
30262                                           ! 4471         set_diskette_current_cyl(drive, track);
30263                       00008A6E            .639:
30264                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
30265 8A6E           8A46         FD            mov	al,-3[bp]
30266 8A71           30E4                       xor	ah,ah
30267 8A73           50                         push	ax
30268                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
30269 8A74           8A46         FF            mov	al,-1[bp]
30270 8A77           30E4                       xor	ah,ah
30271 8A79           50                         push	ax
30272                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
30273 8A7A           E8         0C40            call	_set_diskette_current_cyl
30274 8A7D           83C4                   04  add	sp,*4
30275                                           !BCC_EOS
30276                                           ! 4472         AX = ((AX & 0x00ff) | ((0x00) << 8));
30277                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30278 8A80           8A46         16            mov	al,$16[bp]
30279                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
30280 8A83           0C                     00  or	al,*0
30281                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
30282 8A85           30E4                       xor	ah,ah
30283 8A87           8946         16            mov	$16[bp],ax
30284                                           !BCC_EOS
30285                                           ! 4473         FLAGS &= 0xfffe;
30286                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30287 8A8A           8B46         1C            mov	ax,$1C[bp]
30288 8A8D           24                     FE  and	al,#$FE
30289 8A8F           8946         1C            mov	$1C[bp],ax
30290                                           !BCC_EOS
30291                                           ! 4474         return;
30292 8A92           89EC                       mov	sp,bp
30293 8A94           5D                         pop	bp
30294 8A95           C3                         ret
30295                                           !BCC_EOS
30296                                           ! 4475         }
30297                                           ! 4476       else if (ah == 0x03) {
30298 8A96           E9         042C            br 	.63B
30299                       00008A99            .626:
30300                                           ! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
30301 8A99           8A46         E6            mov	al,-$1A[bp]
30302 8A9C           3C                     03  cmp	al,*3
30303 8A9E         0F85         03FB            bne 	.63C
30304                       00008AA2            .63D:
30305                                           ! 4477         page = (ES >> 12);
30306                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
30307 8AA2           8B46         06            mov	ax,6[bp]
30308 8AA5           88E0                       mov	al,ah
30309 8AA7           30E4                       xor	ah,ah
30310 8AA9           B1                     04  mov	cl,*4
30311 8AAB           D3E8                       shr	ax,cl
30312                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
30313 8AAD           8846         F3            mov	-$D[bp],al
30314                                           !BCC_EOS
30315                                           ! 4478         base_es = (ES << 4);
30316                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
30317 8AB0           8B46         06            mov	ax,6[bp]
30318 8AB3           B1                     04  mov	cl,*4
30319 8AB5           D3E0                       shl	ax,cl
30320                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
30321 8AB7           8946         F4            mov	-$C[bp],ax
30322                                           !BCC_EOS
30323                                           ! 4479         base_address = base_es + BX;
30324                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
30325 8ABA           8B46         F4            mov	ax,-$C[bp]
30326 8ABD           0346         10            add	ax,$10[bp]
30327                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
30328 8AC0           8946         F8            mov	-8[bp],ax
30329                                           !BCC_EOS
30330                                           ! 4480         if ( base_address < base_es ) {
30331                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
30332 8AC3           8B46         F8            mov	ax,-8[bp]
30333 8AC6           3B46         F4            cmp	ax,-$C[bp]
30334 8AC9           73           07            jae 	.63E
30335                       00008ACB            .63F:
30336                                           ! 4481           page++;
30337                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
30338 8ACB           8A46         F3            mov	al,-$D[bp]
30339 8ACE           40                         inc	ax
30340 8ACF           8846         F3            mov	-$D[bp],al
30341                                           !BCC_EOS
30342                                           ! 4482           }
30343                                           ! 4483         base_count = (num_sectors * 512) - 1;
30344                       00008AD2            .63E:
30345                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
30346 8AD2           8A46         FE            mov	al,-2[bp]
30347 8AD5           30E4                       xor	ah,ah
30348 8AD7           B9                   0200  mov	cx,#$200
30349 8ADA           F7E9                       imul	cx
30350                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
30351                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
30352 8ADC           48                         dec	ax
30353 8ADD           8946         F6            mov	-$A[bp],ax
30354                                           !BCC_EOS
30355                                           ! 4484         last_addr = base_address + base_count;
30356                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
30357 8AE0           8B46         F8            mov	ax,-8[bp]
30358 8AE3           0346         F6            add	ax,-$A[bp]
30359                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
30360 8AE6           8946         E2            mov	-$1E[bp],ax
30361                                           !BCC_EOS
30362                                           ! 4485         if (last_addr < base_address) {
30363                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
30364 8AE9           8B46         E2            mov	ax,-$1E[bp]
30365 8AEC           3B46         F8            cmp	ax,-8[bp]
30366 8AEF           73           2A            jae 	.640
30367                       00008AF1            .641:
30368                                           ! 4486           AX = ((AX & 0x00ff) | ((0x09) << 8));
30369                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30370 8AF1           8A46         16            mov	al,$16[bp]
30371                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
30372 8AF4           30E4                       xor	ah,ah
30373 8AF6           0D                   0900  or	ax,#$900
30374                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30375 8AF9           8946         16            mov	$16[bp],ax
30376                                           !BCC_EOS
30377                                           ! 4487           set_diskette_ret_status(0x09);
30378                                           ! Debug: list int = const 9 (used reg = )
30379 8AFC           B8                   0009  mov	ax,*9
30380 8AFF           50                         push	ax
30381                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30382 8B00           E8         0BA2            call	_set_diskette_ret_status
30383 8B03           44                         inc	sp
30384 8B04           44                         inc	sp
30385                                           !BCC_EOS
30386                                           ! 4488           AX = ((AX & 0xff00) | (0));
30387                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
30388 8B05           8B46         16            mov	ax,$16[bp]
30389 8B08           30C0                       xor	al,al
30390                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
30391 8B0A           0C                     00  or	al,*0
30392                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30393 8B0C           8946         16            mov	$16[bp],ax
30394                                           !BCC_EOS
30395                                           ! 4489           FLAGS |= 0x0001;
30396                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30397 8B0F           8B46         1C            mov	ax,$1C[bp]
30398 8B12           0C                     01  or	al,*1
30399 8B14           8946         1C            mov	$1C[bp],ax
30400                                           !BCC_EOS
30401                                           ! 4490           return;
30402 8B17           89EC                       mov	sp,bp
30403 8B19           5D                         pop	bp
30404 8B1A           C3                         ret
30405                                           !BCC_EOS
30406                                           ! 4491           }
30407                                           ! 4492         ;
30408                       00008B1B            .640:
30409                                           !BCC_EOS
30410                                           ! 4493         outb(0x000a, 0x06);
30411                                           ! Debug: list int = const 6 (used reg = )
30412 8B1B           B8                   0006  mov	ax,*6
30413 8B1E           50                         push	ax
30414                                           ! Debug: list int = const $A (used reg = )
30415 8B1F           B8                   000A  mov	ax,*$A
30416 8B22           50                         push	ax
30417                                           ! Debug: func () void = outb+0 (used reg = )
30418 8B23           E8         7A38            call	_outb
30419 8B26           83C4                   04  add	sp,*4
30420                                           !BCC_EOS
30421                                           ! 4494         outb(0x000c, 0x00);
30422                                           ! Debug: list int = const 0 (used reg = )
30423 8B29           31C0                       xor	ax,ax
30424 8B2B           50                         push	ax
30425                                           ! Debug: list int = const $C (used reg = )
30426 8B2C           B8                   000C  mov	ax,*$C
30427 8B2F           50                         push	ax
30428                                           ! Debug: func () void = outb+0 (used reg = )
30429 8B30           E8         7A2B            call	_outb
30430 8B33           83C4                   04  add	sp,*4
30431                                           !BCC_EOS
30432                                           ! 4495         outb(0x0004, base_address);
30433                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
30434 8B36           FF76         F8            push	-8[bp]
30435                                           ! Debug: list int = const 4 (used reg = )
30436 8B39           B8                   0004  mov	ax,*4
30437 8B3C           50                         push	ax
30438                                           ! Debug: func () void = outb+0 (used reg = )
30439 8B3D           E8         7A1E            call	_outb
30440 8B40           83C4                   04  add	sp,*4
30441                                           !BCC_EOS
30442                                           ! 4496         outb(0x0004, base_address>>8);
30443                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
30444 8B43           8B46         F8            mov	ax,-8[bp]
30445 8B46           88E0                       mov	al,ah
30446 8B48           30E4                       xor	ah,ah
30447                                           ! Debug: list unsigned int = ax+0 (used reg = )
30448 8B4A           50                         push	ax
30449                                           ! Debug: list int = const 4 (used reg = )
30450 8B4B           B8                   0004  mov	ax,*4
30451 8B4E           50                         push	ax
30452                                           ! Debug: func () void = outb+0 (used reg = )
30453 8B4F           E8         7A0C            call	_outb
30454 8B52           83C4                   04  add	sp,*4
30455                                           !BCC_EOS
30456                                           ! 4497         outb(0x000c, 0x00);
30457                                           ! Debug: list int = const 0 (used reg = )
30458 8B55           31C0                       xor	ax,ax
30459 8B57           50                         push	ax
30460                                           ! Debug: list int = const $C (used reg = )
30461 8B58           B8                   000C  mov	ax,*$C
30462 8B5B           50                         push	ax
30463                                           ! Debug: func () void = outb+0 (used reg = )
30464 8B5C           E8         79FF            call	_outb
30465 8B5F           83C4                   04  add	sp,*4
30466                                           !BCC_EOS
30467                                           ! 4498         outb(0x0005, base_count);
30468                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
30469 8B62           FF76         F6            push	-$A[bp]
30470                                           ! Debug: list int = const 5 (used reg = )
30471 8B65           B8                   0005  mov	ax,*5
30472 8B68           50                         push	ax
30473                                           ! Debug: func () void = outb+0 (used reg = )
30474 8B69           E8         79F2            call	_outb
30475 8B6C           83C4                   04  add	sp,*4
30476                                           !BCC_EOS
30477                                           ! 4499         outb(0x0005, base_count>>8);
30478                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
30479 8B6F           8B46         F6            mov	ax,-$A[bp]
30480 8B72           88E0                       mov	al,ah
30481 8B74           30E4                       xor	ah,ah
30482                                           ! Debug: list unsigned int = ax+0 (used reg = )
30483 8B76           50                         push	ax
30484                                           ! Debug: list int = const 5 (used reg = )
30485 8B77           B8                   0005  mov	ax,*5
30486 8B7A           50                         push	ax
30487                                           ! Debug: func () void = outb+0 (used reg = )
30488 8B7B           E8         79E0            call	_outb
30489 8B7E           83C4                   04  add	sp,*4
30490                                           !BCC_EOS
30491                                           ! 4500         mode_register = 0x4a;
30492                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
30493 8B81           B0                     4A  mov	al,*$4A
30494 8B83           8846         F2            mov	-$E[bp],al
30495                                           !BCC_EOS
30496                                           ! 4501         outb(0x000b, mode_register);
30497                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
30498 8B86           8A46         F2            mov	al,-$E[bp]
30499 8B89           30E4                       xor	ah,ah
30500 8B8B           50                         push	ax
30501                                           ! Debug: list int = const $B (used reg = )
30502 8B8C           B8                   000B  mov	ax,*$B
30503 8B8F           50                         push	ax
30504                                           ! Debug: func () void = outb+0 (used reg = )
30505 8B90           E8         79CB            call	_outb
30506 8B93           83C4                   04  add	sp,*4
30507                                           !BCC_EOS
30508                                           ! 4502         outb(0x0081, page);
30509                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
30510 8B96           8A46         F3            mov	al,-$D[bp]
30511 8B99           30E4                       xor	ah,ah
30512 8B9B           50                         push	ax
30513                                           ! Debug: list int = const $81 (used reg = )
30514 8B9C           B8                   0081  mov	ax,#$81
30515 8B9F           50                         push	ax
30516                                           ! Debug: func () void = outb+0 (used reg = )
30517 8BA0           E8         79BB            call	_outb
30518 8BA3           83C4                   04  add	sp,*4
30519                                           !BCC_EOS
30520                                           ! 4503         ;
30521                                           !BCC_EOS
30522                                           ! 4504         outb(0x000a, 0x02);
30523                                           ! Debug: list int = const 2 (used reg = )
30524 8BA6           B8                   0002  mov	ax,*2
30525 8BA9           50                         push	ax
30526                                           ! Debug: list int = const $A (used reg = )
30527 8BAA           B8                   000A  mov	ax,*$A
30528 8BAD           50                         push	ax
30529                                           ! Debug: func () void = outb+0 (used reg = )
30530 8BAE           E8         79AD            call	_outb
30531 8BB1           83C4                   04  add	sp,*4
30532                                           !BCC_EOS
30533                                           ! 4505         val8 = read_byte(0x0000, 0x043e);
30534                                           ! Debug: list int = const $43E (used reg = )
30535 8BB4           B8                   043E  mov	ax,#$43E
30536 8BB7           50                         push	ax
30537                                           ! Debug: list int = const 0 (used reg = )
30538 8BB8           31C0                       xor	ax,ax
30539 8BBA           50                         push	ax
30540                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30541 8BBB           E8         7A40            call	_read_byte
30542 8BBE           83C4                   04  add	sp,*4
30543                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
30544 8BC1           8846         F1            mov	-$F[bp],al
30545                                           !BCC_EOS
30546                                           ! 4506         val8 &= 0x7f;
30547                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
30548 8BC4           8A46         F1            mov	al,-$F[bp]
30549 8BC7           24                     7F  and	al,*$7F
30550 8BC9           8846         F1            mov	-$F[bp],al
30551                                           !BCC_EOS
30552                                           ! 4507         write_byte(0x0000, 0x043e, val8);
30553                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
30554 8BCC           8A46         F1            mov	al,-$F[bp]
30555 8BCF           30E4                       xor	ah,ah
30556 8BD1           50                         push	ax
30557                                           ! Debug: list int = const $43E (used reg = )
30558 8BD2           B8                   043E  mov	ax,#$43E
30559 8BD5           50                         push	ax
30560                                           ! Debug: list int = const 0 (used reg = )
30561 8BD6           31C0                       xor	ax,ax
30562 8BD8           50                         push	ax
30563                                           ! Debug: func () void = write_byte+0 (used reg = )
30564 8BD9           E8         7A48            call	_write_byte
30565 8BDC           83C4                   06  add	sp,*6
30566                                           !BCC_EOS
30567                                           ! 4508         if (drive)
30568 8BDF           8A46         FF            mov	al,-1[bp]
30569 8BE2           84C0                       test	al,al
30570 8BE4           74           07            je  	.642
30571                       00008BE6            .643:
30572                                           ! 4509           dor = 0x20;
30573                                           ! Debug: eq int = const $20 to unsigned char dor = [S+$20-$12] (used reg = )
30574 8BE6           B0                     20  mov	al,*$20
30575 8BE8           8846         F0            mov	-$10[bp],al
30576                                           !BCC_EOS
30577                                           ! 4510         else
30578                                           ! 4511           dor = 0x10;
30579 8BEB           EB           05            jmp .644
30580                       00008BED            .642:
30581                                           ! Debug: eq int = const $10 to unsigned char dor = [S+$20-$12] (used reg = )
30582 8BED           B0                     10  mov	al,*$10
30583 8BEF           8846         F0            mov	-$10[bp],al
30584                                           !BCC_EOS
30585                                           ! 4512         dor |= 0x0c;
30586                       00008BF2            .644:
30587                                           ! Debug: orab int = const $C to unsigned char dor = [S+$20-$12] (used reg = )
30588 8BF2           8A46         F0            mov	al,-$10[bp]
30589 8BF5           0C                     0C  or	al,*$C
30590 8BF7           8846         F0            mov	-$10[bp],al
30591                                           !BCC_EOS
30592                                           ! 4513         dor |= drive;
30593                                           ! Debug: orab unsigned char drive = [S+$20-3] to unsigned char dor = [S+$20-$12] (used reg = )
30594 8BFA           8A46         F0            mov	al,-$10[bp]
30595 8BFD           0A46         FF            or	al,-1[bp]
30596 8C00           8846         F0            mov	-$10[bp],al
30597                                           !BCC_EOS
30598                                           ! 4514         outb(0x03f2, dor);
30599                                           ! Debug: list unsigned char dor = [S+$20-$12] (used reg = )
30600 8C03           8A46         F0            mov	al,-$10[bp]
30601 8C06           30E4                       xor	ah,ah
30602 8C08           50                         push	ax
30603                                           ! Debug: list int = const $3F2 (used reg = )
30604 8C09           B8                   03F2  mov	ax,#$3F2
30605 8C0C           50                         push	ax
30606                                           ! Debug: func () void = outb+0 (used reg = )
30607 8C0D           E8         794E            call	_outb
30608 8C10           83C4                   04  add	sp,*4
30609                                           !BCC_EOS
30610                                           ! 4515         write_byte(0x40,0x40, 37);
30611                                           ! Debug: list int = const $25 (used reg = )
30612 8C13           B8                   0025  mov	ax,*$25
30613 8C16           50                         push	ax
30614                                           ! Debug: list int = const $40 (used reg = )
30615 8C17           B8                   0040  mov	ax,*$40
30616 8C1A           50                         push	ax
30617                                           ! Debug: list int = const $40 (used reg = )
30618 8C1B           B8                   0040  mov	ax,*$40
30619 8C1E           50                         push	ax
30620                                           ! Debug: func () void = write_byte+0 (used reg = )
30621 8C1F           E8         7A02            call	_write_byte
30622 8C22           83C4                   06  add	sp,*6
30623                                           !BCC_EOS
30624                                           ! 4516         val8 = inb(0x3f4);
30625                                           ! Debug: list int = const $3F4 (used reg = )
30626 8C25           B8                   03F4  mov	ax,#$3F4
30627 8C28           50                         push	ax
30628                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30629 8C29           E8         791C            call	_inb
30630 8C2C           44                         inc	sp
30631 8C2D           44                         inc	sp
30632                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
30633 8C2E           8846         F1            mov	-$F[bp],al
30634                                           !BCC_EOS
30635                                           ! 4517         if ( (val8 & 0xf0) != 0x80 )
30636                                           ! Debug: and int = const $F0 to unsigned char val8 = [S+$20-$11] (used reg = )
30637 8C31           8A46         F1            mov	al,-$F[bp]
30638 8C34           24                     F0  and	al,#$F0
30639                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
30640 8C36           3C                     80  cmp	al,#$80
30641 8C38           74           0E            je  	.645
30642                       00008C3A            .646:
30643                                           ! 4518           bios_printf((2 | 4 | 1), "int13_diskette:f03: ctrl not ready\n");
30644                                           ! Debug: list * char = .647+0 (used reg = )
30645 8C3A           BB                   D174  mov	bx,#.647
30646 8C3D           53                         push	bx
30647                                           ! Debug: list int = const 7 (used reg = )
30648 8C3E           B8                   0007  mov	ax,*7
30649 8C41           50                         push	ax
30650                                           ! Debug: func () void = bios_printf+0 (used reg = )
30651 8C42           E8         7C64            call	_bios_printf
30652 8C45           83C4                   04  add	sp,*4
30653                                           !BCC_EOS
30654                                           ! 4519         outb(0x03f5, 0xc5);
30655                       00008C48            .645:
30656                                           ! Debug: list int = const $C5 (used reg = )
30657 8C48           B8                   00C5  mov	ax,#$C5
30658 8C4B           50                         push	ax
30659                                           ! Debug: list int = const $3F5 (used reg = )
30660 8C4C           B8                   03F5  mov	ax,#$3F5
30661 8C4F           50                         push	ax
30662                                           ! Debug: func () void = outb+0 (used reg = )
30663 8C50           E8         790B            call	_outb
30664 8C53           83C4                   04  add	sp,*4
30665                                           !BCC_EOS
30666                                           ! 4520         outb(0x03f5, (head << 2) | drive);
30667                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
30668 8C56           8A46         FB            mov	al,-5[bp]
30669 8C59           30E4                       xor	ah,ah
30670 8C5B           D1E0                       shl	ax,*1
30671 8C5D           D1E0                       shl	ax,*1
30672                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
30673 8C5F           0A46         FF            or	al,-1[bp]
30674                                           ! Debug: list unsigned int = ax+0 (used reg = )
30675 8C62           50                         push	ax
30676                                           ! Debug: list int = const $3F5 (used reg = )
30677 8C63           B8                   03F5  mov	ax,#$3F5
30678 8C66           50                         push	ax
30679                                           ! Debug: func () void = outb+0 (used reg = )
30680 8C67           E8         78F4            call	_outb
30681 8C6A           83C4                   04  add	sp,*4
30682                                           !BCC_EOS
30683                                           ! 4521         outb(0x03f5, track);
30684                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
30685 8C6D           8A46         FD            mov	al,-3[bp]
30686 8C70           30E4                       xor	ah,ah
30687 8C72           50                         push	ax
30688                                           ! Debug: list int = const $3F5 (used reg = )
30689 8C73           B8                   03F5  mov	ax,#$3F5
30690 8C76           50                         push	ax
30691                                           ! Debug: func () void = outb+0 (used reg = )
30692 8C77           E8         78E4            call	_outb
30693 8C7A           83C4                   04  add	sp,*4
30694                                           !BCC_EOS
30695                                           ! 4522         outb(0x03f5, head);
30696                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
30697 8C7D           8A46         FB            mov	al,-5[bp]
30698 8C80           30E4                       xor	ah,ah
30699 8C82           50                         push	ax
30700                                           ! Debug: list int = const $3F5 (used reg = )
30701 8C83           B8                   03F5  mov	ax,#$3F5
30702 8C86           50                         push	ax
30703                                           ! Debug: func () void = outb+0 (used reg = )
30704 8C87           E8         78D4            call	_outb
30705 8C8A           83C4                   04  add	sp,*4
30706                                           !BCC_EOS
30707                                           ! 4523         outb(0x03f5, sector);
30708                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
30709 8C8D           8A46         FC            mov	al,-4[bp]
30710 8C90           30E4                       xor	ah,ah
30711 8C92           50                         push	ax
30712                                           ! Debug: list int = const $3F5 (used reg = )
30713 8C93           B8                   03F5  mov	ax,#$3F5
30714 8C96           50                         push	ax
30715                                           ! Debug: func () void = outb+0 (used reg = )
30716 8C97           E8         78C4            call	_outb
30717 8C9A           83C4                   04  add	sp,*4
30718                                           !BCC_EOS
30719                                           ! 4524         outb(0x03f5, 2);
30720                                           ! Debug: list int = const 2 (used reg = )
30721 8C9D           B8                   0002  mov	ax,*2
30722 8CA0           50                         push	ax
30723                                           ! Debug: list int = const $3F5 (used reg = )
30724 8CA1           B8                   03F5  mov	ax,#$3F5
30725 8CA4           50                         push	ax
30726                                           ! Debug: func () void = outb+0 (used reg = )
30727 8CA5           E8         78B6            call	_outb
30728 8CA8           83C4                   04  add	sp,*4
30729                                           !BCC_EOS
30730                                           ! 4525         outb(0x03f5, sector + num_sectors - 1);
30731                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
30732 8CAB           8A46         FC            mov	al,-4[bp]
30733 8CAE           30E4                       xor	ah,ah
30734 8CB0           0246         FE            add	al,-2[bp]
30735 8CB3           80D4                   00  adc	ah,*0
30736                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
30737                                           ! Debug: list unsigned int = ax-1 (used reg = )
30738 8CB6           48                         dec	ax
30739 8CB7           50                         push	ax
30740                                           ! Debug: list int = const $3F5 (used reg = )
30741 8CB8           B8                   03F5  mov	ax,#$3F5
30742 8CBB           50                         push	ax
30743                                           ! Debug: func () void = outb+0 (used reg = )
30744 8CBC           E8         789F            call	_outb
30745 8CBF           83C4                   04  add	sp,*4
30746                                           !BCC_EOS
30747                                           ! 4526         outb(0x03f5, 0);
30748                                           ! Debug: list int = const 0 (used reg = )
30749 8CC2           31C0                       xor	ax,ax
30750 8CC4           50                         push	ax
30751                                           ! Debug: list int = const $3F5 (used reg = )
30752 8CC5           B8                   03F5  mov	ax,#$3F5
30753 8CC8           50                         push	ax
30754                                           ! Debug: func () void = outb+0 (used reg = )
30755 8CC9           E8         7892            call	_outb
30756 8CCC           83C4                   04  add	sp,*4
30757                                           !BCC_EOS
30758                                           ! 4527         outb(0x03f5, 0xff);
30759                                           ! Debug: list int = const $FF (used reg = )
30760 8CCF           B8                   00FF  mov	ax,#$FF
30761 8CD2           50                         push	ax
30762                                           ! Debug: list int = const $3F5 (used reg = )
30763 8CD3           B8                   03F5  mov	ax,#$3F5
30764 8CD6           50                         push	ax
30765                                           ! Debug: func () void = outb+0 (used reg = )
30766 8CD7           E8         7884            call	_outb
30767 8CDA           83C4                   04  add	sp,*4
30768                                           !BCC_EOS
30769                                           ! 4528 #asm
30770                                           !BCC_EOS
30771                                           !BCC_ASM
30772                       0000002A            _int13_diskette_function.BP	set	$2A
30773                       0000000C            .int13_diskette_function.BP	set	$C
30774                       00000038            _int13_diskette_function.CS	set	$38
30775                       0000001A            .int13_diskette_function.CS	set	$1A
30776                       00000032            _int13_diskette_function.CX	set	$32
30777                       00000014            .int13_diskette_function.CX	set	$14
30778                       00000016            _int13_diskette_function.base_address	set	$16
30779                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
30780                       00000026            _int13_diskette_function.DI	set	$26
30781                       00000008            .int13_diskette_function.DI	set	8
30782                       0000003A            _int13_diskette_function.FLAGS	set	$3A
30783                       0000001C            .int13_diskette_function.FLAGS	set	$1C
30784                       00000014            _int13_diskette_function.base_count	set	$14
30785                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
30786                       0000001A            _int13_diskette_function.sector	set	$1A
30787                       FFFFFFFC            .int13_diskette_function.sector	set	-4
30788                       00000022            _int13_diskette_function.DS	set	$22
30789                       00000004            .int13_diskette_function.DS	set	4
30790                       00000019            _int13_diskette_function.head	set	$19
30791                       FFFFFFFB            .int13_diskette_function.head	set	-5
30792                       0000002C            _int13_diskette_function.ELDX	set	$2C
30793                       0000000E            .int13_diskette_function.ELDX	set	$E
30794                       0000000E            _int13_diskette_function.dor	set	$E
30795                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
30796                       00000030            _int13_diskette_function.DX	set	$30
30797                       00000012            .int13_diskette_function.DX	set	$12
30798                       00000007            _int13_diskette_function.return_status	set	7
30799                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
30800                       00000002            _int13_diskette_function.es	set	2
30801                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
30802                       00000010            _int13_diskette_function.mode_register	set	$10
30803                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
30804                       00000024            _int13_diskette_function.ES	set	$24
30805                       00000006            .int13_diskette_function.ES	set	6
30806                       00000012            _int13_diskette_function.base_es	set	$12
30807                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
30808                       0000001B            _int13_diskette_function.track	set	$1B
30809                       FFFFFFFD            .int13_diskette_function.track	set	-3
30810                       00000028            _int13_diskette_function.SI	set	$28
30811                       0000000A            .int13_diskette_function.SI	set	$A
30812                       00000006            _int13_diskette_function.drive_type	set	6
30813                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
30814                       0000001C            _int13_diskette_function.num_sectors	set	$1C
30815                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
30816                       00000036            _int13_diskette_function.IP	set	$36
30817                       00000018            .int13_diskette_function.IP	set	$18
30818                       00000018            _int13_diskette_function.status	set	$18
30819                       FFFFFFFA            .int13_diskette_function.status	set	-6
30820                       00000034            _int13_diskette_function.AX	set	$34
30821                       00000016            .int13_diskette_function.AX	set	$16
30822                       0000000F            _int13_diskette_function.val8	set	$F
30823                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
30824                       00000000            _int13_diskette_function.last_addr	set	0
30825                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
30826                       00000011            _int13_diskette_function.page	set	$11
30827                       FFFFFFF3            .int13_diskette_function.page	set	-$D
30828                       00000004            _int13_diskette_function.ah	set	4
30829                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
30830                       0000001D            _int13_diskette_function.drive	set	$1D
30831                       FFFFFFFF            .int13_diskette_function.drive	set	-1
30832                       00000005            _int13_diskette_function.num_floppies	set	5
30833                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
30834                       0000002E            _int13_diskette_function.BX	set	$2E
30835                       00000010            .int13_diskette_function.BX	set	$10
30836 8CDD           FB                                 sti
30837                                           ! 4530 endasm
30838                                           !BCC_ENDASM
30839                                           !BCC_EOS
30840                                           ! 4531         val8 = (read_byte(0x0000, 0x043e) & 0x80);
30841                                           ! Debug: list int = const $43E (used reg = )
30842 8CDE           B8                   043E  mov	ax,#$43E
30843 8CE1           50                         push	ax
30844                                           ! Debug: list int = const 0 (used reg = )
30845 8CE2           31C0                       xor	ax,ax
30846 8CE4           50                         push	ax
30847                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30848 8CE5           E8         7916            call	_read_byte
30849 8CE8           83C4                   04  add	sp,*4
30850                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
30851 8CEB           24                     80  and	al,#$80
30852                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
30853 8CED           8846         F1            mov	-$F[bp],al
30854                                           !BCC_EOS
30855                                           ! 4532         while ( val8 == 0 ) {
30856 8CF0           EB           12            jmp .649
30857                       00008CF2            .64A:
30858                                           ! 4533           val8 = (read_byte(0x0000, 0x043e) & 0x80);
30859                                           ! Debug: list int = const $43E (used reg = )
30860 8CF2           B8                   043E  mov	ax,#$43E
30861 8CF5           50                         push	ax
30862                                           ! Debug: list int = const 0 (used reg = )
30863 8CF6           31C0                       xor	ax,ax
30864 8CF8           50                         push	ax
30865                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30866 8CF9           E8         7902            call	_read_byte
30867 8CFC           83C4                   04  add	sp,*4
30868                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
30869 8CFF           24                     80  and	al,#$80
30870                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
30871 8D01           8846         F1            mov	-$F[bp],al
30872                                           !BCC_EOS
30873                                           ! 4534           }
30874                                           ! 4535        val8 = 0;
30875                       00008D04            .649:
30876                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
30877 8D04           8A46         F1            mov	al,-$F[bp]
30878 8D07           84C0                       test	al,al
30879 8D09           74           E7            je 	.64A
30880                       00008D0B            .64B:
30881                       00008D0B            .648:
30882                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
30883 8D0B           30C0                       xor	al,al
30884 8D0D           8846         F1            mov	-$F[bp],al
30885                                           !BCC_EOS
30886                                           ! 4536 #asm
30887                                           !BCC_EOS
30888                                           !BCC_ASM
30889                       0000002A            _int13_diskette_function.BP	set	$2A
30890                       0000000C            .int13_diskette_function.BP	set	$C
30891                       00000038            _int13_diskette_function.CS	set	$38
30892                       0000001A            .int13_diskette_function.CS	set	$1A
30893                       00000032            _int13_diskette_function.CX	set	$32
30894                       00000014            .int13_diskette_function.CX	set	$14
30895                       00000016            _int13_diskette_function.base_address	set	$16
30896                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
30897                       00000026            _int13_diskette_function.DI	set	$26
30898                       00000008            .int13_diskette_function.DI	set	8
30899                       0000003A            _int13_diskette_function.FLAGS	set	$3A
30900                       0000001C            .int13_diskette_function.FLAGS	set	$1C
30901                       00000014            _int13_diskette_function.base_count	set	$14
30902                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
30903                       0000001A            _int13_diskette_function.sector	set	$1A
30904                       FFFFFFFC            .int13_diskette_function.sector	set	-4
30905                       00000022            _int13_diskette_function.DS	set	$22
30906                       00000004            .int13_diskette_function.DS	set	4
30907                       00000019            _int13_diskette_function.head	set	$19
30908                       FFFFFFFB            .int13_diskette_function.head	set	-5
30909                       0000002C            _int13_diskette_function.ELDX	set	$2C
30910                       0000000E            .int13_diskette_function.ELDX	set	$E
30911                       0000000E            _int13_diskette_function.dor	set	$E
30912                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
30913                       00000030            _int13_diskette_function.DX	set	$30
30914                       00000012            .int13_diskette_function.DX	set	$12
30915                       00000007            _int13_diskette_function.return_status	set	7
30916                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
30917                       00000002            _int13_diskette_function.es	set	2
30918                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
30919                       00000010            _int13_diskette_function.mode_register	set	$10
30920                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
30921                       00000024            _int13_diskette_function.ES	set	$24
30922                       00000006            .int13_diskette_function.ES	set	6
30923                       00000012            _int13_diskette_function.base_es	set	$12
30924                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
30925                       0000001B            _int13_diskette_function.track	set	$1B
30926                       FFFFFFFD            .int13_diskette_function.track	set	-3
30927                       00000028            _int13_diskette_function.SI	set	$28
30928                       0000000A            .int13_diskette_function.SI	set	$A
30929                       00000006            _int13_diskette_function.drive_type	set	6
30930                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
30931                       0000001C            _int13_diskette_function.num_sectors	set	$1C
30932                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
30933                       00000036            _int13_diskette_function.IP	set	$36
30934                       00000018            .int13_diskette_function.IP	set	$18
30935                       00000018            _int13_diskette_function.status	set	$18
30936                       FFFFFFFA            .int13_diskette_function.status	set	-6
30937                       00000034            _int13_diskette_function.AX	set	$34
30938                       00000016            .int13_diskette_function.AX	set	$16
30939                       0000000F            _int13_diskette_function.val8	set	$F
30940                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
30941                       00000000            _int13_diskette_function.last_addr	set	0
30942                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
30943                       00000011            _int13_diskette_function.page	set	$11
30944                       FFFFFFF3            .int13_diskette_function.page	set	-$D
30945                       00000004            _int13_diskette_function.ah	set	4
30946                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
30947                       0000001D            _int13_diskette_function.drive	set	$1D
30948                       FFFFFFFF            .int13_diskette_function.drive	set	-1
30949                       00000005            _int13_diskette_function.num_floppies	set	5
30950                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
30951                       0000002E            _int13_diskette_function.BX	set	$2E
30952                       00000010            .int13_diskette_function.BX	set	$10
30953 8D10           FA                                 cli
30954                                           ! 4538 endasm
30955                                           !BCC_ENDASM
30956                                           !BCC_EOS
30957                                           ! 4539         val8 = read_byte(0x0000, 0x043e);
30958                                           ! Debug: list int = const $43E (used reg = )
30959 8D11           B8                   043E  mov	ax,#$43E
30960 8D14           50                         push	ax
30961                                           ! Debug: list int = const 0 (used reg = )
30962 8D15           31C0                       xor	ax,ax
30963 8D17           50                         push	ax
30964                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30965 8D18           E8         78E3            call	_read_byte
30966 8D1B           83C4                   04  add	sp,*4
30967                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
30968 8D1E           8846         F1            mov	-$F[bp],al
30969                                           !BCC_EOS
30970                                           ! 4540         val8 &= 0x7f;
30971                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
30972 8D21           8A46         F1            mov	al,-$F[bp]
30973 8D24           24                     7F  and	al,*$7F
30974 8D26           8846         F1            mov	-$F[bp],al
30975                                           !BCC_EOS
30976                                           ! 4541         write_byte(0x0000, 0x043
30977                                           ! 4541 e, val8);
30978                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
30979 8D29           8A46         F1            mov	al,-$F[bp]
30980 8D2C           30E4                       xor	ah,ah
30981 8D2E           50                         push	ax
30982                                           ! Debug: list int = const $43E (used reg = )
30983 8D2F           B8                   043E  mov	ax,#$43E
30984 8D32           50                         push	ax
30985                                           ! Debug: list int = const 0 (used reg = )
30986 8D33           31C0                       xor	ax,ax
30987 8D35           50                         push	ax
30988                                           ! Debug: func () void = write_byte+0 (used reg = )
30989 8D36           E8         78EB            call	_write_byte
30990 8D39           83C4                   06  add	sp,*6
30991                                           !BCC_EOS
30992                                           ! 4542         val8 = inb(0x3f4);
30993                                           ! Debug: list int = const $3F4 (used reg = )
30994 8D3C           B8                   03F4  mov	ax,#$3F4
30995 8D3F           50                         push	ax
30996                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30997 8D40           E8         7805            call	_inb
30998 8D43           44                         inc	sp
30999 8D44           44                         inc	sp
31000                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31001 8D45           8846         F1            mov	-$F[bp],al
31002                                           !BCC_EOS
31003                                           ! 4543         if ( (val8 & 0xc0) != 0xc0 )
31004                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
31005 8D48           8A46         F1            mov	al,-$F[bp]
31006 8D4B           24                     C0  and	al,#$C0
31007                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
31008 8D4D           3C                     C0  cmp	al,#$C0
31009 8D4F           74           0E            je  	.64C
31010                       00008D51            .64D:
31011                                           ! 4544           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
31012                                           ! Debug: list * char = .64E+0 (used reg = )
31013 8D51           BB                   D154  mov	bx,#.64E
31014 8D54           53                         push	bx
31015                                           ! Debug: list int = const 7 (used reg = )
31016 8D55           B8                   0007  mov	ax,*7
31017 8D58           50                         push	ax
31018                                           ! Debug: func () void = bios_printf+0 (used reg = )
31019 8D59           E8         7B4D            call	_bios_printf
31020 8D5C           83C4                   04  add	sp,*4
31021                                           !BCC_EOS
31022                                           ! 4545         return_status[0] = inb(0x3f5);
31023                       00008D5F            .64C:
31024                                           ! Debug: list int = const $3F5 (used reg = )
31025 8D5F           B8                   03F5  mov	ax,#$3F5
31026 8D62           50                         push	ax
31027                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31028 8D63           E8         77E2            call	_inb
31029 8D66           44                         inc	sp
31030 8D67           44                         inc	sp
31031                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
31032 8D68           8846         E9            mov	-$17[bp],al
31033                                           !BCC_EOS
31034                                           ! 4546         return_status[1] = inb(0x3f5);
31035                                           ! Debug: list int = const $3F5 (used reg = )
31036 8D6B           B8                   03F5  mov	ax,#$3F5
31037 8D6E           50                         push	ax
31038                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31039 8D6F           E8         77D6            call	_inb
31040 8D72           44                         inc	sp
31041 8D73           44                         inc	sp
31042                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
31043 8D74           8846         EA            mov	-$16[bp],al
31044                                           !BCC_EOS
31045                                           ! 4547         return_status[2] = inb(0x3f5);
31046                                           ! Debug: list int = const $3F5 (used reg = )
31047 8D77           B8                   03F5  mov	ax,#$3F5
31048 8D7A           50                         push	ax
31049                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31050 8D7B           E8         77CA            call	_inb
31051 8D7E           44                         inc	sp
31052 8D7F           44                         inc	sp
31053                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
31054 8D80           8846         EB            mov	-$15[bp],al
31055                                           !BCC_EOS
31056                                           ! 4548         return_status[3] = inb(0x3f5);
31057                                           ! Debug: list int = const $3F5 (used reg = )
31058 8D83           B8                   03F5  mov	ax,#$3F5
31059 8D86           50                         push	ax
31060                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31061 8D87           E8         77BE            call	_inb
31062 8D8A           44                         inc	sp
31063 8D8B           44                         inc	sp
31064                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
31065 8D8C           8846         EC            mov	-$14[bp],al
31066                                           !BCC_EOS
31067                                           ! 4549         return_status[4] = inb(0x3f5);
31068                                           ! Debug: list int = const $3F5 (used reg = )
31069 8D8F           B8                   03F5  mov	ax,#$3F5
31070 8D92           50                         push	ax
31071                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31072 8D93           E8         77B2            call	_inb
31073 8D96           44                         inc	sp
31074 8D97           44                         inc	sp
31075                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
31076 8D98           8846         ED            mov	-$13[bp],al
31077                                           !BCC_EOS
31078                                           ! 4550         return_status[5] = inb(0x3f5);
31079                                           ! Debug: list int = const $3F5 (used reg = )
31080 8D9B           B8                   03F5  mov	ax,#$3F5
31081 8D9E           50                         push	ax
31082                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31083 8D9F           E8         77A6            call	_inb
31084 8DA2           44                         inc	sp
31085 8DA3           44                         inc	sp
31086                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
31087 8DA4           8846         EE            mov	-$12[bp],al
31088                                           !BCC_EOS
31089                                           ! 4551         return_status[6] = inb(0x3f5);
31090                                           ! Debug: list int = const $3F5 (used reg = )
31091 8DA7           B8                   03F5  mov	ax,#$3F5
31092 8DAA           50                         push	ax
31093                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31094 8DAB           E8         779A            call	_inb
31095 8DAE           44                         inc	sp
31096 8DAF           44                         inc	sp
31097                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
31098 8DB0           8846         EF            mov	-$11[bp],al
31099                                           !BCC_EOS
31100                                           ! 4552         write_byte(0x0040, 0x0042, return_status[0]);
31101                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
31102 8DB3           8A46         E9            mov	al,-$17[bp]
31103 8DB6           30E4                       xor	ah,ah
31104 8DB8           50                         push	ax
31105                                           ! Debug: list int = const $42 (used reg = )
31106 8DB9           B8                   0042  mov	ax,*$42
31107 8DBC           50                         push	ax
31108                                           ! Debug: list int = const $40 (used reg = )
31109 8DBD           B8                   0040  mov	ax,*$40
31110 8DC0           50                         push	ax
31111                                           ! Debug: func () void = write_byte+0 (used reg = )
31112 8DC1           E8         7860            call	_write_byte
31113 8DC4           83C4                   06  add	sp,*6
31114                                           !BCC_EOS
31115                                           ! 4553         write_byte(0x0040, 0x0043, return_status[1]);
31116                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
31117 8DC7           8A46         EA            mov	al,-$16[bp]
31118 8DCA           30E4                       xor	ah,ah
31119 8DCC           50                         push	ax
31120                                           ! Debug: list int = const $43 (used reg = )
31121 8DCD           B8                   0043  mov	ax,*$43
31122 8DD0           50                         push	ax
31123                                           ! Debug: list int = const $40 (used reg = )
31124 8DD1           B8                   0040  mov	ax,*$40
31125 8DD4           50                         push	ax
31126                                           ! Debug: func () void = write_byte+0 (used reg = )
31127 8DD5           E8         784C            call	_write_byte
31128 8DD8           83C4                   06  add	sp,*6
31129                                           !BCC_EOS
31130                                           ! 4554         write_byte(0x0040, 0x0044, return_status[2]);
31131                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
31132 8DDB           8A46         EB            mov	al,-$15[bp]
31133 8DDE           30E4                       xor	ah,ah
31134 8DE0           50                         push	ax
31135                                           ! Debug: list int = const $44 (used reg = )
31136 8DE1           B8                   0044  mov	ax,*$44
31137 8DE4           50                         push	ax
31138                                           ! Debug: list int = const $40 (used reg = )
31139 8DE5           B8                   0040  mov	ax,*$40
31140 8DE8           50                         push	ax
31141                                           ! Debug: func () void = write_byte+0 (used reg = )
31142 8DE9           E8         7838            call	_write_byte
31143 8DEC           83C4                   06  add	sp,*6
31144                                           !BCC_EOS
31145                                           ! 4555         write_byte(0x0040, 0x0045, return_status[3]);
31146                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
31147 8DEF           8A46         EC            mov	al,-$14[bp]
31148 8DF2           30E4                       xor	ah,ah
31149 8DF4           50                         push	ax
31150                                           ! Debug: list int = const $45 (used reg = )
31151 8DF5           B8                   0045  mov	ax,*$45
31152 8DF8           50                         push	ax
31153                                           ! Debug: list int = const $40 (used reg = )
31154 8DF9           B8                   0040  mov	ax,*$40
31155 8DFC           50                         push	ax
31156                                           ! Debug: func () void = write_byte+0 (used reg = )
31157 8DFD           E8         7824            call	_write_byte
31158 8E00           83C4                   06  add	sp,*6
31159                                           !BCC_EOS
31160                                           ! 4556         write_byte(0x0040, 0x0046, return_status[4]);
31161                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
31162 8E03           8A46         ED            mov	al,-$13[bp]
31163 8E06           30E4                       xor	ah,ah
31164 8E08           50                         push	ax
31165                                           ! Debug: list int = const $46 (used reg = )
31166 8E09           B8                   0046  mov	ax,*$46
31167 8E0C           50                         push	ax
31168                                           ! Debug: list int = const $40 (used reg = )
31169 8E0D           B8                   0040  mov	ax,*$40
31170 8E10           50                         push	ax
31171                                           ! Debug: func () void = write_byte+0 (used reg = )
31172 8E11           E8         7810            call	_write_byte
31173 8E14           83C4                   06  add	sp,*6
31174                                           !BCC_EOS
31175                                           ! 4557         write_byte(0x0040, 0x0047, return_status[5]);
31176                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
31177 8E17           8A46         EE            mov	al,-$12[bp]
31178 8E1A           30E4                       xor	ah,ah
31179 8E1C           50                         push	ax
31180                                           ! Debug: list int = const $47 (used reg = )
31181 8E1D           B8                   0047  mov	ax,*$47
31182 8E20           50                         push	ax
31183                                           ! Debug: list int = const $40 (used reg = )
31184 8E21           B8                   0040  mov	ax,*$40
31185 8E24           50                         push	ax
31186                                           ! Debug: func () void = write_byte+0 (used reg = )
31187 8E25           E8         77FC            call	_write_byte
31188 8E28           83C4                   06  add	sp,*6
31189                                           !BCC_EOS
31190                                           ! 4558         write_byte(0x0040, 0x0048, return_status[6]);
31191                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
31192 8E2B           8A46         EF            mov	al,-$11[bp]
31193 8E2E           30E4                       xor	ah,ah
31194 8E30           50                         push	ax
31195                                           ! Debug: list int = const $48 (used reg = )
31196 8E31           B8                   0048  mov	ax,*$48
31197 8E34           50                         push	ax
31198                                           ! Debug: list int = const $40 (used reg = )
31199 8E35           B8                   0040  mov	ax,*$40
31200 8E38           50                         push	ax
31201                                           ! Debug: func () void = write_byte+0 (used reg = )
31202 8E39           E8         77E8            call	_write_byte
31203 8E3C           83C4                   06  add	sp,*6
31204                                           !BCC_EOS
31205                                           ! 4559         if ( (return_status[0] & 0xc0) != 0 ) {
31206                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
31207 8E3F           8A46         E9            mov	al,-$17[bp]
31208 8E42           24                     C0  and	al,#$C0
31209                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
31210 8E44           84C0                       test	al,al
31211 8E46           74           2B            je  	.64F
31212                       00008E48            .650:
31213                                           ! 4560           if ( (return_status[1] & 0x02) != 0 ) {
31214                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
31215 8E48           8A46         EA            mov	al,-$16[bp]
31216 8E4B           24                     02  and	al,*2
31217                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
31218 8E4D           84C0                       test	al,al
31219 8E4F           74           14            je  	.651
31220                       00008E51            .652:
31221                                           ! 4561             AX = 0x0300;
31222                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
31223 8E51           B8                   0300  mov	ax,#$300
31224 8E54           8946         16            mov	$16[bp],ax
31225                                           !BCC_EOS
31226                                           ! 4562             FLAGS |= 0x0001;
31227                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31228 8E57           8B46         1C            mov	ax,$1C[bp]
31229 8E5A           0C                     01  or	al,*1
31230 8E5C           8946         1C            mov	$1C[bp],ax
31231                                           !BCC_EOS
31232                                           ! 4563             return;
31233 8E5F           89EC                       mov	sp,bp
31234 8E61           5D                         pop	bp
31235 8E62           C3                         ret
31236                                           !BCC_EOS
31237                                           ! 4564           } else {
31238 8E63           EB           0E            jmp .653
31239                       00008E65            .651:
31240                                           ! 4565             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
31241                                           ! Debug: list * char = .654+0 (used reg = )
31242 8E65           BB                   D12F  mov	bx,#.654
31243 8E68           53                         push	bx
31244                                           ! Debug: list int = const 7 (used reg = )
31245 8E69           B8                   0007  mov	ax,*7
31246 8E6C           50                         push	ax
31247                                           ! Debug: func () void = bios_printf+0 (used reg = )
31248 8E6D           E8         7A39            call	_bios_printf
31249 8E70           83C4                   04  add	sp,*4
31250                                           !BCC_EOS
31251                                           ! 4566           }
31252                                           ! 4567         }
31253                       00008E73            .653:
31254                                           ! 4568         set_diskette_current_cyl(drive, track);
31255                       00008E73            .64F:
31256                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
31257 8E73           8A46         FD            mov	al,-3[bp]
31258 8E76           30E4                       xor	ah,ah
31259 8E78           50                         push	ax
31260                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
31261 8E79           8A46         FF            mov	al,-1[bp]
31262 8E7C           30E4                       xor	ah,ah
31263 8E7E           50                         push	ax
31264                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
31265 8E7F           E8         083B            call	_set_diskette_current_cyl
31266 8E82           83C4                   04  add	sp,*4
31267                                           !BCC_EOS
31268                                           ! 4569         AX = ((AX & 0x00ff) | ((0x00) << 8));
31269                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31270 8E85           8A46         16            mov	al,$16[bp]
31271                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
31272 8E88           0C                     00  or	al,*0
31273                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
31274 8E8A           30E4                       xor	ah,ah
31275 8E8C           8946         16            mov	$16[bp],ax
31276                                           !BCC_EOS
31277                                           ! 4570         FLAGS &= 0xfffe;
31278                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31279 8E8F           8B46         1C            mov	ax,$1C[bp]
31280 8E92           24                     FE  and	al,#$FE
31281 8E94           8946         1C            mov	$1C[bp],ax
31282                                           !BCC_EOS
31283                                           ! 4571         return;
31284 8E97           89EC                       mov	sp,bp
31285 8E99           5D                         pop	bp
31286 8E9A           C3                         ret
31287                                           !BCC_EOS
31288                                           ! 4572         }
31289                                           ! 4573       else {
31290 8E9B           EB           28            jmp .655
31291                       00008E9D            .63C:
31292                                           ! 4574         set_diskette_current_cyl(drive, track);
31293                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
31294 8E9D           8A46         FD            mov	al,-3[bp]
31295 8EA0           30E4                       xor	ah,ah
31296 8EA2           50                         push	ax
31297                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
31298 8EA3           8A46         FF            mov	al,-1[bp]
31299 8EA6           30E4                       xor	ah,ah
31300 8EA8           50                         push	ax
31301                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
31302 8EA9           E8         0811            call	_set_diskette_current_cyl
31303 8EAC           83C4                   04  add	sp,*4
31304                                           !BCC_EOS
31305                                           ! 4575         FLAGS &= 0xfffe;
31306                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31307 8EAF           8B46         1C            mov	ax,$1C[bp]
31308 8EB2           24                     FE  and	al,#$FE
31309 8EB4           8946         1C            mov	$1C[bp],ax
31310                                           !BCC_EOS
31311                                           ! 4576         AX = ((AX & 0x00ff) | ((0x00) << 8));
31312                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31313 8EB7           8A46         16            mov	al,$16[bp]
31314                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
31315 8EBA           0C                     00  or	al,*0
31316                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
31317 8EBC           30E4                       xor	ah,ah
31318 8EBE           8946         16            mov	$16[bp],ax
31319                                           !BCC_EOS
31320                                           ! 4577         return;
31321 8EC1           89EC                       mov	sp,bp
31322 8EC3           5D                         pop	bp
31323 8EC4           C3                         ret
31324                                           !BCC_EOS
31325                                           ! 4578         }
31326                                           ! 4579     case 0x05:
31327                       00008EC5            .655:
31328                       00008EC5            .63B:
31329                                           ! 4580 ;
31330                       00008EC5            .656:
31331                                           !BCC_EOS
31332                                           ! 4581       num_sectors = ( AX & 0x00ff );
31333                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31334 8EC5           8A46         16            mov	al,$16[bp]
31335                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
31336 8EC8           8846         FE            mov	-2[bp],al
31337                                           !BCC_EOS
31338                                           ! 4582       track = ( CX >> 8 );
31339                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
31340 8ECB           8B46         14            mov	ax,$14[bp]
31341 8ECE           88E0                       mov	al,ah
31342 8ED0           30E4                       xor	ah,ah
31343                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
31344 8ED2           8846         FD            mov	-3[bp],al
31345                                           !BCC_EOS
31346                                           ! 4583       head = ( DX >> 8 );
31347                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
31348 8ED5           8B46         12            mov	ax,$12[bp]
31349 8ED8           88E0                       mov	al,ah
31350 8EDA           30E4                       xor	ah,ah
31351                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
31352 8EDC           8846         FB            mov	-5[bp],al
31353                                           !BCC_EOS
31354                                           ! 4584       drive = ( ELDX & 0x00ff );
31355                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
31356 8EDF           8A46         0E            mov	al,$E[bp]
31357                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
31358 8EE2           8846         FF            mov	-1[bp],al
31359                                           !BCC_EOS
31360                                           ! 4585       if ((drive > 1) || (head > 1) || (track > 79) ||
31361                                           ! 4586           (num_sectors == 0) || (num_sectors > 18)) {
31362                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
31363 8EE5           8A46         FF            mov	al,-1[bp]
31364 8EE8           3C                     01  cmp	al,*1
31365 8EEA           77           1C            ja  	.658
31366                       00008EEC            .65C:
31367                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
31368 8EEC           8A46         FB            mov	al,-5[bp]
31369 8EEF           3C                     01  cmp	al,*1
31370 8EF1           77           15            ja  	.658
31371                       00008EF3            .65B:
31372                                           ! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
31373 8EF3           8A46         FD            mov	al,-3[bp]
31374 8EF6           3C                     4F  cmp	al,*$4F
31375 8EF8           77           0E            ja  	.658
31376                       00008EFA            .65A:
31377                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
31378 8EFA           8A46         FE            mov	al,-2[bp]
31379 8EFD           84C0                       test	al,al
31380 8EFF           74           07            je  	.658
31381                       00008F01            .659:
31382                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
31383 8F01           8A46         FE            mov	al,-2[bp]
31384 8F04           3C                     12  cmp	al,*$12
31385 8F06           76           1C            jbe 	.657
31386                       00008F08            .658:
31387                                           ! 4587         AX = ((AX & 0x00ff) | ((1) << 8));
31388                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31389 8F08           8A46         16            mov	al,$16[bp]
31390                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
31391 8F0B           30E4                       xor	ah,ah
31392 8F0D           0D                   0100  or	ax,#$100
31393                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31394 8F10           8946         16            mov	$16[bp],ax
31395                                           !BCC_EOS
31396                                           ! 4588         set_diskette_ret_status(1);
31397                                           ! Debug: list int = const 1 (used reg = )
31398 8F13           B8                   0001  mov	ax,*1
31399 8F16           50                         push	ax
31400                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31401 8F17           E8         078B            call	_set_diskette_ret_status
31402 8F1A           44                         inc	sp
31403 8F1B           44                         inc	sp
31404                                           !BCC_EOS
31405                                           ! 4589         FLAGS |= 0x0001;
31406                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31407 8F1C           8B46         1C            mov	ax,$1C[bp]
31408 8F1F           0C                     01  or	al,*1
31409 8F21           8946         1C            mov	$1C[bp],ax
31410                                           !BCC_EOS
31411                                           ! 4590         }
31412                                           ! 4591       if (floppy_drive_exists(drive) == 0) {
31413                       00008F24            .657:
31414                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31415 8F24           8A46         FF            mov	al,-1[bp]
31416 8F27           30E4                       xor	ah,ah
31417 8F29           50                         push	ax
31418                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
31419 8F2A           E8         F515            call	_floppy_drive_exists
31420 8F2D           44                         inc	sp
31421 8F2E           44                         inc	sp
31422                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31423 8F2F           85C0                       test	ax,ax
31424 8F31           75           20            jne 	.65D
31425                       00008F33            .65E:
31426                                           ! 4592         AX = ((AX & 0x00ff) | ((0x80) << 8));
31427                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31428 8F33           8A46         16            mov	al,$16[bp]
31429                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31430 8F36           30E4                       xor	ah,ah
31431 8F38           0D                   8000  or	ax,#-$8000
31432                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31433 8F3B           8946         16            mov	$16[bp],ax
31434                                           !BCC_EOS
31435                                           ! 4593         set_diskette_ret_status(0x80);
31436                                           ! Debug: list int = const $80 (used reg = )
31437 8F3E           B8                   0080  mov	ax,#$80
31438 8F41           50                         push	ax
31439                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31440 8F42           E8         0760            call	_set_diskette_ret_status
31441 8F45           44                         inc	sp
31442 8F46           44                         inc	sp
31443                                           !BCC_EOS
31444                                           ! 4594         FLAGS |= 0x0001;
31445                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31446 8F47           8B46         1C            mov	ax,$1C[bp]
31447 8F4A           0C                     01  or	al,*1
31448 8F4C           8946         1C            mov	$1C[bp],ax
31449                                           !BCC_EOS
31450                                           ! 4595         return;
31451 8F4F           89EC                       mov	sp,bp
31452 8F51           5D                         pop	bp
31453 8F52           C3                         ret
31454                                           !BCC_EOS
31455                                           ! 4596         }
31456                                           ! 4597       if (floppy_media_known(drive) == 0) {
31457                       00008F53            .65D:
31458                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31459 8F53           8A46         FF            mov	al,-1[bp]
31460 8F56           30E4                       xor	ah,ah
31461 8F58           50                         push	ax
31462                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
31463 8F59           E8         F1B2            call	_floppy_media_known
31464 8F5C           44                         inc	sp
31465 8F5D           44                         inc	sp
31466                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31467 8F5E           85C0                       test	ax,ax
31468 8F60           75           39            jne 	.65F
31469                       00008F62            .660:
31470                                           ! 4598         if (floppy_media_sense(drive) == 0) {
31471                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31472 8F62           8A46         FF            mov	al,-1[bp]
31473 8F65           30E4                       xor	ah,ah
31474 8F67           50                         push	ax
31475                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
31476 8F68           E8         F226            call	_floppy_media_sense
31477 8F6B           44                         inc	sp
31478 8F6C           44                         inc	sp
31479                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31480 8F6D           85C0                       test	ax,ax
31481 8F6F           75           2A            jne 	.661
31482                       00008F71            .662:
31483                                           ! 4599           AX = ((AX & 
31484                                           ! 4599 0x00ff) | ((0x0C) << 8));
31485                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31486 8F71           8A46         16            mov	al,$16[bp]
31487                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
31488 8F74           30E4                       xor	ah,ah
31489 8F76           0D                   0C00  or	ax,#$C00
31490                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31491 8F79           8946         16            mov	$16[bp],ax
31492                                           !BCC_EOS
31493                                           ! 4600           set_diskette_ret_status(0x0C);
31494                                           ! Debug: list int = const $C (used reg = )
31495 8F7C           B8                   000C  mov	ax,*$C
31496 8F7F           50                         push	ax
31497                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31498 8F80           E8         0722            call	_set_diskette_ret_status
31499 8F83           44                         inc	sp
31500 8F84           44                         inc	sp
31501                                           !BCC_EOS
31502                                           ! 4601           AX = ((AX & 0xff00) | (0));
31503                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31504 8F85           8B46         16            mov	ax,$16[bp]
31505 8F88           30C0                       xor	al,al
31506                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31507 8F8A           0C                     00  or	al,*0
31508                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31509 8F8C           8946         16            mov	$16[bp],ax
31510                                           !BCC_EOS
31511                                           ! 4602           FLAGS |= 0x0001;
31512                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31513 8F8F           8B46         1C            mov	ax,$1C[bp]
31514 8F92           0C                     01  or	al,*1
31515 8F94           8946         1C            mov	$1C[bp],ax
31516                                           !BCC_EOS
31517                                           ! 4603           return;
31518 8F97           89EC                       mov	sp,bp
31519 8F99           5D                         pop	bp
31520 8F9A           C3                         ret
31521                                           !BCC_EOS
31522                                           ! 4604           }
31523                                           ! 4605         }
31524                       00008F9B            .661:
31525                                           ! 4606       page = (ES >> 12);
31526                       00008F9B            .65F:
31527                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
31528 8F9B           8B46         06            mov	ax,6[bp]
31529 8F9E           88E0                       mov	al,ah
31530 8FA0           30E4                       xor	ah,ah
31531 8FA2           B1                     04  mov	cl,*4
31532 8FA4           D3E8                       shr	ax,cl
31533                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
31534 8FA6           8846         F3            mov	-$D[bp],al
31535                                           !BCC_EOS
31536                                           ! 4607       base_es = (ES << 4);
31537                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
31538 8FA9           8B46         06            mov	ax,6[bp]
31539 8FAC           B1                     04  mov	cl,*4
31540 8FAE           D3E0                       shl	ax,cl
31541                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
31542 8FB0           8946         F4            mov	-$C[bp],ax
31543                                           !BCC_EOS
31544                                           ! 4608       base_address = base_es + BX;
31545                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
31546 8FB3           8B46         F4            mov	ax,-$C[bp]
31547 8FB6           0346         10            add	ax,$10[bp]
31548                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
31549 8FB9           8946         F8            mov	-8[bp],ax
31550                                           !BCC_EOS
31551                                           ! 4609       if ( base_address < base_es ) {
31552                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
31553 8FBC           8B46         F8            mov	ax,-8[bp]
31554 8FBF           3B46         F4            cmp	ax,-$C[bp]
31555 8FC2           73           07            jae 	.663
31556                       00008FC4            .664:
31557                                           ! 4610         page++;
31558                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
31559 8FC4           8A46         F3            mov	al,-$D[bp]
31560 8FC7           40                         inc	ax
31561 8FC8           8846         F3            mov	-$D[bp],al
31562                                           !BCC_EOS
31563                                           ! 4611         }
31564                                           ! 4612       base_count = (num_sectors * 4) - 1;
31565                       00008FCB            .663:
31566                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
31567 8FCB           8A46         FE            mov	al,-2[bp]
31568 8FCE           30E4                       xor	ah,ah
31569 8FD0           D1E0                       shl	ax,*1
31570 8FD2           D1E0                       shl	ax,*1
31571                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
31572                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
31573 8FD4           48                         dec	ax
31574 8FD5           8946         F6            mov	-$A[bp],ax
31575                                           !BCC_EOS
31576                                           ! 4613       last_addr = base_address + base_count;
31577                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
31578 8FD8           8B46         F8            mov	ax,-8[bp]
31579 8FDB           0346         F6            add	ax,-$A[bp]
31580                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
31581 8FDE           8946         E2            mov	-$1E[bp],ax
31582                                           !BCC_EOS
31583                                           ! 4614       if (last_addr < base_address) {
31584                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
31585 8FE1           8B46         E2            mov	ax,-$1E[bp]
31586 8FE4           3B46         F8            cmp	ax,-8[bp]
31587 8FE7           73           2A            jae 	.665
31588                       00008FE9            .666:
31589                                           ! 4615         AX = ((AX & 0x00ff) | ((0x09) << 8));
31590                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31591 8FE9           8A46         16            mov	al,$16[bp]
31592                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
31593 8FEC           30E4                       xor	ah,ah
31594 8FEE           0D                   0900  or	ax,#$900
31595                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31596 8FF1           8946         16            mov	$16[bp],ax
31597                                           !BCC_EOS
31598                                           ! 4616         set_diskette_ret_status(0x09);
31599                                           ! Debug: list int = const 9 (used reg = )
31600 8FF4           B8                   0009  mov	ax,*9
31601 8FF7           50                         push	ax
31602                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31603 8FF8           E8         06AA            call	_set_diskette_ret_status
31604 8FFB           44                         inc	sp
31605 8FFC           44                         inc	sp
31606                                           !BCC_EOS
31607                                           ! 4617         AX = ((AX & 0xff00) | (0));
31608                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31609 8FFD           8B46         16            mov	ax,$16[bp]
31610 9000           30C0                       xor	al,al
31611                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31612 9002           0C                     00  or	al,*0
31613                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31614 9004           8946         16            mov	$16[bp],ax
31615                                           !BCC_EOS
31616                                           ! 4618         FLAGS |= 0x0001;
31617                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31618 9007           8B46         1C            mov	ax,$1C[bp]
31619 900A           0C                     01  or	al,*1
31620 900C           8946         1C            mov	$1C[bp],ax
31621                                           !BCC_EOS
31622                                           ! 4619         return;
31623 900F           89EC                       mov	sp,bp
31624 9011           5D                         pop	bp
31625 9012           C3                         ret
31626                                           !BCC_EOS
31627                                           ! 4620         }
31628                                           ! 4621       outb(0x000a, 0x06);
31629                       00009013            .665:
31630                                           ! Debug: list int = const 6 (used reg = )
31631 9013           B8                   0006  mov	ax,*6
31632 9016           50                         push	ax
31633                                           ! Debug: list int = const $A (used reg = )
31634 9017           B8                   000A  mov	ax,*$A
31635 901A           50                         push	ax
31636                                           ! Debug: func () void = outb+0 (used reg = )
31637 901B           E8         7540            call	_outb
31638 901E           83C4                   04  add	sp,*4
31639                                           !BCC_EOS
31640                                           ! 4622       outb(0x000c, 0x00);
31641                                           ! Debug: list int = const 0 (used reg = )
31642 9021           31C0                       xor	ax,ax
31643 9023           50                         push	ax
31644                                           ! Debug: list int = const $C (used reg = )
31645 9024           B8                   000C  mov	ax,*$C
31646 9027           50                         push	ax
31647                                           ! Debug: func () void = outb+0 (used reg = )
31648 9028           E8         7533            call	_outb
31649 902B           83C4                   04  add	sp,*4
31650                                           !BCC_EOS
31651                                           ! 4623       outb(0x0004, base_address);
31652                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
31653 902E           FF76         F8            push	-8[bp]
31654                                           ! Debug: list int = const 4 (used reg = )
31655 9031           B8                   0004  mov	ax,*4
31656 9034           50                         push	ax
31657                                           ! Debug: func () void = outb+0 (used reg = )
31658 9035           E8         7526            call	_outb
31659 9038           83C4                   04  add	sp,*4
31660                                           !BCC_EOS
31661                                           ! 4624       outb(0x0004, base_address>>8);
31662                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
31663 903B           8B46         F8            mov	ax,-8[bp]
31664 903E           88E0                       mov	al,ah
31665 9040           30E4                       xor	ah,ah
31666                                           ! Debug: list unsigned int = ax+0 (used reg = )
31667 9042           50                         push	ax
31668                                           ! Debug: list int = const 4 (used reg = )
31669 9043           B8                   0004  mov	ax,*4
31670 9046           50                         push	ax
31671                                           ! Debug: func () void = outb+0 (used reg = )
31672 9047           E8         7514            call	_outb
31673 904A           83C4                   04  add	sp,*4
31674                                           !BCC_EOS
31675                                           ! 4625       outb(0x000c, 0x00);
31676                                           ! Debug: list int = const 0 (used reg = )
31677 904D           31C0                       xor	ax,ax
31678 904F           50                         push	ax
31679                                           ! Debug: list int = const $C (used reg = )
31680 9050           B8                   000C  mov	ax,*$C
31681 9053           50                         push	ax
31682                                           ! Debug: func () void = outb+0 (used reg = )
31683 9054           E8         7507            call	_outb
31684 9057           83C4                   04  add	sp,*4
31685                                           !BCC_EOS
31686                                           ! 4626       outb(0x0005, base_count);
31687                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
31688 905A           FF76         F6            push	-$A[bp]
31689                                           ! Debug: list int = const 5 (used reg = )
31690 905D           B8                   0005  mov	ax,*5
31691 9060           50                         push	ax
31692                                           ! Debug: func () void = outb+0 (used reg = )
31693 9061           E8         74FA            call	_outb
31694 9064           83C4                   04  add	sp,*4
31695                                           !BCC_EOS
31696                                           ! 4627       outb(0x0005, base_count>>8);
31697                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
31698 9067           8B46         F6            mov	ax,-$A[bp]
31699 906A           88E0                       mov	al,ah
31700 906C           30E4                       xor	ah,ah
31701                                           ! Debug: list unsigned int = ax+0 (used reg = )
31702 906E           50                         push	ax
31703                                           ! Debug: list int = const 5 (used reg = )
31704 906F           B8                   0005  mov	ax,*5
31705 9072           50                         push	ax
31706                                           ! Debug: func () void = outb+0 (used reg = )
31707 9073           E8         74E8            call	_outb
31708 9076           83C4                   04  add	sp,*4
31709                                           !BCC_EOS
31710                                           ! 4628       mode_register = 0x4a;
31711                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
31712 9079           B0                     4A  mov	al,*$4A
31713 907B           8846         F2            mov	-$E[bp],al
31714                                           !BCC_EOS
31715                                           ! 4629       outb(0x000b, mode_register);
31716                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
31717 907E           8A46         F2            mov	al,-$E[bp]
31718 9081           30E4                       xor	ah,ah
31719 9083           50                         push	ax
31720                                           ! Debug: list int = const $B (used reg = )
31721 9084           B8                   000B  mov	ax,*$B
31722 9087           50                         push	ax
31723                                           ! Debug: func () void = outb+0 (used reg = )
31724 9088           E8         74D3            call	_outb
31725 908B           83C4                   04  add	sp,*4
31726                                           !BCC_EOS
31727                                           ! 4630       outb(0x0081, page);
31728                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
31729 908E           8A46         F3            mov	al,-$D[bp]
31730 9091           30E4                       xor	ah,ah
31731 9093           50                         push	ax
31732                                           ! Debug: list int = const $81 (used reg = )
31733 9094           B8                   0081  mov	ax,#$81
31734 9097           50                         push	ax
31735                                           ! Debug: func () void = outb+0 (used reg = )
31736 9098           E8         74C3            call	_outb
31737 909B           83C4                   04  add	sp,*4
31738                                           !BCC_EOS
31739                                           ! 4631       outb(0x000a, 0x02);
31740                                           ! Debug: list int = const 2 (used reg = )
31741 909E           B8                   0002  mov	ax,*2
31742 90A1           50                         push	ax
31743                                           ! Debug: list int = const $A (used reg = )
31744 90A2           B8                   000A  mov	ax,*$A
31745 90A5           50                         push	ax
31746                                           ! Debug: func () void = outb+0 (used reg = )
31747 90A6           E8         74B5            call	_outb
31748 90A9           83C4                   04  add	sp,*4
31749                                           !BCC_EOS
31750                                           ! 4632       val8 = read_byte(0x0000, 0x043e);
31751                                           ! Debug: list int = const $43E (used reg = )
31752 90AC           B8                   043E  mov	ax,#$43E
31753 90AF           50                         push	ax
31754                                           ! Debug: list int = const 0 (used reg = )
31755 90B0           31C0                       xor	ax,ax
31756 90B2           50                         push	ax
31757                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31758 90B3           E8         7548            call	_read_byte
31759 90B6           83C4                   04  add	sp,*4
31760                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31761 90B9           8846         F1            mov	-$F[bp],al
31762                                           !BCC_EOS
31763                                           ! 4633       val8 &= 0x7f;
31764                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
31765 90BC           8A46         F1            mov	al,-$F[bp]
31766 90BF           24                     7F  and	al,*$7F
31767 90C1           8846         F1            mov	-$F[bp],al
31768                                           !BCC_EOS
31769                                           ! 4634       write_byte(0x0000, 0x043e, val8);
31770                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
31771 90C4           8A46         F1            mov	al,-$F[bp]
31772 90C7           30E4                       xor	ah,ah
31773 90C9           50                         push	ax
31774                                           ! Debug: list int = const $43E (used reg = )
31775 90CA           B8                   043E  mov	ax,#$43E
31776 90CD           50                         push	ax
31777                                           ! Debug: list int = const 0 (used reg = )
31778 90CE           31C0                       xor	ax,ax
31779 90D0           50                         push	ax
31780                                           ! Debug: func () void = write_byte+0 (used reg = )
31781 90D1           E8         7550            call	_write_byte
31782 90D4           83C4                   06  add	sp,*6
31783                                           !BCC_EOS
31784                                           ! 4635       if (drive)
31785 90D7           8A46         FF            mov	al,-1[bp]
31786 90DA           84C0                       test	al,al
31787 90DC           74           07            je  	.667
31788                       000090DE            .668:
31789                                           ! 4636         dor = 0x20;
31790                                           ! Debug: eq int = const $20 to unsigned char dor = [S+$20-$12] (used reg = )
31791 90DE           B0                     20  mov	al,*$20
31792 90E0           8846         F0            mov	-$10[bp],al
31793                                           !BCC_EOS
31794                                           ! 4637       else
31795                                           ! 4638         dor = 0x10;
31796 90E3           EB           05            jmp .669
31797                       000090E5            .667:
31798                                           ! Debug: eq int = const $10 to unsigned char dor = [S+$20-$12] (used reg = )
31799 90E5           B0                     10  mov	al,*$10
31800 90E7           8846         F0            mov	-$10[bp],al
31801                                           !BCC_EOS
31802                                           ! 4639       dor |= 0x0c;
31803                       000090EA            .669:
31804                                           ! Debug: orab int = const $C to unsigned char dor = [S+$20-$12] (used reg = )
31805 90EA           8A46         F0            mov	al,-$10[bp]
31806 90ED           0C                     0C  or	al,*$C
31807 90EF           8846         F0            mov	-$10[bp],al
31808                                           !BCC_EOS
31809                                           ! 4640       dor |= drive;
31810                                           ! Debug: orab unsigned char drive = [S+$20-3] to unsigned char dor = [S+$20-$12] (used reg = )
31811 90F2           8A46         F0            mov	al,-$10[bp]
31812 90F5           0A46         FF            or	al,-1[bp]
31813 90F8           8846         F0            mov	-$10[bp],al
31814                                           !BCC_EOS
31815                                           ! 4641       outb(0x03f2, dor);
31816                                           ! Debug: list unsigned char dor = [S+$20-$12] (used reg = )
31817 90FB           8A46         F0            mov	al,-$10[bp]
31818 90FE           30E4                       xor	ah,ah
31819 9100           50                         push	ax
31820                                           ! Debug: list int = const $3F2 (used reg = )
31821 9101           B8                   03F2  mov	ax,#$3F2
31822 9104           50                         push	ax
31823                                           ! Debug: func () void = outb+0 (used reg = )
31824 9105           E8         7456            call	_outb
31825 9108           83C4                   04  add	sp,*4
31826                                           !BCC_EOS
31827                                           ! 4642       write_byte(0x40,0x40, 37);
31828                                           ! Debug: list int = const $25 (used reg = )
31829 910B           B8                   0025  mov	ax,*$25
31830 910E           50                         push	ax
31831                                           ! Debug: list int = const $40 (used reg = )
31832 910F           B8                   0040  mov	ax,*$40
31833 9112           50                         push	ax
31834                                           ! Debug: list int = const $40 (used reg = )
31835 9113           B8                   0040  mov	ax,*$40
31836 9116           50                         push	ax
31837                                           ! Debug: func () void = write_byte+0 (used reg = )
31838 9117           E8         750A            call	_write_byte
31839 911A           83C4                   06  add	sp,*6
31840                                           !BCC_EOS
31841                                           ! 4643       val8 = inb(0x3f4);
31842                                           ! Debug: list int = const $3F4 (used reg = )
31843 911D           B8                   03F4  mov	ax,#$3F4
31844 9120           50                         push	ax
31845                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31846 9121           E8         7424            call	_inb
31847 9124           44                         inc	sp
31848 9125           44                         inc	sp
31849                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31850 9126           8846         F1            mov	-$F[bp],al
31851                                           !BCC_EOS
31852                                           ! 4644       if ( (val8 & 0xf0) != 0x80 )
31853                                           ! Debug: and int = const $F0 to unsigned char val8 = [S+$20-$11] (used reg = )
31854 9129           8A46         F1            mov	al,-$F[bp]
31855 912C           24                     F0  and	al,#$F0
31856                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
31857 912E           3C                     80  cmp	al,#$80
31858 9130           74           0E            je  	.66A
31859                       00009132            .66B:
31860                                           ! 4645         bios_printf((2 | 4 | 1), "int13_diskette:f05: ctrl not ready\n");
31861                                           ! Debug: list * char = .66C+0 (used reg = )
31862 9132           BB                   D10B  mov	bx,#.66C
31863 9135           53                         push	bx
31864                                           ! Debug: list int = const 7 (used reg = )
31865 9136           B8                   0007  mov	ax,*7
31866 9139           50                         push	ax
31867                                           ! Debug: func () void = bios_printf+0 (used reg = )
31868 913A           E8         776C            call	_bios_printf
31869 913D           83C4                   04  add	sp,*4
31870                                           !BCC_EOS
31871                                           ! 4646       outb(0x03f5, 0x4d);
31872                       00009140            .66A:
31873                                           ! Debug: list int = const $4D (used reg = )
31874 9140           B8                   004D  mov	ax,*$4D
31875 9143           50                         push	ax
31876                                           ! Debug: list int = const $3F5 (used reg = )
31877 9144           B8                   03F5  mov	ax,#$3F5
31878 9147           50                         push	ax
31879                                           ! Debug: func () void = outb+0 (used reg = )
31880 9148           E8         7413            call	_outb
31881 914B           83C4                   04  add	sp,*4
31882                                           !BCC_EOS
31883                                           ! 4647       outb(0x03f5, (head << 2) | drive);
31884                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
31885 914E           8A46         FB            mov	al,-5[bp]
31886 9151           30E4                       xor	ah,ah
31887 9153           D1E0                       shl	ax,*1
31888 9155           D1E0                       shl	ax,*1
31889                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
31890 9157           0A46         FF            or	al,-1[bp]
31891                                           ! Debug: list unsigned int = ax+0 (used reg = )
31892 915A           50                         push	ax
31893                                           ! Debug: list int = const $3F5 (used reg = )
31894 915B           B8                   03F5  mov	ax,#$3F5
31895 915E           50                         push	ax
31896                                           ! Debug: func () void = outb+0 (used reg = )
31897 915F           E8         73FC            call	_outb
31898 9162           83C4                   04  add	sp,*4
31899                                           !BCC_EOS
31900                                           ! 4648       outb(0x03f5, 2);
31901                                           ! Debug: list int = const 2 (used reg = )
31902 9165           B8                   0002  mov	ax,*2
31903 9168           50                         push	ax
31904                                           ! Debug: list int = const $3F5 (used reg = )
31905 9169           B8                   03F5  mov	ax,#$3F5
31906 916C           50                         push	ax
31907                                           ! Debug: func () void = outb+0 (used reg = )
31908 916D           E8         73EE            call	_outb
31909 9170           83C4                   04  add	sp,*4
31910                                           !BCC_EOS
31911                                           ! 4649       outb(0x03f5, num_sectors);
31912                                           ! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
31913 9173           8A46         FE            mov	al,-2[bp]
31914 9176           30E4                       xor	ah,ah
31915 9178           50                         push	ax
31916                                           ! Debug: list int = const $3F5 (used reg = )
31917 9179           B8                   03F5  mov	ax,#$3F5
31918 917C           50                         push	ax
31919                                           ! Debug: func () void = outb+0 (used reg = )
31920 917D           E8         73DE            call	_outb
31921 9180           83C4                   04  add	sp,*4
31922                                           !BCC_EOS
31923                                           ! 4650       outb(0x03f5, 0);
31924                                           ! Debug: list int = const 0 (used reg = )
31925 9183           31C0                       xor	ax,ax
31926 9185           50                         push	ax
31927                                           ! Debug: list int = const $3F5 (used reg = )
31928 9186           B8                   03F5  mov	ax,#$3F5
31929 9189           50                         push	ax
31930                                           ! Debug: func () void = outb+0 (used reg = )
31931 918A           E8         73D1            call	_outb
31932 918D           83C4                   04  add	sp,*4
31933                                           !BCC_EOS
31934                                           ! 4651       outb(0x03f5, 0xf6);
31935                                           ! Debug: list int = const $F6 (used reg = )
31936 9190           B8                   00F6  mov	ax,#$F6
31937 9193           50                         push	ax
31938                                           ! Debug: list int = const $3F5 (used reg = )
31939 9194           B8                   03F5  mov	ax,#$3F5
31940 9197           50                         push	ax
31941                                           ! Debug: func () void = outb+0 (used reg = )
31942 9198           E8         73C3            call	_outb
31943 919B           83C4                   04  add	sp,*4
31944                                           !BCC_EOS
31945                                           ! 4652 #asm
31946                                           !BCC_EOS
31947                                           !BCC_ASM
31948                       0000002A            _int13_diskette_function.BP	set	$2A
31949                       0000000C            .int13_diskette_function.BP	set	$C
31950                       00000038            _int13_diskette_function.CS	set	$38
31951                       0000001A            .int13_diskette_function.CS	set	$1A
31952                       00000032            _int13_diskette_function.CX	set	$32
31953                       00000014            .int13_diskette_function.CX	set	$14
31954                       00000016            _int13_diskette_function.base_address	set	$16
31955                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
31956                       00000026            _int13_diskette_function.DI	set	$26
31957                       00000008            .int13_diskette_function.DI	set	8
31958                       0000003A            _int13_diskette_function.FLAGS	set	$3A
31959                       0000001C            .int13_diskette_function.FLAGS	set	$1C
31960                       00000014            _int13_diskette_function.base_count	set	$14
31961                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
31962                       0000001A            _int13_diskette_function.sector	set	$1A
31963                       FFFFFFFC            .int13_diskette_function.sector	set	-4
31964                       00000022            _int13_diskette_function.DS	set	$22
31965                       00000004            .int13_diskette_function.DS	set	4
31966                       00000019            _int13_diskette_function.head	set	$19
31967                       FFFFFFFB            .int13_diskette_function.head	set	-5
31968                       0000002C            _int13_diskette_function.ELDX	set	$2C
31969                       0000000E            .int13_diskette_function.ELDX	set	$E
31970                       0000000E            _int13_diskette_function.dor	set	$E
31971                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
31972                       00000030            _int13_diskette_function.DX	set	$30
31973                       00000012            .int13_diskette_function.DX	set	$12
31974                       00000007            _int13_diskette_function.return_status	set	7
31975                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
31976                       00000002            _int13_diskette_function.es	set	2
31977                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
31978                       00000010            _int13_diskette_function.mode_register	set	$10
31979                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
31980                       00000024            _int13_diskette_function.ES	set	$24
31981                       00000006            .int13_diskette_function.ES	set	6
31982                       00000012            _int13_diskette_function.base_es	set	$12
31983                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
31984                       0000001B            _int13_diskette_function.track	set	$1B
31985                       FFFFFFFD            .int13_diskette_function.track	set	-3
31986                       00000028            _int13_diskette_function.SI	set	$28
31987                       0000000A            .int13_diskette_function.SI	set	$A
31988                       00000006            _int13_diskette_function.drive_type	set	6
31989                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
31990                       0000001C            _int13_diskette_function.num_sectors	set	$1C
31991                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
31992                       00000036            _int13_diskette_function.IP	set	$36
31993                       00000018            .int13_diskette_function.IP	set	$18
31994                       00000018            _int13_diskette_function.status	set	$18
31995                       FFFFFFFA            .int13_diskette_function.status	set	-6
31996                       00000034            _int13_diskette_function.AX	set	$34
31997                       00000016            .int13_diskette_function.AX	set	$16
31998                       0000000F            _int13_diskette_function.val8	set	$F
31999                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32000                       00000000            _int13_diskette_function.last_addr	set	0
32001                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32002                       00000011            _int13_diskette_function.page	set	$11
32003                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32004                       00000004            _int13_diskette_function.ah	set	4
32005                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32006                       0000001D            _int13_diskette_function.drive	set	$1D
32007                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32008                       00000005            _int13_diskette_function.num_floppies	set	5
32009                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32010                       0000002E            _int13_diskette_function.BX	set	$2E
32011                       00000010            .int13_diskette_function.BX	set	$10
32012 919E           FB                               sti
32013                                           ! 4654 endasm
32014                                           !BCC_ENDASM
32015                                           !BCC_EOS
32016                                           ! 4655       val8 = (read_byte(0x0000, 0x043e) & 0x80);
32017                                           ! Debug: list int = const $43E (used reg = )
32018 919F           B8                   043E  mov	ax,#$43E
32019 91A2           50                         push	ax
32020                                           ! Debug: list int = const 0 (used reg = )
32021 91A3           31C0                       xor	ax,ax
32022 91A5           50                         push	ax
32023                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32024 91A6           E8         7455            call	_read_byte
32025 91A9           83C4                   04  add	sp,*4
32026                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
32027 91AC           24                     80  and	al,#$80
32028                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32029 91AE           8846         F1            mov	-$F[bp],al
32030                                           !BCC_EOS
32031                                           ! 4656       while ( val8 == 0 ) {
32032 91B1           EB           12            jmp .66E
32033                       000091B3            .66F:
32034                                           ! 4657         val8 = (read_byte(0x0000, 0x043e) & 0x80);
32035                                           ! Debug: list int = const $43E (used reg = )
32036 91B3           B8                   043E  mov	ax,#$43E
32037 91B6           50                         push	ax
32038                                           ! Debug: list int = const 0 (used reg = )
32039 91B7           31C0                       xor	ax,ax
32040 91B9           50                         push	ax
32041                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32042 91BA           E8         7441            call	_read_byte
32043 91BD           83C4                   04  add	sp,*4
32044                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
32045 91C0           24                     80  and	al,#$80
32046                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32047 91C2           8846         F1            mov	-$F[bp],al
32048                                           !BCC_EOS
32049                                           ! 4658         }
32050                                           ! 4659      val8 = 0;
32051                       000091C5            .66E:
32052                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32053 91C5           8A46         F1            mov	al,-$F[bp]
32054 91C8           84C0                       test	al,al
32055 91CA           74           E7            je 	.66F
32056                       000091CC            .670:
32057                       000091CC            .66D:
32058                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32059 91CC           30C0                       xor	al,al
32060 91CE           8846         F1            mov	-$F[bp],al
32061                                           !BCC_EOS
32062                                           ! 4660 #asm
32063                                           !BCC_EOS
32064                                           !BCC_ASM
32065                       0000002A            _int13_diskette_function.BP	set	$2A
32066                       0000000C            .int13_diskette_function.BP	set	$C
32067                       00000038            _int13_diskette_function.CS	set	$38
32068                       0000001A            .int13_diskette_function.CS	set	$1A
32069                       00000032            _int13_diskette_function.CX	set	$32
32070                       00000014            .int13_diskette_function.CX	set	$14
32071                       00000016            _int13_diskette_function.base_address	set	$16
32072                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32073                       00000026            _int13_diskette_function.DI	set	$26
32074                       00000008            .int13_diskette_function.DI	set	8
32075                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32076                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32077                       00000014            _int13_diskette_function.base_count	set	$14
32078                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32079                       0000001A            _int13_diskette_function.sector	set	$1A
32080                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32081                       00000022            _int13_diskette_function.DS	set	$22
32082                       00000004            .int13_diskette_function.DS	set	4
32083                       00000019            _int13_diskette_function.head	set	$19
32084                       FFFFFFFB            .int13_diskette_function.head	set	-5
32085                       0000002C            _int13_diskette_function.ELDX	set	$2C
32086                       0000000E            .int13_diskette_function.ELDX	set	$E
32087                       0000000E            _int13_diskette_function.dor	set	$E
32088                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32089                       00000030            _int13_diskette_function.DX	set	$30
32090                       00000012            .int13_diskette_function.DX	set	$12
32091                       00000007            _int13_diskette_function.return_status	set	7
32092                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32093                       00000002            _int13_diskette_function.es	set	2
32094                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32095                       00000010            _int13_diskette_function.mode_register	set	$10
32096                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32097                       00000024            _int13_diskette_function.ES	set	$24
32098                       00000006            .int13_diskette_function.ES	set	6
32099                       00000012            _int13_diskette_function.base_es	set	$12
32100                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32101                       0000001B            _int13_diskette_function.track	set	$1B
32102                       FFFFFFFD            .int13_diskette_function.track	set	-3
32103                       00000028            _int13_diskette_function.SI	set	$28
32104                       0000000A            .int13_diskette_function.SI	set	$A
32105                       00000006            _int13_diskette_function.drive_type	set	6
32106                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32107                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32108                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32109                       00000036            _int13_diskette_function.IP	set	$36
32110                       00000018            .int13_diskette_function.IP	set	$18
32111                       00000018            _int13_diskette_function.status	set	$18
32112                       FFFFFFFA            .int13_diskette_function.status	set	-6
32113                       00000034            _int13_diskette_function.AX	set	$34
32114                       00000016            .int13_diskette_function.AX	set	$16
32115                       0000000F            _int13_diskette_function.val8	set	$F
32116                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32117                       00000000            _int13_diskette_function.last_addr	set	0
32118                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32119                       00000011            _int13_diskette_function.page	set	$11
32120                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32121                       00000004            _int13_diskette_function.ah	set	4
32122                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32123                       0000001D            _int13_diskette_function.drive	set	$1D
32124                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32125                       00000005            _int13_diskette_function.num_floppies	set	5
32126                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32127                       0000002E            _int13_diskette_function.BX	set	$2E
32128                       00000010            .int13_diskette_function.BX	set	$10
32129 91D1           FA                               cli
32130                                           ! 4662 endasm
32131                                           !BCC_ENDASM
32132                                           !BCC_EOS
32133                                           ! 4663       val8 = read_byte(0x0000, 0x043e);
32134                                           ! Debug: list int = const $43E (used reg = )
32135 91D2           B8                   043E  mov	ax,#$43E
32136 91D5           50                         push	ax
32137                                           ! Debug: list int = const 0 (used reg = )
32138 91D6           31C0                       xor	ax,ax
32139 91D8           50                         push	ax
32140                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32141 91D9           E8         7422            call	_read_byte
32142 91DC           83C4                   04  add	sp,*4
32143                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32144 91DF           8846         F1            mov	-$F[bp],al
32145                                           !BCC_EOS
32146                                           ! 4664       val8 &= 0x7f;
32147                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
32148 91E2           8A46         F1            mov	al,-$F[bp]
32149 91E5           24                     7F  and	al,*$7F
32150 91E7           8846         F1            mov	-$F[bp],al
32151                                           !BCC_EOS
32152                                           ! 4665       write_byte(0x0000, 0x043e, val8);
32153                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
32154 91EA           8A46         F1            mov	al,-$F[bp]
32155 91ED           30E4                       xor	ah,ah
32156 91EF           50                         push	ax
32157                                           ! Debug: list int = const $43E (used reg = )
32158 91F0           B8                   043E  mov	ax,#$43E
32159 91F3           50                         push	ax
32160                                           ! Debug: list int = const 0 (used reg = )
32161 91F4           31C0                       xor	ax,ax
32162 91F6           50                         push	ax
32163                                           ! Debug: func () void = write_byte+0 (used reg = )
32164 91F7           E8         742A            call	_write_byte
32165 91FA           83C4                   06  add	sp,*6
32166                                           !BCC_EOS
32167                                           ! 4666       val8 = inb(0x3f4);
32168                                           ! Debug: list int = const $3F4 (used reg = )
32169 91FD           B8                   03F4  mov	ax,#$3F4
32170 9200           50                         push	ax
32171                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32172 9201           E8         7344            call	_inb
32173 9204           44                         inc	sp
32174 9205           44                         inc	sp
32175                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32176 9206           8846         F1            mov	-$F[bp],al
32177                                           !BCC_EOS
32178                                           ! 4667       if ( (val8 & 0xc0) != 0xc0 )
32179                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
32180 9209           8A46         F1            mov	al,-$F[bp]
32181 920C           24                     C0  and	al,#$C0
32182                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
32183 920E           3C                     C0  cmp	al,#$C0
32184 9210           74           0E            je  	.671
32185                       00009212            .672:
32186                                           ! 4668         bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
32187                                           ! Debug: list * char = .673+0 (used reg = )
32188 9212           BB                   D0EB  mov	bx,#.673
32189 9215           53                         push	bx
32190                                           ! Debug: list int = const 7 (used reg = )
32191 9216           B8                   0007  mov	ax,*7
32192 9219           50                         push	ax
32193                                           ! Debug: func () void = bios_printf+0 (used reg = )
32194 921A           E8         768C            call	_bios_printf
32195 921D           83C4                   04  add	sp,*4
32196                                           !BCC_EOS
32197                                           ! 4669       return_status[0] = inb(0x3f5);
32198                       00009220            .671:
32199                                           ! Debug: list int = const $3F5 (used reg = )
32200 9220           B8                   03F5  mov	ax,#$3F5
32201 9223           50                         push	ax
32202                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32203 9224           E8         7321            call	_inb
32204 9227           44                         inc	sp
32205 9228           44                         inc	sp
32206                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
32207 9229           8846         E9            mov	-$17[bp],al
32208                                           !BCC_EOS
32209                                           ! 4670       return_status[1] = inb(0x3f5);
32210                                           ! Debug: list int = const $3F5 (used reg = )
32211 922C           B8                   03F5  mov	ax,#$3F5
32212 922F           50                         push	ax
32213                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32214 9230           E8         7315            call	_inb
32215 9233           44                         inc	sp
32216 9234           44                         inc	sp
32217                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
32218 9235           8846         EA            mov	-$16[bp],al
32219                                           !BCC_EOS
32220                                           ! 4671       return_status[2] 
32221                                           ! 4671 = inb(0x3f5);
32222                                           ! Debug: list int = const $3F5 (used reg = )
32223 9238           B8                   03F5  mov	ax,#$3F5
32224 923B           50                         push	ax
32225                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32226 923C           E8         7309            call	_inb
32227 923F           44                         inc	sp
32228 9240           44                         inc	sp
32229                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
32230 9241           8846         EB            mov	-$15[bp],al
32231                                           !BCC_EOS
32232                                           ! 4672       return_status[3] = inb(0x3f5);
32233                                           ! Debug: list int = const $3F5 (used reg = )
32234 9244           B8                   03F5  mov	ax,#$3F5
32235 9247           50                         push	ax
32236                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32237 9248           E8         72FD            call	_inb
32238 924B           44                         inc	sp
32239 924C           44                         inc	sp
32240                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
32241 924D           8846         EC            mov	-$14[bp],al
32242                                           !BCC_EOS
32243                                           ! 4673       return_status[4] = inb(0x3f5);
32244                                           ! Debug: list int = const $3F5 (used reg = )
32245 9250           B8                   03F5  mov	ax,#$3F5
32246 9253           50                         push	ax
32247                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32248 9254           E8         72F1            call	_inb
32249 9257           44                         inc	sp
32250 9258           44                         inc	sp
32251                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
32252 9259           8846         ED            mov	-$13[bp],al
32253                                           !BCC_EOS
32254                                           ! 4674       return_status[5] = inb(0x3f5);
32255                                           ! Debug: list int = const $3F5 (used reg = )
32256 925C           B8                   03F5  mov	ax,#$3F5
32257 925F           50                         push	ax
32258                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32259 9260           E8         72E5            call	_inb
32260 9263           44                         inc	sp
32261 9264           44                         inc	sp
32262                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
32263 9265           8846         EE            mov	-$12[bp],al
32264                                           !BCC_EOS
32265                                           ! 4675       return_status[6] = inb(0x3f5);
32266                                           ! Debug: list int = const $3F5 (used reg = )
32267 9268           B8                   03F5  mov	ax,#$3F5
32268 926B           50                         push	ax
32269                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32270 926C           E8         72D9            call	_inb
32271 926F           44                         inc	sp
32272 9270           44                         inc	sp
32273                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
32274 9271           8846         EF            mov	-$11[bp],al
32275                                           !BCC_EOS
32276                                           ! 4676       write_byte(0x0040, 0x0042, return_status[0]);
32277                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
32278 9274           8A46         E9            mov	al,-$17[bp]
32279 9277           30E4                       xor	ah,ah
32280 9279           50                         push	ax
32281                                           ! Debug: list int = const $42 (used reg = )
32282 927A           B8                   0042  mov	ax,*$42
32283 927D           50                         push	ax
32284                                           ! Debug: list int = const $40 (used reg = )
32285 927E           B8                   0040  mov	ax,*$40
32286 9281           50                         push	ax
32287                                           ! Debug: func () void = write_byte+0 (used reg = )
32288 9282           E8         739F            call	_write_byte
32289 9285           83C4                   06  add	sp,*6
32290                                           !BCC_EOS
32291                                           ! 4677       write_byte(0x0040, 0x0043, return_status[1]);
32292                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
32293 9288           8A46         EA            mov	al,-$16[bp]
32294 928B           30E4                       xor	ah,ah
32295 928D           50                         push	ax
32296                                           ! Debug: list int = const $43 (used reg = )
32297 928E           B8                   0043  mov	ax,*$43
32298 9291           50                         push	ax
32299                                           ! Debug: list int = const $40 (used reg = )
32300 9292           B8                   0040  mov	ax,*$40
32301 9295           50                         push	ax
32302                                           ! Debug: func () void = write_byte+0 (used reg = )
32303 9296           E8         738B            call	_write_byte
32304 9299           83C4                   06  add	sp,*6
32305                                           !BCC_EOS
32306                                           ! 4678       write_byte(0x0040, 0x0044, return_status[2]);
32307                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
32308 929C           8A46         EB            mov	al,-$15[bp]
32309 929F           30E4                       xor	ah,ah
32310 92A1           50                         push	ax
32311                                           ! Debug: list int = const $44 (used reg = )
32312 92A2           B8                   0044  mov	ax,*$44
32313 92A5           50                         push	ax
32314                                           ! Debug: list int = const $40 (used reg = )
32315 92A6           B8                   0040  mov	ax,*$40
32316 92A9           50                         push	ax
32317                                           ! Debug: func () void = write_byte+0 (used reg = )
32318 92AA           E8         7377            call	_write_byte
32319 92AD           83C4                   06  add	sp,*6
32320                                           !BCC_EOS
32321                                           ! 4679       write_byte(0x0040, 0x0045, return_status[3]);
32322                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
32323 92B0           8A46         EC            mov	al,-$14[bp]
32324 92B3           30E4                       xor	ah,ah
32325 92B5           50                         push	ax
32326                                           ! Debug: list int = const $45 (used reg = )
32327 92B6           B8                   0045  mov	ax,*$45
32328 92B9           50                         push	ax
32329                                           ! Debug: list int = const $40 (used reg = )
32330 92BA           B8                   0040  mov	ax,*$40
32331 92BD           50                         push	ax
32332                                           ! Debug: func () void = write_byte+0 (used reg = )
32333 92BE           E8         7363            call	_write_byte
32334 92C1           83C4                   06  add	sp,*6
32335                                           !BCC_EOS
32336                                           ! 4680       write_byte(0x0040, 0x0046, return_status[4]);
32337                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
32338 92C4           8A46         ED            mov	al,-$13[bp]
32339 92C7           30E4                       xor	ah,ah
32340 92C9           50                         push	ax
32341                                           ! Debug: list int = const $46 (used reg = )
32342 92CA           B8                   0046  mov	ax,*$46
32343 92CD           50                         push	ax
32344                                           ! Debug: list int = const $40 (used reg = )
32345 92CE           B8                   0040  mov	ax,*$40
32346 92D1           50                         push	ax
32347                                           ! Debug: func () void = write_byte+0 (used reg = )
32348 92D2           E8         734F            call	_write_byte
32349 92D5           83C4                   06  add	sp,*6
32350                                           !BCC_EOS
32351                                           ! 4681       write_byte(0x0040, 0x0047, return_status[5]);
32352                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
32353 92D8           8A46         EE            mov	al,-$12[bp]
32354 92DB           30E4                       xor	ah,ah
32355 92DD           50                         push	ax
32356                                           ! Debug: list int = const $47 (used reg = )
32357 92DE           B8                   0047  mov	ax,*$47
32358 92E1           50                         push	ax
32359                                           ! Debug: list int = const $40 (used reg = )
32360 92E2           B8                   0040  mov	ax,*$40
32361 92E5           50                         push	ax
32362                                           ! Debug: func () void = write_byte+0 (used reg = )
32363 92E6           E8         733B            call	_write_byte
32364 92E9           83C4                   06  add	sp,*6
32365                                           !BCC_EOS
32366                                           ! 4682       write_byte(0x0040, 0x0048, return_status[6]);
32367                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
32368 92EC           8A46         EF            mov	al,-$11[bp]
32369 92EF           30E4                       xor	ah,ah
32370 92F1           50                         push	ax
32371                                           ! Debug: list int = const $48 (used reg = )
32372 92F2           B8                   0048  mov	ax,*$48
32373 92F5           50                         push	ax
32374                                           ! Debug: list int = const $40 (used reg = )
32375 92F6           B8                   0040  mov	ax,*$40
32376 92F9           50                         push	ax
32377                                           ! Debug: func () void = write_byte+0 (used reg = )
32378 92FA           E8         7327            call	_write_byte
32379 92FD           83C4                   06  add	sp,*6
32380                                           !BCC_EOS
32381                                           ! 4683       if ( (return_status[0] & 0xc0) != 0 ) {
32382                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
32383 9300           8A46         E9            mov	al,-$17[bp]
32384 9303           24                     C0  and	al,#$C0
32385                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32386 9305           84C0                       test	al,al
32387 9307           74           2B            je  	.674
32388                       00009309            .675:
32389                                           ! 4684         if ( (return_status[1] & 0x02) != 0 ) {
32390                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
32391 9309           8A46         EA            mov	al,-$16[bp]
32392 930C           24                     02  and	al,*2
32393                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32394 930E           84C0                       test	al,al
32395 9310           74           14            je  	.676
32396                       00009312            .677:
32397                                           ! 4685           AX = 0x0300;
32398                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
32399 9312           B8                   0300  mov	ax,#$300
32400 9315           8946         16            mov	$16[bp],ax
32401                                           !BCC_EOS
32402                                           ! 4686           FLAGS |= 0x0001;
32403                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32404 9318           8B46         1C            mov	ax,$1C[bp]
32405 931B           0C                     01  or	al,*1
32406 931D           8946         1C            mov	$1C[bp],ax
32407                                           !BCC_EOS
32408                                           ! 4687           return;
32409 9320           89EC                       mov	sp,bp
32410 9322           5D                         pop	bp
32411 9323           C3                         ret
32412                                           !BCC_EOS
32413                                           ! 4688         } else {
32414 9324           EB           0E            jmp .678
32415                       00009326            .676:
32416                                           ! 4689           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
32417                                           ! Debug: list * char = .679+0 (used reg = )
32418 9326           BB                   D0C5  mov	bx,#.679
32419 9329           53                         push	bx
32420                                           ! Debug: list int = const 7 (used reg = )
32421 932A           B8                   0007  mov	ax,*7
32422 932D           50                         push	ax
32423                                           ! Debug: func () void = bios_printf+0 (used reg = )
32424 932E           E8         7578            call	_bios_printf
32425 9331           83C4                   04  add	sp,*4
32426                                           !BCC_EOS
32427                                           ! 4690         }
32428                                           ! 4691       }
32429                       00009334            .678:
32430                                           ! 4692       AX = ((AX & 0x00ff) | ((0) << 8));
32431                       00009334            .674:
32432                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32433 9334           8A46         16            mov	al,$16[bp]
32434                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32435 9337           0C                     00  or	al,*0
32436                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
32437 9339           30E4                       xor	ah,ah
32438 933B           8946         16            mov	$16[bp],ax
32439                                           !BCC_EOS
32440                                           ! 4693       set_diskette_ret_status(0);
32441                                           ! Debug: list int = const 0 (used reg = )
32442 933E           31C0                       xor	ax,ax
32443 9340           50                         push	ax
32444                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32445 9341           E8         0361            call	_set_diskette_ret_status
32446 9344           44                         inc	sp
32447 9345           44                         inc	sp
32448                                           !BCC_EOS
32449                                           ! 4694       set_diskette_current_cyl(drive, 0);
32450                                           ! Debug: list int = const 0 (used reg = )
32451 9346           31C0                       xor	ax,ax
32452 9348           50                         push	ax
32453                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
32454 9349           8A46         FF            mov	al,-1[bp]
32455 934C           30E4                       xor	ah,ah
32456 934E           50                         push	ax
32457                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
32458 934F           E8         036B            call	_set_diskette_current_cyl
32459 9352           83C4                   04  add	sp,*4
32460                                           !BCC_EOS
32461                                           ! 4695       FLAGS &= 0xfffe;
32462                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32463 9355           8B46         1C            mov	ax,$1C[bp]
32464 9358           24                     FE  and	al,#$FE
32465 935A           8946         1C            mov	$1C[bp],ax
32466                                           !BCC_EOS
32467                                           ! 4696       return;
32468 935D           89EC                       mov	sp,bp
32469 935F           5D                         pop	bp
32470 9360           C3                         ret
32471                                           !BCC_EOS
32472                                           ! 4697     case 0x08:
32473                                           ! 4698 ;
32474                       00009361            .67A:
32475                                           !BCC_EOS
32476                                           ! 4699       drive = ( ELDX & 0x00ff );
32477                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
32478 9361           8A46         0E            mov	al,$E[bp]
32479                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
32480 9364           8846         FF            mov	-1[bp],al
32481                                           !BCC_EOS
32482                                           ! 4700       if (drive > 1) {
32483                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
32484 9367           8A46         FF            mov	al,-1[bp]
32485 936A           3C                     01  cmp	al,*1
32486 936C           76           35            jbe 	.67B
32487                       0000936E            .67C:
32488                                           ! 4701         AX = 0;
32489                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
32490 936E           31C0                       xor	ax,ax
32491 9370           8946         16            mov	$16[bp],ax
32492                                           !BCC_EOS
32493                                           ! 4702         BX = 0;
32494                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
32495 9373           31C0                       xor	ax,ax
32496 9375           8946         10            mov	$10[bp],ax
32497                                           !BCC_EOS
32498                                           ! 4703         CX = 0;
32499                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
32500 9378           31C0                       xor	ax,ax
32501 937A           8946         14            mov	$14[bp],ax
32502                                           !BCC_EOS
32503                                           ! 4704         DX = 0;
32504                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
32505 937D           31C0                       xor	ax,ax
32506 937F           8946         12            mov	$12[bp],ax
32507                                           !BCC_EOS
32508                                           ! 4705         ES = 0;
32509                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
32510 9382           31C0                       xor	ax,ax
32511 9384           8946         06            mov	6[bp],ax
32512                                           !BCC_EOS
32513                                           ! 4706         DI = 0;
32514                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
32515 9387           31C0                       xor	ax,ax
32516 9389           8946         08            mov	8[bp],ax
32517                                           !BCC_EOS
32518                                           ! 4707         DX = ((DX & 0xff00) | (num_floppies));
32519                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
32520 938C           8B46         12            mov	ax,$12[bp]
32521 938F           30C0                       xor	al,al
32522                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
32523 9391           0A46         E7            or	al,-$19[bp]
32524                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
32525 9394           8946         12            mov	$12[bp],ax
32526                                           !BCC_EOS
32527                                           ! 4708         FLAGS |= 0x0001;
32528                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32529 9397           8B46         1C            mov	ax,$1C[bp]
32530 939A           0C                     01  or	al,*1
32531 939C           8946         1C            mov	$1C[bp],ax
32532                                           !BCC_EOS
32533                                           ! 4709         return;
32534 939F           89EC                       mov	sp,bp
32535 93A1           5D                         pop	bp
32536 93A2           C3                         ret
32537                                           !BCC_EOS
32538                                           ! 4710         }
32539                                           ! 4711       drive_type = inb_cmos(0x10);
32540                       000093A3            .67B:
32541                                           ! Debug: list int = const $10 (used reg = )
32542 93A3           B8                   0010  mov	ax,*$10
32543 93A6           50                         push	ax
32544                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32545 93A7           E8         71E3            call	_inb_cmos
32546 93AA           44                         inc	sp
32547 93AB           44                         inc	sp
32548                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
32549 93AC           8846         E8            mov	-$18[bp],al
32550                                           !BCC_EOS
32551                                           ! 4712       num_floppies = 0;
32552                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
32553 93AF           30C0                       xor	al,al
32554 93B1           8846         E7            mov	-$19[bp],al
32555                                           !BCC_EOS
32556                                           ! 4713       if (drive_type & 0xf0)
32557                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
32558 93B4           8A46         E8            mov	al,-$18[bp]
32559 93B7           24                     F0  and	al,#$F0
32560 93B9           84C0                       test	al,al
32561 93BB           74           07            je  	.67D
32562                       000093BD            .67E:
32563                                           ! 4714         num_floppies++;
32564                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
32565 93BD           8A46         E7            mov	al,-$19[bp]
32566 93C0           40                         inc	ax
32567 93C1           8846         E7            mov	-$19[bp],al
32568                                           !BCC_EOS
32569                                           ! 4715       if (drive_type & 0x0f)
32570                       000093C4            .67D:
32571                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
32572 93C4           8A46         E8            mov	al,-$18[bp]
32573 93C7           24                     0F  and	al,*$F
32574 93C9           84C0                       test	al,al
32575 93CB           74           07            je  	.67F
32576                       000093CD            .680:
32577                                           ! 4716         num_floppies++;
32578                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
32579 93CD           8A46         E7            mov	al,-$19[bp]
32580 93D0           40                         inc	ax
32581 93D1           8846         E7            mov	-$19[bp],al
32582                                           !BCC_EOS
32583                                           ! 4717       if (drive == 0)
32584                       000093D4            .67F:
32585                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
32586 93D4           8A46         FF            mov	al,-1[bp]
32587 93D7           84C0                       test	al,al
32588 93D9           75           0E            jne 	.681
32589                       000093DB            .682:
32590                                           ! 4718         drive_type >>= 4;
32591                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
32592 93DB           8A46         E8            mov	al,-$18[bp]
32593 93DE           30E4                       xor	ah,ah
32594 93E0           B1                     04  mov	cl,*4
32595 93E2           D3E8                       shr	ax,cl
32596 93E4           8846         E8            mov	-$18[bp],al
32597                                           !BCC_EOS
32598                                           ! 4719       else
32599                                           ! 4720         drive_type &= 0x0f;
32600 93E7           EB           08            jmp .683
32601                       000093E9            .681:
32602                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
32603 93E9           8A46         E8            mov	al,-$18[bp]
32604 93EC           24                     0F  and	al,*$F
32605 93EE           8846         E8            mov	-$18[bp],al
32606                                           !BCC_EOS
32607                                           ! 4721       BX = ((BX & 0x00ff) | ((0) << 8));
32608                       000093F1            .683:
32609                                           ! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
32610 93F1           8A46         10            mov	al,$10[bp]
32611                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32612 93F4           0C                     00  or	al,*0
32613                                           ! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
32614 93F6           30E4                       xor	ah,ah
32615 93F8           8946         10            mov	$10[bp],ax
32616                                           !BCC_EOS
32617                                           ! 4722       BX = ((BX & 0xff00) | (drive_type));
32618                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
32619 93FB           8B46         10            mov	ax,$10[bp]
32620 93FE           30C0                       xor	al,al
32621                                           ! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
32622 9400           0A46         E8            or	al,-$18[bp]
32623                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
32624 9403           8946         10            mov	$10[bp],ax
32625                                           !BCC_EOS
32626                                           ! 4723       AX = ((AX & 0x00ff) | ((0) << 8));
32627                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32628 9406           8A46         16            mov	al,$16[bp]
32629                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32630 9409           0C                     00  or	al,*0
32631                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
32632 940B           30E4                       xor	ah,ah
32633 940D           8946         16            mov	$16[bp],ax
32634                                           !BCC_EOS
32635                                           ! 4724       AX = ((AX & 0xff00) | (0));
32636                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32637 9410           8B46         16            mov	ax,$16[bp]
32638 9413           30C0                       xor	al,al
32639                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32640 9415           0C                     00  or	al,*0
32641                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32642 9417           8946         16            mov	$16[bp],ax
32643                                           !BCC_EOS
32644                                           ! 4725       DX = ((DX & 0xff00) | (num_floppies));
32645                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
32646 941A           8B46         12            mov	ax,$12[bp]
32647 941D           30C0                       xor	al,al
32648                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
32649 941F           0A46         E7            or	al,-$19[bp]
32650                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
32651 9422           8946         12            mov	$12[bp],ax
32652                                           !BCC_EOS
32653                                           ! 4726       switch (drive_type) {
32654 9425           8A46         E8            mov	al,-$18[bp]
32655 9428           E9         00BC            br 	.686
32656                                           ! 4727         case 0:
32657                                           ! 4728           CX = 0;
32658                       0000942B            .687:
32659                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
32660 942B           31C0                       xor	ax,ax
32661 942D           8946         14            mov	$14[bp],ax
32662                                           !BCC_EOS
32663                                           ! 4729           DX = ((DX & 0x00ff) | ((0) << 8));
32664                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
32665 9430           8A46         12            mov	al,$12[bp]
32666                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32667 9433           0C                     00  or	al,*0
32668                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
32669 9435           30E4                       xor	ah,ah
32670 9437           8946         12            mov	$12[bp],ax
32671                                           !BCC_EOS
32672                                           ! 4730           break;
32673 943A           E9         00D1            br 	.684
32674                                           !BCC_EOS
32675                                           ! 4731         case 1:
32676                                           ! 4732           CX = 0x2709;
32677                       0000943D            .688:
32678                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
32679 943D           B8                   2709  mov	ax,#$2709
32680 9440           8946         14            mov	$14[bp],ax
32681                                           !BCC_EOS
32682                                           ! 4733           DX = ((DX & 0x00ff) | ((1) << 8));
32683                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
32684 9443           8A46         12            mov	al,$12[bp]
32685                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
32686 9446           30E4                       xor	ah,ah
32687 9448           0D                   0100  or	ax,#$100
32688                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
32689 944B           8946         12            mov	$12[bp],ax
32690                                           !BCC_EOS
32691                                           ! 4734           break;
32692 944E           E9         00BD            br 	.684
32693                                           !BCC_EOS
32694                                           ! 4735         case 2:
32695                                           ! 4736           CX = 0x4f0f;
32696                       00009451            .689:
32697                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
32698 9451           B8                   4F0F  mov	ax,#$4F0F
32699 9454           8946         14            mov	$14[bp],ax
32700                                           !BCC_EOS
32701                                           ! 4737           DX = ((DX & 0x00ff) | ((1) << 8));
32702                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
32703 9457           8A46         12            mov	al,$12[bp]
32704                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
32705 945A           30E4                       xor	ah,ah
32706 945C           0D                   0100  or	ax,#$100
32707                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
32708 945F           8946         12            mov	$12[bp],ax
32709                                           !BCC_EOS
32710                                           ! 4738           break;
32711 9462           E9         00A9            br 	.684
32712                                           !BCC_EOS
32713                                           ! 4739         case 3:
32714                                           ! 4740           CX = 0x4f09;
32715                       00009465            .68A:
32716                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
32717 9465           B8                   4F09  mov	ax,#$4F09
32718 9468           8946         14            mov	$14[bp],ax
32719                                           !BCC_EOS
32720                                           ! 4741      
32721                                           ! 4741      DX = ((DX & 0x00ff) | ((1) << 8));
32722                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
32723 946B           8A46         12            mov	al,$12[bp]
32724                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
32725 946E           30E4                       xor	ah,ah
32726 9470           0D                   0100  or	ax,#$100
32727                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
32728 9473           8946         12            mov	$12[bp],ax
32729                                           !BCC_EOS
32730                                           ! 4742           break;
32731 9476           E9         0095            br 	.684
32732                                           !BCC_EOS
32733                                           ! 4743         case 4:
32734                                           ! 4744           CX = 0x4f12;
32735                       00009479            .68B:
32736                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
32737 9479           B8                   4F12  mov	ax,#$4F12
32738 947C           8946         14            mov	$14[bp],ax
32739                                           !BCC_EOS
32740                                           ! 4745           DX = ((DX & 0x00ff) | ((1) << 8));
32741                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
32742 947F           8A46         12            mov	al,$12[bp]
32743                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
32744 9482           30E4                       xor	ah,ah
32745 9484           0D                   0100  or	ax,#$100
32746                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
32747 9487           8946         12            mov	$12[bp],ax
32748                                           !BCC_EOS
32749                                           ! 4746           break;
32750 948A           E9         0081            br 	.684
32751                                           !BCC_EOS
32752                                           ! 4747         case 5:
32753                                           ! 4748           CX = 0x4f24;
32754                       0000948D            .68C:
32755                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
32756 948D           B8                   4F24  mov	ax,#$4F24
32757 9490           8946         14            mov	$14[bp],ax
32758                                           !BCC_EOS
32759                                           ! 4749           DX = ((DX & 0x00ff) | ((1) << 8));
32760                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
32761 9493           8A46         12            mov	al,$12[bp]
32762                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
32763 9496           30E4                       xor	ah,ah
32764 9498           0D                   0100  or	ax,#$100
32765                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
32766 949B           8946         12            mov	$12[bp],ax
32767                                           !BCC_EOS
32768                                           ! 4750           break;
32769 949E           EB           6E            jmp .684
32770                                           !BCC_EOS
32771                                           ! 4751         case 6:
32772                                           ! 4752           CX = 0x2708;
32773                       000094A0            .68D:
32774                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
32775 94A0           B8                   2708  mov	ax,#$2708
32776 94A3           8946         14            mov	$14[bp],ax
32777                                           !BCC_EOS
32778                                           ! 4753           DX = ((DX & 0x00ff) | ((0) << 8));
32779                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
32780 94A6           8A46         12            mov	al,$12[bp]
32781                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32782 94A9           0C                     00  or	al,*0
32783                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
32784 94AB           30E4                       xor	ah,ah
32785 94AD           8946         12            mov	$12[bp],ax
32786                                           !BCC_EOS
32787                                           ! 4754           break;
32788 94B0           EB           5C            jmp .684
32789                                           !BCC_EOS
32790                                           ! 4755         case 7:
32791                                           ! 4756           CX = 0x2709;
32792                       000094B2            .68E:
32793                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
32794 94B2           B8                   2709  mov	ax,#$2709
32795 94B5           8946         14            mov	$14[bp],ax
32796                                           !BCC_EOS
32797                                           ! 4757           DX = ((DX & 0x00ff) | ((0) << 8));
32798                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
32799 94B8           8A46         12            mov	al,$12[bp]
32800                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32801 94BB           0C                     00  or	al,*0
32802                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
32803 94BD           30E4                       xor	ah,ah
32804 94BF           8946         12            mov	$12[bp],ax
32805                                           !BCC_EOS
32806                                           ! 4758           break;
32807 94C2           EB           4A            jmp .684
32808                                           !BCC_EOS
32809                                           ! 4759         case 8:
32810                                           ! 4760           CX = 0x2708;
32811                       000094C4            .68F:
32812                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
32813 94C4           B8                   2708  mov	ax,#$2708
32814 94C7           8946         14            mov	$14[bp],ax
32815                                           !BCC_EOS
32816                                           ! 4761           DX = ((DX & 0x00ff) | ((1) << 8));
32817                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
32818 94CA           8A46         12            mov	al,$12[bp]
32819                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
32820 94CD           30E4                       xor	ah,ah
32821 94CF           0D                   0100  or	ax,#$100
32822                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
32823 94D2           8946         12            mov	$12[bp],ax
32824                                           !BCC_EOS
32825                                           ! 4762           break;
32826 94D5           EB           37            jmp .684
32827                                           !BCC_EOS
32828                                           ! 4763         default:
32829                                           ! 4764           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
32830                       000094D7            .690:
32831                                           ! Debug: list * char = .691+0 (used reg = )
32832 94D7           BB                   D0A5  mov	bx,#.691
32833 94DA           53                         push	bx
32834                                           ! Debug: list int = const 7 (used reg = )
32835 94DB           B8                   0007  mov	ax,*7
32836 94DE           50                         push	ax
32837                                           ! Debug: func () void = bios_printf+0 (used reg = )
32838 94DF           E8         73C7            call	_bios_printf
32839 94E2           83C4                   04  add	sp,*4
32840                                           !BCC_EOS
32841                                           ! 4765         }
32842                                           ! 4766 #asm
32843 94E5           EB           27            jmp .684
32844                       000094E7            .686:
32845 94E7           2C                     00  sub	al,*0
32846 94E9           72           EC            jb 	.690
32847 94EB           3C                     08  cmp	al,*8
32848 94ED           77           1D            ja  	.692
32849 94EF           30E4                       xor	ah,ah
32850 94F1           D1E0                       shl	ax,*1
32851 94F3           89C3                       mov	bx,ax
32852 94F5           2E                         seg	cs
32853 94F6           FFA7       94FA            br	.693[bx]
32854                       000094FA            .693:
32855 94FA                      942B            .word	.687
32856 94FC                      943D            .word	.688
32857 94FE                      9451            .word	.689
32858 9500                      9465            .word	.68A
32859 9502                      9479            .word	.68B
32860 9504                      948D            .word	.68C
32861 9506                      94A0            .word	.68D
32862 9508                      94B2            .word	.68E
32863 950A                      94C4            .word	.68F
32864                       0000950C            .692:
32865 950C           EB           C9            jmp	.690
32866                       0000950E            .684:
32867                                           !BCC_EOS
32868                                           !BCC_ASM
32869                       0000002A            _int13_diskette_function.BP	set	$2A
32870                       0000000C            .int13_diskette_function.BP	set	$C
32871                       00000038            _int13_diskette_function.CS	set	$38
32872                       0000001A            .int13_diskette_function.CS	set	$1A
32873                       00000032            _int13_diskette_function.CX	set	$32
32874                       00000014            .int13_diskette_function.CX	set	$14
32875                       00000016            _int13_diskette_function.base_address	set	$16
32876                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32877                       00000026            _int13_diskette_function.DI	set	$26
32878                       00000008            .int13_diskette_function.DI	set	8
32879                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32880                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32881                       00000014            _int13_diskette_function.base_count	set	$14
32882                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32883                       0000001A            _int13_diskette_function.sector	set	$1A
32884                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32885                       00000022            _int13_diskette_function.DS	set	$22
32886                       00000004            .int13_diskette_function.DS	set	4
32887                       00000019            _int13_diskette_function.head	set	$19
32888                       FFFFFFFB            .int13_diskette_function.head	set	-5
32889                       0000002C            _int13_diskette_function.ELDX	set	$2C
32890                       0000000E            .int13_diskette_function.ELDX	set	$E
32891                       0000000E            _int13_diskette_function.dor	set	$E
32892                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32893                       00000030            _int13_diskette_function.DX	set	$30
32894                       00000012            .int13_diskette_function.DX	set	$12
32895                       00000007            _int13_diskette_function.return_status	set	7
32896                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32897                       00000002            _int13_diskette_function.es	set	2
32898                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32899                       00000010            _int13_diskette_function.mode_register	set	$10
32900                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32901                       00000024            _int13_diskette_function.ES	set	$24
32902                       00000006            .int13_diskette_function.ES	set	6
32903                       00000012            _int13_diskette_function.base_es	set	$12
32904                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32905                       0000001B            _int13_diskette_function.track	set	$1B
32906                       FFFFFFFD            .int13_diskette_function.track	set	-3
32907                       00000028            _int13_diskette_function.SI	set	$28
32908                       0000000A            .int13_diskette_function.SI	set	$A
32909                       00000006            _int13_diskette_function.drive_type	set	6
32910                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32911                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32912                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32913                       00000036            _int13_diskette_function.IP	set	$36
32914                       00000018            .int13_diskette_function.IP	set	$18
32915                       00000018            _int13_diskette_function.status	set	$18
32916                       FFFFFFFA            .int13_diskette_function.status	set	-6
32917                       00000034            _int13_diskette_function.AX	set	$34
32918                       00000016            .int13_diskette_function.AX	set	$16
32919                       0000000F            _int13_diskette_function.val8	set	$F
32920                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32921                       00000000            _int13_diskette_function.last_addr	set	0
32922                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32923                       00000011            _int13_diskette_function.page	set	$11
32924                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32925                       00000004            _int13_diskette_function.ah	set	4
32926                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32927                       0000001D            _int13_diskette_function.drive	set	$1D
32928                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32929                       00000005            _int13_diskette_function.num_floppies	set	5
32930                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32931                       0000002E            _int13_diskette_function.BX	set	$2E
32932                       00000010            .int13_diskette_function.BX	set	$10
32933 950E           55                               push bp
32934 950F           89E5                             mov bp, sp
32935 9511           B8                   EFDF        mov ax, #diskette_param_table2
32936 9514           8946         28                  mov _int13_diskette_function.DI+2[bp], ax
32937 9517           8C4E         26                  mov _int13_diskette_function.ES+2[bp], cs
32938 951A           5D                               pop bp
32939                                           ! 4773 endasm
32940                                           !BCC_ENDASM
32941                                           !BCC_EOS
32942                                           ! 4774       FLAGS &= 0xfffe;
32943                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32944 951B           8B46         1C            mov	ax,$1C[bp]
32945 951E           24                     FE  and	al,#$FE
32946 9520           8946         1C            mov	$1C[bp],ax
32947                                           !BCC_EOS
32948                                           ! 4775       return;
32949 9523           89EC                       mov	sp,bp
32950 9525           5D                         pop	bp
32951 9526           C3                         ret
32952                                           !BCC_EOS
32953                                           ! 4776     case 0x15:
32954                                           ! 4777 ;
32955                       00009527            .694:
32956                                           !BCC_EOS
32957                                           ! 4778       drive = ( ELDX & 0x00ff );
32958                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
32959 9527           8A46         0E            mov	al,$E[bp]
32960                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
32961 952A           8846         FF            mov	-1[bp],al
32962                                           !BCC_EOS
32963                                           ! 4779       if (drive > 1) {
32964                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
32965 952D           8A46         FF            mov	al,-1[bp]
32966 9530           3C                     01  cmp	al,*1
32967 9532           76           16            jbe 	.695
32968                       00009534            .696:
32969                                           ! 4780         AX = ((AX & 0x00ff) | ((0) << 8));
32970                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32971 9534           8A46         16            mov	al,$16[bp]
32972                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32973 9537           0C                     00  or	al,*0
32974                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
32975 9539           30E4                       xor	ah,ah
32976 953B           8946         16            mov	$16[bp],ax
32977                                           !BCC_EOS
32978                                           ! 4781         FLAGS |= 0x0001;
32979                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32980 953E           8B46         1C            mov	ax,$1C[bp]
32981 9541           0C                     01  or	al,*1
32982 9543           8946         1C            mov	$1C[bp],ax
32983                                           !BCC_EOS
32984                                           ! 4782         return;
32985 9546           89EC                       mov	sp,bp
32986 9548           5D                         pop	bp
32987 9549           C3                         ret
32988                                           !BCC_EOS
32989                                           ! 4783         }
32990                                           ! 4784       drive_type = inb_cmos(0x10);
32991                       0000954A            .695:
32992                                           ! Debug: list int = const $10 (used reg = )
32993 954A           B8                   0010  mov	ax,*$10
32994 954D           50                         push	ax
32995                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
32996 954E           E8         703C            call	_inb_cmos
32997 9551           44                         inc	sp
32998 9552           44                         inc	sp
32999                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
33000 9553           8846         E8            mov	-$18[bp],al
33001                                           !BCC_EOS
33002                                           ! 4785       if (drive == 0)
33003                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
33004 9556           8A46         FF            mov	al,-1[bp]
33005 9559           84C0                       test	al,al
33006 955B           75           0E            jne 	.697
33007                       0000955D            .698:
33008                                           ! 4786         drive_type >>= 4;
33009                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
33010 955D           8A46         E8            mov	al,-$18[bp]
33011 9560           30E4                       xor	ah,ah
33012 9562           B1                     04  mov	cl,*4
33013 9564           D3E8                       shr	ax,cl
33014 9566           8846         E8            mov	-$18[bp],al
33015                                           !BCC_EOS
33016                                           ! 4787       else
33017                                           ! 4788         drive_type &= 0x0f;
33018 9569           EB           08            jmp .699
33019                       0000956B            .697:
33020                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
33021 956B           8A46         E8            mov	al,-$18[bp]
33022 956E           24                     0F  and	al,*$F
33023 9570           8846         E8            mov	-$18[bp],al
33024                                           !BCC_EOS
33025                                           ! 4789       FLAGS &= 0xfffe;
33026                       00009573            .699:
33027                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33028 9573           8B46         1C            mov	ax,$1C[bp]
33029 9576           24                     FE  and	al,#$FE
33030 9578           8946         1C            mov	$1C[bp],ax
33031                                           !BCC_EOS
33032                                           ! 4790       if (drive_type==0) {
33033                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
33034 957B           8A46         E8            mov	al,-$18[bp]
33035 957E           84C0                       test	al,al
33036 9580           75           0C            jne 	.69A
33037                       00009582            .69B:
33038                                           ! 4791         AX = ((AX & 0x00ff) | ((0) << 8));
33039                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33040 9582           8A46         16            mov	al,$16[bp]
33041                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33042 9585           0C                     00  or	al,*0
33043                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33044 9587           30E4                       xor	ah,ah
33045 9589           8946         16            mov	$16[bp],ax
33046                                           !BCC_EOS
33047                                           ! 4792         }
33048                                           ! 4793       else {
33049 958C           EB           0B            jmp .69C
33050                       0000958E            .69A:
33051                                           ! 4794         AX = ((AX & 0x00ff) | ((1) << 8));
33052                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33053 958E           8A46         16            mov	al,$16[bp]
33054                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
33055 9591           30E4                       xor	ah,ah
33056 9593           0D                   0100  or	ax,#$100
33057                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33058 9596           8946         16            mov	$16[bp],ax
33059                                           !BCC_EOS
33060                                           ! 4795         }
33061                                           ! 4796       return;
33062                       00009599            .69C:
33063 9599           89EC                       mov	sp,bp
33064 959B           5D                         pop	bp
33065 959C           C3                         ret
33066                                           !BCC_EOS
33067                                           ! 4797     case 0x16:
33068                                           ! 4798 ;
33069                       0000959D            .69D:
33070                                           !BCC_EOS
33071                                           ! 4799       drive = ( ELDX & 0x00ff );
33072                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
33073 959D           8A46         0E            mov	al,$E[bp]
33074                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
33075 95A0           8846         FF            mov	-1[bp],al
33076                                           !BCC_EOS
33077                                           ! 4800       if (drive > 1) {
33078                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
33079 95A3           8A46         FF            mov	al,-1[bp]
33080 95A6           3C                     01  cmp	al,*1
33081 95A8           76           20            jbe 	.69E
33082                       000095AA            .69F:
33083                                           ! 4801         AX = ((AX & 0x00ff) | ((0x01) << 8));
33084                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33085 95AA           8A46         16            mov	al,$16[bp]
33086                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
33087 95AD           30E4                       xor	ah,ah
33088 95AF           0D                   0100  or	ax,#$100
33089                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33090 95B2           8946         16            mov	$16[bp],ax
33091                                           !BCC_EOS
33092                                           ! 4802         set_diskette_ret_status(0x01);
33093                                           ! Debug: list int = const 1 (used reg = )
33094 95B5           B8                   0001  mov	ax,*1
33095 95B8           50                         push	ax
33096                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33097 95B9           E8         00E9            call	_set_diskette_ret_status
33098 95BC           44                         inc	sp
33099 95BD           44                         inc	sp
33100                                           !BCC_EOS
33101                                           ! 4803         FLAGS |= 0x0001;
33102                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33103 95BE           8B46         1C            mov	ax,$1C[bp]
33104 95C1           0C                     01  or	al,*1
33105 95C3           8946         1C            mov	$1C[bp],ax
33106                                           !BCC_EOS
33107                                           ! 4804         return;
33108 95C6           89EC                       mov	sp,bp
33109 95C8           5D                         pop	bp
33110 95C9           C3                         ret
33111                                           !BCC_EOS
33112                                           ! 4805         }
33113                                           ! 4806       AX = ((AX & 0x00ff) | ((0x06) << 8));
33114                       000095CA            .69E:
33115                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33116 95CA           8A46         16            mov	al,$16[bp]
33117                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
33118 95CD           30E4                       xor	ah,ah
33119 95CF           0D                   0600  or	ax,#$600
33120                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33121 95D2           8946         16            mov	$16[bp],ax
33122                                           !BCC_EOS
33123                                           ! 4807       set_diskette_ret_status(0x06);
33124                                           ! Debug: list int = const 6 (used reg = )
33125 95D5           B8                   0006  mov	ax,*6
33126 95D8           50                         push	ax
33127                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33128 95D9           E8         00C9            call	_set_diskette_ret_status
33129 95DC           44                         inc	sp
33130 95DD           44                         inc	sp
33131                                           !BCC_EOS
33132                                           ! 4808       FLAGS |= 0x0001;
33133                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33134 95DE           8B46         1C            mov	ax,$1C[bp]
33135 95E1           0C                     01  or	al,*1
33136 95E3           8946         1C            mov	$1C[bp],ax
33137                                           !BCC_EOS
33138                                           ! 4809       return;
33139 95E6           89EC                       mov	sp,bp
33140 95E8           5D                         pop	bp
33141 95E9           C3                         ret
33142                                           !BCC_EOS
33143                                           ! 4810     case 0x17:
33144                                           ! 4811 ;
33145                       000095EA            .6A0:
33146                                           !BCC_EOS
33147                                           ! 4812       AX = ((AX & 0x00ff) | ((0x01) << 8));
33148                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33149 95EA           8A46         16            mov	al,$16[bp]
33150                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
33151 95ED           30E4                       xor	ah,ah
33152 95EF           0D                   0100  or	ax,#$100
33153                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33154 95F2           8946         16            mov	$16[bp],ax
33155                                           !BCC_EOS
33156                                           ! 4813       set_diskette_ret_status(1);
33157                                           ! Debug: list int = const 1 (used reg = )
33158 95F5           B8                   0001  mov	ax,*1
33159 95F8           50                         push	ax
33160                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33161 95F9           E8         00A9            call	_set_diskette_ret_status
33162 95FC           44                         inc	sp
33163 95FD           44                         inc	sp
33164                                           !BCC_EOS
33165                                           ! 4814       FLAGS |= 0x0001;
33166                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33167 95FE           8B46         1C            mov	ax,$1C[bp]
33168 9601           0C                     01  or	al,*1
33169 9603           8946         1C            mov	$1C[bp],ax
33170                                           !BCC_EOS
33171                                           ! 4815       return;
33172 9606           89EC                       mov	sp,bp
33173 9608           5D                         pop	bp
33174 9609           C3                         ret
33175                                           !BCC_EOS
33176                                           ! 4816     case 0x18:
33177                                           ! 4817 ;
33178                       0000960A            .6A1:
33179                                           !BCC_EOS
33180                                           ! 4818       AX = ((AX & 0x00ff) | ((0x01) << 8));
33181                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33182 960A           8A46         16            mov	al,$16[bp]
33183                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
33184 960D           30E4                       xor	ah,ah
33185 960F           0D                   0100  or	ax,#$100
33186                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33187 9612           8946         16            mov	$16[bp],ax
33188                                           !BCC_EOS
33189                                           ! 4819       set_diskette_ret_status(1);
33190                                           ! Debug: list int = const 1 (used reg = )
33191 9615           B8                   0001  mov	ax,*1
33192 9618           50                         push	ax
33193                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33194 9619           E8         0089            call	_set_diskette_ret_status
33195 961C           44                         inc	sp
33196 961D           44                         inc	sp
33197                                           !BCC_EOS
33198                                           ! 4820       FLAGS |= 0x0001;
33199                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33200 961E           8B46         1C            mov	ax,$1C[bp]
33201 9621           0C                     01  or	al,*1
33202 9623           8946         1C            mov	$1C[bp],ax
33203                                           !BCC_EOS
33204                                           ! 4821       return;
33205 9626           89EC                       mov	sp,bp
33206 9628           5D                         pop	bp
33207 9629           C3                         ret
33208                                           !BCC_EOS
33209                                           ! 4822     default:
33210                                           ! 4823         bios_printf(4, "int13_diskette: unsupported AH=%02x\n", ( AX >> 8 ));
33211                       0000962A            .6A2:
33212                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
33213 962A           8B46         16            mov	ax,$16[bp]
33214 962D           88E0                       mov	al,ah
33215 962F           30E4                       xor	ah,ah
33216                                           ! Debug: list unsigned int = ax+0 (used reg = )
33217 9631           50                         push	ax
33218                                           ! Debug: list * char = .6A3+0 (used reg = )
33219 9632           BB                   D080  mov	bx,#.6A3
33220 9635           53                         push	bx
33221                                           ! Debug: list int = const 4 (used reg = )
33222 9636           B8                   0004  mov	ax,*4
33223 9639           50                         push	ax
33224                                           ! Debug: func () void = bios_printf+0 (used reg = )
33225 963A           E8         726C            call	_bios_printf
33226 963D           83C4                   06  add	sp,*6
33227                                           !BCC_EOS
33228                                           ! 4824       
33229                                           ! 4824   AX = ((AX & 0x00ff) | ((0x01) << 8));
33230                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33231 9640           8A46         16            mov	al,$16[bp]
33232                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
33233 9643           30E4                       xor	ah,ah
33234 9645           0D                   0100  or	ax,#$100
33235                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33236 9648           8946         16            mov	$16[bp],ax
33237                                           !BCC_EOS
33238                                           ! 4825         set_diskette_ret_status(1);
33239                                           ! Debug: list int = const 1 (used reg = )
33240 964B           B8                   0001  mov	ax,*1
33241 964E           50                         push	ax
33242                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33243 964F           E8         0053            call	_set_diskette_ret_status
33244 9652           44                         inc	sp
33245 9653           44                         inc	sp
33246                                           !BCC_EOS
33247                                           ! 4826         FLAGS |= 0x0001;
33248                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33249 9654           8B46         1C            mov	ax,$1C[bp]
33250 9657           0C                     01  or	al,*1
33251 9659           8946         1C            mov	$1C[bp],ax
33252                                           !BCC_EOS
33253                                           ! 4827         return;
33254 965C           89EC                       mov	sp,bp
33255 965E           5D                         pop	bp
33256 965F           C3                         ret
33257                                           !BCC_EOS
33258                                           ! 4828     }
33259                                           ! 4829 }
33260 9660           EB           3F            jmp .609
33261                       00009662            .60B:
33262 9662           2C                     00  sub	al,*0
33263 9664           72           C4            jb 	.6A2
33264 9666           3C                     08  cmp	al,*8
33265 9668           77           1D            ja  	.6A4
33266 966A           30E4                       xor	ah,ah
33267 966C           D1E0                       shl	ax,*1
33268 966E           89C3                       mov	bx,ax
33269 9670           2E                         seg	cs
33270 9671           FFA7       9675            br	.6A5[bx]
33271                       00009675            .6A5:
33272 9675                      84A0            .word	.60C
33273 9677                      854A            .word	.614
33274 9679                      858C            .word	.617
33275 967B                      858C            .word	.618
33276 967D                      858C            .word	.619
33277 967F                      8EC5            .word	.656
33278 9681                      962A            .word	.6A2
33279 9683                      962A            .word	.6A2
33280 9685                      9361            .word	.67A
33281                       00009687            .6A4:
33282 9687           2C                     15  sub	al,*$15
33283 9689         0F84         FE9A            beq 	.694
33284 968D           2C                     01  sub	al,*1
33285 968F         0F84         FF0A            beq 	.69D
33286 9693           2C                     01  sub	al,*1
33287 9695         0F84         FF51            beq 	.6A0
33288 9699           2C                     01  sub	al,*1
33289 969B         0F84         FF6B            beq 	.6A1
33290 969F           EB           89            jmp	.6A2
33291                       000096A1            .609:
33292                       FFFFFFE0            ..FFDB	=	-$20
33293 96A1           89EC                       mov	sp,bp
33294 96A3           5D                         pop	bp
33295 96A4           C3                         ret
33296                                           ! 4830  void
33297                                           ! Register BX used in function int13_diskette_function
33298                                           ! 4831 set_diskette_ret_status(value)
33299                                           ! 4832   Bit8u value;
33300                                           export	_set_diskette_ret_status
33301                       000096A5            _set_diskette_ret_status:
33302                                           !BCC_EOS
33303                                           ! 4833 {
33304                                           ! 4834   write_byte(0x0040, 0x0041, value);
33305 96A5           55                         push	bp
33306 96A6           89E5                       mov	bp,sp
33307                                           ! Debug: list unsigned char value = [S+2+2] (used reg = )
33308 96A8           8A46         04            mov	al,4[bp]
33309 96AB           30E4                       xor	ah,ah
33310 96AD           50                         push	ax
33311                                           ! Debug: list int = const $41 (used reg = )
33312 96AE           B8                   0041  mov	ax,*$41
33313 96B1           50                         push	ax
33314                                           ! Debug: list int = const $40 (used reg = )
33315 96B2           B8                   0040  mov	ax,*$40
33316 96B5           50                         push	ax
33317                                           ! Debug: func () void = write_byte+0 (used reg = )
33318 96B6           E8         6F6B            call	_write_byte
33319 96B9           89EC                       mov	sp,bp
33320                                           !BCC_EOS
33321                                           ! 4835 }
33322 96BB           5D                         pop	bp
33323 96BC           C3                         ret
33324                                           ! 4836   void
33325                                           ! 4837 set_diskette_current_cyl(drive, cyl)
33326                                           ! 4838   Bit8u drive;
33327                                           export	_set_diskette_current_cyl
33328                       000096BD            _set_diskette_current_cyl:
33329                                           !BCC_EOS
33330                                           ! 4839   Bit8u cyl;
33331                                           !BCC_EOS
33332                                           ! 4840 {
33333                                           ! 4841   if (drive > 1)
33334 96BD           55                         push	bp
33335 96BE           89E5                       mov	bp,sp
33336                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
33337 96C0           8A46         04            mov	al,4[bp]
33338 96C3           3C                     01  cmp	al,*1
33339 96C5           76           0D            jbe 	.6A6
33340                       000096C7            .6A7:
33341                                           ! 4842     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
33342                                           ! Debug: list * char = .6A8+0 (used reg = )
33343 96C7           BB                   D059  mov	bx,#.6A8
33344 96CA           53                         push	bx
33345                                           ! Debug: list int = const 7 (used reg = )
33346 96CB           B8                   0007  mov	ax,*7
33347 96CE           50                         push	ax
33348                                           ! Debug: func () void = bios_printf+0 (used reg = )
33349 96CF           E8         71D7            call	_bios_printf
33350 96D2           89EC                       mov	sp,bp
33351                                           !BCC_EOS
33352                                           ! 4843   write_byte(0x0040, 0x0094+drive, cyl);
33353                       000096D4            .6A6:
33354                                           ! Debug: list unsigned char cyl = [S+2+4] (used reg = )
33355 96D4           8A46         06            mov	al,6[bp]
33356 96D7           30E4                       xor	ah,ah
33357 96D9           50                         push	ax
33358                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
33359                                           ! Debug: expression subtree swapping
33360 96DA           8A46         04            mov	al,4[bp]
33361 96DD           30E4                       xor	ah,ah
33362                                           ! Debug: list unsigned int = ax+$94 (used reg = )
33363 96DF           05                   0094  add	ax,#$94
33364 96E2           50                         push	ax
33365                                           ! Debug: list int = const $40 (used reg = )
33366 96E3           B8                   0040  mov	ax,*$40
33367 96E6           50                         push	ax
33368                                           ! Debug: func () void = write_byte+0 (used reg = )
33369 96E7           E8         6F3A            call	_write_byte
33370 96EA           89EC                       mov	sp,bp
33371                                           !BCC_EOS
33372                                           ! 4844 }
33373 96EC           5D                         pop	bp
33374 96ED           C3                         ret
33375                                           ! 4845   void
33376                                           ! Register BX used in function set_diskette_current_cyl
33377                                           ! 4846 determine_floppy_media(drive)
33378                                           ! 4847   Bit16u drive;
33379                                           export	_determine_floppy_media
33380                       000096EE            _determine_floppy_media:
33381                                           !BCC_EOS
33382                                           ! 4848 {
33383                                           ! 4849 }
33384 96EE           C3                         ret
33385                                           ! 4850   void
33386                                           ! 4851 int17_function(regs, ds, iret_addr)
33387                                           ! 4852   pusha_regs_t regs;
33388                                           export	_int17_function
33389                       000096EF            _int17_function:
33390                                           !BCC_EOS
33391                                           ! 4853   Bit16u ds;
33392                                           !BCC_EOS
33393                                           ! 4854   iret_addr_t iret_addr;
33394                                           !BCC_EOS
33395                                           ! 4855 {
33396                                           ! 4856   Bit16u addr,timeout;
33397                                           !BCC_EOS
33398                                           ! 4857   Bit8u val8;
33399                                           !BCC_EOS
33400                                           ! 4858 #asm
33401 96EF           55                         push	bp
33402 96F0           89E5                       mov	bp,sp
33403 96F2           83C4                   FA  add	sp,*-6
33404                                           !BCC_EOS
33405                                           !BCC_ASM
33406                       0000001A            _int17_function.ds	set	$1A
33407                       00000014            .int17_function.ds	set	$14
33408                       00000002            _int17_function.timeout	set	2
33409                       FFFFFFFC            .int17_function.timeout	set	-4
33410                       00000001            _int17_function.val8	set	1
33411                       FFFFFFFB            .int17_function.val8	set	-5
33412                       0000001C            _int17_function.iret_addr	set	$1C
33413                       00000016            .int17_function.iret_addr	set	$16
33414                       00000004            _int17_function.addr	set	4
33415                       FFFFFFFE            .int17_function.addr	set	-2
33416                       0000000A            _int17_function.regs	set	$A
33417                       00000004            .int17_function.regs	set	4
33418 96F5           FB                           sti
33419                                           ! 4860 endasm
33420                                           !BCC_ENDASM
33421                                           !BCC_EOS
33422                                           ! 4861   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
33423                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
33424 96F6           8B46         0E            mov	ax,$E[bp]
33425 96F9           D1E0                       shl	ax,*1
33426                                           ! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
33427                                           ! Debug: list unsigned int = ax+8 (used reg = )
33428 96FB           05                   0008  add	ax,*8
33429 96FE           50                         push	ax
33430                                           ! Debug: list int = const $40 (used reg = )
33431 96FF           B8                   0040  mov	ax,*$40
33432 9702           50                         push	ax
33433                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
33434 9703           E8         6F0B            call	_read_word
33435 9706           83C4                   04  add	sp,*4
33436                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
33437 9709           8946         FE            mov	-2[bp],ax
33438                                           !BCC_EOS
33439                                           ! 4862   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
33440                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
33441 970C           8A46         13            mov	al,$13[bp]
33442 970F           3C                     03  cmp	al,*3
33443 9711         0F83         0106            bhis	.6A9
33444                       00009715            .6AC:
33445                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
33446 9715           8B46         0E            mov	ax,$E[bp]
33447 9718           3D                   0003  cmp	ax,*3
33448 971B         0F83         00FC            bhis	.6A9
33449                       0000971F            .6AB:
33450                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
33451 971F           8B46         FE            mov	ax,-2[bp]
33452 9722           85C0                       test	ax,ax
33453 9724         0F84         00F3            beq 	.6A9
33454                       00009728            .6AA:
33455                                           ! 4863     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
33456                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
33457                                           ! Debug: expression subtree swapping
33458 9728           8B46         0E            mov	ax,$E[bp]
33459                                           ! Debug: list unsigned int = ax+$78 (used reg = )
33460 972B           05                   0078  add	ax,*$78
33461 972E           50                         push	ax
33462                                           ! Debug: list int = const $40 (used reg = )
33463 972F           B8                   0040  mov	ax,*$40
33464 9732           50                         push	ax
33465                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33466 9733           E8         6EC8            call	_read_byte
33467 9736           83C4                   04  add	sp,*4
33468                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
33469 9739           30E4                       xor	ah,ah
33470 973B           88C4                       mov	ah,al
33471 973D           30C0                       xor	al,al
33472                                           ! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
33473 973F           8946         FC            mov	-4[bp],ax
33474                                           !BCC_EOS
33475                                           ! 4864     if (regs.u.r8.ah == 0) {
33476                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
33477 9742           8A46         13            mov	al,$13[bp]
33478 9745           84C0                       test	al,al
33479 9747           75           66            jne 	.6AD
33480                       00009749            .6AE:
33481                                           ! 4865       outb(addr, regs.u.r8.al);
33482                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
33483 9749           8A46         12            mov	al,$12[bp]
33484 974C           30E4                       xor	ah,ah
33485 974E           50                         push	ax
33486                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
33487 974F           FF76         FE            push	-2[bp]
33488                                           ! Debug: func () void = outb+0 (used reg = )
33489 9752           E8         6E09            call	_outb
33490 9755           83C4                   04  add	sp,*4
33491                                           !BCC_EOS
33492                                           ! 4866       val8 = inb(addr+2);
33493                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
33494 9758           8B46         FE            mov	ax,-2[bp]
33495                                           ! Debug: list unsigned int = ax+2 (used reg = )
33496 975B           40                         inc	ax
33497 975C           40                         inc	ax
33498 975D           50                         push	ax
33499                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33500 975E           E8         6DE7            call	_inb
33501 9761           44                         inc	sp
33502 9762           44                         inc	sp
33503                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
33504 9763           8846         FB            mov	-5[bp],al
33505                                           !BCC_EOS
33506                                           ! 4867       outb(addr+2, val8 | 0x01);
33507                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
33508 9766           8A46         FB            mov	al,-5[bp]
33509 9769           0C                     01  or	al,*1
33510                                           ! Debug: list unsigned char = al+0 (used reg = )
33511 976B           30E4                       xor	ah,ah
33512 976D           50                         push	ax
33513                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
33514 976E           8B46         FE            mov	ax,-2[bp]
33515                                           ! Debug: list unsigned int = ax+2 (used reg = )
33516 9771           40                         inc	ax
33517 9772           40                         inc	ax
33518 9773           50                         push	ax
33519                                           ! Debug: func () void = outb+0 (used reg = )
33520 9774           E8         6DE7            call	_outb
33521 9777           83C4                   04  add	sp,*4
33522                                           !BCC_EOS
33523                                           ! 4868 #asm
33524                                           !BCC_EOS
33525                                           !BCC_ASM
33526                       0000001A            _int17_function.ds	set	$1A
33527                       00000014            .int17_function.ds	set	$14
33528                       00000002            _int17_function.timeout	set	2
33529                       FFFFFFFC            .int17_function.timeout	set	-4
33530                       00000001            _int17_function.val8	set	1
33531                       FFFFFFFB            .int17_function.val8	set	-5
33532                       0000001C            _int17_function.iret_addr	set	$1C
33533                       00000016            .int17_function.iret_addr	set	$16
33534                       00000004            _int17_function.addr	set	4
33535                       FFFFFFFE            .int17_function.addr	set	-2
33536                       0000000A            _int17_function.regs	set	$A
33537                       00000004            .int17_function.regs	set	4
33538 977A           90                               nop
33539                                           ! 4870 endasm
33540                                           !BCC_ENDASM
33541                                           !BCC_EOS
33542                                           ! 4871       outb(addr+2, val8 & ~0x01);
33543                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
33544 977B           8A46         FB            mov	al,-5[bp]
33545 977E           24                     FE  and	al,#$FE
33546                                           ! Debug: list unsigned char = al+0 (used reg = )
33547 9780           30E4                       xor	ah,ah
33548 9782           50                         push	ax
33549                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
33550 9783           8B46         FE            mov	ax,-2[bp]
33551                                           ! Debug: list unsigned int = ax+2 (used reg = )
33552 9786           40                         inc	ax
33553 9787           40                         inc	ax
33554 9788           50                         push	ax
33555                                           ! Debug: func () void = outb+0 (used reg = )
33556 9789           E8         6DD2            call	_outb
33557 978C           83C4                   04  add	sp,*4
33558                                           !BCC_EOS
33559                                           ! 4872       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
33560 978F           EB           07            jmp .6B0
33561                       00009791            .6B1:
33562                                           ! 4873         timeout--;
33563                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
33564 9791           8B46         FC            mov	ax,-4[bp]
33565 9794           48                         dec	ax
33566 9795           8946         FC            mov	-4[bp],ax
33567                                           !BCC_EOS
33568                                           ! 4874       }
33569                                           ! 4875     }
33570                       00009798            .6B0:
33571                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
33572 9798           8B46         FE            mov	ax,-2[bp]
33573                                           ! Debug: list unsigned int = ax+1 (used reg = )
33574 979B           40                         inc	ax
33575 979C           50                         push	ax
33576                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33577 979D           E8         6DA8            call	_inb
33578 97A0           44                         inc	sp
33579 97A1           44                         inc	sp
33580                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
33581 97A2           24                     40  and	al,*$40
33582                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
33583 97A4           3C                     40  cmp	al,*$40
33584 97A6           75           07            jne 	.6B2
33585                       000097A8            .6B3:
33586 97A8           8B46         FC            mov	ax,-4[bp]
33587 97AB           85C0                       test	ax,ax
33588 97AD           75           E2            jne	.6B1
33589                       000097AF            .6B2:
33590                       000097AF            .6AF:
33591                                           ! 4876     if (regs.u.r8.ah == 1) {
33592                       000097AF            .6AD:
33593                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
33594 97AF           8A46         13            mov	al,$13[bp]
33595 97B2           3C                     01  cmp	al,*1
33596 97B4           75           37            jne 	.6B4
33597                       000097B6            .6B5:
33598                                           ! 4877       val8 = inb(addr+2);
33599                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
33600 97B6           8B46         FE            mov	ax,-2[bp]
33601                                           ! Debug: list unsigned int = ax+2 (used reg = )
33602 97B9           40                         inc	ax
33603 97BA           40                         inc	ax
33604 97BB           50                         push	ax
33605                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33606 97BC           E8         6D89            call	_inb
33607 97BF           44                         inc	sp
33608 97C0           44                         inc	sp
33609                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
33610 97C1           8846         FB            mov	-5[bp],al
33611                                           !BCC_EOS
33612                                           ! 4878       outb(addr+2, val8 & ~0x04);
33613                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
33614 97C4           8A46         FB            mov	al,-5[bp]
33615 97C7           24                     FB  and	al,#$FB
33616                                           ! Debug: list unsigned char = al+0 (used reg = )
33617 97C9           30E4                       xor	ah,ah
33618 97CB           50                         push	ax
33619                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
33620 97CC           8B46         FE            mov	ax,-2[bp]
33621                                           ! Debug: list unsigned int = ax+2 (used reg = )
33622 97CF           40                         inc	ax
33623 97D0           40                         inc	ax
33624 97D1           50                         push	ax
33625                                           ! Debug: func () void = outb+0 (used reg = )
33626 97D2           E8         6D89            call	_outb
33627 97D5           83C4                   04  add	sp,*4
33628                                           !BCC_EOS
33629                                           ! 4879 #asm
33630                                           !BCC_EOS
33631                                           !BCC_ASM
33632                       0000001A            _int17_function.ds	set	$1A
33633                       00000014            .int17_function.ds	set	$14
33634                       00000002            _int17_function.timeout	set	2
33635                       FFFFFFFC            .int17_function.timeout	set	-4
33636                       00000001            _int17_function.val8	set	1
33637                       FFFFFFFB            .int17_function.val8	set	-5
33638                       0000001C            _int17_function.iret_addr	set	$1C
33639                       00000016            .int17_function.iret_addr	set	$16
33640                       00000004            _int17_function.addr	set	4
33641                       FFFFFFFE            .int17_function.addr	set	-2
33642                       0000000A            _int17_function.regs	set	$A
33643                       00000004            .int17_function.regs	set	4
33644 97D8           90                               nop
33645                                           ! 4881 endasm
33646                                           !BCC_ENDASM
33647                                           !BCC_EOS
33648                                           ! 4882       outb(addr+2, val8 | 0x04);
33649                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
33650 97D9           8A46         FB            mov	al,-5[bp]
33651 97DC           0C                     04  or	al,*4
33652                                           ! Debug: list unsigned char = al+0 (used reg = )
33653 97DE           30E4                       xor	ah,ah
33654 97E0           50                         push	ax
33655                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
33656 97E1           8B46         FE            mov	ax,-2[bp]
33657                                           ! Debug: list unsigned int = ax+2 (used reg = )
33658 97E4           40                         inc	ax
33659 97E5           40                         inc	ax
33660 97E6           50                         push	ax
33661                                           ! Debug: func () void = outb+0 (used reg = )
33662 97E7           E8         6D74            call	_outb
33663 97EA           83C4                   04  add	sp,*4
33664                                           !BCC_EOS
33665                                           ! 4883     }
33666                                           ! 4884     val8 = inb(addr+1);
33667                       000097ED            .6B4:
33668                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
33669 97ED           8B46         FE            mov	ax,-2[bp]
33670                                           ! Debug: list unsigned int = ax+1 (used reg = )
33671 97F0           40                         inc	ax
33672 97F1           50                         push	ax
33673                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33674 97F2           E8         6D53            call	_inb
33675 97F5           44                         inc	sp
33676 97F6           44                         inc	sp
33677                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
33678 97F7           8846         FB            mov	-5[bp],al
33679                                           !BCC_EOS
33680                                           ! 4885     regs.u.r8.ah = (val8 ^ 0x48);
33681                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
33682 97FA           8A46         FB            mov	al,-5[bp]
33683 97FD           34                     48  xor	al,*$48
33684                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
33685 97FF           8846         13            mov	$13[bp],al
33686                                           !BCC_EOS
33687                                           ! 4886     if (!timeout) regs.u.r8.ah |= 0x01;
33688 9802           8B46         FC            mov	ax,-4[bp]
33689 9805           85C0                       test	ax,ax
33690 9807           75           08            jne 	.6B6
33691                       00009809            .6B7:
33692                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
33693 9809           8A46         13            mov	al,$13[bp]
33694 980C           0C                     01  or	al,*1
33695 980E           8846         13            mov	$13[bp],al
33696                                           !BCC_EOS
33697                                           ! 4887     iret_addr.flags.u.r8.flagsl &= 0xfe;
33698                       00009811            .6B6:
33699                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
33700 9811           8A46         1A            mov	al,$1A[bp]
33701 9814           24                     FE  and	al,#$FE
33702 9816           8846         1A            mov	$1A[bp],al
33703                                           !BCC_EOS
33704                                           ! 4888   } else {
33705 9819           EB           08            jmp .6B8
33706                       0000981B            .6A9:
33707                                           ! 4889     iret_addr.flags.u.r8.flagsl |= 0x01;
33708                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
33709 981B           8A46         1A            mov	al,$1A[bp]
33710 981E           0C                     01  or	al,*1
33711 9820           8846         1A            mov	$1A[bp],al
33712                                           !BCC_EOS
33713                                           ! 4890   }
33714                                           ! 4891 }
33715                       00009823            .6B8:
33716 9823           89EC                       mov	sp,bp
33717 9825           5D                         pop	bp
33718 9826           C3                         ret
33719                                           ! 4892 void
33720                                           ! 4893 int18_function(seq_nr)
33721                                           ! 4894 Bit16u seq_nr;
33722                                           export	_int18_function
33723                       00009827            _int18_function:
33724                                           !BCC_EOS
33725                                           ! 4895 {
33726                                           ! 4896   Bit16u ebda_seg=read_word(0x0040,0x000E);
33727 9827           55                         push	bp
33728 9828           89E5                       mov	bp,sp
33729 982A           4C                         dec	sp
33730 982B           4C                         dec	sp
33731                                           ! Debug: list int = const $E (used reg = )
33732 982C           B8                   000E  mov	ax,*$E
33733 982F           50                         push	ax
33734                                           ! Debug: list int = const $40 (used reg = )
33735 9830           B8                   0040  mov	ax,*$40
33736 9833           50                         push	ax
33737                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
33738 9834           E8         6DDA            call	_read_word
33739 9837           83C4                   04  add	sp,*4
33740                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
33741 983A           8946         FE            mov	-2[bp],ax
33742                                           !BCC_EOS
33743                                           ! 4897   Bit16u bootdev;
33744                                           !BCC_EOS
33745                                           ! 4898   Bit8u bootdrv;
33746                                           !BCC_EOS
33747                                           ! 4899   Bit8u bootchk;
33748                                           !BCC_EOS
33749                                           ! 4900   Bit16u bootseg;
33750                                           !BCC_EOS
33751                                           ! 4901   Bit16u bootip;
33752                                           !BCC_EOS
33753                                           ! 4902   Bit16u status;
33754                                           !BCC_EOS
33755                                           ! 4903   struct ipl_entry e;
33756                                           !BCC_EOS
33757                                           ! 4904   bootdev = inb_cmos(0x3d);
33758 983D           83C4                   E6  add	sp,*-$1A
33759                                           ! Debug: list int = const $3D (used reg = )
33760 9840           B8                   003D  mov	ax,*$3D
33761 9843           50                         push	ax
33762                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33763 9844           E8         6D46            call	_inb_cmos
33764 9847           44                         inc	sp
33765 9848           44                         inc	sp
33766                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$1E-6] (used reg = )
33767 9849           30E4                       xor	ah,ah
33768 984B           8946         FC            mov	-4[bp],ax
33769                                           !BCC_EOS
33770                                           ! 4905   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
33771                                           ! Debug: list int = const $38 (used reg = )
33772 984E           B8                   0038  mov	ax,*$38
33773 9851           50                         push	ax
33774                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33775 9852           E8         6D38            call	_inb_cmos
33776 9855           44                         inc	sp
33777 9856           44                         inc	sp
33778                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
33779 9857           24                     F0  and	al,#$F0
33780                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
33781 9859           30E4                       xor	ah,ah
33782 985B           B1                     04  mov	cl,*4
33783 985D           D3E0                       shl	ax,cl
33784                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$1E-6] (used reg = )
33785 985F           0B46         FC            or	ax,-4[bp]
33786 9862           8946         FC            mov	-4[bp],ax
33787                                           !BCC_EOS
33788                                           ! 4906   bootdev >>= 4 * seq_nr;
33789                                           ! Debug: mul unsigned short seq_nr = [S+$1E+2] to int = const 4 (used reg = )
33790                                           ! Debug: expression subtree swapping
33791 9865           8B46         04            mov	ax,4[bp]
33792 9868           D1E0                       shl	ax,*1
33793 986A           D1E0                       shl	ax,*1
33794                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$1E-6] (used reg = )
33795 986C           89C3                       mov	bx,ax
33796 986E           8B46         FC            mov	ax,-4[bp]
33797 9871           89D9                       mov	cx,bx
33798 9873           D3E8                       shr	ax,cl
33799 9875           8946         FC            mov	-4[bp],ax
33800                                           !BCC_EOS
33801                                           ! 4907   bootdev &= 0xf;
33802                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$1E-6] (used reg = )
33803 9878           8A46         FC            mov	al,-4[bp]
33804 987B           24                     0F  and	al,*$F
33805 987D           30E4                       xor	ah,ah
33806 987F           8946         FC            mov	-4[bp],ax
33807                                           !BCC_EOS
33808                                           ! 4908   if (bootdev == 0) bios_printf((2 | 4 | 1), "No bootable device.\n");
33809                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$1E-6] (used reg = )
33810 9882           8B46         FC            mov	ax,-4[bp]
33811 9885           85C0                       test	ax,ax
33812 9887           75           0E            jne 	.6B9
33813                       00009889            .6BA:
33814                                           ! Debug: list * char = .6BB+0 (used reg = )
33815 9889           BB                   D044  mov	bx,#.6BB
33816 988C           53                         push	bx
33817                                           ! Debug: list int = const 7 (used reg = )
33818 988D           B8                   0007  mov	ax,*7
33819 9890           50                         push	ax
33820                                           ! Debug: func () void = bios_printf+0 (used reg = )
33821 9891           E8         7015            call	_bios_printf
33822 9894           83C4                   04  add	sp,*4
33823                                           !BCC_EOS
33824                                           ! 4909   bootdev -= 1;
33825                       00009897            .6B9:
33826                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$1E-6] (used reg = )
33827 9897           8B46         FC            mov	ax,-4[bp]
33828 989A           48                         dec	ax
33829 989B           8946         FC            mov	-4[bp],ax
33830                                           !BCC_EOS
33831                                           ! 4910   if (get_boot_vector(bootdev, &e) == 0) {
33832                                           ! Debug: list * struct ipl_entry e = S+$1E-$1E (used reg = )
33833 989E           8D5E         E4            lea	bx,-$1C[bp]
33834 98A1           53                         push	bx
33835                                           ! Debug: list unsigned short bootdev = [S+$20-6] (used reg = )
33836 98A2           FF76         FC            push	-4[bp]
33837                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
33838 98A5           E8         78B1            call	_get_boot_vector
33839 98A8           83C4                   04  add	sp,*4
33840                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
33841 98AB           84C0                       test	al,al
33842 98AD           75           15            jne 	.6BC
33843                       000098AF            .6BD:
33844                                           ! 4911     bios_printf(4, "Invalid boot device (0x%x)\n", bootdev);
33845                                           ! Debug: list unsigned short bootdev = [S+$1E-6] (used reg = )
33846 98AF           FF76         FC            push	-4[bp]
33847                                           ! Debug: list * char = .6BE+0 (used reg = )
33848 98B2           BB                   D028  mov	bx,#.6BE
33849 98B5           53                         push	bx
33850                                           ! Debug: list int = const 4 (used reg = )
33851 98B6           B8                   0004  mov	ax,*4
33852 98B9           50                         push	ax
33853                                           ! Debug: func () void = bios_printf+0 (used reg = )
33854 98BA           E8         6FEC            call	_bios_printf
33855 98BD           83C4                   06  add	sp,*6
33856                                           !BCC_EOS
33857                                           ! 4912     return;
33858 98C0           89EC                       mov	sp,bp
33859 98C2           5D                         pop	bp
33860 98C3           C3                         ret
33861                                           !BCC_EOS
33862                                           ! 4913   }
33863                                           ! 4914   print_boot_device(e.type);
33864                       000098C4            .6BC:
33865                                           ! Debug: list unsigned short e = [S+$1E-$1E] (used reg = )
33866 98C4           FF76         E4            push	-$1C[bp]
33867                                           ! Debug: func () void = print_boot_device+0 (used reg = )
33868 98C7           E8         790E            call	_print_boot_device
33869 98CA           44                         inc	sp
33870 98CB           44                         inc	sp
33871                                           !BCC_EOS
33872                                           ! 4915   switch(e.type) {
33873 98CC           8B46         E4            mov	ax,-$1C[bp]
33874 98CF           E9         015F            br 	.6C1
33875                                           ! 4916   case 0x01:
33876                                           ! 4917   case 
33877                       000098D2            .6C2:
33878                                           ! 4917 0x02:
33879                                           ! 4918     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
33880                       000098D2            .6C3:
33881                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$1E-$1E] (used reg = )
33882 98D2           8B46         E4            mov	ax,-$1C[bp]
33883 98D5           3D                   0002  cmp	ax,*2
33884 98D8           75           04            jne 	.6C4
33885                       000098DA            .6C5:
33886 98DA           B0                     80  mov	al,#$80
33887 98DC           EB           02            jmp .6C6
33888                       000098DE            .6C4:
33889 98DE           30C0                       xor	al,al
33890                       000098E0            .6C6:
33891                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$1E-7] (used reg = )
33892 98E0           8846         FB            mov	-5[bp],al
33893                                           !BCC_EOS
33894                                           ! 4919     bootseg = 0x07c0;
33895                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$1E-$A] (used reg = )
33896 98E3           B8                   07C0  mov	ax,#$7C0
33897 98E6           8946         F8            mov	-8[bp],ax
33898                                           !BCC_EOS
33899                                           ! 4920     status = 0;
33900                                           ! Debug: eq int = const 0 to unsigned short status = [S+$1E-$E] (used reg = )
33901 98E9           31C0                       xor	ax,ax
33902 98EB           8946         F4            mov	-$C[bp],ax
33903                                           !BCC_EOS
33904                                           ! 4921 #asm
33905                                           !BCC_EOS
33906                                           !BCC_ASM
33907                       00000012            _int18_function.bootip	set	$12
33908                       FFFFFFF6            .int18_function.bootip	set	-$A
33909                       00000020            _int18_function.seq_nr	set	$20
33910                       00000004            .int18_function.seq_nr	set	4
33911                       00000016            _int18_function.bootchk	set	$16
33912                       FFFFFFFA            .int18_function.bootchk	set	-6
33913                       00000014            _int18_function.bootseg	set	$14
33914                       FFFFFFF8            .int18_function.bootseg	set	-8
33915                       0000001A            _int18_function.ebda_seg	set	$1A
33916                       FFFFFFFE            .int18_function.ebda_seg	set	-2
33917                       00000010            _int18_function.status	set	$10
33918                       FFFFFFF4            .int18_function.status	set	-$C
33919                       00000017            _int18_function.bootdrv	set	$17
33920                       FFFFFFFB            .int18_function.bootdrv	set	-5
33921                       00000018            _int18_function.bootdev	set	$18
33922                       FFFFFFFC            .int18_function.bootdev	set	-4
33923                       00000000            _int18_function.e	set	0
33924                       FFFFFFE4            .int18_function.e	set	-$1C
33925 98EE           55                             push bp
33926 98EF           89E5                           mov bp, sp
33927 98F1           50                             push ax
33928 98F2           53                             push bx
33929 98F3           51                             push cx
33930 98F4           52                             push dx
33931 98F5           8A56         19                mov dl, _int18_function.bootdrv + 2[bp]
33932 98F8           8B46         16                mov ax, _int18_function.bootseg + 2[bp]
33933 98FB           8EC0                           mov es, ax ;; segment
33934 98FD           BB                   0000      mov bx, #0x0000 ;; offset
33935 9900           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
33936 9902           B0                     01      mov al, #0x01 ;; read 1 sector
33937 9904           B5                     00      mov ch, #0x00 ;; track 0
33938 9906           B1                     01      mov cl, #0x01 ;; sector 1
33939 9908           B6                     00      mov dh, #0x00 ;; head 0
33940 990A           CD                     13      int #0x13 ;; read sector
33941 990C           73           06                jnc int19_load_done
33942 990E           B8                   0001      mov ax, #0x0001
33943 9911           8946         12                mov _int18_function.status + 2[bp], ax
33944                       00009914            int19_load_done:
33945 9914           5A                             pop dx
33946 9915           59                             pop cx
33947 9916           5B                             pop bx
33948 9917           58                             pop ax
33949 9918           5D                             pop bp
33950                                           ! 4947 endasm
33951                                           !BCC_ENDASM
33952                                           !BCC_EOS
33953                                           ! 4948     if (status != 0) {
33954                                           ! Debug: ne int = const 0 to unsigned short status = [S+$1E-$E] (used reg = )
33955 9919           8B46         F4            mov	ax,-$C[bp]
33956 991C           85C0                       test	ax,ax
33957 991E           74           11            je  	.6C7
33958                       00009920            .6C8:
33959                                           ! 4949       print_boot_failure(e.type, 1);
33960                                           ! Debug: list int = const 1 (used reg = )
33961 9920           B8                   0001  mov	ax,*1
33962 9923           50                         push	ax
33963                                           ! Debug: list unsigned short e = [S+$20-$1E] (used reg = )
33964 9924           FF76         E4            push	-$1C[bp]
33965                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
33966 9927           E8         78FC            call	_print_boot_failure
33967 992A           83C4                   04  add	sp,*4
33968                                           !BCC_EOS
33969                                           ! 4950       return;
33970 992D           89EC                       mov	sp,bp
33971 992F           5D                         pop	bp
33972 9930           C3                         ret
33973                                           !BCC_EOS
33974                                           ! 4951     }
33975                                           ! 4952     if (e.type != 0x00 || !((inb_cmos(0x38) & 0x01))) {
33976                       00009931            .6C7:
33977                                           ! Debug: ne int = const 0 to unsigned short e = [S+$1E-$1E] (used reg = )
33978 9931           8B46         E4            mov	ax,-$1C[bp]
33979 9934           85C0                       test	ax,ax
33980 9936           75           0F            jne 	.6CA
33981                       00009938            .6CB:
33982                                           ! Debug: list int = const $38 (used reg = )
33983 9938           B8                   0038  mov	ax,*$38
33984 993B           50                         push	ax
33985                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
33986 993C           E8         6C4E            call	_inb_cmos
33987 993F           44                         inc	sp
33988 9940           44                         inc	sp
33989                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
33990 9941           24                     01  and	al,*1
33991 9943           84C0                       test	al,al
33992 9945           75           22            jne 	.6C9
33993                       00009947            .6CA:
33994                                           ! 4953       if (read_word(bootseg,0x1fe) != 0xaa55) {
33995                                           ! Debug: list int = const $1FE (used reg = )
33996 9947           B8                   01FE  mov	ax,#$1FE
33997 994A           50                         push	ax
33998                                           ! Debug: list unsigned short bootseg = [S+$20-$A] (used reg = )
33999 994B           FF76         F8            push	-8[bp]
34000                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
34001 994E           E8         6CC0            call	_read_word
34002 9951           83C4                   04  add	sp,*4
34003                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
34004 9954           3D                   AA55  cmp	ax,#$AA55
34005 9957           74           10            je  	.6CC
34006                       00009959            .6CD:
34007                                           ! 4954         print_boot_failure(e.type, 0);
34008                                           ! Debug: list int = const 0 (used reg = )
34009 9959           31C0                       xor	ax,ax
34010 995B           50                         push	ax
34011                                           ! Debug: list unsigned short e = [S+$20-$1E] (used reg = )
34012 995C           FF76         E4            push	-$1C[bp]
34013                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
34014 995F           E8         78C4            call	_print_boot_failure
34015 9962           83C4                   04  add	sp,*4
34016                                           !BCC_EOS
34017                                           ! 4955         return;
34018 9965           89EC                       mov	sp,bp
34019 9967           5D                         pop	bp
34020 9968           C3                         ret
34021                                           !BCC_EOS
34022                                           ! 4956       }
34023                                           ! 4957     }
34024                       00009969            .6CC:
34025                                           ! 4958     tcpa_add_bootdevice((Bit32u)0L, (Bit32u)bootdrv);
34026                       00009969            .6C9:
34027                                           ! Debug: cast unsigned long = const 0 to unsigned char bootdrv = [S+$1E-7] (used reg = )
34028 9969           8A46         FB            mov	al,-5[bp]
34029 996C           30E4                       xor	ah,ah
34030 996E           31DB                       xor	bx,bx
34031                                           ! Debug: list unsigned long = bx+0 (used reg = )
34032 9970           53                         push	bx
34033 9971           50                         push	ax
34034                                           ! Debug: list unsigned long = const 0 (used reg = )
34035 9972           31C0                       xor	ax,ax
34036 9974           31DB                       xor	bx,bx
34037 9976           53                         push	bx
34038 9977           50                         push	ax
34039                                           ! Debug: func () void = tcpa_add_bootdevice+0 (used reg = )
34040 9978           E8         0F68            call	_tcpa_add_bootdevice
34041 997B           83C4                   08  add	sp,*8
34042                                           !BCC_EOS
34043                                           ! 4959     tcpa_ipl((Bit32u)0L,(Bit32u)bootseg,(Bit32u)0L,(Bit32u)512L);
34044                                           ! Debug: list unsigned long = const $200 (used reg = )
34045 997E           B8                   0200  mov	ax,#$200
34046 9981           31DB                       xor	bx,bx
34047 9983           53                         push	bx
34048 9984           50                         push	ax
34049                                           ! Debug: list unsigned long = const 0 (used reg = )
34050 9985           31C0                       xor	ax,ax
34051 9987           31DB                       xor	bx,bx
34052 9989           53                         push	bx
34053 998A           50                         push	ax
34054                                           ! Debug: cast unsigned long = const 0 to unsigned short bootseg = [S+$26-$A] (used reg = )
34055 998B           8B46         F8            mov	ax,-8[bp]
34056 998E           31DB                       xor	bx,bx
34057                                           ! Debug: list unsigned long = bx+0 (used reg = )
34058 9990           53                         push	bx
34059 9991           50                         push	ax
34060                                           ! Debug: list unsigned long = const 0 (used reg = )
34061 9992           31C0                       xor	ax,ax
34062 9994           31DB                       xor	bx,bx
34063 9996           53                         push	bx
34064 9997           50                         push	ax
34065                                           ! Debug: func () void = tcpa_ipl+0 (used reg = )
34066 9998           E8         0F4E            call	_tcpa_ipl
34067 999B           83C4                   10  add	sp,*$10
34068                                           !BCC_EOS
34069                                           ! 4960     bootip = (bootseg & 0x0fff) << 4;
34070                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$1E-$A] (used reg = )
34071 999E           8B46         F8            mov	ax,-8[bp]
34072 99A1           25                   0FFF  and	ax,#$FFF
34073                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
34074 99A4           B1                     04  mov	cl,*4
34075 99A6           D3E0                       shl	ax,cl
34076                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$1E-$C] (used reg = )
34077 99A8           8946         F6            mov	-$A[bp],ax
34078                                           !BCC_EOS
34079                                           ! 4961     bootseg &= 0xf000;
34080                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$1E-$A] (used reg = )
34081 99AB           8B46         F8            mov	ax,-8[bp]
34082 99AE           25                   F000  and	ax,#$F000
34083 99B1           8946         F8            mov	-8[bp],ax
34084                                           !BCC_EOS
34085                                           ! 4962   break;
34086 99B4           E9         0096            br 	.6BF
34087                                           !BCC_EOS
34088                                           ! 4963   case 0x03:
34089                                           ! 4964     status = cdrom_boot();
34090                       000099B7            .6CE:
34091                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
34092 99B7           E8         9D73            call	_cdrom_boot
34093                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$1E-$E] (used reg = )
34094 99BA           8946         F4            mov	-$C[bp],ax
34095                                           !BCC_EOS
34096                                           ! 4965     if ( (status & 0x00ff) !=0 ) {
34097                                           ! Debug: and int = const $FF to unsigned short status = [S+$1E-$E] (used reg = )
34098 99BD           8A46         F4            mov	al,-$C[bp]
34099                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34100 99C0           84C0                       test	al,al
34101 99C2           74           19            je  	.6CF
34102                       000099C4            .6D0:
34103                                           ! 4966       print_cdromboot_failure(status);
34104                                           ! Debug: list unsigned short status = [S+$1E-$E] (used reg = )
34105 99C4           FF76         F4            push	-$C[bp]
34106                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
34107 99C7           E8         78D4            call	_print_cdromboot_failure
34108 99CA           44                         inc	sp
34109 99CB           44                         inc	sp
34110                                           !BCC_EOS
34111                                           ! 4967       print_boot_failure(e.type, 1);
34112                                           ! Debug: list int = const 1 (used reg = )
34113 99CC           B8                   0001  mov	ax,*1
34114 99CF           50                         push	ax
34115                                           ! Debug: list unsigned short e = [S+$20-$1E] (used reg = )
34116 99D0           FF76         E4            push	-$1C[bp]
34117                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
34118 99D3           E8         7850            call	_print_boot_failure
34119 99D6           83C4                   04  add	sp,*4
34120                                           !BCC_EOS
34121                                           ! 4968       return;
34122 99D9           89EC                       mov	sp,bp
34123 99DB           5D                         pop	bp
34124 99DC           C3                         ret
34125                                           !BCC_EOS
34126                                           ! 4969     }
34127                                           ! 4970     bootdrv = (Bit8u)(status>>8);
34128                       000099DD            .6CF:
34129                                           ! Debug: sr int = const 8 to unsigned short status = [S+$1E-$E] (used reg = )
34130 99DD           8B46         F4            mov	ax,-$C[bp]
34131 99E0           88E0                       mov	al,ah
34132 99E2           30E4                       xor	ah,ah
34133                                           ! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
34134                                           ! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$1E-7] (used reg = )
34135 99E4           8846         FB            mov	-5[bp],al
34136                                           !BCC_EOS
34137                                           ! 4971     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
34138                                           ! Debug: list * unsigned short = const $246 (used reg = )
34139 99E7           B8                   0246  mov	ax,#$246
34140 99EA           50                         push	ax
34141                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
34142 99EB           FF76         FE            push	-2[bp]
34143                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
34144 99EE           E8         6C20            call	_read_word
34145 99F1           83C4                   04  add	sp,*4
34146                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$1E-$A] (used reg = )
34147 99F4           8946         F8            mov	-8[bp],ax
34148                                           !BCC_EOS
34149                                           ! 4972     bootip = (bootseg & 0x0fff) << 4;
34150                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$1E-$A] (used reg = )
34151 99F7           8B46         F8            mov	ax,-8[bp]
34152 99FA           25                   0FFF  and	ax,#$FFF
34153                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
34154 99FD           B1                     04  mov	cl,*4
34155 99FF           D3E0                       shl	ax,cl
34156                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$1E-$C] (used reg = )
34157 9A01           8946         F6            mov	-$A[bp],ax
34158                                           !BCC_EOS
34159                                           ! 4973     bootseg &= 0xf000;
34160                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$1E-$A] (used reg = )
34161 9A04           8B46         F8            mov	ax,-8[bp]
34162 9A07           25                   F000  and	ax,#$F000
34163 9A0A           8946         F8            mov	-8[bp],ax
34164                                           !BCC_EOS
34165                                           ! 4974     break;
34166 9A0D           EB           3E            jmp .6BF
34167                                           !BCC_EOS
34168                                           ! 4975   case 0x80:
34169                                           ! 4976     bootseg = e.vector >> 16;
34170                       00009A0F            .6D1:
34171                                           ! Debug: sr int = const $10 to unsigned long e = [S+$1E-$1A] (used reg = )
34172 9A0F           8B46         E8            mov	ax,-$18[bp]
34173 9A12           8B5E         EA            mov	bx,-$16[bp]
34174 9A15           93                         xchg	bx,ax
34175 9A16           31DB                       xor	bx,bx
34176                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$1E-$A] (used reg = )
34177 9A18           8946         F8            mov	-8[bp],ax
34178                                           !BCC_EOS
34179                                           ! 4977     bootip = e.vector & 0xffff;
34180                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$1E-$1A] (used reg = )
34181                                           ! Debug: expression subtree swapping
34182 9A1B           B8                   FFFF  mov	ax,#$FFFF
34183 9A1E           31DB                       xor	bx,bx
34184 9A20           8D7E         E8            lea	di,-$18[bp]
34185 9A23           E8         6665            call	landul
34186                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$1E-$C] (used reg = )
34187 9A26           8946         F6            mov	-$A[bp],ax
34188                                           !BCC_EOS
34189                                           ! 4978     break;
34190 9A29           EB           22            jmp .6BF
34191                                           !BCC_EOS
34192                                           ! 4979   default: return;
34193                       00009A2B            .6D2:
34194 9A2B           89EC                       mov	sp,bp
34195 9A2D           5D                         pop	bp
34196 9A2E           C3                         ret
34197                                           !BCC_EOS
34198                                           ! 4980   }
34199                                           ! 4981 #asm
34200 9A2F           EB           1C            jmp .6BF
34201                       00009A31            .6C1:
34202 9A31           2D                   0001  sub	ax,*1
34203 9A34         0F84         FE9A            beq 	.6C2
34204 9A38           2D                   0001  sub	ax,*1
34205 9A3B         0F84         FE93            beq 	.6C3
34206 9A3F           2D                   0001  sub	ax,*1
34207 9A42         0F84         FF71            beq 	.6CE
34208 9A46           2D                   007D  sub	ax,*$7D
34209 9A49           74           C4            je 	.6D1
34210 9A4B           EB           DE            jmp	.6D2
34211                       00009A4D            .6BF:
34212                       FFFFFFE2            ..FFDA	=	-$1E
34213                                           !BCC_EOS
34214                                           !BCC_ASM
34215                       00000012            _int18_function.bootip	set	$12
34216                       FFFFFFF6            .int18_function.bootip	set	-$A
34217                       00000020            _int18_function.seq_nr	set	$20
34218                       00000004            .int18_function.seq_nr	set	4
34219                       00000016            _int18_function.bootchk	set	$16
34220                       FFFFFFFA            .int18_function.bootchk	set	-6
34221                       00000014            _int18_function.bootseg	set	$14
34222                       FFFFFFF8            .int18_function.bootseg	set	-8
34223                       0000001A            _int18_function.ebda_seg	set	$1A
34224                       FFFFFFFE            .int18_function.ebda_seg	set	-2
34225                       00000010            _int18_function.status	set	$10
34226                       FFFFFFF4            .int18_function.status	set	-$C
34227                       00000017            _int18_function.bootdrv	set	$17
34228                       FFFFFFFB            .int18_function.bootdrv	set	-5
34229                       00000018            _int18_function.bootdev	set	$18
34230                       FFFFFFFC            .int18_function.bootdev	set	-4
34231                       00000000            _int18_function.e	set	0
34232                       FFFFFFE4            .int18_function.e	set	-$1C
34233 9A4D           89E5                           mov bp, sp
34234                                               ;; Build an iret stack frame that will take us to the boot vector.
34235                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
34236 9A4F           9C                             pushf
34237 9A50           8B46         14                mov ax, _int18_function.bootseg + 0[bp]
34238 9A53           50                             push ax
34239 9A54           8B46         12                mov ax, _int18_function.bootip + 0[bp]
34240 9A57           50                             push ax
34241                                               ;; Set the magic number in ax and the boot drive in dl.
34242 9A58           B8                   AA55      mov ax, #0xaa55
34243 9A5B           8A56         17                mov dl, _int18_function.bootdrv + 0[bp]
34244                                               ;; Zero some of the other registers.
34245 9A5E           31DB                           xor bx, bx
34246 9A60           8EDB                           mov ds, bx
34247 9A62           8EC3                           mov es, bx
34248 9A64           89DD                           mov bp, bx
34249                                               ;; Go!
34250 9A66           CF                             iret
34251                                           ! 5000 endasm
34252                                           !BCC_ENDASM
34253                                           !BCC_EOS
34254                                           ! 5001 }
34255 9A67           89EC                       mov	sp,bp
34256 9A69           5D                         pop	bp
34257 9A6A           C3                         ret
34258                                           ! 5002   void
34259                                           ! Register BX used in function int18_function
34260                                           ! 5003 int1a_function(regs, ds, iret_addr)
34261                                           ! 5004   pusha_regs_t regs;
34262                                           export	_int1a_function
34263                       00009A6B            _int1a_function:
34264                                           !BCC_EOS
34265                                           ! 5005   Bit16u ds;
34266                                           !BCC_EOS
34267                                           ! 5006   iret_addr_t iret_addr;
34268                                           !BCC_EOS
34269                                           ! 5007 {
34270                                           ! 5008   Bit8u val8;
34271                                           !BCC_EOS
34272                                           ! 5009   ;
34273 9A6B           55                         push	bp
34274 9A6C           89E5                       mov	bp,sp
34275 9A6E           4C                         dec	sp
34276 9A6F           4C                         dec	sp
34277                                           !BCC_EOS
34278                                           ! 5010 #asm
34279                                           !BCC_EOS
34280                                           !BCC_ASM
34281                       00000016            _int1a_function.ds	set	$16
34282                       00000014            .int1a_function.ds	set	$14
34283                       00000001            _int1a_function.val8	set	1
34284                       FFFFFFFF            .int1a_function.val8	set	-1
34285                       00000018            _int1a_function.iret_addr	set	$18
34286                       00000016            .int1a_function.iret_addr	set	$16
34287                       00000006            _int1a_function.regs	set	6
34288                       00000004            .int1a_function.regs	set	4
34289 9A70           FB                           sti
34290                                           ! 5012 endasm
34291                                           !BCC_ENDASM
34292                                           !BCC_EOS
34293                                           ! 5013   switch (regs.u.r8.ah) {
34294 9A71           8A46         13            mov	al,$13[bp]
34295 9A74           E9         0348            br 	.6D5
34296                                           ! 5014     case 0:
34297                                           ! 5015 #asm
34298                       00009A77            .6D6:
34299                                           !BCC_EOS
34300                                           !BCC_ASM
34301                       00000016            _int1a_function.ds	set	$16
34302                       00000014            .int1a_function.ds	set	$14
34303                       00000001            _int1a_function.val8	set	1
34304                       FFFFFFFF            .int1a_function.val8	set	-1
34305                       00000018            _int1a_function.iret_addr	set	$18
34306                       00000016            .int1a_function.iret_addr	set	$16
34307                       00000006            _int1a_function.regs	set	6
34308                       00000004            .int1a_function.regs	set	4
34309 9A77           FA                               cli
34310                                           ! 5017 endasm
34311                                           !BCC_ENDASM
34312                                           !BCC_EOS
34313                                           ! 5018       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
34314                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
34315 9A78           A1         046E            mov	ax,[$46E]
34316 9A7B           8946         10            mov	$10[bp],ax
34317                                           !BCC_EOS
34318                                           ! 5019       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
34319                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
34320 9A7E           A1         046C            mov	ax,[$46C]
34321 9A81           8946         0E            mov	$E[bp],ax
34322                                           !BCC_EOS
34323                                           ! 5020       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
34324                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
34325 9A84           A0         0470            mov	al,[$470]
34326 9A87           8846         12            mov	$12[bp],al
34327                                           !BCC_EOS
34328                                           ! 5021       ((bios_data_t *) 0)->midnight_flag = 0;
34329                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
34330 9A8A           30C0                       xor	al,al
34331 9A8C           A2         0470            mov	[$470],al
34332                                           !BCC_EOS
34333                                           ! 5022 #asm
34334                                           !BCC_EOS
34335                                           !BCC_ASM
34336                       00000016            _int1a_function.ds	set	$16
34337                       00000014            .int1a_function.ds	set	$14
34338                       00000001            _int1a_function.val8	set	1
34339                       FFFFFFFF            .int1a_function.val8	set	-1
34340                       00000018            _int1a_function.iret_addr	set	$18
34341                       00000016            .int1a_function.iret_addr	set	$16
34342                       00000006            _int1a_function.regs	set	6
34343                       00000004            .int1a_function.regs	set	4
34344 9A8F           FB                               sti
34345                                           ! 5024 endasm
34346                                           !BCC_ENDASM
34347                                           !BCC_EOS
34348                                           ! 5025       iret_addr.flags.u.r8.flagsl &= 0xfe;
34349                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
34350 9A90           8A46         1A            mov	al,$1A[bp]
34351 9A93           24                     FE  and	al,#$FE
34352 9A95           8846         1A            mov	$1A[bp],al
34353                                           !BCC_EOS
34354                                           ! 5026       break;
34355 9A98           E9         034F            br 	.6D3
34356                                           !BCC_EOS
34357                                           ! 5027     case 1:
34358                                           ! 5028 #asm
34359                       00009A9B            .6D7:
34360                                           !BCC_EOS
34361                                           !BCC_ASM
34362                       00000016            _int1a_function.ds	set	$16
34363                       00000014            .int1a_function.ds	set	$14
34364                       00000001            _int1a_function.val8	set	1
34365                       FFFFFFFF            .int1a_function.val8	set	-1
34366                       00000018            _int1a_function.iret_addr	set	$18
34367                       00000016            .int1a_function.iret_addr	set	$16
34368                       00000006            _int1a_function.regs	set	6
34369                       00000004            .int1a_function.regs	set	4
34370 9A9B           FA                               cli
34371                                           ! 5030 endasm
34372                                           !BCC_ENDASM
34373                                           !BCC_EOS
34374                                           ! 5031       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
34375                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
34376 9A9C           8B46         10            mov	ax,$10[bp]
34377 9A9F           A3         046E            mov	[$46E],ax
34378                                           !BCC_EOS
34379                                           ! 5032       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
34380                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
34381 9AA2           8B46         0E            mov	ax,$E[bp]
34382 9AA5           A3         046C            mov	[$46C],ax
34383                                           !BCC_EOS
34384                                           ! 5033       ((bios_data_t *) 0)->midnight_flag = 0;
34385                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
34386 9AA8           30C0                       xor	al,al
34387 9AAA           A2         0470            mov	[$470],al
34388                                           !BCC_EOS
34389                                           ! 5034 #asm
34390                                           !BCC_EOS
34391                                           !BCC_ASM
34392                       00000016            _int1a_function.ds	set	$16
34393                       00000014            .int1a_function.ds	set	$14
34394                       00000001            _int1a_function.val8	set	1
34395                       FFFFFFFF            .int1a_function.val8	set	-1
34396                       00000018            _int1a_function.iret_addr	set	$18
34397                       00000016            .int1a_function.iret_addr	set	$16
34398                       00000006            _int1a_function.regs	set	6
34399                       00000004            .int1a_function.regs	set	4
34400 9AAD           FB                               sti
34401                                           ! 5036 endasm
34402                                           !BCC_ENDASM
34403                                           !BCC_EOS
34404                                           ! 5037       regs.u.r8.ah = 0;
34405                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
34406 9AAE           30C0                       xor	al,al
34407 9AB0           8846         13            mov	$13[bp],al
34408                                           !BCC_EOS
34409                                           ! 5038       iret_addr.flags.u.r8.flagsl &= 0xfe;
34410                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
34411 9AB3           8A46         1A            mov	al,$1A[bp]
34412 9AB6           24                     FE  and	al,#$FE
34413 9AB8           8846         1A            mov	$1A[bp],al
34414                                           !BCC_EOS
34415                                           ! 5039       break;
34416 9ABB           E9         032C            br 	.6D3
34417                                           !BCC_EOS
34418                                           ! 5040     case 2:
34419                                           ! 5041       if (rtc_updating()) {
34420                       00009ABE            .6D8:
34421                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
34422 9ABE           E8         6B09            call	_rtc_updating
34423 9AC1           85C0                       test	ax,ax
34424 9AC3           74           0B            je  	.6D9
34425                       00009AC5            .6DA:
34426                                           ! 5042         iret_addr.flags.u.r8.flagsl |= 0x01;
34427                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
34428 9AC5           8A46         1A            mov	al,$1A[bp]
34429 9AC8           0C                     01  or	al,*1
34430 9ACA           8846         1A            mov	$1A[bp],al
34431                                           !BCC_EOS
34432                                           ! 5043         break;
34433 9ACD           E9         031A            br 	.6D3
34434                                           !BCC_EOS
34435                                           ! 5044         }
34436                                           ! 5045       regs.u.r8.dh = inb_cmos(0x00);
34437                       00009AD0            .6D9:
34438                                           ! Debug: list int = const 0 (used reg = )
34439 9AD0           31C0                       xor	ax,ax
34440 9AD2           50                         push	ax
34441                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34442 9AD3           E8         6AB7            call	_inb_cmos
34443 9AD6           44                         inc	sp
34444 9AD7           44                         inc	sp
34445                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
34446 9AD8           8846         0F            mov	$F[bp],al
34447                                           !BCC_EOS
34448                                           ! 5046       regs.u.r8.cl = inb_cmos(0x02);
34449                                           ! Debug: list int = const 2 (used reg = )
34450 9ADB           B8                   0002  mov	ax,*2
34451 9ADE           50                         push	ax
34452                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34453 9ADF           E8         6AAB            call	_inb_cmos
34454 9AE2           44                         inc	sp
34455 9AE3           44                         inc	sp
34456                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
34457 9AE4           8846         10            mov	$10[bp],al
34458                                           !BCC_EOS
34459                                           ! 5047       regs.u.r8.ch = inb_cmos(0x04);
34460                                           ! Debug: list int = const 4 (used reg = )
34461 9AE7           B8                   0004  mov	ax,*4
34462 9AEA           50                         push	ax
34463                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34464 9AEB           E8         6A9F            call	_inb_cmos
34465 9AEE           44                         inc	sp
34466 9AEF           44                         inc	sp
34467                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
34468 9AF0           8846         11            mov	$11[bp],al
34469                                           !BCC_EOS
34470                                           ! 5048       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
34471                                           ! Debug: list int = const $B (used reg = )
34472 9AF3           B8                   000B  mov	ax,*$B
34473 9AF6           50                         push	ax
34474                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34475 9AF7           E8         6A93            call	_inb_cmos
34476 9AFA           44                         inc	sp
34477 9AFB           44                         inc	sp
34478                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
34479 9AFC           24                     01  and	al,*1
34480                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
34481 9AFE           8846         0E            mov	$E[bp],al
34482                                           !BCC_EOS
34483                                           ! 5049       regs.u.r8.ah = 0;
34484                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
34485 9B01           30C0                       xor	al,al
34486 9B03           8846         13            mov	$13[bp],al
34487                                           !BCC_EOS
34488                                           ! 5050       regs.u.r8.al = regs.u.r8.ch;
34489                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
34490 9B06           8A46         11            mov	al,$11[bp]
34491 9B09           8846         12            mov	$12[bp],al
34492                                           !BCC_EOS
34493                                           ! 5051       iret_addr.flags.u.r8.flagsl &= 0xfe;
34494                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
34495 9B0C           8A46         1A            mov	al,$1A[bp]
34496 9B0F           24                     FE  and	al,#$FE
34497 9B11           8846         1A            mov	$1A[bp],al
34498                                           !BCC_EOS
34499                                           ! 5052       break;
34500 9B14           E9         02D3            br 	.6D3
34501                                           !BCC_EOS
34502                                           ! 5053     case 3:
34503                                           ! 5054       if (rtc_updating()) {
34504                       00009B17            .6DB:
34505                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
34506 9B17           E8         6AB0            call	_rtc_updating
34507 9B1A           85C0                       test	ax,ax
34508 9B1C           74           03            je  	.6DC
34509                       00009B1E            .6DD:
34510                                           ! 5055         init_rtc();
34511                                           ! Debug: func () void = init_rtc+0 (used reg = )
34512 9B1E           E8         6A78            call	_init_rtc
34513                                           !BCC_EOS
34514                                           ! 5056         }
34515                                           ! 5057       outb_cmos(0x00, regs.u.r8.dh);
34516                       00009B21            .6DC:
34517                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
34518 9B21           8A46         0F            mov	al,$F[bp]
34519 9B24           30E4                       xor	ah,ah
34520 9B26           50                         push	ax
34521                                           ! Debug: list int = const 0 (used reg = )
34522 9B27           31C0                       xor	ax,ax
34523 9B29           50                         push	ax
34524                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34525 9B2A           E8         6A51            call	_outb_cmos
34526 9B2D           83C4                   04  add	sp,*4
34527                                           !BCC_EOS
34528                                           ! 5058       outb_cmos(0x02, regs.u.r8.cl);
34529                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
34530 9B30           8A46         10            mov	al,$10[bp]
34531 9B33           30E4                       xor	ah,ah
34532 9B35           50                         push	ax
34533                                           ! Debug: list int = const 2 (used reg = )
34534 9B36           B8                   0002  mov	ax,*2
34535 9B39           50                         push	ax
34536                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34537 9B3A           E8         6A41            call	_outb_cmos
34538 9B3D           83C4                   04  add	sp,*4
34539                                           !BCC_EOS
34540                                           ! 5059       outb_cmos(0x04, regs.u.r8.ch);
34541                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
34542 9B40           8A46         11            mov	al,$11[bp]
34543 9B43           30E4                       xor	ah,ah
34544 9B45           50                         push	ax
34545                                           ! Debug: list int = const 4 (used reg = )
34546 9B46           B8                   0004  mov	ax,*4
34547 9B49           50                         push	ax
34548                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34549 9B4A           E8         6A31            call	_outb_cmos
34550 9B4D           83C4                   04  add	sp,*4
34551                                           !BCC_EOS
34552                                           ! 5060       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
34553                                           ! Debug: expression subtree swapping
34554                                           ! Debug: list int = const $B (used reg = )
34555 9B50           B8                   000B  mov	ax,*$B
34556 9B53           50                         push	ax
34557                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34558 9B54           E8         6A36            call	_inb_cmos
34559 9B57           44                         inc	sp
34560 9B58           44                         inc	sp
34561                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
34562 9B59           24                     60  and	al,*$60
34563                                           ! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
34564 9B5B           0C                     02  or	al,*2
34565 9B5D           50                         push	ax
34566                                           ! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
34567 9B5E           8A46         0E            mov	al,$E[bp]
34568 9B61           24                     01  and	al,*1
34569                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
34570 9B63           0A46         FC            or	al,0+..FFD9[bp]
34571 9B66           44                         inc	sp
34572 9B67           44                         inc	sp
34573                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
34574 9B68           8846         FF            mov	-1[bp],al
34575                                           !BCC_EOS
34576                                           ! 5061       outb_cmos(0x0b, val8);
34577                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
34578 9B6B           8A46         FF            mov	al,-1[bp]
34579 9B6E           30E4                       xor	ah,ah
34580 9B70           50                         push	ax
34581                                           ! Debug: list int = const $B (used reg = )
34582 9B71           B8                   000B  mov	ax,*$B
34583 9B74           50                         push	ax
34584                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34585 9B75           E8         6A06            call	_outb_cmos
34586 9B78           83C4                   04  add	sp,*4
34587                                           !BCC_EOS
34588                                           ! 5062       regs.u.r8.ah = 0;
34589                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
34590 9B7B           30C0                       xor	al,al
34591 9B7D           8846         13            mov	$13[bp],al
34592                                           !BCC_EOS
34593                                           ! 5063       regs.u.r8.al = val8;
34594                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
34595 9B80           8A46         FF            mov	al,-1[bp]
34596 9B83           8846         12            mov	$12[bp],al
34597                                           !BCC_EOS
34598                                           ! 5064       iret_addr.flags.u.r8.flagsl &= 0xfe;
34599                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
34600 9B86           8A46         1A            mov	al,$1A[bp]
34601 9B89           24                     FE  and	al,#$FE
34602 9B8B           8846         1A            mov	$1A[bp],al
34603                                           !BCC_EOS
34604                                           ! 5065       break;
34605 9B8E           E9         0259            br 	.6D3
34606                                           !BCC_EOS
34607                                           ! 5066     case 4:
34608                                           ! 5067       regs.u.r8.ah = 0;
34609                       00009B91            .6DE:
34610                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
34611 9B91           30C0                       xor	al,al
34612 9B93           8846         13            mov	$13[bp],al
34613                                           !BCC_EOS
34614                                           ! 5068       if (rtc_updating()) {
34615                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
34616 9B96           E8         6A31            call	_rtc_updating
34617 9B99           85C0                       test	ax,ax
34618 9B9B           74           0B            je  	.6DF
34619                       00009B9D            .6E0:
34620                                           ! 5069         iret_addr.flags.u.r8.flagsl |= 0x01;
34621                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
34622 9B9D           8A46         1A            mov	al,$1A[bp]
34623 9BA0           0C                     01  or	al,*1
34624 9BA2           8846         1A            mov	$1A[bp],al
34625                                           !BCC_EOS
34626                                           ! 5070         break;
34627 9BA5           E9         0242            br 	.6D3
34628                                           !BCC_EOS
34629                                           ! 5071         }
34630                                           ! 5072       regs.u.r8.cl = inb_cmos(0x09);
34631                       00009BA8            .6DF:
34632                                           ! Debug: list int = const 9 (used reg = )
34633 9BA8           B8                   0009  mov	ax,*9
34634 9BAB           50                         push	ax
34635                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34636 9BAC           E8         69DE            call	_inb_cmos
34637 9BAF           44                         inc	sp
34638 9BB0           44                         inc	sp
34639                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
34640 9BB1           8846         10            mov	$10[bp],al
34641                                           !BCC_EOS
34642                                           ! 5073       regs.u.r8.dh = inb_cmos(0x08);
34643                                           ! Debug: list int = const 8 (used reg = )
34644 9BB4           B8                   0008  mov	ax,*8
34645 9BB7           50                         push	ax
34646                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34647 9BB8           E8         69D2            call	_inb_cmos
34648 9BBB           44                         inc	sp
34649 9BBC           44                         inc	sp
34650                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
34651 9BBD           8846         0F            mov	$F[bp],al
34652                                           !BCC_EOS
34653                                           ! 5074       regs.u.r8.dl = inb_cmos(0x07);
34654                                           ! Debug: list int = const 7 (used reg = )
34655 9BC0           B8                   0007  mov	ax,*7
34656 9BC3           50                         push	ax
34657                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34658 9BC4           E8         69C6            call	_inb_cmos
34659 9BC7           44                         inc	sp
34660 9BC8           44                         inc	sp
34661                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
34662 9BC9           8846         0E            mov	$E[bp],al
34663                                           !BCC_EOS
34664                                           ! 5075       regs.u.r8.ch = inb_cmos(0x32);
34665                                           ! Debug: list int = const $32 (used reg = )
34666 9BCC           B8                   0032  mov	ax,*$32
34667 9BCF           50                         push	ax
34668                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34669 9BD0           E8         69BA            call	_inb_cmos
34670 9BD3           44                         inc	sp
34671 9BD4           44                         inc	sp
34672                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
34673 9BD5           8846         11            mov	$11[bp],al
34674                                           !BCC_EOS
34675                                           ! 5076       regs.u.r8.al = regs.u.r8.ch;
34676                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
34677 9BD8           8A46         11            mov	al,$11[bp]
34678 9BDB           8846         12            mov	$12[bp],al
34679                                           !BCC_EOS
34680                                           ! 5077       iret_addr.flags.u.r8.flagsl &= 0xfe;
34681                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
34682 9BDE           8A46         1A            mov	al,$1A[bp]
34683 9BE1           24                     FE  and	al,#$FE
34684 9BE3           8846         1A            mov	$1A[bp],al
34685                                           !BCC_EOS
34686                                           ! 5078       break;
34687 9BE6           E9         0201            br 	.6D3
34688                                           !BCC_EOS
34689                                           ! 5079     case 5:
34690                                           ! 5080       if (rtc_updating(
34691                       00009BE9            .6E1:
34692                                           ! 5080 )) {
34693                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
34694 9BE9           E8         69DE            call	_rtc_updating
34695 9BEC           85C0                       test	ax,ax
34696 9BEE           74           0E            je  	.6E2
34697                       00009BF0            .6E3:
34698                                           ! 5081         init_rtc();
34699                                           ! Debug: func () void = init_rtc+0 (used reg = )
34700 9BF0           E8         69A6            call	_init_rtc
34701                                           !BCC_EOS
34702                                           ! 5082         iret_addr.flags.u.r8.flagsl |= 0x01;
34703                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
34704 9BF3           8A46         1A            mov	al,$1A[bp]
34705 9BF6           0C                     01  or	al,*1
34706 9BF8           8846         1A            mov	$1A[bp],al
34707                                           !BCC_EOS
34708                                           ! 5083         break;
34709 9BFB           E9         01EC            br 	.6D3
34710                                           !BCC_EOS
34711                                           ! 5084         }
34712                                           ! 5085       outb_cmos(0x09, regs.u.r8.cl);
34713                       00009BFE            .6E2:
34714                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
34715 9BFE           8A46         10            mov	al,$10[bp]
34716 9C01           30E4                       xor	ah,ah
34717 9C03           50                         push	ax
34718                                           ! Debug: list int = const 9 (used reg = )
34719 9C04           B8                   0009  mov	ax,*9
34720 9C07           50                         push	ax
34721                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34722 9C08           E8         6973            call	_outb_cmos
34723 9C0B           83C4                   04  add	sp,*4
34724                                           !BCC_EOS
34725                                           ! 5086       outb_cmos(0x08, regs.u.r8.dh);
34726                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
34727 9C0E           8A46         0F            mov	al,$F[bp]
34728 9C11           30E4                       xor	ah,ah
34729 9C13           50                         push	ax
34730                                           ! Debug: list int = const 8 (used reg = )
34731 9C14           B8                   0008  mov	ax,*8
34732 9C17           50                         push	ax
34733                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34734 9C18           E8         6963            call	_outb_cmos
34735 9C1B           83C4                   04  add	sp,*4
34736                                           !BCC_EOS
34737                                           ! 5087       outb_cmos(0x07, regs.u.r8.dl);
34738                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
34739 9C1E           8A46         0E            mov	al,$E[bp]
34740 9C21           30E4                       xor	ah,ah
34741 9C23           50                         push	ax
34742                                           ! Debug: list int = const 7 (used reg = )
34743 9C24           B8                   0007  mov	ax,*7
34744 9C27           50                         push	ax
34745                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34746 9C28           E8         6953            call	_outb_cmos
34747 9C2B           83C4                   04  add	sp,*4
34748                                           !BCC_EOS
34749                                           ! 5088       outb_cmos(0x32, regs.u.r8.ch);
34750                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
34751 9C2E           8A46         11            mov	al,$11[bp]
34752 9C31           30E4                       xor	ah,ah
34753 9C33           50                         push	ax
34754                                           ! Debug: list int = const $32 (used reg = )
34755 9C34           B8                   0032  mov	ax,*$32
34756 9C37           50                         push	ax
34757                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34758 9C38           E8         6943            call	_outb_cmos
34759 9C3B           83C4                   04  add	sp,*4
34760                                           !BCC_EOS
34761                                           ! 5089       val8 = inb_cmos(0x0b) & 0x7f;
34762                                           ! Debug: list int = const $B (used reg = )
34763 9C3E           B8                   000B  mov	ax,*$B
34764 9C41           50                         push	ax
34765                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34766 9C42           E8         6948            call	_inb_cmos
34767 9C45           44                         inc	sp
34768 9C46           44                         inc	sp
34769                                           ! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
34770 9C47           24                     7F  and	al,*$7F
34771                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
34772 9C49           8846         FF            mov	-1[bp],al
34773                                           !BCC_EOS
34774                                           ! 5090       outb_cmos(0x0b, val8);
34775                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
34776 9C4C           8A46         FF            mov	al,-1[bp]
34777 9C4F           30E4                       xor	ah,ah
34778 9C51           50                         push	ax
34779                                           ! Debug: list int = const $B (used reg = )
34780 9C52           B8                   000B  mov	ax,*$B
34781 9C55           50                         push	ax
34782                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34783 9C56           E8         6925            call	_outb_cmos
34784 9C59           83C4                   04  add	sp,*4
34785                                           !BCC_EOS
34786                                           ! 5091       regs.u.r8.ah = 0;
34787                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
34788 9C5C           30C0                       xor	al,al
34789 9C5E           8846         13            mov	$13[bp],al
34790                                           !BCC_EOS
34791                                           ! 5092       regs.u.r8.al = val8;
34792                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
34793 9C61           8A46         FF            mov	al,-1[bp]
34794 9C64           8846         12            mov	$12[bp],al
34795                                           !BCC_EOS
34796                                           ! 5093       iret_addr.flags.u.r8.flagsl &= 0xfe;
34797                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
34798 9C67           8A46         1A            mov	al,$1A[bp]
34799 9C6A           24                     FE  and	al,#$FE
34800 9C6C           8846         1A            mov	$1A[bp],al
34801                                           !BCC_EOS
34802                                           ! 5094       break;
34803 9C6F           E9         0178            br 	.6D3
34804                                           !BCC_EOS
34805                                           ! 5095     case 6:
34806                                           ! 5096       val8 = inb_cmos(0x0b);
34807                       00009C72            .6E4:
34808                                           ! Debug: list int = const $B (used reg = )
34809 9C72           B8                   000B  mov	ax,*$B
34810 9C75           50                         push	ax
34811                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34812 9C76           E8         6914            call	_inb_cmos
34813 9C79           44                         inc	sp
34814 9C7A           44                         inc	sp
34815                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
34816 9C7B           8846         FF            mov	-1[bp],al
34817                                           !BCC_EOS
34818                                           ! 5097       regs.u.r16.ax = 0;
34819                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
34820 9C7E           31C0                       xor	ax,ax
34821 9C80           8946         12            mov	$12[bp],ax
34822                                           !BCC_EOS
34823                                           ! 5098       if (val8 & 0x20) {
34824                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
34825 9C83           8A46         FF            mov	al,-1[bp]
34826 9C86           24                     20  and	al,*$20
34827 9C88           84C0                       test	al,al
34828 9C8A           74           0B            je  	.6E5
34829                       00009C8C            .6E6:
34830                                           ! 5099         iret_addr.flags.u.r8.flagsl |= 0x01;
34831                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
34832 9C8C           8A46         1A            mov	al,$1A[bp]
34833 9C8F           0C                     01  or	al,*1
34834 9C91           8846         1A            mov	$1A[bp],al
34835                                           !BCC_EOS
34836                                           ! 5100         break;
34837 9C94           E9         0153            br 	.6D3
34838                                           !BCC_EOS
34839                                           ! 5101         }
34840                                           ! 5102       if (rtc_updating()) {
34841                       00009C97            .6E5:
34842                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
34843 9C97           E8         6930            call	_rtc_updating
34844 9C9A           85C0                       test	ax,ax
34845 9C9C           74           03            je  	.6E7
34846                       00009C9E            .6E8:
34847                                           ! 5103         init_rtc();
34848                                           ! Debug: func () void = init_rtc+0 (used reg = )
34849 9C9E           E8         68F8            call	_init_rtc
34850                                           !BCC_EOS
34851                                           ! 5104         }
34852                                           ! 5105       outb_cmos(0x01, regs.u.r8.dh);
34853                       00009CA1            .6E7:
34854                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
34855 9CA1           8A46         0F            mov	al,$F[bp]
34856 9CA4           30E4                       xor	ah,ah
34857 9CA6           50                         push	ax
34858                                           ! Debug: list int = const 1 (used reg = )
34859 9CA7           B8                   0001  mov	ax,*1
34860 9CAA           50                         push	ax
34861                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34862 9CAB           E8         68D0            call	_outb_cmos
34863 9CAE           83C4                   04  add	sp,*4
34864                                           !BCC_EOS
34865                                           ! 5106       outb_cmos(0x03, regs.u.r8.cl);
34866                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
34867 9CB1           8A46         10            mov	al,$10[bp]
34868 9CB4           30E4                       xor	ah,ah
34869 9CB6           50                         push	ax
34870                                           ! Debug: list int = const 3 (used reg = )
34871 9CB7           B8                   0003  mov	ax,*3
34872 9CBA           50                         push	ax
34873                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34874 9CBB           E8         68C0            call	_outb_cmos
34875 9CBE           83C4                   04  add	sp,*4
34876                                           !BCC_EOS
34877                                           ! 5107       outb_cmos(0x05, regs.u.r8.ch);
34878                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
34879 9CC1           8A46         11            mov	al,$11[bp]
34880 9CC4           30E4                       xor	ah,ah
34881 9CC6           50                         push	ax
34882                                           ! Debug: list int = const 5 (used reg = )
34883 9CC7           B8                   0005  mov	ax,*5
34884 9CCA           50                         push	ax
34885                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34886 9CCB           E8         68B0            call	_outb_cmos
34887 9CCE           83C4                   04  add	sp,*4
34888                                           !BCC_EOS
34889                                           ! 5108       outb(0xa1, inb(0xa1) & 0xfe);
34890                                           ! Debug: list int = const $A1 (used reg = )
34891 9CD1           B8                   00A1  mov	ax,#$A1
34892 9CD4           50                         push	ax
34893                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34894 9CD5           E8         6870            call	_inb
34895 9CD8           44                         inc	sp
34896 9CD9           44                         inc	sp
34897                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
34898 9CDA           24                     FE  and	al,#$FE
34899                                           ! Debug: list unsigned char = al+0 (used reg = )
34900 9CDC           30E4                       xor	ah,ah
34901 9CDE           50                         push	ax
34902                                           ! Debug: list int = const $A1 (used reg = )
34903 9CDF           B8                   00A1  mov	ax,#$A1
34904 9CE2           50                         push	ax
34905                                           ! Debug: func () void = outb+0 (used reg = )
34906 9CE3           E8         6878            call	_outb
34907 9CE6           83C4                   04  add	sp,*4
34908                                           !BCC_EOS
34909                                           ! 5109       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
34910                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
34911 9CE9           8A46         FF            mov	al,-1[bp]
34912 9CEC           24                     7F  and	al,*$7F
34913                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
34914 9CEE           0C                     20  or	al,*$20
34915                                           ! Debug: list unsigned char = al+0 (used reg = )
34916 9CF0           30E4                       xor	ah,ah
34917 9CF2           50                         push	ax
34918                                           ! Debug: list int = const $B (used reg = )
34919 9CF3           B8                   000B  mov	ax,*$B
34920 9CF6           50                         push	ax
34921                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34922 9CF7           E8         6884            call	_outb_cmos
34923 9CFA           83C4                   04  add	sp,*4
34924                                           !BCC_EOS
34925                                           ! 5110       iret_addr.flags.u.r8.flagsl &= 0xfe;
34926                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
34927 9CFD           8A46         1A            mov	al,$1A[bp]
34928 9D00           24                     FE  and	al,#$FE
34929 9D02           8846         1A            mov	$1A[bp],al
34930                                           !BCC_EOS
34931                                           ! 5111       break;
34932 9D05           E9         00E2            br 	.6D3
34933                                           !BCC_EOS
34934                                           ! 5112     case 7:
34935                                           ! 5113       val8 = inb_cmos(0x0b);
34936                       00009D08            .6E9:
34937                                           ! Debug: list int = const $B (used reg = )
34938 9D08           B8                   000B  mov	ax,*$B
34939 9D0B           50                         push	ax
34940                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34941 9D0C           E8         687E            call	_inb_cmos
34942 9D0F           44                         inc	sp
34943 9D10           44                         inc	sp
34944                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
34945 9D11           8846         FF            mov	-1[bp],al
34946                                           !BCC_EOS
34947                                           ! 5114       outb_cmos(0x0b, val8 & 0x57);
34948                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
34949 9D14           8A46         FF            mov	al,-1[bp]
34950 9D17           24                     57  and	al,*$57
34951                                           ! Debug: list unsigned char = al+0 (used reg = )
34952 9D19           30E4                       xor	ah,ah
34953 9D1B           50                         push	ax
34954                                           ! Debug: list int = const $B (used reg = )
34955 9D1C           B8                   000B  mov	ax,*$B
34956 9D1F           50                         push	ax
34957                                           ! Debug: func () void = outb_cmos+0 (used reg = )
34958 9D20           E8         685B            call	_outb_cmos
34959 9D23           83C4                   04  add	sp,*4
34960                                           !BCC_EOS
34961                                           ! 5115       regs.u.r8.ah = 0;
34962                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
34963 9D26           30C0                       xor	al,al
34964 9D28           8846         13            mov	$13[bp],al
34965                                           !BCC_EOS
34966                                           ! 5116       regs.u.r8.al = val8;
34967                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
34968 9D2B           8A46         FF            mov	al,-1[bp]
34969 9D2E           8846         12            mov	$12[bp],al
34970                                           !BCC_EOS
34971                                           ! 5117       iret_addr.flags.u.r8.flagsl &= 0xfe;
34972                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
34973 9D31           8A46         1A            mov	al,$1A[bp]
34974 9D34           24                     FE  and	al,#$FE
34975 9D36           8846         1A            mov	$1A[bp],al
34976                                           !BCC_EOS
34977                                           ! 5118       break;
34978 9D39           E9         00AE            br 	.6D3
34979                                           !BCC_EOS
34980                                           ! 5119     case 0xb1:
34981                                           ! 5120       if (regs.u.r8.bl == 0xff) {
34982                       00009D3C            .6EA:
34983                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
34984 9D3C           8A46         0C            mov	al,$C[bp]
34985 9D3F           3C                     FF  cmp	al,#$FF
34986 9D41           75           10            jne 	.6EB
34987                       00009D43            .6EC:
34988                                           ! 5121         bios_printf(4, "PCI BIOS: PCI not present\n");
34989                                           ! Debug: list * char = .6ED+0 (used reg = )
34990 9D43           BB                   D00D  mov	bx,#.6ED
34991 9D46           53                         push	bx
34992                                           ! Debug: list int = const 4 (used reg = )
34993 9D47           B8                   0004  mov	ax,*4
34994 9D4A           50                         push	ax
34995                                           ! Debug: func () void = bios_printf+0 (used reg = )
34996 9D4B           E8         6B5B            call	_bios_printf
34997 9D4E           83C4                   04  add	sp,*4
34998                                           !BCC_EOS
34999                                           ! 5122       } else if (regs.u.r8.bl == 0x81) {
35000 9D51           EB           52            jmp .6EE
35001                       00009D53            .6EB:
35002                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
35003 9D53           8A46         0C            mov	al,$C[bp]
35004 9D56           3C                     81  cmp	al,#$81
35005 9D58           75           16            jne 	.6EF
35006                       00009D5A            .6F0:
35007                                           ! 5123         bios_printf(4, "unsupported PCI BIOS function 0x%02x\n", regs.u.r8.al);
35008                                           ! Debug: list unsigned char regs = [S+4+$10] (used reg = )
35009 9D5A           8A46         12            mov	al,$12[bp]
35010 9D5D           30E4                       xor	ah,ah
35011 9D5F           50                         push	ax
35012                                           ! Debug: list * char = .6F1+0 (used reg = )
35013 9D60           BB                   CFE7  mov	bx,#.6F1
35014 9D63           53                         push	bx
35015                                           ! Debug: list int = const 4 (used reg = )
35016 9D64           B8                   0004  mov	ax,*4
35017 9D67           50                         push	ax
35018                                           ! Debug: func () void = bios_printf+0 (used reg = )
35019 9D68           E8         6B3E            call	_bios_printf
35020 9D6B           83C4                   06  add	sp,*6
35021                                           !BCC_EOS
35022                                           ! 5124       } else if (regs.u.r8.bl == 0x83) {
35023 9D6E           EB           35            jmp .6F2
35024                       00009D70            .6EF:
35025                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
35026 9D70           8A46         0C            mov	al,$C[bp]
35027 9D73           3C                     83  cmp	al,#$83
35028 9D75           75           13            jne 	.6F3
35029                       00009D77            .6F4:
35030                                           ! 5125         bios_printf(4, "bad PCI vendor ID %04x\n", regs.u.r16.dx);
35031                                           ! Debug: list unsigned short regs = [S+4+$C] (used reg = )
35032 9D77           FF76         0E            push	$E[bp]
35033                                           ! Debug: list * char = .6F5+0 (used reg = )
35034 9D7A           BB                   CFCF  mov	bx,#.6F5
35035 9D7D           53                         push	bx
35036                                           ! Debug: list int = const 4 (used reg = )
35037 9D7E           B8                   0004  mov	ax,*4
35038 9D81           50                         push	ax
35039                                           ! Debug: func () void = bios_printf+0 (used reg = )
35040 9D82           E8         6B24            call	_bios_printf
35041 9D85           83C4                   06  add	sp,*6
35042                                           !BCC_EOS
35043                                           ! 5126       } else if (regs.u.r8.bl == 0x86) {
35044 9D88           EB           1B            jmp .6F6
35045                       00009D8A            .6F3:
35046                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
35047 9D8A           8A46         0C            mov	al,$C[bp]
35048 9D8D           3C                     86  cmp	al,#$86
35049 9D8F           75           14            jne 	.6F7
35050                       00009D91            .6F8:
35051                                           ! 5127         bios_printf(4, "PCI device %04x:%04x not found\n", regs.u.r16.dx, regs.u.r16.cx);
35052                                           ! Debug: list unsigned short regs = [S+4+$E] (used reg = )
35053 9D91           FF76         10            push	$10[bp]
35054                                           ! Debug: list unsigned short regs = [S+6+$C] (used reg = )
35055 9D94           FF76         0E            push	$E[bp]
35056                                           ! Debug: list * char = .6F9+0 (used reg = )
35057 9D97           BB                   CFAF  mov	bx,#.6F9
35058 9D9A           53                         push	bx
35059                                           ! Debug: list int = const 4 (used reg = )
35060 9D9B           B8                   0004  mov	ax,*4
35061 9D9E           50                         push	ax
35062                                           ! Debug: func () void = bios_printf+0 (used reg = )
35063 9D9F           E8         6B07            call	_bios_printf
35064 9DA2           83C4                   08  add	sp,*8
35065                                           !BCC_EOS
35066                                           ! 5128       }
35067                                           ! 5129       regs.u.r8.ah = regs.u.r8.bl;
35068                       00009DA5            .6F7:
35069                       00009DA5            .6F6:
35070                       00009DA5            .6F2:
35071                       00009DA5            .6EE:
35072                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
35073 9DA5           8A46         0C            mov	al,$C[bp]
35074 9DA8           8846         13            mov	$13[bp],al
35075                                           !BCC_EOS
35076                                           ! 5130       iret_addr.flags.u.r8.flagsl |= 0x01;
35077                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
35078 9DAB           8A46         1A            mov	al,$1A[bp]
35079 9DAE           0C                     01  or	al,*1
35080 9DB0           8846         1A            mov	$1A[bp],al
35081                                           !BCC_EOS
35082                                           ! 5131       break;
35083 9DB3           EB           35            jmp .6D3
35084                                           !BCC_EOS
35085                                           ! 5132     default:
35086                                           ! 5133       iret_addr.flags.u.r8.flagsl |= 0x01;
35087                       00009DB5            .6FA:
35088                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
35089 9DB5           8A46         1A            mov	al,$1A[bp]
35090 9DB8           0C                     01  or	al,*1
35091 9DBA           8846         1A            mov	$1A[bp],al
35092                                           !BCC_EOS
35093                                           ! 5134     }
35094                                           ! 5135 }
35095 9DBD           EB           2B            jmp .6D3
35096                       00009DBF            .6D5:
35097 9DBF           2C                     00  sub	al,*0
35098 9DC1           72           F2            jb 	.6FA
35099 9DC3           3C                     07  cmp	al,*7
35100 9DC5           77           1B            ja  	.6FB
35101 9DC7           30E4                       xor	ah,ah
35102 9DC9           D1E0                       shl	ax,*1
35103 9DCB           89C3                       mov	bx,ax
35104 9DCD           2E                         seg	cs
35105 9DCE           FFA7       9DD2            br	.6FC[bx]
35106                       00009DD2            .6FC:
35107 9DD2                      9A77            .word	.6D6
35108 9DD4                      9A9B            .word	.6D7
35109 9DD6                      9ABE            .word	.6D8
35110 9DD8                      9B17            .word	.6DB
35111 9DDA                      9B91            .word	.6DE
35112 9DDC                      9BE9            .word	.6E1
35113 9DDE                      9C72            .word	.6E4
35114 9DE0                      9D08            .word	.6E9
35115                       00009DE2            .6FB:
35116 9DE2           2C                     B1  sub	al,#$B1
35117 9DE4         0F84         FF54            beq 	.6EA
35118 9DE8           EB           CB            jmp	.6FA
35119                       00009DEA            .6D3:
35120                       FFFFFFFC            ..FFD9	=	-4
35121 9DEA           89EC                       mov	sp,bp
35122 9DEC           5D                         pop	bp
35123 9DED           C3                         ret
35124                                           ! 5136   void
35125                                           ! Register BX used in function int1a_function
35126                                           ! 5137 int70_function(regs, ds, iret_addr)
35127                                           ! 5138   pusha_regs_t regs;
35128                                           export	_int70_function
35129                       00009DEE            _int70_function:
35130                                           !BCC_EOS
35131                                           ! 5139   Bit16u ds;
35132                                           !BCC_EOS
35133                                           ! 5140   iret_addr_t iret_addr;
35134                                           !BCC_EOS
35135                                           ! 5141 {
35136                                           ! 5142   Bit8u registerB = 0, registerC = 0;
35137 9DEE           55                         push	bp
35138 9DEF           89E5                       mov	bp,sp
35139 9DF1           4C                         dec	sp
35140                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
35141 9DF2           30C0                       xor	al,al
35142 9DF4           8846         FF            mov	-1[bp],al
35143 9DF7           4C                         dec	sp
35144                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
35145 9DF8           30C0                       xor	al,al
35146 9DFA           8846         FE            mov	-2[bp],al
35147                                           !BCC_EOS
35148                                           ! 5143   registerB = inb_cmos( 0xB );
35149                                           ! Debug: list int = const $B (used reg = )
35150 9DFD           B8                   000B  mov	ax,*$B
35151 9E00           50                         push	ax
35152                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35153 9E01           E8         6789            call	_inb_cmos
35154 9E04           44                         inc	sp
35155 9E05           44                         inc	sp
35156                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
35157 9E06           8846         FF            mov	-1[bp],al
35158                                           !BCC_EOS
35159                                           ! 5144   registerC = inb_cmos( 0xC );
35160                                           ! Debug: list int = const $C (used reg = )
35161 9E09           B8                   000C  mov	ax,*$C
35162 9E0C           50                         push	ax
35163                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35164 9E0D           E8         677D            call	_inb_cmos
35165 9E10           44                         inc	sp
35166 9E11           44                         inc	sp
35167                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
35168 9E12           8846         FE            mov	-2[bp],al
35169                                           !BCC_EOS
35170                                           ! 5145   if( ( registerB & 0x60 ) != 0 ) {
35171                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
35172 9E15           8A46         FF            mov	al,-1[bp]
35173 9E18           24                     60  and	al,*$60
35174                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35175 9E1A           84C0                       test	al,al
35176 9E1C         0F84         00E2            beq 	.6FD
35177                       00009E20            .6FE:
35178                                           ! 5146     if( ( registerC & 0x20 ) != 0 ) {
35179                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
35180 9E20           8A46         FE            mov	al,-2[bp]
35181 9E23           24                     20  and	al,*$20
35182                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35183 9E25           84C0                       test	al,al
35184 9E27           74           04            je  	.6FF
35185                       00009E29            .700:
35186                                           ! 5147 #asm
35187                                           !BCC_EOS
35188                                           !BCC_ASM
35189                       00000000            _int70_function.registerC	set	0
35190                       FFFFFFFE            .int70_function.registerC	set	-2
35191                       00000016            _int70_function.ds	set	$16
35192                       00000014            .int70_function.ds	set	$14
35193                       00000001            _int70_function.registerB	set	1
35194                       FFFFFFFF            .int70_function.registerB	set	-1
35195                       00000018            _int70_function.iret_addr	set	$18
35196                       00000016            .int70_function.iret_addr	set	$16
35197                       00000006            _int70_function.regs	set	6
35198                       00000004            .int70_function.regs	set	4
35199 9E29           FB                               sti
35200 9E2A           CD                     4A        int #0x4a
35201 9E2C           FA                               cli
35202                                           ! 5151 endasm
35203                                           !BCC_ENDASM
35204                                           !BCC_EOS
35205                                           ! 5152     }
35206                                           ! 5153     if( ( registerC & 
35207                       00009E2D            .6FF:
35208                                           ! 5153 0x40 ) != 0 ) {
35209                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
35210 9E2D           8A46         FE            mov	al,-2[bp]
35211 9E30           24                     40  and	al,*$40
35212                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35213 9E32           84C0                       test	al,al
35214 9E34         0F84         00CA            beq 	.701
35215                       00009E38            .702:
35216                                           ! 5154       if( read_byte( 0x40, 0xA0 ) != 0 ) {
35217                                           ! Debug: list int = const $A0 (used reg = )
35218 9E38           B8                   00A0  mov	ax,#$A0
35219 9E3B           50                         push	ax
35220                                           ! Debug: list int = const $40 (used reg = )
35221 9E3C           B8                   0040  mov	ax,*$40
35222 9E3F           50                         push	ax
35223                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
35224 9E40           E8         67BB            call	_read_byte
35225 9E43           83C4                   04  add	sp,*4
35226                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35227 9E46           84C0                       test	al,al
35228 9E48         0F84         00B6            beq 	.703
35229                       00009E4C            .704:
35230                                           ! 5155         Bit32u time, toggle;
35231                                           !BCC_EOS
35232                                           ! 5156         time = read_dword( 0x40, 0x9C );
35233 9E4C           83C4                   F8  add	sp,*-8
35234                                           ! Debug: list int = const $9C (used reg = )
35235 9E4F           B8                   009C  mov	ax,#$9C
35236 9E52           50                         push	ax
35237                                           ! Debug: list int = const $40 (used reg = )
35238 9E53           B8                   0040  mov	ax,*$40
35239 9E56           50                         push	ax
35240                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
35241 9E57           E8         61FB            call	_read_dword
35242 9E5A           89D3                       mov	bx,dx
35243 9E5C           83C4                   04  add	sp,*4
35244                                           ! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
35245 9E5F           8946         FA            mov	-6[bp],ax
35246 9E62           895E         FC            mov	-4[bp],bx
35247                                           !BCC_EOS
35248                                           ! 5157         if( time < 0x3D1 ) {
35249                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
35250 9E65           B8                   03D1  mov	ax,#$3D1
35251 9E68           31DB                       xor	bx,bx
35252 9E6A           8D7E         FA            lea	di,-6[bp]
35253 9E6D           E8         622B            call	lcmpul
35254 9E70           76           5D            jbe 	.705
35255                       00009E72            .706:
35256                                           ! 5158           Bit16u segment, offset;
35257                                           !BCC_EOS
35258                                           ! 5159           offset = read_word( 0x40, 0x98 );
35259 9E72           83C4                   FC  add	sp,*-4
35260                                           ! Debug: list int = const $98 (used reg = )
35261 9E75           B8                   0098  mov	ax,#$98
35262 9E78           50                         push	ax
35263                                           ! Debug: list int = const $40 (used reg = )
35264 9E79           B8                   0040  mov	ax,*$40
35265 9E7C           50                         push	ax
35266                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35267 9E7D           E8         6791            call	_read_word
35268 9E80           83C4                   04  add	sp,*4
35269                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
35270 9E83           8946         F2            mov	-$E[bp],ax
35271                                           !BCC_EOS
35272                                           ! 5160           segment = read_word( 0x40, 0x9A );
35273                                           ! Debug: list int = const $9A (used reg = )
35274 9E86           B8                   009A  mov	ax,#$9A
35275 9E89           50                         push	ax
35276                                           ! Debug: list int = const $40 (used reg = )
35277 9E8A           B8                   0040  mov	ax,*$40
35278 9E8D           50                         push	ax
35279                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35280 9E8E           E8         6780            call	_read_word
35281 9E91           83C4                   04  add	sp,*4
35282                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
35283 9E94           8946         F4            mov	-$C[bp],ax
35284                                           !BCC_EOS
35285                                           ! 5161           write_byte( 0x40, 0xA0, 0 );
35286                                           ! Debug: list int = const 0 (used reg = )
35287 9E97           31C0                       xor	ax,ax
35288 9E99           50                         push	ax
35289                                           ! Debug: list int = const $A0 (used reg = )
35290 9E9A           B8                   00A0  mov	ax,#$A0
35291 9E9D           50                         push	ax
35292                                           ! Debug: list int = const $40 (used reg = )
35293 9E9E           B8                   0040  mov	ax,*$40
35294 9EA1           50                         push	ax
35295                                           ! Debug: func () void = write_byte+0 (used reg = )
35296 9EA2           E8         677F            call	_write_byte
35297 9EA5           83C4                   06  add	sp,*6
35298                                           !BCC_EOS
35299                                           ! 5162           outb_cmos( 0xB, registerB & 0x37 );
35300                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
35301 9EA8           8A46         FF            mov	al,-1[bp]
35302 9EAB           24                     37  and	al,*$37
35303                                           ! Debug: list unsigned char = al+0 (used reg = )
35304 9EAD           30E4                       xor	ah,ah
35305 9EAF           50                         push	ax
35306                                           ! Debug: list int = const $B (used reg = )
35307 9EB0           B8                   000B  mov	ax,*$B
35308 9EB3           50                         push	ax
35309                                           ! Debug: func () void = outb_cmos+0 (used reg = )
35310 9EB4           E8         66C7            call	_outb_cmos
35311 9EB7           83C4                   04  add	sp,*4
35312                                           !BCC_EOS
35313                                           ! 5163           write_byte( segment, offset, 0x80 );
35314                                           ! Debug: list int = const $80 (used reg = )
35315 9EBA           B8                   0080  mov	ax,#$80
35316 9EBD           50                         push	ax
35317                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
35318 9EBE           FF76         F2            push	-$E[bp]
35319                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
35320 9EC1           FF76         F4            push	-$C[bp]
35321                                           ! Debug: func () void = write_byte+0 (used reg = )
35322 9EC4           E8         675D            call	_write_byte
35323 9EC7           83C4                   06  add	sp,*6
35324                                           !BCC_EOS
35325                                           ! 5164         } else {
35326 9ECA           83C4                   04  add	sp,*4
35327 9ECD           EB           30            jmp .707
35328                       00009ECF            .705:
35329                                           ! 5165           time -= 0x3D1;
35330                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
35331 9ECF           B8                   03D1  mov	ax,#$3D1
35332 9ED2           31DB                       xor	bx,bx
35333 9ED4           53                         push	bx
35334 9ED5           50                         push	ax
35335 9ED6           8B46         FA            mov	ax,-6[bp]
35336 9ED9           8B5E         FC            mov	bx,-4[bp]
35337 9EDC           8D7E         F2            lea	di,-$E[bp]
35338 9EDF           E8         61CF            call	lsubul
35339 9EE2           8946         FA            mov	-6[bp],ax
35340 9EE5           895E         FC            mov	-4[bp],bx
35341 9EE8           83C4                   04  add	sp,*4
35342                                           !BCC_EOS
35343                                           ! 5166           write_dword( 0x40, 0x9C, time );
35344                                           ! Debug: list unsigned long time = [S+$C-8] (used reg = )
35345 9EEB           FF76         FC            push	-4[bp]
35346 9EEE           FF76         FA            push	-6[bp]
35347                                           ! Debug: list int = const $9C (used reg = )
35348 9EF1           B8                   009C  mov	ax,#$9C
35349 9EF4           50                         push	ax
35350                                           ! Debug: list int = const $40 (used reg = )
35351 9EF5           B8                   0040  mov	ax,*$40
35352 9EF8           50                         push	ax
35353                                           ! Debug: func () void = write_dword+0 (used reg = )
35354 9EF9           E8         6170            call	_write_dword
35355 9EFC           83C4                   08  add	sp,*8
35356                                           !BCC_EOS
35357                                           ! 5167         }
35358                                           ! 5168       }
35359                       00009EFF            .707:
35360 9EFF           83C4                   08  add	sp,*8
35361                                           ! 5169     }
35362                       00009F02            .703:
35363                                           ! 5170   }
35364                       00009F02            .701:
35365                                           ! 5171 #asm
35366                       00009F02            .6FD:
35367                                           !BCC_EOS
35368                                           !BCC_ASM
35369                       00000000            _int70_function.registerC	set	0
35370                       FFFFFFFE            .int70_function.registerC	set	-2
35371                       00000016            _int70_function.ds	set	$16
35372                       00000014            .int70_function.ds	set	$14
35373                       00000001            _int70_function.registerB	set	1
35374                       FFFFFFFF            .int70_function.registerB	set	-1
35375                       00000018            _int70_function.iret_addr	set	$18
35376                       00000016            .int70_function.iret_addr	set	$16
35377                       00000006            _int70_function.regs	set	6
35378                       00000004            .int70_function.regs	set	4
35379 9F02           E8         03B7              call eoi_both_pics
35380                                           ! 5173 endasm
35381                                           !BCC_ENDASM
35382                                           !BCC_EOS
35383                                           ! 5174 }
35384 9F05           89EC                       mov	sp,bp
35385 9F07           5D                         pop	bp
35386 9F08           C3                         ret
35387                                           ! 5175 #asm
35388                                           !BCC_ASM
35389                       00000012            _int70_function.ds	set	$12
35390                       00000014            _int70_function.iret_addr	set	$14
35391                       00000002            _int70_function.regs	set	2
35392                                           ;------------------------------------------
35393                                           ;- INT74h : PS/2 mouse hardware interrupt -
35394                                           ;------------------------------------------
35395                       00009F09            int74_handler:
35396 9F09           FB                           sti
35397 9F0A           60                           pusha
35398 9F0B           1E                           push ds ;; save DS
35399 9F0C           6A                     00    push #0x00 ;; placeholder for status
35400 9F0E           6A                     00    push #0x00 ;; placeholder for X
35401 9F10           6A                     00    push #0x00 ;; placeholder for Y
35402 9F12           6A                     00    push #0x00 ;; placeholder for Z
35403 9F14           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
35404 9F16           E8         BE41              call _int74_function
35405 9F19           59                           pop cx ;; remove make_far_call from stack
35406 9F1A           E3           0C              jcxz int74_done
35407                                             ;; make far call to EBDA:0022
35408 9F1C           6A                     00    push #0x00
35409 9F1E           1F                           pop ds
35410 9F1F           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
35411 9F23           1F                           pop ds
35412 9F24           FF1E       0022              call far ptr[0x22]
35413                       00009F28            int74_done:
35414 9F28           FA                           cli
35415 9F29           E8         0390              call eoi_both_pics
35416 9F2C           83C4                   08    add sp, #8 ;; pop status, x, y, z
35417 9F2F           1F                           pop ds ;; restore DS
35418 9F30           61                           popa
35419 9F31           CF                           iret
35420                                           ;; This will perform an IRET, but will retain value of current CF
35421                                           ;; by altering flags on stack. Better than RETF #02.
35422                       00009F32            iret_modify_cf:
35423 9F32           72           09              jc carry_set
35424 9F34           55                           push bp
35425 9F35           89E5                         mov bp, sp
35426 9F37           8066         06        FE    and BYTE [bp + 0x06], #0xfe
35427 9F3B           5D                           pop bp
35428 9F3C           CF                           iret
35429                       00009F3D            carry_set:
35430 9F3D           55                           push bp
35431 9F3E           89E5                         mov bp, sp
35432 9F40           804E         06        01    or BYTE [bp + 0x06], #0x01
35433 9F44           5D                           pop bp
35434 9F45           CF                           iret
35435                                           ;----------------------
35436                                           ;- INT13h (relocated) -
35437                                           ;----------------------
35438                                           ;
35439                                           ; int13_relocated is a little bit messed up since I played with it
35440                                           ; I have to rewrite it:
35441                                           ; - call a function that detect which function to call
35442                                           ; - make all called C function get the same parameters list
35443                                           ;
35444                       00009F46            int13_relocated:
35445                                             ;; check for an eltorito function
35446 9F46           80FC                   4A    cmp ah,#0x4a
35447 9F49           72           10              jb int13_not_eltorito
35448 9F4B           80FC                   4D    cmp ah,#0x4d
35449 9F4E           77           0B              ja int13_not_eltorito
35450 9F50           60                           pusha
35451 9F51           06                           push es
35452 9F52           1E                           push ds
35453 9F53           16                           push ss
35454 9F54           1F                           pop ds
35455 9F55           68                   9FC3    push #int13_out
35456 9F58           E9         D90A              jmp _int13_eltorito ;; ELDX not used
35457                       00009F5B            int13_not_eltorito:
35458 9F5B           50                           push ax
35459 9F5C           53                           push bx
35460 9F5D           51                           push cx
35461 9F5E           52                           push dx
35462                                             ;; check if emulation active
35463 9F5F           E8         975F              call _cdemu_isactive
35464 9F62           3C                     00    cmp al,#0x00
35465 9F64           74           2B              je int13_cdemu_inactive
35466                                             ;; check if access to the emulated drive
35467 9F66           E8         977F              call _cdemu_emulated_drive
35468 9F69           5A                           pop dx
35469 9F6A           52                           push dx
35470 9F6B           38D0                         cmp al,dl ;; int13 on emulated drive
35471 9F6D           75           0F              jne int13_nocdemu
35472 9F6F           5A                           pop dx
35473 9F70           59                           pop cx
35474 9F71           5B                           pop bx
35475 9F72           58                           pop ax
35476 9F73           60                           pusha
35477 9F74           06                           push es
35478 9F75           1E                           push ds
35479 9F76           16                           push ss
35480 9F77           1F                           pop ds
35481 9F78           68                   9FC3    push #int13_out
35482 9F7B           E9         DB37              jmp _int13_cdemu ;; ELDX not used
35483                       00009F7E            int13_nocdemu:
35484 9F7E           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
35485 9F81           38D0                         cmp al,dl ;; al is 0x00 or 0x80
35486 9F83           75           0C              jne int13_cdemu_inactive ;; inactive for device class
35487 9F85           5A                           pop dx
35488 9F86           59                           pop cx
35489 9F87           5B                           pop bx
35490 9F88           58                           pop ax
35491 9F89           50                           push ax
35492 9F8A           51                           push cx
35493 9F8B           52                           push dx
35494 9F8C           53                           push bx
35495 9F8D           FECA                         dec dl ;; real drive is dl - 1
35496 9F8F           EB           08              jmp int13_legacy
35497                       00009F91            int13_cdemu_inactive:
35498 9F91           5A                           pop dx
35499 9F92           59                           pop cx
35500 9F93           5B                           pop bx
35501 9F94           58                           pop ax
35502                       00009F95            int13_noeltorito:
35503 9F95           50                           push ax
35504 9F96           51                           push cx
35505 9F97           52                           push dx
35506 9F98           53                           push bx
35507                       00009F99            int13_legacy:
35508 9F99           52                           push dx ;; push eltorito value of dx instead of sp
35509 9F9A           55                           push bp
35510 9F9B           56                           push si
35511 9F9C           57                           push di
35512 9F9D           06                           push es
35513 9F9E           1E                           push ds
35514 9F9F           16                           push ss
35515 9FA0           1F                           pop ds
35516                                             ;; now the 16-bit registers can be restored with:
35517                                             ;; pop ds; pop es; popa; iret
35518                                             ;; arguments passed to functions should be
35519                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
35520 9FA1           F6C2                   80    test dl, #0x80
35521 9FA4           75           06              jnz int13_notfloppy
35522 9FA6           68                   9FC3    push #int13_out
35523 9FA9           E9         E4DE              jmp _int13_diskette_function
35524                       00009FAC            int13_notfloppy:
35525 9FAC           80FA                   E0    cmp dl, #0xE0
35526 9FAF           72           0F              jb int13_notcdrom
35527 9FB1     66    C1EB                   10    shr ebx, #16
35528 9FB5           53                           push bx
35529 9FB6           E8         CD7D              call _int13_cdrom
35530 9FB9           5B                           pop bx
35531 9FBA     66    C1E3                   10    shl ebx, #16
35532 9FBE           EB           03              jmp int13_out
35533                       00009FC0            int13_notcdrom:
35534                       00009FC0            int13_disk:
35535 9FC0           E8         BEB2              call _int13_harddisk
35536                       00009FC3            int13_out:
35537 9FC3           1F                           pop ds
35538 9FC4           07                           pop es
35539 9FC5           61                           popa
35540 9FC6           CF                           iret
35541                                           ;----------
35542                                           ;- INT18h -
35543                                           ;----------
35544                       00009FC7            int18_handler: ;; Boot Failure recovery: try the next device.
35545                                             ;; Reset SP and SS
35546 9FC7           B8                   FFFE    mov ax, #0xfffe
35547 9FCA           89C4                         mov sp, ax
35548 9FCC           31C0                         xor ax, ax
35549 9FCE           8ED0                         mov ss, ax
35550                                             ;; Get the boot sequence number out of the IPL memory
35551                                             ;; The first time we do this it will have been set to -1 so
35552                                             ;; we will start from device 0.
35553 9FD0           BB                   9FF0    mov bx, #0x9ff0
35554 9FD3           8EDB                         mov ds, bx ;; Set segment
35555 9FD5           8B1E       0082              mov bx, 0x0082 ;; BX is now the sequence number
35556 9FD9           43                           inc bx ;; ++
35557 9FDA           891E       0082              mov 0x0082, bx ;; Write it back
35558 9FDE           8ED8                         mov ds, ax ;; and reset the segment to zero.
35559                                             ;; Call the C code for the next boot device
35560 9FE0           53                           push bx
35561 9FE1           E8         F843              call _int18_function
35562                                             ;; Boot failed: invoke the boot recovery function...
35563 9FE4           CD                     18    int #0x18
35564                                           ;----------
35565                                           ;- INT19h -
35566                                           ;----------
35567                       00009FE6            int19_relocated: ;; Boot function, relocated
35568                                             ;;
35569                                             ;; *** Warning: INT 19h resets the whole machine ***
35570                                             ;;
35571                                             ;; Because PV drivers in HVM guests detach some of the emulated devices,
35572                                             ;; it is not safe to do a soft reboot by just dropping to real mode and
35573                                             ;; invoking INT 19h -- the boot drives might have disappeared!
35574                                             ;; If the user asks for a soft reboot, the only thing we can do is
35575                                             ;; reset the whole machine. When it comes back up, the normal BIOS
35576                                             ;; boot sequence will start, which is more or less the required behaviour.
35577                                             ;;
35578                                             ;; Reset SP and SS
35579 9FE6           B8                   FFFE    mov ax, #0xfffe
35580 9FE9           89C4                         mov sp, ax
35581 9FEB           31C0                         xor ax, ax
35582 9FED           8ED0                         mov ss, ax
35583 9FEF           E8         6F75              call _machine_reset
35584                                           ;----------
35585                                           ;- INT1Ch -
35586                                           ;----------
35587                       00009FF2            int1c_handler: ;; User Timer Tick
35588 9FF2           CF                           iret
35589                                           ;----------------------
35590                                           ;- POST: Floppy Drive -
35591                                           ;----------------------
35592                       00009FF3            floppy_drive_post:
35593 9FF3           B8                   0000    mov ax, #0x0000
35594 9FF6           8ED8                         mov ds, ax
35595 9FF8           B0                     00    mov al, #0x00
35596 9FFA           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
35597 9FFD           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
35598 A000           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
35599 A003           A2         0441              mov 0x0441, al ;; diskette controller status return code
35600 A006           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
35601 A009           A2         0443              mov 0x0443, al ;; diskette controller status register 1
35602 A00C           A2         0444              mov 0x0444, al ;; diskette controller status register 2
35603 A00F           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
35604 A012           A2         0446              mov 0x0446, al ;; diskette controller head number
35605 A015           A2         0447              mov 0x0447, al ;; diskette controller sector number
35606 A018           A2         0448              mov 0x0448, al ;; diskette controller bytes written
35607 A01B           A2         048B              mov 0x048b, al ;; diskette configuration data
35608                                             ;; -----------------------------------------------------------------
35609                                             ;; (048F) diskette controller information
35610                                             ;;
35611 A01E           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
35612 A020           E6                     70    out 0x70, AL
35613 A022           E4                     71    in AL, 0x71
35614 A024           88C4                         mov ah, al ;; save byte to AH
35615                       0000A026            look_drive0:
35616 A026           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
35617 A029           74           04              jz f0_missing ;; jump if no drive0
35618 A02B           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
35619 A02D           EB           02              jmp look_drive1
35620                       0000A02F            f0_missing:
35621 A02F           B3                     00    mov bl, #0x00 ;; no drive0
35622                       0000A031            look_drive1:
35623 A031           88E0                         mov al, ah ;; restore from AH
35624 A033           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
35625 A035           74           03              jz f1_missing ;; jump if no drive1
35626 A037           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
35627                       0000A03A            f1_missing:
35628                                                              ;; leave high bits in BL zerod
35629 A03A           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
35630                                             ;; -----------------------------------------------------------------
35631 A03E           B0                     00    mov al, #0x00
35632 A040           A2         0490              mov 0x0490, al ;; diskette 0 media state
35633 A043           A2         0491              mov 0x0491, al ;; diskette 1 media state
35634                                                              ;; diskette 0,1 operational starting state
35635                                                              ;; drive type has not been determined,
35636                                                              ;; has no changed detection line
35637 A046           A2         0492              mov 0x0492, al
35638 A049           A2         0493              mov 0x0493, al
35639 A04C           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
35640 A04F           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
35641 A052           B0                     02    mov al, #0x02
35642 A054           E6                     0A    out #0x0a, al ;; clear DMA-1 channel 2 mask bit
35643                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   A056           B8                   EFDF    mov ax,  #diskette_param_table2
 +a   A059           A3         0078              mov 0x1E*4, ax
 +a   A05C           B8                   F000    mov ax,  #0xF000
 +a   A05F           A3         007A              mov 0x1E*4+2, ax
35644                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   A062           B8                   EC59    mov ax,  #int13_diskette
 +a   A065           A3         0100              mov 0x40*4, ax
 +a   A068           B8                   F000    mov ax,  #0xF000
 +a   A06B           A3         0102              mov 0x40*4+2, ax
35645                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   A06E           B8                   EF57    mov ax,  #int0e_handler
 +a   A071           A3         0038              mov 0x0E*4, ax
 +a   A074           B8                   F000    mov ax,  #0xF000
 +a   A077           A3         003A              mov 0x0E*4+2, ax
35646 A07A           C3                           ret
35647                                           ;--------------------
35648                                           ;- POST: HARD DRIVE -
35649                                           ;--------------------
35650                                           ; relocated here because the primary POST area isnt big enough.
35651                       0000A07B            hard_drive_post:
35652 A07B           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
35653 A07D           BA                   03F6    mov dx, #0x03f6
35654 A080           EE                           out dx, al
35655 A081           B8                   0000    mov ax, #0x0000
35656 A084           8ED8                         mov ds, ax
35657 A086           A2         0474              mov 0x0474, al
35658 A089           A2         0477              mov 0x0477, al
35659 A08C           A2         048C              mov 0x048c, al
35660 A08F           A2         048D              mov 0x048d, al
35661 A092           A2         048E              mov 0x048e, al
35662 A095           B0                     01    mov al, #0x01
35663 A097           A2         0475              mov 0x0475, al
35664 A09A           B0                     C0    mov al, #0xc0
35665 A09C           A2         0476              mov 0x0476, al
35666                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   A09F           B8                   E3FE    mov ax,  #int13_handler
 +a   A0A2           A3         004C              mov 0x13*4, ax
 +a   A0A5           B8                   F000    mov ax,  #0xF000
 +a   A0A8           A3         004E              mov 0x13*4+2, ax
35667                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   A0AB           B8                   A34B    mov ax,  #int76_handler
 +a   A0AE           A3         01D8              mov 0x76*4, ax
 +a   A0B1           B8                   F000    mov ax,  #0xF000
 +a   A0B4           A3         01DA              mov 0x76*4+2, ax
35668                                             ;; INT 41h: hard disk 0 configuration pointer
35669                                             ;; INT 46h: hard disk 1 configuration pointer
35670                                             SET_INT_VECTOR(0x41, #0x9FC0, #0x003D)
 +a   A0B7           B8                   003D    mov ax,  #0x003D
 +a   A0BA           A3         0104              mov 0x41*4, ax
 +a   A0BD           B8                   9FC0    mov ax,  #0x9FC0
 +a   A0C0           A3         0106              mov 0x41*4+2, ax
35671                                             SET_INT_VECTOR(0x46, #0x9FC0, #0x004D)
 +a   A0C3           B8                   004D    mov ax,  #0x004D
 +a   A0C6           A3         0118              mov 0x46*4, ax
 +a   A0C9           B8                   9FC0    mov ax,  #0x9FC0
 +a   A0CC           A3         011A              mov 0x46*4+2, ax
35672                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
35673 A0CF           B0                     12    mov al, #0x12
35674 A0D1           E6                     70    out #0x70, al
35675 A0D3           E4                     71    in al, #0x71
35676 A0D5           24                     F0    and al, #0xf0
35677 A0D7           3C                     F0    cmp al, #0xf0
35678 A0D9           74           03              je post_d0_extended
35679 A0DB           E9         00D4              jmp check_for_hd1
35680                       0000A0DE            post_d0_extended:
35681 A0DE           B0                     19    mov al, #0x19
35682 A0E0           E6                     70    out #0x70, al
35683 A0E2           E4                     71    in al, #0x71
35684 A0E4           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
35685 A0E6           74           07              je post_d0_type47
35686                                             HALT(8707)
 +a   A0E8           BA                   0400    mov dx,#0x400
 +a   A0EB           B8                   2203    mov ax,#8707
 +a   A0EE           EF                           out dx,ax
35687                       0000A0EF            post_d0_type47:
35688                                             ;; CMOS purpose param table offset
35689                                             ;; 1b cylinders low 0
35690                                             ;; 1c cylinders high 1
35691                                             ;; 1d heads 2
35692                                             ;; 1e write pre-comp low 5
35693                                             ;; 1f write pre-comp high 6
35694                                             ;; 20 retries/bad map/heads>8 8
35695                                             ;; 21 landing zone low C
35696                                             ;; 22 landing zone high D
35697                                             ;; 23 sectors/track E
35698 A0EF           B8                   9FC0    mov ax, #0x9FC0
35699 A0F2           8ED8                         mov ds, ax
35700                                             ;;; Filling EBDA table for hard disk 0.
35701 A0F4           B0                     1F    mov al, #0x1f
35702 A0F6           E6                     70    out #0x70, al
35703 A0F8           E4                     71    in al, #0x71
35704 A0FA           88C4                         mov ah, al
35705 A0FC           B0                     1E    mov al, #0x1e
35706 A0FE           E6                     70    out #0x70, al
35707 A100           E4                     71    in al, #0x71
35708 A102           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
35709 A105           B0                     20    mov al, #0x20
35710 A107           E6                     70    out #0x70, al
35711 A109           E4                     71    in al, #0x71
35712 A10B           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
35713 A10E           B0                     22    mov al, #0x22
35714 A110           E6                     70    out #0x70, al
35715 A112           E4                     71    in al, #0x71
35716 A114           88C4                         mov ah, al
35717 A116           B0                     21    mov al, #0x21
35718 A118           E6                     70    out #0x70, al
35719 A11A           E4                     71    in al, #0x71
35720 A11C           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
35721 A11F           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
35722 A121           E6                     70    out #0x70, al
35723 A123           E4                     71    in al, #0x71 ;; high byte
35724 A125           88C4                         mov ah, al
35725 A127           B0                     1B    mov al, #0x1b
35726 A129           E6                     70    out #0x70, al
35727 A12B           E4                     71    in al, #0x71 ;; low byte
35728 A12D           89C3                         mov bx, ax ;; BX = cylinders
35729 A12F           B0                     1D    mov al, #0x1d
35730 A131           E6                     70    out #0x70, al
35731 A133           E4                     71    in al, #0x71
35732 A135           88C1                         mov cl, al ;; CL = heads
35733 A137           B0                     23    mov al, #0x23
35734 A139           E6                     70    out #0x70, al
35735 A13B           E4                     71    in al, #0x71
35736 A13D           88C2                         mov dl, al ;; DL = sectors
35737 A13F           81FB                 0400    cmp bx, #1024
35738 A143           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
35739                       0000A145            hd0_post_physical_chs:
35740                                             ;; no logical CHS mapping used, just physical CHS
35741                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
35742 A145           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
35743 A149           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
35744 A14D           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
35745 A151           EB           5F              jmp check_for_hd1
35746                       0000A153            hd0_post_logical_chs:
35747                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
35748 A153           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
35749 A157           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
35750 A15B           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
35751 A15F           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
35752 A163           B0                     A0    mov al, #0xa0
35753 A165           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
35754 A168           81FB                 0800    cmp bx, #2048
35755 A16C           77           06              jnbe hd0_post_above_2048
35756                                             ;; 1024 < c <= 2048 cylinders
35757 A16E           D1EB                         shr bx, #0x01
35758 A170           D0E1                         shl cl, #0x01
35759 A172           EB           22              jmp hd0_post_store_logical
35760                       0000A174            hd0_post_above_2048:
35761 A174           81FB                 1000    cmp bx, #4096
35762 A178           77           08              jnbe hd0_post_above_4096
35763                                             ;; 2048 < c <= 4096 cylinders
35764 A17A           C1EB                   02    shr bx, #0x02
35765 A17D           C0E1                   02    shl cl, #0x02
35766 A180           EB           14              jmp hd0_post_store_logical
35767                       0000A182            hd0_post_above_4096:
35768 A182           81FB                 2000    cmp bx, #8192
35769 A186           77           08              jnbe hd0_post_above_8192
35770                                             ;; 4096 < c <= 8192 cylinders
35771 A188           C1EB                   03    shr bx, #0x03
35772 A18B           C0E1                   03    shl cl, #0x03
35773 A18E           EB           06              jmp hd0_post_store_logical
35774                       0000A190            hd0_post_above_8192:
35775                                             ;; 8192 < c <= 16384 cylinders
35776 A190           C1EB                   04    shr bx, #0x04
35777 A193           C0E1                   04    shl cl, #0x04
35778                       0000A196            hd0_post_store_logical:
35779 A196           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
35780 A19A           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
35781                                             ;; checksum
35782 A19E           B1                     0F    mov cl, #0x0f ;; repeat count
35783 A1A0           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
35784 A1A3           B0                     00    mov al, #0x00 ;; sum
35785                       0000A1A5            hd0_post_checksum_loop:
35786 A1A5           0204                         add al, [si]
35787 A1A7           46                           inc si
35788 A1A8           FEC9                         dec cl
35789 A1AA           75           F9              jnz hd0_post_checksum_loop
35790 A1AC           F6D0                         not al ;; now take 2s complement
35791 A1AE           FEC0                         inc al
35792 A1B0           8804                         mov [si], al
35793                                           ;;; Done filling EBDA table for hard disk 0.
35794                       0000A1B2            check_for_hd1:
35795                                             ;; is there really a second hard disk? if not, return now
35796 A1B2           B0                     12    mov al, #0x12
35797 A1B4           E6                     70    out #0x70, al
35798 A1B6           E4                     71    in al, #0x71
35799 A1B8           24                     0F    and al, #0x0f
35800 A1BA           75           01              jnz post_d1_exists
35801 A1BC           C3                           ret
35802                       0000A1BD            post_d1_exists:
35803                                             ;; check that the hd type is really 0x0f.
35804 A1BD           3C                     0F    cmp al, #0x0f
35805 A1BF           74           07              jz post_d1_extended
35806                                             HALT(8844)
 +a   A1C1           BA                   0400    mov dx,#0x400
 +a   A1C4           B8                   228C    mov ax,#8844
 +a   A1C7           EF                           out dx,ax
35807                       0000A1C8            post_d1_extended:
35808                                             ;; check that the extended type is 47 - user definable
35809 A1C8           B0                     1A    mov al, #0x1a
35810 A1CA           E6                     70    out #0x70, al
35811 A1CC           E4                     71    in al, #0x71
35812 A1CE           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
35813 A1D0           74           07              je post_d1_type47
35814                                             HALT(8852)
 +a   A1D2           BA                   0400    mov dx,#0x400
 +a   A1D5           B8                   2294    mov ax,#8852
 +a   A1D8           EF                           out dx,ax
35815                       0000A1D9            post_d1_type47:
35816                                             ;; Table for disk1.
35817                                             ;; CMOS purpose param table offset
35818                                             ;; 0x24 cylinders low 0
35819                                             ;; 0x25 cylinders high 1
35820                                             ;; 0x26 heads 2
35821                                             ;; 0x27 write pre-comp low 5
35822                                             ;; 0x28 write pre-comp high 6
35823                                             ;; 0x29 heads>8 8
35824                                             ;; 0x2a landing zone low C
35825                                             ;; 0x2b landing zone high D
35826                                             ;; 0x2c sectors/track E
35827                                           ;;; Fill EBDA table for hard disk 1.
35828 A1D9           B8                   9FC0    mov ax, #0x9FC0
35829 A1DC           8ED8                         mov ds, ax
35830 A1DE           B0                     28    mov al, #0x28
35831 A1E0           E6                     70    out #0x70, al
35832 A1E2           E4                     71    in al, #0x71
35833 A1E4           88C4                         mov ah, al
35834 A1E6           B0                     27    mov al, #0x27
35835 A1E8           E6                     70    out #0x70, al
35836 A1EA           E4                     71    in al, #0x71
35837 A1EC           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
35838 A1EF           B0                     29    mov al, #0x29
35839 A1F1           E6                     70    out #0x70, al
35840 A1F3           E4                     71    in al, #0x71
35841 A1F5           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
35842 A1F8           B0                     2B    mov al, #0x2b
35843 A1FA           E6                     70    out #0x70, al
35844 A1FC           E4                     71    in al, #0x71
35845 A1FE           88C4                         mov ah, al
35846 A200           B0                     2A    mov al, #0x2a
35847 A202           E6                     70    out #0x70, al
35848 A204           E4                     71    in al, #0x71
35849 A206           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
35850 A209           B0                     25    mov al, #0x25 ;; get cylinders word in AX
35851 A20B           E6                     70    out #0x70, al
35852 A20D           E4                     71    in al, #0x71 ;; high byte
35853 A20F           88C4                         mov ah, al
35854 A211           B0                     24    mov al, #0x24
35855 A213           E6                     70    out #0x70, al
35856 A215           E4                     71    in al, #0x71 ;; low byte
35857 A217           89C3                         mov bx, ax ;; BX = cylinders
35858 A219           B0                     26    mov al, #0x26
35859 A21B           E6                     70    out #0x70, al
35860 A21D           E4                     71    in al, #0x71
35861 A21F           88C1                         mov cl, al ;; CL = heads
35862 A221           B0                     2C    mov al, #0x2c
35863 A223           E6                     70    out #0x70, al
35864 A225           E4                     71    in al, #0x71
35865 A227           88C2                         mov dl, al ;; DL = sectors
35866 A229           81FB                 0400    cmp bx, #1024
35867 A22D           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
35868                       0000A22F            hd1_post_physical_chs:
35869                                             ;; no logical CHS mapping used, just physical CHS
35870                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
35871 A22F           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
35872 A233           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
35873 A237           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
35874 A23B           C3                           ret
35875                       0000A23C            hd1_post_logical_chs:
35876                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
35877 A23C           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
35878 A240           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
35879 A244           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
35880 A248           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
35881 A24C           B0                     A0    mov al, #0xa0
35882 A24E           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
35883 A251           81FB                 0800    cmp bx, #2048
35884 A255           77           06              jnbe hd1_post_above_2048
35885                                             ;; 1024 < c <= 2048 cylinders
35886 A257           D1EB                         shr bx, #0x01
35887 A259           D0E1                         shl cl, #0x01
35888 A25B           EB           22              jmp hd1_post_store_logical
35889                       0000A25D            hd1_post_above_2048:
35890 A25D           81FB                 1000    cmp bx, #4096
35891 A261           77           08              jnbe hd1_post_above_4096
35892                                             ;; 2048 < c <= 4096 cylinders
35893 A263           C1EB                   02    shr bx, #0x02
35894 A266           C0E1                   02    shl cl, #0x02
35895 A269           EB           14              jmp hd1_post_store_logical
35896                       0000A26B            hd1_post_above_4096:
35897 A26B           81FB                 2000    cmp bx, #8192
35898 A26F           77           08              jnbe hd1_post_above_8192
35899                                             ;; 4096 < c <= 8192 cylinders
35900 A271           C1EB                   03    shr bx, #0x03
35901 A274           C0E1                   03    shl cl, #0x03
35902 A277           EB           06              jmp hd1_post_store_logical
35903                       0000A279            hd1_post_above_8192:
35904                                             ;; 8192 < c <= 16384 cylinders
35905 A279           C1EB                   04    shr bx, #0x04
35906 A27C           C0E1                   04    shl cl, #0x04
35907                       0000A27F            hd1_post_store_logical:
35908 A27F           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
35909 A283           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
35910                                             ;; checksum
35911 A287           B1                     0F    mov cl, #0x0f ;; repeat count
35912 A289           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
35913 A28C           B0                     00    mov al, #0x00 ;; sum
35914                       0000A28E            hd1_post_checksum_loop:
35915 A28E           0204                         add al, [si]
35916 A290           46                           inc si
35917 A291           FEC9                         dec cl
35918 A293           75           F9              jnz hd1_post_checksum_loop
35919 A295           F6D0                         not al ;; now take 2s complement
35920 A297           FEC0                         inc al
35921 A299           8804                         mov [si], al
35922                                           ;;; Done filling EBDA table for hard disk 1.
35923 A29B           C3                           ret
35924                                           ;--------------------
35925                                           ;- POST: EBDA segment
35926                                           ;--------------------
35927                                           ; relocated here because the primary POST area isnt big enough.
35928                       0000A29C            ebda_post:
35929 A29C           B8                   9FC0    mov ax, #0x9FC0
35930 A29F           8ED8                         mov ds, ax
35931 A2A1           C606       0000        01    mov byte ptr [0x0], #1
35932 A2A6           31C0                         xor ax, ax ; mov EBDA seg into 40E
35933 A2A8           8ED8                         mov ds, ax
35934 A2AA           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
35935 A2B0           C3                           ret;;
35936                                           ;--------------------
35937                                           ;- POST: EOI + jmp via [0x40:67)
35938                                           ;--------------------
35939                                           ; relocated here because the primary POST area isnt big enough.
35940                       0000A2B1            eoi_jmp_post:
35941 A2B1           E8         0008              call eoi_both_pics
35942 A2B4           31C0                         xor ax, ax
35943 A2B6           8ED8                         mov ds, ax
35944 A2B8           FF2E       0467              jmp far ptr [0x467]
35945                                           ;--------------------
35946                       0000A2BC            eoi_both_pics:
35947 A2BC           B0                     20    mov al, #0x20
35948 A2BE           E6                     A0    out #0xA0, al ;; slave PIC EOI
35949                       0000A2C0            eoi_master_pic:
35950 A2C0           B0                     20    mov al, #0x20
35951 A2C2           E6                     20    out #0x20, al ;; master PIC EOI
35952 A2C4           C3                           ret
35953                                           ;--------------------
35954                       0000A2C5            BcdToBin:
35955                                             ;; in: AL in BCD format
35956                                             ;; out: AL in binary format, AH will always be 0
35957                                             ;; trashes BX
35958 A2C5           88C3                         mov bl, al
35959 A2C7           80E3                   0F    and bl, #0x0f ;; bl has low digit
35960 A2CA           C0E8                   04    shr al, #4 ;; al has high digit
35961 A2CD           B7                     0A    mov bh, #10
35962 A2CF           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
35963 A2D1           00D8                         add al, bl ;; then add low digit
35964 A2D3           C3                           ret
35965                                           ;--------------------
35966                       0000A2D4            timer_tick_post:
35967                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
35968                                             ;; Timer Ticks Roller Flag (0x470:byte)
35969                                             ;; The Timer Ticks Count needs to be set according to
35970                                             ;; the current CMOS time, as if ticks have been occurring
35971                                             ;; at 18.2hz since midnight up to this point. Calculating
35972                                             ;; this is a little complicated. Here are the factors I gather
35973                                             ;; regarding this. 14,318,180 hz was the original clock speed,
35974                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
35975                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
35976                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
35977                                             ;; the timer. With a maximum 16bit timer count, this is again
35978                                             ;; divided down by 65536 to 18.2hz.
35979                                             ;;
35980                                             ;; 14,318,180 Hz clock
35981                                             ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
35982                                             ;; /4 = 1,193,181 Hz fed to timer
35983                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
35984                                             ;; 1 second = 18.20650736 ticks
35985                                             ;; 1 minute = 1092.390442 ticks
35986                                             ;; 1 hour = 65543.42651 ticks
35987                                             ;;
35988                                             ;; Given the values in the CMOS clock, one could calculate
35989                                             ;; the number of ticks by the following:
35990                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
35991                                             ;; (BcdToBin(minutes) * 1092.3904)
35992                                             ;; (BcdToBin(hours) * 65543.427)
35993                                             ;; To get a little more accuracy, since Im using integer
35994                                             ;; arithmatic, I use:
35995                                             ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
35996                                             ;; (BcdToBin(minutes) * 10923904) / 10000 +
35997                                             ;; (BcdToBin(hours) * 65543427) / 1000
35998                                             ;; assuming DS=0000
35999                                             ;; get CMOS seconds
36000 A2D4     66    31C0                         xor eax, eax ;; clear EAX
36001 A2D7           B0                     00    mov al, #0x00
36002 A2D9           E6                     70    out #0x70, al
36003 A2DB           E4                     71    in al, #0x71 ;; AL has CMOS seconds in BCD
36004 A2DD           E8         FFE5              call BcdToBin ;; EAX now has seconds in binary
36005 A2E0     66    BA               0115CF2B    mov edx, #18206507
36006 A2E6     66    F7E2                         mul eax, edx
36007 A2E9     66    BB               000F4240    mov ebx, #1000000
36008 A2EF     66    31D2                         xor edx, edx
36009 A2F2     66    F7F3                         div eax, ebx
36010 A2F5     66    89C1                         mov ecx, eax ;; ECX will accumulate total ticks
36011                                             ;; get CMOS minutes
36012 A2F8     66    31C0                         xor eax, eax ;; clear EAX
36013 A2FB           B0                     02    mov al, #0x02
36014 A2FD           E6                     70    out #0x70, al
36015 A2FF           E4                     71    in al, #0x71 ;; AL has CMOS minutes in BCD
36016 A301           E8         FFC1              call BcdToBin ;; EAX now has minutes in binary
36017 A304     66    BA               00A6AF80    mov edx, #10923904
36018 A30A     66    F7E2                         mul eax, edx
36019 A30D     66    BB               00002710    mov ebx, #10000
36020 A313     66    31D2                         xor edx, edx
36021 A316     66    F7F3                         div eax, ebx
36022 A319     66    01C1                         add ecx, eax ;; add to total ticks
36023                                             ;; get CMOS hours
36024 A31C     66    31C0                         xor eax, eax ;; clear EAX
36025 A31F           B0                     04    mov al, #0x04
36026 A321           E6                     70    out #0x70, al
36027 A323           E4                     71    in al, #0x71 ;; AL has CMOS hours in BCD
36028 A325           E8         FF9D              call BcdToBin ;; EAX now has hours in binary
36029 A328     66    BA               03E81D03    mov edx, #65543427
36030 A32E     66    F7E2                         mul eax, edx
36031 A331     66    BB               000003E8    mov ebx, #1000
36032 A337     66    31D2                         xor edx, edx
36033 A33A     66    F7F3                         div eax, ebx
36034 A33D     66    01C1                         add ecx, eax ;; add to total ticks
36035 A340     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
36036 A345           30C0                         xor al, al
36037 A347           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
36038 A34A           C3                           ret
36039                                           ;--------------------
36040                       0000A34B            int76_handler:
36041                                             ;; record completion in BIOS task complete flag
36042 A34B           50                           push ax
36043 A34C           1E                           push ds
36044 A34D           B8                   0040    mov ax, #0x0040
36045 A350           8ED8                         mov ds, ax
36046 A352           C706       008E      00FF    mov 0x008E, #0xff
36047 A358           E8         FF61              call eoi_both_pics
36048 A35B           1F                           pop ds
36049 A35C           58                           pop ax
36050 A35D           CF                           iret
36051                                           ;--------------------
36052                                           use32 386
36053                       0000A35E            apm32_out_str:
36054 A35E           50                           push eax
36055 A35F           53                           push ebx
36056 A360           89C3                         mov ebx, eax
36057                       0000A362            apm32_out_str1:
36058 A362           2E                           SEG CS
36059 A363   67      8A07                         mov al, byte ptr [bx]
36060 A366           3C                     00    cmp al, #0
36061 A368           74           04              je apm32_out_str2
36062 A36A           EE                           outb dx, al
36063 A36B           43                           inc ebx
36064 A36C           EB           F4              jmp apm32_out_str1
36065                       0000A36E            apm32_out_str2:
36066 A36E           5B                           pop ebx
36067 A36F           58                           pop eax
36068 A370           C3                           ret
36069                       0000A371            apm32_07_poweroff_str:
36070 A371                        53              .ascii "Shutdown"
36071 A379                        00              db 0
36072                       0000A37A            apm32_07_suspend_str:
36073 A37A                        53              .ascii "Suspend"
36074 A381                        00              db 0
36075                       0000A382            apm32_07_standby_str:
36076 A382                        53              .ascii "Standby"
36077 A389                        00              db 0
36078                       0000A38A            _apm32_entry:
36079 A38A     66    9C                           pushf
36080                                           ;-----------------
36081                                           ; APM interface disconnect
36082                       0000A38C            apm32_04:
36083 A38C           3C                     04    cmp al, #0x04
36084 A38E           75           05              jne apm32_05
36085 A390           E9     000000A5              jmp apm32_ok
36086                                           ;-----------------
36087                                           ; APM cpu idle
36088                       0000A395            apm32_05:
36089 A395           3C                     05    cmp al, #0x05
36090 A397           75           0B              jne apm32_07
36091 A399     66    9C                           pushf ; XEN
36092 A39B           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
36093 A39C           F4                           hlt
36094 A39D     66    9D                           popf ; XEN
36095 A39F           E9     00000096              jmp apm32_ok
36096                                           ;-----------------
36097                                           ; APM Set Power State
36098                       0000A3A4            apm32_07:
36099 A3A4           3C                     07    cmp al, #0x07
36100 A3A6           75           52              jne apm32_08
36101 A3A8     66    83FB                   01    cmp bx, #1
36102 A3AC   7405    E9     00000087              jne apm32_ok
36103 A3B3     66    83F9                   03    cmp cx, #3
36104 A3B7           74           0E              je apm32_07_poweroff
36105 A3B9     66    83F9                   02    cmp cx, #2
36106 A3BD           74           19              je apm32_07_suspend
36107 A3BF     66    83F9                   01    cmp cx, #1
36108 A3C3           74           24              je apm32_07_standby
36109 A3C5           75           73              jne apm32_ok
36110                       0000A3C7            apm32_07_poweroff:
36111 A3C7           FA                           cli
36112 A3C8     66    BA                   8900    mov dx, #0x8900
36113 A3CC     66    B8                   A371    mov ax, #apm32_07_poweroff_str
36114 A3D0           E8     FFFFFF89              call apm32_out_str
36115                       0000A3D5            apm32_07_1:
36116 A3D5           F4                           hlt
36117 A3D6           EB           FD              jmp apm32_07_1
36118                       0000A3D8            apm32_07_suspend:
36119 A3D8           52                           push edx
36120 A3D9     66    BA                   8900    mov dx, #0x8900
36121 A3DD     66    B8                   A37A    mov ax, #apm32_07_suspend_str
36122 A3E1           E8     FFFFFF78              call apm32_out_str
36123 A3E6           5A                           pop edx
36124 A3E7           EB           51              jmp apm32_ok
36125                       0000A3E9            apm32_07_standby:
36126 A3E9           52                           push edx
36127 A3EA     66    BA                   8900    mov dx, #0x8900
36128 A3EE     66    B8                   A382    mov ax, #apm32_07_standby_str
36129 A3F2           E8     FFFFFF67              call apm32_out_str
36130 A3F7           5A                           pop edx
36131 A3F8           EB           40              jmp apm32_ok
36132                                           ;-----------------
36133                                           ; APM Enable / Disable
36134                       0000A3FA            apm32_08:
36135 A3FA           3C                     08    cmp al, #0x08
36136 A3FC           75           02              jne apm32_0a
36137 A3FE           EB           3A              jmp apm32_ok
36138                                           ;-----------------
36139                                           ; Get Power Status
36140                       0000A400            apm32_0a:
36141 A400           3C                     0A    cmp al, #0x0a
36142 A402           75           12              jne apm32_0b
36143 A404           B7                     01    mov bh, #0x01
36144 A406           B3                     FF    mov bl, #0xff
36145 A408           B5                     80    mov ch, #0x80
36146 A40A           B1                     FF    mov cl, #0xff
36147 A40C     66    BA                   FFFF    mov dx, #0xffff
36148 A410     66    BE                   0000    mov si, #0
36149 A414           EB           24              jmp apm32_ok
36150                                           ;-----------------
36151                                           ; Get PM Event
36152                       0000A416            apm32_0b:
36153 A416           3C                     0B    cmp al, #0x0b
36154 A418           75           04              jne apm32_0e
36155 A41A           B4                     80    mov ah, #0x80
36156 A41C           EB           20              jmp apm32_error
36157                                           ;-----------------
36158                                           ; APM Driver Version
36159                       0000A41E            apm32_0e:
36160 A41E           3C                     0E    cmp al, #0x0e
36161 A420           75           06              jne apm32_0f
36162 A422           B4                     01    mov ah, #1
36163 A424           B0                     02    mov al, #2
36164 A426           EB           12              jmp apm32_ok
36165                                           ;-----------------
36166                                           ; APM Engage / Disengage
36167                       0000A428            apm32_0f:
36168 A428           3C                     0F    cmp al, #0x0f
36169 A42A           75           02              jne apm32_10
36170 A42C           EB           0C              jmp apm32_ok
36171                                           ;-----------------
36172                                           ; APM Get Capabilities
36173                       0000A42E            apm32_10:
36174 A42E           3C                     10    cmp al, #0x10
36175 A430           75           0C              jne apm32_unimplemented
36176 A432           B3                     00    mov bl, #0
36177 A434     66    B9                   0000    mov cx, #0
36178 A438           EB           00              jmp apm32_ok
36179                                           ;-----------------
36180                       0000A43A            apm32_ok:
36181 A43A     66    9D                           popf
36182 A43C           F8                           clc
36183 A43D           CB                           retf
36184                       0000A43E            apm32_unimplemented:
36185                       0000A43E            apm32_error:
36186 A43E     66    9D                           popf
36187 A440           F9                           stc
36188 A441           CB                           retf
36189                                           use16 386
36190                       0000A442            apm16_out_str:
36191 A442     66    50                           push eax
36192 A444     66    53                           push ebx
36193 A446     66    89C3                         mov ebx, eax
36194                       0000A449            apm16_out_str1:
36195 A449           2E                           SEG CS
36196 A44A           8A07                         mov al, byte ptr [bx]
36197 A44C           3C                     00    cmp al, #0
36198 A44E           74           05              je apm16_out_str2
36199 A450           EE                           outb dx, al
36200 A451     66    43                           inc ebx
36201 A453           EB           F4              jmp apm16_out_str1
36202                       0000A455            apm16_out_str2:
36203 A455     66    5B                           pop ebx
36204 A457     66    58                           pop eax
36205 A459           C3                           ret
36206                       0000A45A            apm16_07_poweroff_str:
36207 A45A                        53              .ascii "Shutdown"
36208 A462                        00              db 0
36209                       0000A463            apm16_07_suspend_str:
36210 A463                        53              .ascii "Suspend"
36211 A46A                        00              db 0
36212                       0000A46B            apm16_07_standby_str:
36213 A46B                        53              .ascii "Standby"
36214 A472                        00              db 0
36215                       0000A473            _apm16_entry:
36216 A473           9C                           pushf
36217                                           ;-----------------
36218                                           ; APM interface disconnect
36219                       0000A474            apm16_04:
36220 A474           3C                     04    cmp al, #0x04
36221 A476           75           03              jne apm16_05
36222 A478           E9         008D              jmp apm16_ok
36223                                           ;-----------------
36224                                           ; APM cpu idle
36225                       0000A47B            apm16_05:
36226 A47B           3C                     05    cmp al, #0x05
36227 A47D           75           07              jne apm16_07
36228 A47F           9C                           pushf ; XEN
36229 A480           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
36230 A481           F4                           hlt
36231 A482           9D                           popf ; XEN
36232 A483           E9         0082              jmp apm16_ok
36233                                           ;-----------------
36234                                           ; APM Set Power State
36235                       0000A486            apm16_07:
36236 A486           3C                     07    cmp al, #0x07
36237 A488           75           41              jne apm16_08
36238 A48A           83FB                   01    cmp bx, #1
36239 A48D           75           79              jne apm16_ok
36240 A48F           83F9                   03    cmp cx, #3
36241 A492           74           0C              je apm16_07_poweroff
36242 A494           83F9                   02    cmp cx, #2
36243 A497           74           14              je apm16_07_suspend
36244 A499           83F9                   01    cmp cx, #1
36245 A49C           74           1E              je apm16_07_standby
36246 A49E           75           68              jne apm16_ok
36247                       0000A4A0            apm16_07_poweroff:
36248 A4A0           FA                           cli
36249 A4A1           BA                   8900    mov dx, #0x8900
36250 A4A4           B8                   A45A    mov ax, #apm16_07_poweroff_str
36251 A4A7           E8         FF98              call apm16_out_str
36252                       0000A4AA            apm16_07_1:
36253 A4AA           F4                           hlt
36254 A4AB           EB           FD              jmp apm16_07_1
36255                       0000A4AD            apm16_07_suspend:
36256 A4AD     66    52                           push edx
36257 A4AF           BA                   8900    mov dx, #0x8900
36258 A4B2           B8                   A463    mov ax, #apm16_07_suspend_str
36259 A4B5           E8         FF8A              call apm16_out_str
36260 A4B8     66    5A                           pop edx
36261 A4BA           EB           4C              jmp apm16_ok
36262                       0000A4BC            apm16_07_standby:
36263 A4BC     66    52                           push edx
36264 A4BE           BA                   8900    mov dx, #0x8900
36265 A4C1           B8                   A46B    mov ax, #apm16_07_standby_str
36266 A4C4           E8         FF7B              call apm16_out_str
36267 A4C7     66    5A                           pop edx
36268 A4C9           EB           3D              jmp apm16_ok
36269                                           ;-----------------
36270                                           ; APM Enable / Disable
36271                       0000A4CB            apm16_08:
36272 A4CB           3C                     08    cmp al, #0x08
36273 A4CD           75           02              jne apm16_0a
36274 A4CF           EB           37              jmp apm16_ok
36275                                           ;-----------------
36276                                           ; Get Power Status
36277                       0000A4D1            apm16_0a:
36278 A4D1           3C                     0A    cmp al, #0x0a
36279 A4D3           75           10              jne apm16_0b
36280 A4D5           B7                     01    mov bh, #0x01
36281 A4D7           B3                     FF    mov bl, #0xff
36282 A4D9           B5                     80    mov ch, #0x80
36283 A4DB           B1                     FF    mov cl, #0xff
36284 A4DD           BA                   FFFF    mov dx, #0xffff
36285 A4E0           BE                   0000    mov si, #0
36286 A4E3           EB           23              jmp apm16_ok
36287                                           ;-----------------
36288                                           ; Get PM Event
36289                       0000A4E5            apm16_0b:
36290 A4E5           3C                     0B    cmp al, #0x0b
36291 A4E7           75           04              jne apm16_0e
36292 A4E9           B4                     80    mov ah, #0x80
36293 A4EB           EB           1E              jmp apm16_error
36294                                           ;-----------------
36295                                           ; APM Driver Version
36296                       0000A4ED            apm16_0e:
36297 A4ED           3C                     0E    cmp al, #0x0e
36298 A4EF           75           06              jne apm16_0f
36299 A4F1           B4                     01    mov ah, #1
36300 A4F3           B0                     02    mov al, #2
36301 A4F5           EB           11              jmp apm16_ok
36302                                           ;-----------------
36303                                           ; APM Engage / Disengage
36304                       0000A4F7            apm16_0f:
36305 A4F7           3C                     0F    cmp al, #0x0f
36306 A4F9           75           02              jne apm16_10
36307 A4FB           EB           0B              jmp apm16_ok
36308                                           ;-----------------
36309                                           ; APM Get Capabilities
36310                       0000A4FD            apm16_10:
36311 A4FD           3C                     10    cmp al, #0x10
36312 A4FF           75           0A              jne apm16_unimplemented
36313 A501           B3                     00    mov bl, #0
36314 A503           B9                   0000    mov cx, #0
36315 A506           EB           00              jmp apm16_ok
36316                                           ;-----------------
36317                       0000A508            apm16_ok:
36318 A508           9D                           popf
36319 A509           F8                           clc
36320 A50A           CB                           retf
36321                       0000A50B            apm16_unimplemented:
36322                       0000A50B            apm16_error:
36323 A50B           9D                           popf
36324 A50C           F9                           stc
36325 A50D           CB                           retf
36326                       0000A50E            apmreal_out_str:
36327 A50E     66    50                           push eax
36328 A510     66    53                           push ebx
36329 A512     66    89C3                         mov ebx, eax
36330                       0000A515            apmreal_out_str1:
36331 A515           2E                           SEG CS
36332 A516           8A07                         mov al, byte ptr [bx]
36333 A518           3C                     00    cmp al, #0
36334 A51A           74           05              je apmreal_out_str2
36335 A51C           EE                           outb dx, al
36336 A51D     66    43                           inc ebx
36337 A51F           EB           F4              jmp apmreal_out_str1
36338                       0000A521            apmreal_out_str2:
36339 A521     66    5B                           pop ebx
36340 A523     66    58                           pop eax
36341 A525           C3                           ret
36342                       0000A526            apmreal_07_poweroff_str:
36343 A526                        53              .ascii "Shutdown"
36344 A52E                        00              db 0
36345                       0000A52F            apmreal_07_suspend_str:
36346 A52F                        53              .ascii "Suspend"
36347 A536                        00              db 0
36348                       0000A537            apmreal_07_standby_str:
36349 A537                        53              .ascii "Standby"
36350 A53E                        00              db 0
36351 A53F           9C                           pushf
36352                       0000A540            _apmreal_entry:
36353                                           ;-----------------
36354                                           ; APM installation check
36355                       0000A540            apmreal_00:
36356 A540           3C                     00    cmp al, #0x00
36357 A542           75           0E              jne apmreal_01
36358 A544           B4                     01    mov ah, #1
36359 A546           B0                     02    mov al, #2
36360 A548           B7                     50    mov bh, #0x50
36361 A54A           B3                     4D    mov bl, #0x4d
36362 A54C           B9                   0003    mov cx, #0x3
36363 A54F           E9         00D0              jmp apmreal_ok
36364                                           ;-----------------
36365                                           ; APM real mode interface connect
36366                       0000A552            apmreal_01:
36367 A552           3C                     01    cmp al, #0x01
36368 A554           75           03              jne apmreal_02
36369 A556           E9         00C9              jmp apmreal_ok
36370                                           ;-----------------
36371                                           ; APM 16 bit protected mode interface connect
36372                       0000A559            apmreal_02:
36373 A559           3C                     02    cmp al, #0x02
36374 A55B           75           12              jne apmreal_03
36375 A55D           BB                   A473    mov bx, #_apm16_entry
36376 A560           B8                   F000    mov ax, #0xf000
36377 A563           BE                   FFF0    mov si, #0xfff0
36378 A566           B9                   F000    mov cx, #0xf000
36379 A569           BF                   FFF0    mov di, #0xfff0
36380 A56C           E9         00B3              jmp apmreal_ok
36381                                           ;-----------------
36382                                           ; APM 32 bit protected mode interface connect
36383                       0000A56F            apmreal_03:
36384 A56F           3C                     03    cmp al, #0x03
36385 A571           75           1B              jne apmreal_04
36386 A573           B8                   F000    mov ax, #0xf000
36387 A576     66    BB               0000A38A    mov ebx, #_apm32_entry
36388 A57C           B9                   F000    mov cx, #0xf000
36389 A57F     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
36390 A585           BA                   F000    mov dx, #0xf000
36391 A588           BF                   FFF0    mov di, #0xfff0
36392 A58B           E9         0094              jmp apmreal_ok
36393                                           ;-----------------
36394                                           ; APM interface disconnect
36395                       0000A58E            apmreal_04:
36396 A58E           3C                     04    cmp al, #0x04
36397 A590           75           03              jne apmreal_05
36398 A592           E9         008D              jmp apmreal_ok
36399                                           ;-----------------
36400                                           ; APM cpu idle
36401                       0000A595            apmreal_05:
36402 A595           3C                     05    cmp al, #0x05
36403 A597           75           07              jne apmreal_07
36404 A599           9C                           pushf ; XEN
36405 A59A           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
36406 A59B           F4                           hlt
36407 A59C           9D                           popf ; XEN
36408 A59D           E9         0082              jmp apmreal_ok
36409                                           ;-----------------
36410                                           ; APM Set Power State
36411                       0000A5A0            apmreal_07:
36412 A5A0           3C                     07    cmp al, #0x07
36413 A5A2           75           41              jne apmreal_08
36414 A5A4           83FB                   01    cmp bx, #1
36415 A5A7           75           79              jne apmreal_ok
36416 A5A9           83F9                   03    cmp cx, #3
36417 A5AC           74           0C              je apmreal_07_poweroff
36418 A5AE           83F9                   02    cmp cx, #2
36419 A5B1           74           14              je apmreal_07_suspend
36420 A5B3           83F9                   01    cmp cx, #1
36421 A5B6           74           1E              je apmreal_07_standby
36422 A5B8           75           68              jne apmreal_ok
36423                       0000A5BA            apmreal_07_poweroff:
36424 A5BA           FA                           cli
36425 A5BB           BA                   8900    mov dx, #0x8900
36426 A5BE           B8                   A526    mov ax, #apmreal_07_poweroff_str
36427 A5C1           E8         FF4A              call apmreal_out_str
36428                       0000A5C4            apmreal_07_1:
36429 A5C4           F4                           hlt
36430 A5C5           EB           FD              jmp apmreal_07_1
36431                       0000A5C7            apmreal_07_suspend:
36432 A5C7     66    52                           push edx
36433 A5C9           BA                   8900    mov dx, #0x8900
36434 A5CC           B8                   A52F    mov ax, #apmreal_07_suspend_str
36435 A5CF           E8         FF3C              call apmreal_out_str
36436 A5D2     66    5A                           pop edx
36437 A5D4           EB           4C              jmp apmreal_ok
36438                       0000A5D6            apmreal_07_standby:
36439 A5D6     66    52                           push edx
36440 A5D8           BA                   8900    mov dx, #0x8900
36441 A5DB           B8                   A537    mov ax, #apmreal_07_standby_str
36442 A5DE           E8         FF2D              call apmreal_out_str
36443 A5E1     66    5A                           pop edx
36444 A5E3           EB           3D              jmp apmreal_ok
36445                                           ;-----------------
36446                                           ; APM Enable / Disable
36447                       0000A5E5            apmreal_08:
36448 A5E5           3C                     08    cmp al, #0x08
36449 A5E7           75           02              jne apmreal_0a
36450 A5E9           EB           37              jmp apmreal_ok
36451                                           ;-----------------
36452                                           ; Get Power Status
36453                       0000A5EB            apmreal_0a:
36454 A5EB           3C                     0A    cmp al, #0x0a
36455 A5ED           75           10              jne apmreal_0b
36456 A5EF           B7                     01    mov bh, #0x01
36457 A5F1           B3                     FF    mov bl, #0xff
36458 A5F3           B5                     80    mov ch, #0x80
36459 A5F5           B1                     FF    mov cl, #0xff
36460 A5F7           BA                   FFFF    mov dx, #0xffff
36461 A5FA           BE                   0000    mov si, #0
36462 A5FD           EB           23              jmp apmreal_ok
36463                                           ;-----------------
36464                                           ; Get PM Event
36465                       0000A5FF            apmreal_0b:
36466 A5FF           3C                     0B    cmp al, #0x0b
36467 A601           75           04              jne apmreal_0e
36468 A603           B4                     80    mov ah, #0x80
36469 A605           EB           20              jmp apmreal_error
36470                                           ;-----------------
36471                                           ; APM Driver Version
36472                       0000A607            apmreal_0e:
36473 A607           3C                     0E    cmp al, #0x0e
36474 A609           75           06              jne apmreal_0f
36475 A60B           B4                     01    mov ah, #1
36476 A60D           B0                     02    mov al, #2
36477 A60F           EB           11              jmp apmreal_ok
36478                                           ;-----------------
36479                                           ; APM Engage / Disengage
36480                       0000A611            apmreal_0f:
36481 A611           3C                     0F    cmp al, #0x0f
36482 A613           75           02              jne apmreal_10
36483 A615           EB           0B              jmp apmreal_ok
36484                                           ;-----------------
36485                                           ; APM Get Capabilities
36486                       0000A617            apmreal_10:
36487 A617           3C                     10    cmp al, #0x10
36488 A619           75           0C              jne apmreal_unimplemented
36489 A61B           B3                     00    mov bl, #0
36490 A61D           B9                   0000    mov cx, #0
36491 A620           EB           00              jmp apmreal_ok
36492                                           ;-----------------
36493                       0000A622            apmreal_ok:
36494 A622           9D                           popf
36495 A623           F8                           clc
36496 A624           E9         F90B              jmp iret_modify_cf
36497                       0000A627            apmreal_unimplemented:
36498                       0000A627            apmreal_error:
36499 A627           9D                           popf
36500 A628           F9                           stc
36501 A629           E9         F906              jmp iret_modify_cf
36502                                           ! 6286 endasm
36503                                           !BCC_ENDASM
36504                                           ! 6287 #asm
36505                                           !BCC_ASM
36506                       00000012            _int70_function.ds	set	$12
36507                       00000014            _int70_function.iret_addr	set	$14
36508                       00000002            _int70_function.regs	set	2
36509                                               ; Switch into protected mode to allow access to 32 bit addresses.
36510                                               ; This function allows switching into protected mode.
36511                                               ; (the specs says big real mode, but that will not work)
36512                                               ;
36513                                               ; preserves all registers and prepares cs, ds, es, ss for usage
36514                                               ; in protected mode; while in prot.mode interrupts remain disabled
36515                       0000A62C            switch_to_protmode:
36516 A62C           FA                             cli
36517                                               ; have to fix the stack for proper return address in 32 bit mode
36518 A62D           6A                     0F      push WORD #(0xf000>>12) ;extended return address
36519 A62F           55                             push bp ;pop@A1
36520 A630           89E5                           mov bp, sp
36521 A632     66    50                             push eax ;pop@A2
36522 A634     66    8B46         02                mov eax, 2[bp] ; fix return address
36523 A638     66    C1C0                   10      rol eax, #16
36524 A63C     66    8946         02                mov 2[bp], eax
36525 A640     66    89E0                           mov eax, esp
36526 A643     66    C1C8                   10      ror eax, #16 ; hi(esp)
36527 A647           53                             push bx ; preserve before function call
36528 A648           51                             push cx
36529 A649           52                             push dx
36530 A64A           50                             push ax ; prepare stack for
36531 A64B           06                             push es ; call
36532 A64C           1E                             push ds
36533 A64D           0E                             push cs
36534 A64E           16                             push ss
36535 A64F           E8         013C                call _store_segment_registers
36536 A652           83C4                   0A      add sp, #10 ; pop ax,es-ss
36537 A655           5A                             pop dx ; restore after function call
36538 A656           59                             pop cx
36539 A657           5B                             pop bx
36540                                               ; calculate protected-mode esp from ss:sp
36541 A658     66    81E4             0000FFFF      and esp, #0xffff
36542 A65F     66    31C0                           xor eax, eax
36543 A662           8CD0                           mov ax, ss
36544 A664     66    C1C0                   04      rol eax, #4
36545 A668     66    01E0                           add eax, esp
36546 A66B     66    89C4                           mov esp, eax
36547 A66E           2E                             seg cs
36548 A66F         0F0116       A6C0                lgdt my_gdtdesc ; switch to own table
36549 A674         0F20C0                           mov eax, cr0
36550 A677           0C                     01      or al, #0x1 ; protected mode 'on'
36551 A679         0F22C0                           mov cr0, eax
36552 A67C     66    EA     000FA684      0008      jmpf DWORD (0xf0000 | switch_to_protmode_goon_1), #(gdt_entry_pm_cs - gdt_base)
36553                                               USE32
36554                       0000A684            switch_to_protmode_goon_1:
36555 A684     66    B8                   0018      mov ax, #(gdt_entry_pm_32bit_ds - gdt_base) ; 32 bit segment that allows
36556 A688           8ED8                           mov ds, ax ; to reach all 32 bit
36557 A68A           8EC0                           mov es, ax ; addresses
36558 A68C           8ED0                           mov ss, ax
36559 A68E           58                             pop eax ;@A2
36560 A68F     66    5D                             pop bp ;@A1
36561 A691           C3                             ret
36562                                               USE16
36563 A692                  00000010                .align 16
36564                       0000A6A0            gdt_base:
36565                                               ; see Intel SW Dev. Manuals section 3.4.5, Volume 3 for meaning of bits
36566 A6A0                      0000                .word 0,0
36567 A6A4                        00                .byte 0,0,0,0
36568                       0000A6A8            gdt_entry_pm_cs:
36569                                               ; 32 bit code segment for protected mode
36570 A6A8                      FFFF                .word 0xffff, 0x0000
36571 A6AC                        00                .byte 0x00, 0x9a, 0xcf, 0x00
36572                       0000A6B0            gdt_entry_pm_16bit_cs:
36573                                               ; temp. 16 bit code segment used while in protected mode
36574 A6B0                      FFFF                .word 0xffff, 0x0000
36575 A6B4                        0F                .byte 0xf0000 >> 16, 0x9a, 0x0, 0x0
36576                       0000A6B8            gdt_entry_pm_32bit_ds:
36577                                               ; (32 bit) data segment (r/w) reaching all possible areas in 32bit memory
36578                                               ; 4kb granularity
36579 A6B8                      FFFF                .word 0xffff, 0x0000
36580 A6BC                        00                .byte 0x0, 0x92, 0xcf, 0x0
36581                       0000A6C0            gdt_entry_end:
36582                       0000A6C0            my_gdtdesc:
36583 A6C0                      001F                .word (gdt_entry_end - gdt_base) - 1
36584 A6C2                  000FA6A0                .long gdt_base | 0xf0000
36585                       0000A6C6            realmode_gdtdesc: ;to be used in real mode
36586 A6C6                      FFFF                .word 0xffff
36587 A6C8                  00000000                .long 0x0
36588                       0000A6CC            switch_to_realmode:
36589                                               ; Implementation of switching from protected mode to real mode
36590                                               ; prepares cs, es, ds, ss to be used in real mode
36591                                               ; spills eax
36592                                               USE32
36593                                               ; need to fix up the stack to return in 16 bit mode
36594                                               ; currently the 32 bit return address is on the stack
36595 A6CC           58                             pop eax
36596 A6CD     66    50                             push ax
36597 A6CF     66    53                             push bx ;pop@1
36598 A6D1     66    56                             push si ;pop@2
36599 A6D3           E8     0000005A                call _ebda_ss_offset32 ; get the offset of the ss
36600 A6D8     66    89C3                           mov bx, ax ; entry within the ebda.
36601 A6DB           EA     0000A6E2      0010      jmpf switch_to_realmode_goon_1, #(gdt_entry_pm_16bit_cs - gdt_base)
36602                                               USE16
36603                       0000A6E2            switch_to_realmode_goon_1:
36604 A6E2         0F20C0                           mov eax, cr0
36605 A6E5           24                     FE      and al, #0xfe ; protected mode 'off'
36606 A6E7         0F22C0                           mov cr0, eax
36607 A6EA           EA         A6EF      F000      jmpf switch_to_realmode_goon_2, #0xf000
36608                       0000A6EF            switch_to_realmode_goon_2:
36609                                               ; get orig. 'ss' without using the stack (no 'call'!)
36610 A6EF     66    31C0                           xor eax, eax ; clear upper 16 bits (and lower)
36611 A6F2           B8                   0040      mov ax, #0x40 ; where is the ebda located?
36612 A6F5           8ED8                           mov ds, ax
36613 A6F7           BE                   000E      mov si, #0xe
36614 A6FA           3E                             seg ds
36615 A6FB           8B04                           mov ax, [si] ; ax = segment of ebda
36616 A6FD           8ED8                           mov ds, ax ; segment of ebda
36617 A6FF           3E                             seg ds
36618 A700           8B07                           mov ax, [bx] ; stack segment - bx has been set above
36619 A702           8ED0                           mov ss, ax
36620                                               ; from esp and ss calculate real-mode sp
36621 A704     66    C1C0                   04      rol eax, #4
36622 A708     66    29C4                           sub esp, eax
36623 A70B           52                             push dx ;preserve before call(s)
36624 A70C           51                             push cx
36625 A70D           53                             push bx
36626 A70E           E8         012D                call _get_register_ds ; get orig. 'ds'
36627 A711           8ED8                           mov ds, ax
36628 A713           E8         0136                call _get_register_es ; get orig. 'es'
36629 A716           8EC0                           mov es, ax
36630 A718           E8         013F                call _get_register_esp_hi ; fix the upper 16 bits of esp
36631 A71B     66    C1CC                   10      ror esp, #16
36632 A71F           89C4                           mov sp, ax
36633 A721     66    C1C4                   10      rol esp, #16
36634 A725           5B                             pop bx
36635 A726           59                             pop cx
36636 A727           5A                             pop dx
36637 A728           2E                             seg cs
36638 A729         0F0116       A6C6                lgdt realmode_gdtdesc
36639 A72E           FB                             sti ; allow interrupts
36640 A72F           5E                             pop si ;@2
36641 A730           5B                             pop bx ;@1
36642 A731           C3                             ret
36643                                           ! 6422 endasm
36644                                           !BCC_ENDASM
36645                                           ! 6423 Bit16u
36646                                           ! Register BX used in function int70_function
36647                                           ! 6424 ebda_ss_offset32()
36648                                           ! 6425 {
36649                                           export	_ebda_ss_offset32
36650                       0000A732            _ebda_ss_offset32:
36651                                           ! 6426 #asm
36652                                           !BCC_ASM
36653                                               USE32
36654                                           ! 6428 endasm
36655                                           !BCC_ENDASM
36656                                           ! 6429     return &((ebda_data_t *) 0)->upcall.reg_ss;
36657 A732     66    55                         push	bp
36658 A734     66    89E5                       mov	bp,sp
36659 A737     66    B8                   0250  mov	ax,#$250
36660 A73B     66    5D                         pop	bp
36661 A73D           C3                         ret
36662                                           !BCC_EOS
36663                                           ! 6430 #asm
36664                                           !BCC_EOS
36665                                           !BCC_ASM
36666                                               USE16
36667                                           ! 6432 endasm
36668                                           !BCC_ENDASM
36669                                           !BCC_EOS
36670                                           ! 6433 }
36671                                           ! 6434 Bit16u
36672                                           ! 6435 read_word_from_ebda(offset)
36673                                           ! 6436     Bit16u offset;
36674                                           export	_read_word_from_ebda
36675                       0000A73E            _read_word_from_ebda:
36676                                           !BCC_EOS
36677                                           ! 6437 {
36678                                           ! 6438  Bit16u ebda_seg = read_word(0x0040, 0x000E);
36679 A73E           55                         push	bp
36680 A73F           89E5                       mov	bp,sp
36681 A741           4C                         dec	sp
36682 A742           4C                         dec	sp
36683                                           ! Debug: list int = const $E (used reg = )
36684 A743           B8                   000E  mov	ax,*$E
36685 A746           50                         push	ax
36686                                           ! Debug: list int = const $40 (used reg = )
36687 A747           B8                   0040  mov	ax,*$40
36688 A74A           50                         push	ax
36689                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36690 A74B           E8         5EC3            call	_read_word
36691 A74E           83C4                   04  add	sp,*4
36692                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
36693 A751           8946         FE            mov	-2[bp],ax
36694                                           !BCC_EOS
36695                                           ! 6439  return read_word(ebda_seg, offset);
36696                                           ! Debug: list unsigned short offset = [S+4+2] (used reg = )
36697 A754           FF76         04            push	4[bp]
36698                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
36699 A757           FF76         FE            push	-2[bp]
36700                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36701 A75A           E8         5EB4            call	_read_word
36702 A75D           83C4                   04  add	sp,*4
36703                                           ! Debug: cast unsigned short = const 0 to unsigned short = ax+0 (used reg = )
36704 A760           89EC                       mov	sp,bp
36705 A762           5D                         pop	bp
36706 A763           C3                         ret
36707                                           !BCC_EOS
36708                                           ! 6440 }
36709                                           ! 6441 Bit32u
36710                                           ! 6442 read_dword_from_ebda(offset)
36711                                           ! 6443     Bit16u offset;
36712                                           export	_read_dword_from_ebda
36713                       0000A764            _read_dword_from_ebda:
36714                                           !BCC_EOS
36715                                           ! 6444 {
36716                                           ! 6445  Bit16u ebda_seg = read_word(0x0040, 0x000E);
36717 A764           55                         push	bp
36718 A765           89E5                       mov	bp,sp
36719 A767           4C                         dec	sp
36720 A768           4C                         dec	sp
36721                                           ! Debug: list int = const $E (used reg = )
36722 A769           B8                   000E  mov	ax,*$E
36723 A76C           50                         push	ax
36724                                           ! Debug: list int = const $40 (used reg = )
36725 A76D           B8                   0040  mov	ax,*$40
36726 A770           50                         push	ax
36727                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36728 A771           E8         5E9D            call	_read_word
36729 A774           83C4                   04  add	sp,*4
36730                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
36731 A777           8946         FE            mov	-2[bp],ax
36732                                           !BCC_EOS
36733                                           ! 6446  return read_dword(ebda_seg, offset);
36734                                           ! Debug: list unsigned short offset = [S+4+2] (used reg = )
36735 A77A           FF76         04            push	4[bp]
36736                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
36737 A77D           FF76         FE            push	-2[bp]
36738                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
36739 A780           E8         58D2            call	_read_dword
36740 A783           89D3                       mov	bx,dx
36741 A785           83C4                   04  add	sp,*4
36742                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
36743 A788           89DA                       mov	dx,bx
36744 A78A           89EC                       mov	sp,bp
36745 A78C           5D                         pop	bp
36746 A78D           C3                         ret
36747                                           !BCC_EOS
36748                                           ! 6447 }
36749                                           ! 6448   void
36750                                           ! Register BX used in function read_dword_from_ebda
36751                                           ! 6449 store_segment_registers(ss, cs, ds, es, esp_hi)
36752                                           ! 6450   Bit16u ss, cs, ds, es, esp_hi;
36753                                           export	_store_segment_registers
36754                       0000A78E            _store_segment_registers:
36755                                           !BCC_EOS
36756                                           ! 6451 {
36757                                           ! 6452  Bit16u ebda_seg = read_word(0x0040, 0x000E);
36758 A78E           55                         push	bp
36759 A78F           89E5                       mov	bp,sp
36760 A791           4C                         dec	sp
36761 A792           4C                         dec	sp
36762                                           ! Debug: list int = const $E (used reg = )
36763 A793           B8                   000E  mov	ax,*$E
36764 A796           50                         push	ax
36765                                           ! Debug: list int = const $40 (used reg = )
36766 A797           B8                   0040  mov	ax,*$40
36767 A79A           50                         push	ax
36768                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36769 A79B           E8         5E73            call	_read_word
36770 A79E           83C4                   04  add	sp,*4
36771                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
36772 A7A1           8946         FE            mov	-2[bp],ax
36773                                           !BCC_EOS
36774                                           ! 6453  write_word(ebda_seg, &((ebda_data_t *) 0)->upcall.reg_ss, ss);
36775                                           ! Debug: list unsigned short ss = [S+4+2] (used reg = )
36776 A7A4           FF76         04            push	4[bp]
36777                                           ! Debug: list * unsigned short = const $250 (used reg = )
36778 A7A7           B8                   0250  mov	ax,#$250
36779 A7AA           50                         push	ax
36780                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
36781 A7AB           FF76         FE            push	-2[bp]
36782                                           ! Debug: func () void = write_word+0 (used reg = )
36783 A7AE           E8         5E8B            call	_write_word
36784 A7B1           83C4                   06  add	sp,*6
36785                                           !BCC_EOS
36786                                           ! 6454  write_word(ebda_seg, &((ebda_data_t *) 0)->upcall.reg_cs, cs);
36787                                           ! Debug: list unsigned short cs = [S+4+4] (used reg = )
36788 A7B4           FF76         06            push	6[bp]
36789                                           ! Debug: list * unsigned short = const $252 (used reg = )
36790 A7B7           B8                   0252  mov	ax,#$252
36791 A7BA           50                         push	ax
36792                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
36793 A7BB           FF76         FE            push	-2[bp]
36794                                           ! Debug: func () void = write_word+0 (used reg = )
36795 A7BE           E8         5E7B            call	_write_word
36796 A7C1           83C4                   06  add	sp,*6
36797                                           !BCC_EOS
36798                                           ! 6455  write_word(ebda_seg, &((ebda_data_t *) 0)->upcall.reg_ds, ds);
36799                                           ! Debug: list unsigned short ds = [S+4+6] (used reg = )
36800 A7C4           FF76         08            push	8[bp]
36801                                           ! Debug: list * unsigned short = const $254 (used reg = )
36802 A7C7           B8                   0254  mov	ax,#$254
36803 A7CA           50                         push	ax
36804                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
36805 A7CB           FF76         FE            push	-2[bp]
36806                                           ! Debug: func () void = write_word+0 (used reg = )
36807 A7CE           E8         5E6B            call	_write_word
36808 A7D1           83C4                   06  add	sp,*6
36809                                           !BCC_EOS
36810                                           ! 6456  write_word(ebda_seg, &((ebda_data_t *) 0)->upcall.reg_es, es);
36811                                           ! Debug: list unsigned short es = [S+4+8] (used reg = )
36812 A7D4           FF76         0A            push	$A[bp]
36813                                           ! Debug: list * unsigned short = const $256 (used reg = )
36814 A7D7           B8                   0256  mov	ax,#$256
36815 A7DA           50                         push	ax
36816                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
36817 A7DB           FF76         FE            push	-2[bp]
36818                                           ! Debug: func () void = write_word+0 (used reg = )
36819 A7DE           E8         5E5B            call	_write_word
36820 A7E1           83C4                   06  add	sp,*6
36821                                           !BCC_EOS
36822                                           ! 6457  write_word(ebda_seg, &((ebda_data_t *) 0)->upcall.esp_hi, esp_hi);
36823                                           ! Debug: list unsigned short esp_hi = [S+4+$A] (used reg = )
36824 A7E4           FF76         0C            push	$C[bp]
36825                                           ! Debug: list * unsigned short = const $258 (used reg = )
36826 A7E7           B8                   0258  mov	ax,#$258
36827 A7EA           50                         push	ax
36828                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
36829 A7EB           FF76         FE            push	-2[bp]
36830                                           ! Debug: func () void = write_word+0 (used reg = )
36831 A7EE           E8         5E4B            call	_write_word
36832 A7F1           83C4                   06  add	sp,*6
36833                                           !BCC_EOS
36834                                           ! 6458 }
36835 A7F4           89EC                       mov	sp,bp
36836 A7F6           5D                         pop	bp
36837 A7F7           C3                         ret
36838                                           ! 6459   void
36839                                           ! 6460 store_returnaddress(retaddr)
36840                                           ! 6461    Bit16u retaddr;
36841                                           export	_store_returnaddress
36842                       0000A7F8            _store_returnaddress:
36843                                           !BCC_EOS
36844                                           ! 6462 {
36845                                           ! 6463  Bit16u ebda_seg = read_word(0x0040, 0x000E);
36846 A7F8           55                         push	bp
36847 A7F9           89E5                       mov	bp,sp
36848 A7FB           4C                         dec	sp
36849 A7FC           4C                         dec	sp
36850                                           ! Debug: list int = const $E (used reg = )
36851 A7FD           B8                   000E  mov	ax,*$E
36852 A800           50                         push	ax
36853                                           ! Debug: list int = const $40 (used reg = )
36854 A801           B8                   0040  mov	ax,*$40
36855 A804           50                         push	ax
36856                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36857 A805           E8         5E09            call	_read_word
36858 A808           83C4                   04  add	sp,*4
36859                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
36860 A80B           8946         FE            mov	-2[bp],ax
36861                                           !BCC_EOS
36862                                           ! 6464  write_word(ebda_seg, &((ebda_data_t *) 0)->upcall.retaddr, retaddr);
36863                                           ! Debug: list unsigned short retaddr = [S+4+2] (used reg = )
36864 A80E           FF76         04            push	4[bp]
36865                                           ! Debug: list * unsigned short = const $25A (used reg = )
36866 A811           B8                   025A  mov	ax,#$25A
36867 A814           50                         push	ax
36868                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
36869 A815           FF76         FE            push	-2[bp]
36870                                           ! Debug: func () void = write_word+0 (used reg = )
36871 A818           E8         5E21            call	_write_word
36872 A81B           83C4                   06  add	sp,*6
36873                                           !BCC_EOS
36874                                           ! 6465 }
36875 A81E           89EC                       mov	sp,bp
36876 A820           5D                         pop	bp
36877 A821           C3                         ret
36878                                           ! 6466 Bit16u
36879                                           ! 6467 get_returnaddress()
36880                                           ! 6468 {
36881                                           export	_get_returnaddress
36882                       0000A822            _get_returnaddress:
36883                                           ! 6469  
36884                                           ! 6469 return read_word_from_ebda(&((ebda_data_t *) 0)->upcall.retaddr);
36885 A822           55                         push	bp
36886 A823           89E5                       mov	bp,sp
36887                                           ! Debug: list * unsigned short = const $25A (used reg = )
36888 A825           B8                   025A  mov	ax,#$25A
36889 A828           50                         push	ax
36890                                           ! Debug: func () unsigned short = read_word_from_ebda+0 (used reg = )
36891 A829           E8         FF12            call	_read_word_from_ebda
36892 A82C           89EC                       mov	sp,bp
36893                                           ! Debug: cast unsigned short = const 0 to unsigned short = ax+0 (used reg = )
36894 A82E           5D                         pop	bp
36895 A82F           C3                         ret
36896                                           !BCC_EOS
36897                                           ! 6470 }
36898                                           ! 6471 Bit16u
36899                                           ! 6472 get_register_cs()
36900                                           ! 6473 {
36901                                           export	_get_register_cs
36902                       0000A830            _get_register_cs:
36903                                           ! 6474  return read_word_from_ebda(&((ebda_data_t *) 0)->upcall.reg_cs);
36904 A830           55                         push	bp
36905 A831           89E5                       mov	bp,sp
36906                                           ! Debug: list * unsigned short = const $252 (used reg = )
36907 A833           B8                   0252  mov	ax,#$252
36908 A836           50                         push	ax
36909                                           ! Debug: func () unsigned short = read_word_from_ebda+0 (used reg = )
36910 A837           E8         FF04            call	_read_word_from_ebda
36911 A83A           89EC                       mov	sp,bp
36912                                           ! Debug: cast unsigned short = const 0 to unsigned short = ax+0 (used reg = )
36913 A83C           5D                         pop	bp
36914 A83D           C3                         ret
36915                                           !BCC_EOS
36916                                           ! 6475 }
36917                                           ! 6476 Bit16u
36918                                           ! 6477 get_register_ds()
36919                                           ! 6478 {
36920                                           export	_get_register_ds
36921                       0000A83E            _get_register_ds:
36922                                           ! 6479  return read_word_from_ebda(&((ebda_data_t *) 0)->upcall.reg_ds);
36923 A83E           55                         push	bp
36924 A83F           89E5                       mov	bp,sp
36925                                           ! Debug: list * unsigned short = const $254 (used reg = )
36926 A841           B8                   0254  mov	ax,#$254
36927 A844           50                         push	ax
36928                                           ! Debug: func () unsigned short = read_word_from_ebda+0 (used reg = )
36929 A845           E8         FEF6            call	_read_word_from_ebda
36930 A848           89EC                       mov	sp,bp
36931                                           ! Debug: cast unsigned short = const 0 to unsigned short = ax+0 (used reg = )
36932 A84A           5D                         pop	bp
36933 A84B           C3                         ret
36934                                           !BCC_EOS
36935                                           ! 6480 }
36936                                           ! 6481 Bit16u
36937                                           ! 6482 get_register_es()
36938                                           ! 6483 {
36939                                           export	_get_register_es
36940                       0000A84C            _get_register_es:
36941                                           ! 6484  return read_word_from_ebda(&((ebda_data_t *) 0)->upcall.reg_es);
36942 A84C           55                         push	bp
36943 A84D           89E5                       mov	bp,sp
36944                                           ! Debug: list * unsigned short = const $256 (used reg = )
36945 A84F           B8                   0256  mov	ax,#$256
36946 A852           50                         push	ax
36947                                           ! Debug: func () unsigned short = read_word_from_ebda+0 (used reg = )
36948 A853           E8         FEE8            call	_read_word_from_ebda
36949 A856           89EC                       mov	sp,bp
36950                                           ! Debug: cast unsigned short = const 0 to unsigned short = ax+0 (used reg = )
36951 A858           5D                         pop	bp
36952 A859           C3                         ret
36953                                           !BCC_EOS
36954                                           ! 6485 }
36955                                           ! 6486 Bit16u
36956                                           ! 6487 get_register_esp_hi()
36957                                           ! 6488 {
36958                                           export	_get_register_esp_hi
36959                       0000A85A            _get_register_esp_hi:
36960                                           ! 6489  return read_word_from_ebda(&((ebda_data_t *) 0)->upcall.esp_hi);
36961 A85A           55                         push	bp
36962 A85B           89E5                       mov	bp,sp
36963                                           ! Debug: list * unsigned short = const $258 (used reg = )
36964 A85D           B8                   0258  mov	ax,#$258
36965 A860           50                         push	ax
36966                                           ! Debug: func () unsigned short = read_word_from_ebda+0 (used reg = )
36967 A861           E8         FEDA            call	_read_word_from_ebda
36968 A864           89EC                       mov	sp,bp
36969                                           ! Debug: cast unsigned short = const 0 to unsigned short = ax+0 (used reg = )
36970 A866           5D                         pop	bp
36971 A867           C3                         ret
36972                                           !BCC_EOS
36973                                           ! 6490 }
36974                                           ! 6491 #asm
36975                                           !BCC_ASM
36976                       0000A868            Upcall:
36977                                            ; do the upcall into 32 bit space
36978                                            ; clear the stack frame so that 32 bit space sees all the parameters
36979                                            ; on the stack as if they were prepared for it
36980                                            ; ---> take the 16 bit return address off the stack and remember it
36981                                            ;
36982                                            ; Input:
36983                                            ; bx: index of function to call
36984                                            ; Ouput:
36985                                            ; dx, ax: 32 bit result of call (even if 'void' is expected)
36986 A868           55                          push bp ;pop @1
36987 A869           89E5                        mov bp, sp
36988 A86B           56                          push si ;pop @2
36989 A86C           8B46         02             mov ax, 2[bp] ; 16 bit return address
36990 A86F           50                          push ax
36991 A870           E8         FF85             call _store_returnaddress ; store away
36992 A873           58                          pop ax
36993                                            ; XXX GDT munging requires ROM to be writable!
36994 A874           E8         5E99             call _enable_rom_write_access
36995 A877           C1C3                   02   rol bx, #2
36996 A87A           BE                   CB00   mov si, #jmptable
36997 A87D           2E                          seg cs
36998 A87E     66    8B           00             mov eax, dword ptr [si+bx] ; address to call from table
36999 A881           5E                          pop si ;@2
37000 A882           5D                          pop bp ;@1
37001 A883           83C4                   02   add sp, #2 ; remove 16bit return address from stack
37002 A886           E8         FDA3             call switch_to_protmode
37003                                            USE32
37004 A889           FFD0                        call eax ; call 32bit function
37005 A88B           50                          push eax ; preserve result
37006 A88C           E8     FFFFFE3B             call switch_to_realmode ; back to realmode
37007                                            USE16
37008 A891     66    58                          pop eax ; get result
37009 A893           FF36       0000             push word 0x0000 ; placeholder for 16 bit return address
37010 A897           55                          push bp
37011 A898           89E5                        mov bp,sp
37012 A89A     66    50                          push eax ; preserve work register
37013 A89C           E8         5E7E             call _disable_rom_write_access
37014 A89F           E8         FF80             call _get_returnaddress
37015 A8A2           8946         02             mov 2[bp], ax ; 16bit return address onto stack
37016 A8A5     66    58                          pop eax
37017 A8A7           5D                          pop bp
37018 A8A8     66    C1C8                   10   ror eax, #16 ; result into dx/ax
37019 A8AC           89C2                        mov dx, ax ; hi(res) -> dx
37020 A8AE     66    C1C8                   10   ror eax, #16
37021 A8B2           C3                          ret
37022                                           MACRO DoUpcall
37023                                            mov bx, #?1
37024                                            jmp Upcall
37025                                           MEND
37026                                           ! 6542 endasm
37027                                           !BCC_ENDASM
37028                                           ! 6543 Bit32u tcpa_extend_acpi_log(entry_ptr)
37029                                           ! 6544     Bit32u entry_ptr;
37030                                           export	_tcpa_extend_acpi_log
37031                       0000A8B3            _tcpa_extend_acpi_log:
37032                                           !BCC_EOS
37033                                           ! 6545 {
37034                                           ! 6546 #asm
37035                                           !BCC_ASM
37036                       00000002            _tcpa_extend_acpi_log.entry_ptr	set	2
37037                                            DoUpcall(2)
 +a   A8B3           BB                   0002   mov bx, #2
 +a   A8B6           EB           B0             jmp Upcall
37038                                           ! 6548 endasm
37039                                           !BCC_ENDASM
37040                                           ! 6549 }
37041 A8B8           C3                         ret
37042                                           ! 6550  void
37043                                           ! 6551 tcpa_acpi_init()
37044                                           ! 6552 {
37045                                           export	_tcpa_acpi_init
37046                       0000A8B9            _tcpa_acpi_init:
37047                                           ! 6553 #asm
37048                                           !BCC_ASM
37049                                            DoUpcall(1)
 +a   A8B9           BB                   0001   mov bx, #1
 +a   A8BC           EB           AA             jmp Upcall
37050                                           ! 6555 endasm
37051                                           !BCC_ENDASM
37052                                           ! 6556 }
37053 A8BE           C3                         ret
37054                                           ! 6557  void
37055                                           ! 6558 tcpa_calling_int19h()
37056                                           ! 6559 {
37057                                           export	_tcpa_calling_int19h
37058                       0000A8BF            _tcpa_calling_int19h:
37059                                           ! 6560 #asm
37060                                           !BCC_ASM
37061                                            DoUpcall(3)
 +a   A8BF           BB                   0003   mov bx, #3
 +a   A8C2           EB           A4             jmp Upcall
37062                                           ! 6562 endasm
37063                                           !BCC_ENDASM
37064                                           ! 6563 }
37065 A8C4           C3                         ret
37066                                           ! 6564  void
37067                                           ! 6565 tcpa_returned_int19h()
37068                                           ! 6566 {
37069                                           export	_tcpa_returned_int19h
37070                       0000A8C5            _tcpa_returned_int19h:
37071                                           ! 6567 #asm
37072                                           !BCC_ASM
37073                                            DoUpcall(4)
 +a   A8C5           BB                   0004   mov bx, #4
 +a   A8C8           EB           9E             jmp Upcall
37074                                           ! 6569 endasm
37075                                           !BCC_ENDASM
37076                                           ! 6570 }
37077 A8CA           C3                         ret
37078                                           ! 6571  void
37079                                           ! 6572 tcpa_add_event_separators()
37080                                           ! 6573 {
37081                                           export	_tcpa_add_event_separators
37082                       0000A8CB            _tcpa_add_event_separators:
37083                                           ! 6574 #asm
37084                                           !BCC_ASM
37085                                            DoUpcall(5)
 +a   A8CB           BB                   0005   mov bx, #5
 +a   A8CE           EB           98             jmp Upcall
37086                                           ! 6576 endasm
37087                                           !BCC_ENDASM
37088                                           ! 6577 }
37089 A8D0           C3                         ret
37090                                           ! 6578  void
37091                                           ! 6579 tcpa_wake_event()
37092                                           ! 6580 {
37093                                           export	_tcpa_wake_event
37094                       0000A8D1            _tcpa_wake_event:
37095                                           ! 6581 #asm
37096                                           !BCC_ASM
37097                                            DoUpcall(6)
 +a   A8D1           BB                   0006   mov bx, #6
 +a   A8D4           EB           92             jmp Upcall
37098                                           ! 6583 endasm
37099                                           !BCC_ENDASM
37100                                           ! 6584 }
37101 A8D6           C3                         ret
37102                                           ! 6585  void
37103                                           ! 6586 tcpa_start_option_rom_scan()
37104                                           ! 6587 {
37105                                           export	_tcpa_start_option_rom_scan
37106                       0000A8D7            _tcpa_start_option_rom_scan:
37107                                           ! 6588 #asm
37108                                           !BCC_ASM
37109                                            DoUpcall(8)
 +a   A8D7           BB                   0008   mov bx, #8
 +a   A8DA           EB           8C             jmp Upcall
37110                                           ! 6590 endasm
37111                                           !BCC_ENDASM
37112                                           ! 6591 }
37113 A8DC           C3                         ret
37114                                           ! 6592  void
37115                                           ! 6593 tcpa_option_rom(seg)
37116                                           ! 6594     Bit32u seg;
37117                                           export	_tcpa_option_rom
37118                       0000A8DD            _tcpa_option_rom:
37119                                           !BCC_EOS
37120                                           ! 6595 {
37121                                           ! 6596 #asm
37122                                           !BCC_ASM
37123                       00000002            _tcpa_option_rom.seg	set	2
37124                                            DoUpcall(9)
 +a   A8DD           BB                   0009   mov bx, #9
 +a   A8E0           EB           86             jmp Upcall
37125                                           ! 6598 endasm
37126                                           !BCC_ENDASM
37127                                           ! 6599 }
37128 A8E2           C3                         ret
37129                                           ! 6600 void
37130                                           ! 6601  tcpa_add_bootdevice(bootcd, bootdrv)
37131                                           ! 6602   Bit32u bootcd;
37132                                           export	_tcpa_add_bootdevice
37133                       0000A8E3            _tcpa_add_bootdevice:
37134                                           !BCC_EOS
37135                                           ! 6603   Bit32u bootdrv;
37136                                           !BCC_EOS
37137                                           ! 6604 {
37138                                           ! 6605 #asm
37139                                           !BCC_ASM
37140                       00000002            _tcpa_add_bootdevice.bootcd	set	2
37141                       00000006            _tcpa_add_bootdevice.bootdrv	set	6
37142                                            DoUpcall(7)
 +a   A8E3           BB                   0007   mov bx, #7
 +a   A8E6           EB           80             jmp Upcall
37143                                           ! 6607 endasm
37144                                           !BCC_ENDASM
37145                                           ! 6608 }
37146 A8E8           C3                         ret
37147                                           ! 6609  void
37148                                           ! 6610  tcpa_ipl(bootcd,seg,off,count)
37149                                           ! 6611     Bit32u bootcd;
37150                                           export	_tcpa_ipl
37151                       0000A8E9            _tcpa_ipl:
37152                                           !BCC_EOS
37153                                           ! 6612     Bit32u seg;
37154                                           !BCC_EOS
37155                                           ! 6613     Bit32u off;
37156                                           !BCC_EOS
37157                                           ! 6614     Bit32u count;
37158                                           !BCC_EOS
37159                                           ! 6615 {
37160                                           ! 6616 #asm
37161                                           !BCC_ASM
37162                       0000000E            _tcpa_ipl.count	set	$E
37163                       00000006            _tcpa_ipl.seg	set	6
37164                       00000002            _tcpa_ipl.bootcd	set	2
37165                       0000000A            _tcpa_ipl.off	set	$A
37166                                            DoUpcall(10)
 +a   A8E9           BB                   000A   mov bx, #10
 +a   A8EC           E9         FF79             jmp Upcall
37167                                           ! 6618 endasm
37168                                           !BCC_ENDASM
37169                                           ! 6619 }
37170 A8EF           C3                         ret
37171                                           ! 6620 Bit32u
37172                                           ! 6621 tcpa_initialize_tpm(physpres)
37173                                           ! 6622   Bit32u physpres;
37174                                           export	_tcpa_initialize_tpm
37175                       0000A8F0            _tcpa_initialize_tpm:
37176                                           !BCC_EOS
37177                                           ! 6623 {
37178                                           ! 6624 #asm
37179                                           !BCC_ASM
37180                       00000002            _tcpa_initialize_tpm.physpres	set	2
37181                                            DoUpcall(11)
 +a   A8F0           BB                   000B   mov bx, #11
 +a   A8F3           E9         FF72             jmp Upcall
37182                                           ! 6626 endasm
37183                                           !BCC_ENDASM
37184                                           ! 6627 }
37185 A8F6           C3                         ret
37186                                           ! 6628 void
37187                                           ! 6629 tcpa_measure_post(from, to)
37188                                           ! 6630    Bit32u from;
37189                                           export	_tcpa_measure_post
37190                       0000A8F7            _tcpa_measure_post:
37191                                           !BCC_EOS
37192                                           ! 6631    Bit32u to;
37193                                           !BCC_EOS
37194                                           ! 6632 {
37195                                           ! 6633 #asm
37196                                           !BCC_ASM
37197                       00000002            _tcpa_measure_post.from	set	2
37198                       00000006            _tcpa_measure_post.to	set	6
37199                                            DoUpcall(12)
 +a   A8F7           BB                   000C   mov bx, #12
 +a   A8FA           E9         FF6B             jmp Upcall
37200                                           ! 6635 endasm
37201                                           !BCC_ENDASM
37202                                           ! 6636 }
37203 A8FD           C3                         ret
37204                                           ! 6637 #asm
37205                                           !BCC_ASM
37206                       00000002            _tcpa_measure_post.from	set	2
37207                       00000006            _tcpa_measure_post.to	set	6
37208                                           MACRO POST_MEASURE
37209                                            push word #0x000f
37210                                            push #?2
37211                                            push word #0x000f
37212                                            push #?1
37213                                            call _tcpa_measure_post
37214                                            add sp, #8
37215                                           MEND
37216                                           ! 6646 endasm
37217                                           !BCC_ENDASM
37218                                           ! 6647 void
37219                                           ! 6648 tcpa_do_measure_POSTs()
37220                                           ! 6649 {
37221                                           export	_tcpa_do_measure_POSTs
37222                       0000A8FE            _tcpa_do_measure_POSTs:
37223                                           ! 6650 #asm
37224                                           !BCC_ASM
37225                                            POST_MEASURE(post, nmi)
 +a   A8FE           6A                     0F   push word #0x000f
 +a   A900           68                   E2C3   push # nmi
 +a   A903           6A                     0F   push word #0x000f
 +a   A905           68                   E05B   push #post
 +a   A908           E8         FFEC             call _tcpa_measure_post
 +a   A90B           83C4                   08   add sp, #8
37226                                            POST_MEASURE(floppy_drive_post, hard_drive_post)
 +a   A90E           6A                     0F   push word #0x000f
 +a   A910           68                   A07B   push # hard_drive_post
 +a   A913           6A                     0F   push word #0x000f
 +a   A915           68                   9FF3   push #floppy_drive_post
 +a   A918           E8         FFDC             call _tcpa_measure_post
 +a   A91B           83C4                   08   add sp, #8
37227                                            POST_MEASURE(hard_drive_post, ebda_post)
 +a   A91E           6A                     0F   push word #0x000f
 +a   A920           68                   A29C   push # ebda_post
 +a   A923           6A                     0F   push word #0x000f
 +a   A925           68                   A07B   push #hard_drive_post
 +a   A928           E8         FFCC             call _tcpa_measure_post
 +a   A92B           83C4                   08   add sp, #8
37228                                            POST_MEASURE(ebda_post, eoi_jmp_post)
 +a   A92E           6A                     0F   push word #0x000f
 +a   A930           68                   A2B1   push # eoi_jmp_post
 +a   A933           6A                     0F   push word #0x000f
 +a   A935           68                   A29C   push #ebda_post
 +a   A938           E8         FFBC             call _tcpa_measure_post
 +a   A93B           83C4                   08   add sp, #8
37229                                            POST_MEASURE(eoi_jmp_post, timer_tick_post)
 +a   A93E           6A                     0F   push word #0x000f
 +a   A940           68                   A2D4   push # timer_tick_post
 +a   A943           6A                     0F   push word #0x000f
 +a   A945           68                   A2B1   push #eoi_jmp_post
 +a   A948           E8         FFAC             call _tcpa_measure_post
 +a   A94B           83C4                   08   add sp, #8
37230                                            POST_MEASURE(timer_tick_post, int76_handler)
 +a   A94E           6A                     0F   push word #0x000f
 +a   A950           68                   A34B   push # int76_handler
 +a   A953           6A                     0F   push word #0x000f
 +a   A955           68                   A2D4   push #timer_tick_post
 +a   A958           E8         FF9C             call _tcpa_measure_post
 +a   A95B           83C4                   08   add sp, #8
37231 A95E           C3                          ret
37232                                           ! 6658 endasm
37233                                           !BCC_ENDASM
37234                                           ! 6659 }
37235 A95F           C3                         ret
37236                                           ! 6660 Bit32u
37237                                           ! 6661 TCGInterruptHandler(regs_ptr, es, ds, flags_ptr)
37238                                           ! 6662    Bit32u regs_ptr;
37239                                           export	_TCGInterruptHandler
37240                       0000A960            _TCGInterruptHandler:
37241                                           !BCC_EOS
37242                                           ! 6663    Bit16u es;
37243                                           !BCC_EOS
37244                                           ! 6664    Bit16u ds;
37245                                           !BCC_EOS
37246                                           ! 6665    Bit32u flags_ptr;
37247                                           !BCC_EOS
37248                                           ! 6666 {
37249                                           ! 6667 #asm
37250                                           !BCC_ASM
37251                       0000000A            _TCGInterruptHandler.flags_ptr	set	$A
37252                       00000002            _TCGInterruptHandler.regs_ptr	set	2
37253                       00000008            _TCGInterruptHandler.ds	set	8
37254                       00000006            _TCGInterruptHandler.es	set	6
37255                                            DoUpcall(0)
 +a   A960           BB                   0000   mov bx, #0
 +a   A963           E9         FF02             jmp Upcall
37256                                           ! 6669 endasm
37257                                           !BCC_ENDASM
37258                                           ! 6670 }
37259 A966           C3                         ret
37260                                           ! 6671   void
37261                                           ! 6672 int1a_function32(regs, ES, DS, FLAGS)
37262                                           ! 6673   pushad_regs_t regs;
37263                                           export	_int1a_function32
37264                       0000A967            _int1a_function32:
37265                                           !BCC_EOS
37266                                           ! 6674   Bit16u ES, DS, FLAGS;
37267                                           !BCC_EOS
37268                                           ! 6675 {
37269                                           ! 6676  Bit16u rc;
37270                                           !BCC_EOS
37271                                           ! 6677  ;
37272 A967           55                         push	bp
37273 A968           89E5                       mov	bp,sp
37274 A96A           4C                         dec	sp
37275 A96B           4C                         dec	sp
37276                                           !BCC_EOS
37277                                           ! 6678  switch (regs.u.r8.ah) {
37278 A96C           8A46         21            mov	al,$21[bp]
37279 A96F           E9         00BC            br 	.70A
37280                                           ! 6679  case 0xbb:
37281                                           ! 6680   if (regs.u.r8.al != 0 &&
37282                       0000A972            .70B:
37283                                           ! 6681       regs.u.r32.ebx != 0x41504354L) {
37284                                           ! Debug: ne int = const 0 to unsigned char regs = [S+4+$1E] (used reg = )
37285 A972           8A46         20            mov	al,$20[bp]
37286 A975           84C0                       test	al,al
37287 A977           74           25            je  	.70C
37288                       0000A979            .70E:
37289                                           ! Debug: ne long = const $41504354 to unsigned long regs = [S+4+$12] (used reg = )
37290                                           ! Debug: expression subtree swapping
37291 A979           B8                   4354  mov	ax,#$4354
37292 A97C           BB                   4150  mov	bx,#$4150
37293 A97F           53                         push	bx
37294 A980           50                         push	ax
37295 A981           8B46         14            mov	ax,$14[bp]
37296 A984           8B5E         16            mov	bx,$16[bp]
37297 A987           8D7E         FA            lea	di,-2+..FFD8[bp]
37298 A98A           E8         570E            call	lcmpul
37299 A98D           8D66         FE            lea	sp,2+..FFD8[bp]
37300 A990           74           0C            je  	.70C
37301                       0000A992            .70D:
37302                                           ! 6682       FLAGS |= 0x0001;
37303                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
37304 A992           8B46         28            mov	ax,$28[bp]
37305 A995           0C                     01  or	al,*1
37306 A997           8946         28            mov	$28[bp],ax
37307                                           !BCC_EOS
37308                                           ! 6683       return;
37309 A99A           89EC                       mov	sp,bp
37310 A99C           5D                         pop	bp
37311 A99D           C3                         ret
37312                                           !BCC_EOS
37313                                           ! 6684   }
37314                                           ! 6685   switch(regs.u.r8.al) {
37315                       0000A99E            .70C:
37316 A99E           8A46         20            mov	al,$20[bp]
37317 A9A1           EB           58            jmp .711
37318                                           ! 6686   case 0x00:
37319                                           ! 6687   case 0x01:
37320                       0000A9A3            .712:
37321                                           ! 6688   case 0x02:
37322                       0000A9A3            .713:
37323                                           ! 6689   case 0x03:
37324                       0000A9A3            .714:
37325                                           ! 6690   case 0x04:
37326                       0000A9A3            .715:
37327                                           ! 6691   case 0x05:
37328                       0000A9A3            .716:
37329                                           ! 6692   case 0x06:
37330                       0000A9A3            .717:
37331                                           ! 6693   case 0x07:
37332                       0000A9A3            .718:
37333                                           ! 6694    TCGInterruptHandler(((Bit32u)get_SS() << 4) + (Bit32u)&regs,
37334                       0000A9A3            .719:
37335                                           ! 6695                        ES, DS,
37336                                           ! 6696                        ((Bit32u)get_SS() << 4) + (Bit32u)&FLAGS);
37337                                           ! Debug: expression subtree swapping
37338                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
37339 A9A3           E8         5CB1            call	_get_SS
37340                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
37341 A9A6           31DB                       xor	bx,bx
37342                                           ! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
37343 A9A8           BF                   0004  mov	di,*4
37344 A9AB           E8         5769            call	lslul
37345 A9AE           53                         push	bx
37346 A9AF           50                         push	ax
37347                                           ! Debug: cast unsigned long = const 0 to * unsigned short FLAGS = S+8+$26 (used reg = )
37348 A9B0           89E8                       mov	ax,bp
37349 A9B2           05                   0028  add	ax,*$28
37350 A9B5           31DB                       xor	bx,bx
37351                                           ! Debug: add unsigned long (temp) = [S+8-8] to unsigned long = bx+0 (used reg = )
37352 A9B7           8D7E         FA            lea	di,-2+..FFD8[bp]
37353 A9BA           E8         56D6            call	laddul
37354 A9BD           83C4                   04  add	sp,*4
37355                                           ! Debug: list unsigned long = bx+0 (used reg = )
37356 A9C0           53                         push	bx
37357 A9C1           50                         push	ax
37358                                           ! Debug: list unsigned short DS = [S+8+$24] (used reg = )
37359 A9C2           FF76         26            push	$26[bp]
37360                                           ! Debug: list unsigned short ES = [S+$A+$22] (used reg = )
37361 A9C5           FF76         24            push	$24[bp]
37362                                           ! Debug: expression subtree swapping
37363                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
37364 A9C8           E8         5C8C            call	_get_SS
37365                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
37366 A9CB           31DB                       xor	bx,bx
37367                                           ! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
37368 A9CD           BF                   0004  mov	di,*4
37369 A9D0           E8         5744            call	lslul
37370 A9D3           53                         push	bx
37371 A9D4           50                         push	ax
37372                                           ! Debug: cast unsigned long = const 0 to * struct  regs = S+$10+2 (used reg = )
37373 A9D5           89E8                       mov	ax,bp
37374 A9D7           05                   0004  add	ax,*4
37375 A9DA           31DB                       xor	bx,bx
37376                                           ! Debug: add unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
37377 A9DC           8D7E         F2            lea	di,-$A+..FFD8[bp]
37378 A9DF           E8         56B1            call	laddul
37379 A9E2           83C4                   04  add	sp,*4
37380                                           ! Debug: list unsigned long = bx+0 (used reg = )
37381 A9E5           53                         push	bx
37382 A9E6           50                         push	ax
37383                                           ! Debug: func () unsigned long = TCGInterruptHandler+0 (used reg = )
37384 A9E7           E8         FF76            call	_TCGInterruptHandler
37385 A9EA           89D3                       mov	bx,dx
37386 A9EC           83C4                   0C  add	sp,*$C
37387                                           !BCC_EOS
37388                                           ! 6697    break;
37389 A9EF           EB           2F            jmp .70F
37390                                           !BCC_EOS
37391                                           ! 6698   default:
37392                                           ! 6699    FLAGS |= 0x0001;
37393                       0000A9F1            .71A:
37394                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
37395 A9F1           8B46         28            mov	ax,$28[bp]
37396 A9F4           0C                     01  or	al,*1
37397 A9F6           8946         28            mov	$28[bp],ax
37398                                           !BCC_EOS
37399                                           ! 6700   }
37400                                           ! 6701   break;
37401 A9F9           EB           25            jmp .70F
37402                       0000A9FB            .711:
37403 A9FB           2C                     00  sub	al,*0
37404 A9FD           72           F2            jb 	.71A
37405 A9FF           3C                     07  cmp	al,*7
37406 AA01           77           1B            ja  	.71B
37407 AA03           30E4                       xor	ah,ah
37408 AA05           D1E0                       shl	ax,*1
37409 AA07           89C3                       mov	bx,ax
37410 AA09           2E                         seg	cs
37411 AA0A           FFA7       AA0E            br	.71C[bx]
37412                       0000AA0E            .71C:
37413 AA0E                      A9A3            .word	.712
37414 AA10                      A9A3            .word	.713
37415 AA12                      A9A3            .word	.714
37416 AA14                      A9A3            .word	.715
37417 AA16                      A9A3            .word	.716
37418 AA18                      A9A3            .word	.717
37419 AA1A                      A9A3            .word	.718
37420 AA1C                      A9A3            .word	.719
37421                       0000AA1E            .71B:
37422 AA1E           EB           D1            jmp	.71A
37423                       0000AA20            .70F:
37424 AA20           EB           14            jmp .708
37425                                           !BCC_EOS
37426                                           ! 6702  default:
37427                                           ! 6703   FLAGS |= 0x0001;
37428                       0000AA22            .71D:
37429                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
37430 AA22           8B46         28            mov	ax,$28[bp]
37431 AA25           0C                     01  or	al,*1
37432 AA27           8946         28            mov	$28[bp],ax
37433                                           !BCC_EOS
37434                                           ! 6704   break;
37435 AA2A           EB           0A            jmp .708
37436                                           !BCC_EOS
37437                                           ! 6705  }
37438                                           ! 6706  ;
37439 AA2C           EB           08            jmp .708
37440                       0000AA2E            .70A:
37441 AA2E           2C                     BB  sub	al,#$BB
37442 AA30         0F84         FF3E            beq 	.70B
37443 AA34           EB           EC            jmp	.71D
37444                       0000AA36            .708:
37445                       FFFFFFFC            ..FFD8	=	-4
37446                                           !BCC_EOS
37447                                           ! 6707 }
37448 AA36           89EC                       mov	sp,bp
37449 AA38           5D                         pop	bp
37450 AA39           C3                         ret
37451                                           ! 6708 Bit32u get_s3_waking_vector()
37452                                           ! Register BX used in function int1a_function32
37453                                           ! 6709 {
37454                                           export	_get_s3_waking_vector
37455                       0000AA3A            _get_s3_waking_vector:
37456                                           ! 6710 #asm
37457                                           !BCC_ASM
37458                                            DoUpcall(13)
 +a   AA3A           BB                   000D   mov bx, #13
 +a   AA3D           E9         FE28             jmp Upcall
37459                                           ! 6712 endasm
37460                                           !BCC_ENDASM
37461                                           ! 6713 }
37462 AA40           C3                         ret
37463                                           ! 6714 #asm
37464                                           !BCC_ASM
37465                                           ;--------------------
37466                                           use32 386
37467 AA41                  00000010            .align 16
37468                       0000AA50            bios32_structure:
37469 AA50                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
37470 AA54                      AA60              dw bios32_entry_point, 0xf ;; 32 bit physical address
37471 AA58                        00              db 0 ;; revision level
37472                                             ;; length in paragraphs and checksum stored in a word to prevent errors
37473 AA59                      C301              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
37474 AA5B                        00              db 0,0,0,0,0 ;; reserved
37475 AA60                  00000010            .align 16
37476                       0000AA60            bios32_entry_point:
37477 AA60     66    9C                           pushf
37478 AA62           3D               49435024    cmp eax, #0x49435024
37479 AA67           75           29              jne unknown_service
37480 AA69           B8               80000000    mov eax, #0x80000000
37481 AA6E     66    BA                   0CF8    mov dx, #0x0cf8
37482 AA72           EF                           out dx, eax
37483 AA73     66    BA                   0CFC    mov dx, #0x0cfc
37484 AA77           ED                           in eax, dx
37485 AA78           3D               12378086    cmp eax, #0x12378086
37486 AA7D           75           13              jne unknown_service
37487 AA7F           BB               000F0000    mov ebx, #0x000f0000
37488 AA84           B9               00000000    mov ecx, #0
37489 AA89           BA               0000AAA0    mov edx, #pcibios_protected
37490 AA8E           30C0                         xor al, al
37491 AA90           EB           02              jmp bios32_end
37492                       0000AA92            unknown_service:
37493 AA92           B0                     80    mov al, #0x80
37494                       0000AA94            bios32_end:
37495 AA94     66    9D                           popf
37496 AA96           CB                           retf
37497 AA97                  00000010            .align 16
37498                       0000AAA0            pcibios_protected:
37499 AAA0     66    9C                           pushf
37500 AAA2           FA                           cli
37501 AAA3           56                           push esi
37502 AAA4           57                           push edi
37503 AAA5           3C                     01    cmp al, #0x01 ;; installation check
37504 AAA7           75           14              jne pci_pro_f02
37505 AAA9     66    BB                   0210    mov bx, #0x0210
37506 AAAD     66    B9                   0000    mov cx, #0
37507 AAB1           BA               20494350    mov edx, #0x20494350
37508 AAB6           B0                     01    mov al, #0x01
37509 AAB8           E9     000000E5              jmp pci_pro_ok
37510                       0000AABD            pci_pro_f02: ;; find pci device
37511 AABD           3C                     02    cmp al, #0x02
37512 AABF           75           39              jne pci_pro_f08
37513 AAC1           C1E1                   10    shl ecx, #16
37514 AAC4     66    89D1                         mov cx, dx
37515 AAC7     66    BB                   0000    mov bx, #0x0000
37516 AACB     66    BF                   0000    mov di, #0x00
37517                       0000AACF            pci_pro_devloop:
37518 AACF           E8     000000D7              call pci_pro_select_reg
37519 AAD4     66    BA                   0CFC    mov dx, #0x0cfc
37520 AAD8           ED                           in eax, dx
37521 AAD9           39C8                         cmp eax, ecx
37522 AADB           75           0D              jne pci_pro_nextdev
37523 AADD     66    83FE                   00    cmp si, #0
37524 AAE1   7505    E9     000000BA              je pci_pro_ok
37525 AAE8     66    4E                           dec si
37526                       0000AAEA            pci_pro_nextdev:
37527 AAEA     66    43                           inc bx
37528 AAEC     66    81FB                 0100    cmp bx, #0x0100
37529 AAF1           75           DC              jne pci_pro_devloop
37530 AAF3           B4                     86    mov ah, #0x86
37531 AAF5           E9     000000A1              jmp pci_pro_fail
37532                       0000AAFA            pci_pro_f08: ;; read configuration byte
37533 AAFA           3C                     08    cmp al, #0x08
37534 AAFC           75           1B              jne pci_pro_f09
37535 AAFE           E8     000000A8              call pci_pro_select_reg
37536 AB03           52                           push edx
37537 AB04     66    89FA                         mov dx, di
37538 AB07     66    83E2                   03    and dx, #0x03
37539 AB0B     66    81C2                 0CFC    add dx, #0x0cfc
37540 AB10           EC                           in al, dx
37541 AB11           5A                           pop edx
37542 AB12           88C1                         mov cl, al
37543 AB14           E9     00000089              jmp pci_pro_ok
37544                       0000AB19            pci_pro_f09: ;; read configuration word
37545 AB19           3C                     09    cmp al, #0x09
37546 AB1B           75           1A              jne pci_pro_f0a
37547 AB1D           E8     00000089              call pci_pro_select_reg
37548 AB22           52                           push edx
37549 AB23     66    89FA                         mov dx, di
37550 AB26     66    83E2                   02    and dx, #0x02
37551 AB2A     66    81C2                 0CFC    add dx, #0x0cfc
37552 AB2F     66    ED                           in ax, dx
37553 AB31           5A                           pop edx
37554 AB32     66    89C1                         mov cx, ax
37555 AB35           EB           6B              jmp pci_pro_ok
37556                       0000AB37            pci_pro_f0a: ;; read configuration dword
37557 AB37           3C                     0A    cmp al, #0x0a
37558 AB39           75           10              jne pci_pro_f0b
37559 AB3B           E8     0000006B              call pci_pro_select_reg
37560 AB40           52                           push edx
37561 AB41     66    BA                   0CFC    mov dx, #0x0cfc
37562 AB45           ED                           in eax, dx
37563 AB46           5A                           pop edx
37564 AB47           89C1                         mov ecx, eax
37565 AB49           EB           57              jmp pci_pro_ok
37566                       0000AB4B            pci_pro_f0b: ;; write configuration byte
37567 AB4B           3C                     0B    cmp al, #0x0b
37568 AB4D           75           18              jne pci_pro_f0c
37569 AB4F           E8     00000057              call pci_pro_select_reg
37570 AB54           52                           push edx
37571 AB55     66    89FA                         mov dx, di
37572 AB58     66    83E2                   03    and dx, #0x03
37573 AB5C     66    81C2                 0CFC    add dx, #0x0cfc
37574 AB61           88C8                         mov al, cl
37575 AB63           EE                           out dx, al
37576 AB64           5A                           pop edx
37577 AB65           EB           3B              jmp pci_pro_ok
37578                       0000AB67            pci_pro_f0c: ;; write configuration word
37579 AB67           3C                     0C    cmp al, #0x0c
37580 AB69           75           1A              jne pci_pro_f0d
37581 AB6B           E8     0000003B              call pci_pro_select_reg
37582 AB70           52                           push edx
37583 AB71     66    89FA                         mov dx, di
37584 AB74     66    83E2                   02    and dx, #0x02
37585 AB78     66    81C2                 0CFC    add dx, #0x0cfc
37586 AB7D     66    89C8                         mov ax, cx
37587 AB80     66    EF                           out dx, ax
37588 AB82           5A                           pop edx
37589 AB83           EB           1D              jmp pci_pro_ok
37590                       0000AB85            pci_pro_f0d: ;; write configuration dword
37591 AB85           3C                     0D    cmp al, #0x0d
37592 AB87           75           10              jne pci_pro_unknown
37593 AB89           E8     0000001D              call pci_pro_select_reg
37594 AB8E           52                           push edx
37595 AB8F     66    BA                   0CFC    mov dx, #0x0cfc
37596 AB93           89C8                         mov eax, ecx
37597 AB95           EF                           out dx, eax
37598 AB96           5A                           pop edx
37599 AB97           EB           09              jmp pci_pro_ok
37600                       0000AB99            pci_pro_unknown:
37601 AB99           B4                     81    mov ah, #0x81
37602                       0000AB9B            pci_pro_fail:
37603 AB9B           5F                           pop edi
37604 AB9C           5E                           pop esi
37605 AB9D           FB                           sti
37606 AB9E     66    9D                           popf
37607 ABA0           F9                           stc
37608 ABA1           CB                           retf
37609                       0000ABA2            pci_pro_ok:
37610 ABA2           30E4                         xor ah, ah
37611 ABA4           5F                           pop edi
37612 ABA5           5E                           pop esi
37613 ABA6           FB                           sti
37614 ABA7     66    9D                           popf
37615 ABA9           F8                           clc
37616 ABAA           CB                           retf
37617                       0000ABAB            pci_pro_select_reg:
37618 ABAB           52                           push edx
37619 ABAC           B8               00800000    mov eax, #0x800000
37620 ABB1     66    89D8                         mov ax, bx
37621 ABB4           C1E0                   08    shl eax, #8
37622 ABB7     66    81E7                 00FF    and di, #0xff
37623 ABBC     66    09F8                         or ax, di
37624 ABBF           24                     FC    and al, #0xfc
37625 ABC1     66    BA                   0CF8    mov dx, #0x0cf8
37626 ABC5           EF                           out dx, eax
37627 ABC6           5A                           pop edx
37628 ABC7           C3                           ret
37629                                           use16 386
37630                       0000ABC8            pcibios_real:
37631 ABC8     66    50                           push eax
37632 ABCA           52                           push dx
37633 ABCB     66    B8               80000000    mov eax, #0x80000000
37634 ABD1           BA                   0CF8    mov dx, #0x0cf8
37635 ABD4     66    EF                           out dx, eax
37636 ABD6           BA                   0CFC    mov dx, #0x0cfc
37637 ABD9     66    ED                           in eax, dx
37638 ABDB     66    3D               12378086    cmp eax, #0x12378086
37639 ABE1           74           07              je pci_present
37640 ABE3           5A                           pop dx
37641 ABE4     66    58                           pop eax
37642 ABE6           B4                     FF    mov ah, #0xff
37643 ABE8           F9                           stc
37644 ABE9           C3                           ret
37645                       0000ABEA            pci_present:
37646 ABEA           5A                           pop dx
37647 ABEB     66    58                           pop eax
37648 ABED           3C                     01    cmp al, #0x01 ;; installation check
37649 ABEF           75           1A              jne pci_real_f02
37650 ABF1           B8                   0001    mov ax, #0x0001
37651 ABF4           BB                   0210    mov bx, #0x0210
37652 ABF7           B9                   0000    mov cx, #0
37653 ABFA     66    BA               20494350    mov edx, #0x20494350
37654 AC00     66    BF               000F0000    mov edi, #0xf0000
37655 AC06           BF                   AAA0    mov di, #pcibios_protected
37656 AC09           F8                           clc
37657 AC0A           C3                           ret
37658                       0000AC0B            pci_real_f02: ;; find pci device
37659 AC0B     66    56                           push esi
37660 AC0D     66    57                           push edi
37661 AC0F           3C                     02    cmp al, #0x02
37662 AC11           75           34              jne pci_real_f08
37663 AC13     66    C1E1                   10    shl ecx, #16
37664 AC17           89D1                         mov cx, dx
37665 AC19           BB                   0000    mov bx, #0x0000
37666 AC1C           BF                   0000    mov di, #0x00
37667                       0000AC1F            pci_real_devloop:
37668 AC1F           E8         00B7              call pci_real_select_reg
37669 AC22           BA                   0CFC    mov dx, #0x0cfc
37670 AC25     66    ED                           in eax, dx
37671 AC27     66    39C8                         cmp eax, ecx
37672 AC2A           75           09              jne pci_real_nextdev
37673 AC2C           83FE                   00    cmp si, #0
37674 AC2F   7503    E9         009D              je pci_real_ok
37675 AC34           4E                           dec si
37676                       0000AC35            pci_real_nextdev:
37677 AC35           43                           inc bx
37678 AC36           81FB                 0100    cmp bx, #0x0100
37679 AC3A           75           E3              jne pci_real_devloop
37680 AC3C           89CA                         mov dx, cx
37681 AC3E     66    C1E9                   10    shr ecx, #16
37682 AC42           B4                     86    mov ah, #0x86
37683 AC44           E9         0084              jmp pci_real_fail
37684                       0000AC47            pci_real_f08: ;; read configuration byte
37685 AC47           3C                     08    cmp al, #0x08
37686 AC49           75           13              jne pci_real_f09
37687 AC4B           E8         008B              call pci_real_select_reg
37688 AC4E           52                           push dx
37689 AC4F           89FA                         mov dx, di
37690 AC51           83E2                   03    and dx, #0x03
37691 AC54           81C2                 0CFC    add dx, #0x0cfc
37692 AC58           EC                           in al, dx
37693 AC59           5A                           pop dx
37694 AC5A           88C1                         mov cl, al
37695 AC5C           EB           73              jmp pci_real_ok
37696                       0000AC5E            pci_real_f09: ;; read configuration word
37697 AC5E           3C                     09    cmp al, #0x09
37698 AC60           75           13              jne pci_real_f0a
37699 AC62           E8         0074              call pci_real_select_reg
37700 AC65           52                           push dx
37701 AC66           89FA                         mov dx, di
37702 AC68           83E2                   02    and dx, #0x02
37703 AC6B           81C2                 0CFC    add dx, #0x0cfc
37704 AC6F           ED                           in ax, dx
37705 AC70           5A                           pop dx
37706 AC71           89C1                         mov cx, ax
37707 AC73           EB           5C              jmp pci_real_ok
37708                       0000AC75            pci_real_f0a: ;; read configuration dword
37709 AC75           3C                     0A    cmp al, #0x0a
37710 AC77           75           0F              jne pci_real_f0b
37711 AC79           E8         005D              call pci_real_select_reg
37712 AC7C           52                           push dx
37713 AC7D           BA                   0CFC    mov dx, #0x0cfc
37714 AC80     66    ED                           in eax, dx
37715 AC82           5A                           pop dx
37716 AC83     66    89C1                         mov ecx, eax
37717 AC86           EB           49              jmp pci_real_ok
37718                       0000AC88            pci_real_f0b: ;; write configuration byte
37719 AC88           3C                     0B    cmp al, #0x0b
37720 AC8A           75           13              jne pci_real_f0c
37721 AC8C           E8         004A              call pci_real_select_reg
37722 AC8F           52                           push dx
37723 AC90           89FA                         mov dx, di
37724 AC92           83E2                   03    and dx, #0x03
37725 AC95           81C2                 0CFC    add dx, #0x0cfc
37726 AC99           88C8                         mov al, cl
37727 AC9B           EE                           out dx, al
37728 AC9C           5A                           pop dx
37729 AC9D           EB           32              jmp pci_real_ok
37730                       0000AC9F            pci_real_f0c: ;; write configuration word
37731 AC9F           3C                     0C    cmp al, #0x0c
37732 ACA1           75           13              jne pci_real_f0d
37733 ACA3           E8         0033              call pci_real_select_reg
37734 ACA6           52                           push dx
37735 ACA7           89FA                         mov dx, di
37736 ACA9           83E2                   02    and dx, #0x02
37737 ACAC           81C2                 0CFC    add dx, #0x0cfc
37738 ACB0           89C8                         mov ax, cx
37739 ACB2           EF                           out dx, ax
37740 ACB3           5A                           pop dx
37741 ACB4           EB           1B              jmp pci_real_ok
37742                       0000ACB6            pci_real_f0d: ;; write configuration dword
37743 ACB6           3C                     0D    cmp al, #0x0d
37744 ACB8           75           0F              jne pci_real_unknown
37745 ACBA           E8         001C              call pci_real_select_reg
37746 ACBD           52                           push dx
37747 ACBE           BA                   0CFC    mov dx, #0x0cfc
37748 ACC1     66    89C8                         mov eax, ecx
37749 ACC4     66    EF                           out dx, eax
37750 ACC6           5A                           pop dx
37751 ACC7           EB           08              jmp pci_real_ok
37752                       0000ACC9            pci_real_unknown:
37753 ACC9           B4                     81    mov ah, #0x81
37754                       0000ACCB            pci_real_fail:
37755 ACCB     66    5F                           pop edi
37756 ACCD     66    5E                           pop esi
37757 ACCF           F9                           stc
37758 ACD0           C3                           ret
37759                       0000ACD1            pci_real_ok:
37760 ACD1           30E4                         xor ah, ah
37761 ACD3     66    5F                           pop edi
37762 ACD5     66    5E                           pop esi
37763 ACD7           F8                           clc
37764 ACD8           C3                           ret
37765                       0000ACD9            pci_real_select_reg:
37766 ACD9           52                           push dx
37767 ACDA     66    B8               00800000    mov eax, #0x800000
37768 ACE0           89D8                         mov ax, bx
37769 ACE2     66    C1E0                   08    shl eax, #8
37770 ACE6           81E7                 00FF    and di, #0xff
37771 ACEA           09F8                         or ax, di
37772 ACEC           24                     FC    and al, #0xfc
37773 ACEE           BA                   0CF8    mov dx, #0x0cf8
37774 ACF1     66    EF                           out dx, eax
37775 ACF3           5A                           pop dx
37776 ACF4           C3                           ret
37777 ACF5                  00000010            .align 16
37778                       0000AD00            pci_routing_table_structure:
37779 AD00                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
37780 AD04                        00              db 0, 1 ;; version
37781 AD06                      0080              dw 32 + (6 * 16) ;; table size
37782 AD08                        00              db 0 ;; PCI interrupt router bus
37783 AD09                        08              db 0x08 ;; PCI interrupt router DevFunc
37784 AD0A                      0000              dw 0x0000 ;; PCI exclusive IRQs
37785 AD0C                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
37786 AD0E                      7000              dw 0x7000 ;; compatible PCI interrupt router device ID
37787 AD10                      0000              dw 0,0 ;; Miniport data
37788 AD14                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
37789 AD1F                        07              db 0x07 ;; checksum
37790                                             ;; first slot entry PCI-to-ISA (embedded)
37791 AD20                        00              db 0 ;; pci bus number
37792 AD21                        08              db 0x08 ;; pci device number (bit 7-3)
37793 AD22                        61              db 0x61 ;; link value INTA#: pointer into PCI2ISA config space
37794 AD23                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
37795 AD25                        62              db 0x62 ;; link value INTB#
37796 AD26                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
37797 AD28                        63              db 0x63 ;; link value INTC#
37798 AD29                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
37799 AD2B                        60              db 0x60 ;; link value INTD#
37800 AD2C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
37801 AD2E                        00              db 0 ;; physical slot (0 = embedded)
37802 AD2F                        00              db 0 ;; reserved
37803                                             ;; second slot entry: 1st PCI slot
37804 AD30                        00              db 0 ;; pci bus number
37805 AD31                        10              db 0x10 ;; pci device number (bit 7-3)
37806 AD32                        62              db 0x62 ;; link value INTA#
37807 AD33                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
37808 AD35                        63              db 0x63 ;; link value INTB#
37809 AD36                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
37810 AD38                        60              db 0x60 ;; link value INTC#
37811 AD39                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
37812 AD3B                        61              db 0x61 ;; link value INTD#
37813 AD3C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
37814 AD3E                        01              db 1 ;; physical slot (0 = embedded)
37815 AD3F                        00              db 0 ;; reserved
37816                                             ;; third slot entry: 2nd PCI slot
37817 AD40                        00              db 0 ;; pci bus number
37818 AD41                        18              db 0x18 ;; pci device number (bit 7-3)
37819 AD42                        63              db 0x63 ;; link value INTA#
37820 AD43                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
37821 AD45                        60              db 0x60 ;; link value INTB#
37822 AD46                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
37823 AD48                        61              db 0x61 ;; link value INTC#
37824 AD49                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
37825 AD4B                        62              db 0x62 ;; link value INTD#
37826 AD4C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
37827 AD4E                        02              db 2 ;; physical slot (0 = embedded)
37828 AD4F                        00              db 0 ;; reserved
37829                                             ;; 4th slot entry: 3rd PCI slot
37830 AD50                        00              db 0 ;; pci bus number
37831 AD51                        20              db 0x20 ;; pci device number (bit 7-3)
37832 AD52                        60              db 0x60 ;; link value INTA#
37833 AD53                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
37834 AD55                        61              db 0x61 ;; link value INTB#
37835 AD56                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
37836 AD58                        62              db 0x62 ;; link value INTC#
37837 AD59                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
37838 AD5B                        63              db 0x63 ;; link value INTD#
37839 AD5C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
37840 AD5E                        03              db 3 ;; physical slot (0 = embedded)
37841 AD5F                        00              db 0 ;; reserved
37842                                             ;; 5th slot entry: 4rd PCI slot
37843 AD60                        00              db 0 ;; pci bus number
37844 AD61                        28              db 0x28 ;; pci device number (bit 7-3)
37845 AD62                        61              db 0x61 ;; link value INTA#
37846 AD63                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
37847 AD65                        62              db 0x62 ;; link value INTB#
37848 AD66                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
37849 AD68                        63              db 0x63 ;; link value INTC#
37850 AD69                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
37851 AD6B                        60              db 0x60 ;; link value INTD#
37852 AD6C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
37853 AD6E                        04              db 4 ;; physical slot (0 = embedded)
37854 AD6F                        00              db 0 ;; reserved
37855                                             ;; 6th slot entry: 5rd PCI slot
37856 AD70                        00              db 0 ;; pci bus number
37857 AD71                        30              db 0x30 ;; pci device number (bit 7-3)
37858 AD72                        62              db 0x62 ;; link value INTA#
37859 AD73                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
37860 AD75                        63              db 0x63 ;; link value INTB#
37861 AD76                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
37862 AD78                        60              db 0x60 ;; link value INTC#
37863 AD79                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
37864 AD7B                        61              db 0x61 ;; link value INTD#
37865 AD7C                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
37866 AD7E                        05              db 5 ;; physical slot (0 = embedded)
37867 AD7F                        00              db 0 ;; reserved
37868                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
37869                       0000AD80            detect_parport:
37870 AD80           52                           push dx
37871 AD81           83C2                   02    add dx, #2
37872 AD84           EC                           in al, dx
37873 AD85           24                     DF    and al, #0xdf ; clear input mode
37874 AD87           EE                           out dx, al
37875 AD88           5A                           pop dx
37876 AD89           B0                     AA    mov al, #0xaa
37877 AD8B           EE                           out dx, al
37878 AD8C           EC                           in al, dx
37879 AD8D           3C                     AA    cmp al, #0xaa
37880 AD8F           75           0D              jne no_parport
37881 AD91           53                           push bx
37882 AD92           D1E3                         shl bx, #1
37883 AD94           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
37884 AD98           5B                           pop bx
37885 AD99           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
37886 AD9D           43                           inc bx
37887                       0000AD9E            no_parport:
37888 AD9E           C3                           ret
37889                                           ; serial port detection: base address in DX, index in BX, timeout in CL
37890                       0000AD9F            detect_serial:
37891 AD9F           52                           push dx
37892 ADA0           42                           inc dx
37893 ADA1           B0                     02    mov al, #0x02
37894 ADA3           EE                           out dx, al
37895 ADA4           EC                           in al, dx
37896 ADA5           3C                     02    cmp al, #0x02
37897 ADA7           75           19              jne no_serial
37898 ADA9           42                           inc dx
37899 ADAA           EC                           in al, dx
37900 ADAB           3C                     02    cmp al, #0x02
37901 ADAD           75           13              jne no_serial
37902 ADAF           4A                           dec dx
37903 ADB0           30C0                         xor al, al
37904 ADB2           EE                           out dx, al
37905 ADB3           5A                           pop dx
37906 ADB4           53                           push bx
37907 ADB5           D1E3                         shl bx, #1
37908 ADB7           8997       0400              mov [bx+0x400], dx ; Serial I/O address
37909 ADBB           5B                           pop bx
37910 ADBC           888F       047C              mov [bx+0x47c], cl ; Serial timeout
37911 ADC0           43                           inc bx
37912 ADC1           C3                           ret
37913                       0000ADC2            no_serial:
37914 ADC2           5A                           pop dx
37915 ADC3           C3                           ret
37916                       0000ADC4            rom_checksum:
37917 ADC4           50                           push ax
37918 ADC5           53                           push bx
37919 ADC6           51                           push cx
37920 ADC7           31C0                         xor ax, ax
37921 ADC9           31DB                         xor bx, bx
37922 ADCB           31C9                         xor cx, cx
37923 ADCD           8A2E       0002              mov ch, [2]
37924 ADD1           D1E1                         shl cx, #1
37925                       0000ADD3            checksum_loop:
37926 ADD3           0207                         add al, [bx]
37927 ADD5           43                           inc bx
37928 ADD6           E2           FB              loop checksum_loop
37929 ADD8           24                     FF    and al, #0xff
37930 ADDA           59                           pop cx
37931 ADDB           5B                           pop bx
37932 ADDC           58                           pop ax
37933 ADDD           C3                           ret
37934                                           ;; We need a copy of this string, but we are not actually a PnP BIOS,
37935                                           ;; so make sure it is *not* aligned, so OSes will not see it if they scan.
37936 ADDE                  00000010            .align 16
37937 ADE0                        00              db 0
37938                       0000ADE1            pnp_string:
37939 ADE1                        24              .ascii "$PnP"
37940                       0000ADE5            rom_scan:
37941                                             ;; Scan for existence of valid expansion ROMS.
37942                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
37943                                             ;; General ROM: from 0xC8000..0xDFFFF in 2k increments
37944                                             ;; System ROM: only 0xE0000
37945                                             ;;
37946                                             ;; Header:
37947                                             ;; Offset Value
37948                                             ;; 0 0x55
37949                                             ;; 1 0xAA
37950                                             ;; 2 ROM length in 512-byte blocks
37951                                             ;; 3 ROM initialization entry point (FAR CALL)
37952 ADE5           E8         FAEF              call _tcpa_start_option_rom_scan
37953 ADE8           B9                   C000    mov cx, #0xc000
37954                       0000ADEB            rom_scan_loop:
37955 ADEB           8ED9                         mov ds, cx
37956 ADED           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
37957 ADF0           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
37958 ADF6   7403    E9         008C              jne rom_scan_increment
37959 ADFB           E8         FFC6              call rom_checksum
37960 ADFE   7403    E9         0084              jnz rom_scan_increment
37961 AE03           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
37962                                             ;; We want our increment in 512-byte quantities, rounded to
37963                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
37964 AE06           A8                     03    test al, #0x03
37965 AE08           74           04              jz block_count_rounded
37966 AE0A           24                     FC    and al, #0xfc ;; needs rounding up
37967 AE0C           04                     04    add al, #0x04
37968                       0000AE0E            block_count_rounded:
37969 AE0E           50                           push ax
37970 AE0F           1E                           push ds
37971 AE10     66    51                           push ecx
37972 AE12           31C0                         xor ax, ax
37973 AE14           8ED8                         mov ds, ax
37974 AE16     66    81E1             0000FFFF    and ecx, #0xffff
37975 AE1D     66    51                           push ecx ;; segment where option rom is located at
37976 AE1F           E8         FABB              call _tcpa_option_rom
37977 AE22           83C4                   04    add sp, #4 ;; pop segment
37978 AE25     66    59                           pop ecx ;; original ecx
37979 AE27           1F                           pop ds
37980 AE28           58                           pop ax
37981 AE29           31DB                         xor bx, bx ;; Restore DS back to 0000:
37982 AE2B           8EDB                         mov ds, bx
37983 AE2D           50                           push ax ;; Save AX
37984 AE2E           57                           push di ;; Save DI
37985                                             ;; Push addr of ROM entry point
37986 AE2F           51                           push cx ;; Push seg
37987 AE30           6A                     03    push #0x0003 ;; Push offset
37988                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
37989                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
37990 AE32           B8                   F000    mov ax, #0xf000
37991 AE35           8EC0                         mov es, ax
37992 AE37           8D3E       ADE1              lea di, pnp_string
37993 AE3B           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
37994 AE3D                        FF              db 0xff ;; call_far ss:[bp+0]
37995 AE3E                        5E              db 0x5e
37996 AE3F                        00              db 0
37997 AE40           FA                           cli ;; In case expansion ROM BIOS turns IF on
37998 AE41           83C4                   02    add sp, #2 ;; Pop offset value
37999 AE44           59                           pop cx ;; Pop seg value (restore CX)
38000                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
38001                                             ;; to init all the ROMs and then go back and build an IPL table of
38002                                             ;; all the bootable devices, but we can get away with one pass.
38003 AE45           8ED9                         mov ds, cx ;; ROM base
38004 AE47           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
38005 AE4B           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
38006 AE4D           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
38007 AE50           75           33              jne no_bev
38008 AE52           8B47         02              mov ax, 2[bx]
38009 AE55           3D                   506E    cmp ax, #0x506e
38010 AE58           75           2B              jne no_bev
38011 AE5A           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
38012 AE5D           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
38013 AE60           74           23              je no_bev
38014                                             ;; Found a device that thinks it can boot the system. Record its BEV.
38015 AE62           BB                   9FF0    mov bx, #0x9ff0 ;; Go to the segment where the IPL table lives
38016 AE65           8EDB                         mov ds, bx
38017 AE67           8B1E       0080              mov bx, 0x0080 ;; Read the number of entries so far
38018 AE6B           83FB                   08    cmp bx, #8
38019 AE6E           74           15              je no_bev ;; Get out if the table is full
38020 AE70           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
38021 AE73           C707                 0080    mov 0[bx], #0x80 ;; This entry is a BEV device
38022 AE77           894F         06              mov 6[bx], cx ;; Build a far pointer from the segment...
38023 AE7A           8947         04              mov 4[bx], ax ;; and the offset
38024 AE7D           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
38025 AE80           43                           inc bx ;; We have one more entry now
38026 AE81           891E       0080              mov 0x0080, bx ;; Remember that.
38027                       0000AE85            no_bev:
38028 AE85           5F                           pop di ;; Restore DI
38029 AE86           58                           pop ax ;; Restore AX
38030                       0000AE87            rom_scan_increment:
38031 AE87           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
38032                                                           ;; because the segment selector is shifted left 4 bits.
38033 AE8A           01C1                         add cx, ax
38034 AE8C           81F9                 E000    cmp cx, #0xe000
38035 AE90   7703    E9         FF56              jbe rom_scan_loop
38036 AE95           31C0                         xor ax, ax ;; Restore DS back to 0000:
38037 AE97           8ED8                         mov ds, ax
38038 AE99           C3                           ret
38039                                           ; Copy the SMBIOS entry point from where hvmloader left it.
38040                                           ; The entry point must be somewhere in 0xf0000-0xfffff on a 16-byte boundary,
38041                                           ; but the tables themselves can be elsewhere.
38042                       0000AE9A            smbios_init:
38043 AE9A           50                           push ax
38044 AE9B           51                           push cx
38045 AE9C           06                           push es
38046 AE9D           1E                           push ds
38047 AE9E           57                           push di
38048 AE9F           56                           push si
38049 AEA0           B9                   001F    mov cx, #0x001f ; 0x1f bytes to copy
38050 AEA3           B8                   F000    mov ax, #0xf000
38051 AEA6           8EC0                         mov es, ax ; destination segment is 0xf0000
38052 AEA8           BF                   CF90    mov di, #smbios_entry_point ; destination offset
38053 AEAB           B8                   E900    mov ax, #(0x000E9000>>4)
38054 AEAE           8ED8                         mov ds, ax
38055 AEB0           BE                   0000    mov si, #(0x000E9000&15)
38056 AEB3           FC                           cld
38057 AEB4           F3                           rep
38058 AEB5           A4                             movsb
38059 AEB6           5E                           pop si
38060 AEB7           5F                           pop di
38061 AEB8           1F                           pop ds
38062 AEB9           07                           pop es
38063 AEBA           59                           pop cx
38064 AEBB           58                           pop ax
38065 AEBC           C3                           ret
38066                                           ; The section between the POST entry and the NMI entry is filling up
38067                                           ; and causes crashes if this code was directly there
38068                       0000AEBD            tcpa_post_part1:
38069 AEBD           E8         F9F9              call _tcpa_acpi_init
38070 AEC0     66    6A                     00    push dword #0
38071 AEC3           E8         FA2A              call _tcpa_initialize_tpm
38072 AEC6           83C4                   04    add sp, #4
38073 AEC9           E8         FA32              call _tcpa_do_measure_POSTs
38074 AECC           E8         FA02              call _tcpa_wake_event
38075 AECF           C3                           ret
38076                       0000AED0            tcpa_post_part2:
38077 AED0           E8         F9EC              call _tcpa_calling_int19h
38078 AED3           E8         F9F5              call _tcpa_add_event_separators
38079 AED6           E8         F9EC              call _tcpa_returned_int19h
38080 AED9           C3                           ret
38081                                           ;; for 'C' strings and other data, insert them here with
38082                                           ;; a the following hack:
38083                                           ;; DATA_SEG_DEFS_HERE
38084                                           ;--------
38085                                           ;- POST -
38086                                           ;--------
38087 E05B                                      .org 0xe05b ; POST Entry Point
38088                       0000E05B            post:
38089 E05B           31C0                         xor ax, ax
38090                                             ;; first reset the DMA controllers
38091 E05D           E6                     0D    out 0x0d,al
38092 E05F           E6                     DA    out 0xda,al
38093                                             ;; then initialize the DMA controllers
38094 E061           B0                     C0    mov al, #0xC0
38095 E063           E6                     D6    out 0xD6, al ; cascade mode of channel 4 enabled
38096 E065           B0                     00    mov al, #0x00
38097 E067           E6                     D4    out 0xD4, al ; unmask channel 4
38098                                             ;; Examine CMOS shutdown status.
38099 E069           B0                     0F    mov AL, #0x0f
38100 E06B           E6                     70    out 0x70, AL
38101 E06D           E4                     71    in AL, 0x71
38102                                             ;; backup status
38103 E06F           88C3                         mov bl, al
38104                                             ;; Reset CMOS shutdown status.
38105 E071           B0                     0F    mov AL, #0x0f
38106 E073           E6                     70    out 0x70, AL ; select CMOS register Fh
38107 E075           B0                     00    mov AL, #0x00
38108 E077           E6                     71    out 0x71, AL ; set shutdown action to normal
38109                                             ;; Examine CMOS shutdown status.
38110 E079           88D8                         mov al, bl
38111 E07B           BA                   9FC0    mov dx, #0x9FC0
38112 E07E           8EDA                         mov ds, dx
38113 E080           A2         0001              mov [1], AL
38114 E083           FA                           cli
38115 E084           B8                   FFFE    mov ax, #0xfffe
38116 E087           89C4                         mov sp, ax
38117 E089           B8                   0000    mov ax, #0x0000
38118 E08C           8ED8                         mov ds, ax
38119 E08E           8ED0                         mov ss, ax
38120                                             ;; zero out BIOS data area (40:00..40:ff)
38121 E090           8EC0                         mov es, ax
38122 E092           B9                   0080    mov cx, #0x0080 ;; 128 words
38123 E095           BF                   0400    mov di, #0x0400
38124 E098           FC                           cld
38125 E099           F3                           rep
38126 E09A           AB                             stosw
38127 E09B           E8         358D              call _log_bios_start
38128                                             ;; set all interrupts to default handler
38129 E09E           BB                   0000    mov bx, #0x0000 ;; offset index
38130 E0A1           B9                   0100    mov cx, #0x0100 ;; counter (256 interrupts)
38131 E0A4           B8                   FF53    mov ax, #dummy_iret_handler
38132 E0A7           BA                   F000    mov dx, #0xF000
38133                       0000E0AA            post_default_ints:
38134 E0AA           8907                         mov [bx], ax
38135 E0AC           43                           inc bx
38136 E0AD           43                           inc bx
38137 E0AE           8917                         mov [bx], dx
38138 E0B0           43                           inc bx
38139 E0B1           43                           inc bx
38140 E0B2           E2           F6              loop post_default_ints
38141                                             ;; set vector 0x79 to zero
38142                                             ;; this is used by 'gardian angel' protection system
38143                                             SET_INT_VECTOR(0x79, #0, #0)
 +a   E0B4           B8                   0000    mov ax,  #0
 +a   E0B7           A3         01E4              mov 0x79*4, ax
 +a   E0BA           B8                   0000    mov ax,  #0
 +a   E0BD           A3         01E6              mov 0x79*4+2, ax
38144                                             ;; base memory in K 40:13 (word)
38145 E0C0           B8                   027F    mov ax, #(640 - 1)
38146 E0C3           A3         0413              mov 0x0413, ax
38147                                             ;; Manufacturing Test 40:12
38148                                             ;; zerod out above
38149                                             ;; Warm Boot Flag 0040:0072
38150                                             ;; value of 1234h = skip memory checks
38151                                             ;; zerod out above
38152                                             ;; Printer Services vector
38153                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   E0C6           B8                   EFD2    mov ax,  #int17_handler
 +a   E0C9           A3         005C              mov 0x17*4, ax
 +a   E0CC           B8                   F000    mov ax,  #0xF000
 +a   E0CF           A3         005E              mov 0x17*4+2, ax
38154                                             ;; Bootstrap failure vector
38155                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   E0D2           B8                   9FC7    mov ax,  #int18_handler
 +a   E0D5           A3         0060              mov 0x18*4, ax
 +a   E0D8           B8                   F000    mov ax,  #0xF000
 +a   E0DB           A3         0062              mov 0x18*4+2, ax
38156                                             ;; Bootstrap Loader vector
38157                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   E0DE           B8                   E6F2    mov ax,  #int19_handler
 +a   E0E1           A3         0064              mov 0x19*4, ax
 +a   E0E4           B8                   F000    mov ax,  #0xF000
 +a   E0E7           A3         0066              mov 0x19*4+2, ax
38158                                             ;; User Timer Tick vector
38159                                             SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
 +a   E0EA           B8                   9FF2    mov ax,  #int1c_handler
 +a   E0ED           A3         0070              mov 0x1c*4, ax
 +a   E0F0           B8                   F000    mov ax,  #0xF000
 +a   E0F3           A3         0072              mov 0x1c*4+2, ax
38160                                             ;; Memory Size Check vector
38161                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   E0F6           B8                   F841    mov ax,  #int12_handler
 +a   E0F9           A3         0048              mov 0x12*4, ax
 +a   E0FC           B8                   F000    mov ax,  #0xF000
 +a   E0FF           A3         004A              mov 0x12*4+2, ax
38162                                             ;; Equipment Configuration Check vector
38163                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   E102           B8                   F84D    mov ax,  #int11_handler
 +a   E105           A3         0044              mov 0x11*4, ax
 +a   E108           B8                   F000    mov ax,  #0xF000
 +a   E10B           A3         0046              mov 0x11*4+2, ax
38164                                             ;; System Services
38165                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   E10E           B8                   F859    mov ax,  #int15_handler
 +a   E111           A3         0054              mov 0x15*4, ax
 +a   E114           B8                   F000    mov ax,  #0xF000
 +a   E117           A3         0056              mov 0x15*4+2, ax
38166                                             ;; EBDA setup
38167 E11A           E8         C17F              call ebda_post
38168                                             ;; PIT setup
38169                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E11D           B8                   FEA5    mov ax,  #int08_handler
 +a   E120           A3         0020              mov 0x08*4, ax
 +a   E123           B8                   F000    mov ax,  #0xF000
 +a   E126           A3         0022              mov 0x08*4+2, ax
38170                                             ;; int 1C already points at dummy_iret_handler (above)
38171 E129           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
38172 E12B           E6                     43    out 0x43, al
38173 E12D           B0                     0B    mov al, #0x0b ; #0xe90b = 20 Hz (temporary, until we fix xen/vmx support)
38174 E12F           E6                     40    out 0x40, al ; lsb
38175 E131           B0                     E9    mov al, #0xe9
38176 E133           E6                     40    out 0x40, al ; msb
38177                                             ;; Keyboard
38178                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E135           B8                   E987    mov ax,  #int09_handler
 +a   E138           A3         0024              mov 0x09*4, ax
 +a   E13B           B8                   F000    mov ax,  #0xF000
 +a   E13E           A3         0026              mov 0x09*4+2, ax
38179                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E141           B8                   E82E    mov ax,  #int16_handler
 +a   E144           A3         0058              mov 0x16*4, ax
 +a   E147           B8                   F000    mov ax,  #0xF000
 +a   E14A           A3         005A              mov 0x16*4+2, ax
38180 E14D           31C0                         xor ax, ax
38181 E14F           8ED8                         mov ds, ax
38182 E151           A2         0417              mov 0x0417, al
38183 E154           A2         0418              mov 0x0418, al
38184 E157           A2         0419              mov 0x0419, al
38185 E15A           A2         0471              mov 0x0471, al
38186 E15D           A2         0497              mov 0x0497, al
38187 E160           B0                     10    mov al, #0x10
38188 E162           A2         0496              mov 0x0496, al
38189 E165           BB                   001E    mov bx, #0x001E
38190 E168           891E       041A              mov 0x041A, bx
38191 E16C           891E       041C              mov 0x041C, bx
38192 E170           BB                   001E    mov bx, #0x001E
38193 E173           891E       0480              mov 0x0480, bx
38194 E177           BB                   003E    mov bx, #0x003E
38195 E17A           891E       0482              mov 0x0482, bx
38196 E17E           E8         290D              call _keyboard_init
38197                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
38198 E181           A1         0410              mov ax, 0x0410
38199 E184           B0                     14    mov al, #0x14
38200 E186           E6                     70    out 0x70, al
38201 E188           E4                     71    in al, 0x71
38202 E18A           A3         0410              mov 0x0410, ax
38203 E18D           E8         CD2D              call tcpa_post_part1
38204                                             ;; Parallel setup
38205                                             SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
 +a   E190           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E193           A3         003C              mov 0x0F*4, ax
 +a   E196           B8                   F000    mov ax,  #0xF000
 +a   E199           A3         003E              mov 0x0F*4+2, ax
38206 E19C           31C0                         xor ax, ax
38207 E19E           8ED8                         mov ds, ax
38208 E1A0           31DB                         xor bx, bx
38209 E1A2           B1                     14    mov cl, #0x14 ; timeout value
38210 E1A4           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
38211 E1A7           E8         CBD6              call detect_parport
38212 E1AA           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
38213 E1AD           E8         CBD0              call detect_parport
38214 E1B0           C1E3                   0E    shl bx, #0x0e
38215 E1B3           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
38216 E1B6           25                   3FFF    and ax, #0x3fff
38217 E1B9           09D8                         or ax, bx ; set number of parallel ports
38218 E1BB           A3         0410              mov 0x410, ax
38219                                             ;; Serial setup
38220                                             SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
 +a   E1BE           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1C1           A3         0030              mov 0x0C*4, ax
 +a   E1C4           B8                   F000    mov ax,  #0xF000
 +a   E1C7           A3         0032              mov 0x0C*4+2, ax
38221                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E1CA           B8                   E739    mov ax,  #int14_handler
 +a   E1CD           A3         0050              mov 0x14*4, ax
 +a   E1D0           B8                   F000    mov ax,  #0xF000
 +a   E1D3           A3         0052              mov 0x14*4+2, ax
38222 E1D6           31DB                         xor bx, bx
38223 E1D8           B1                     0A    mov cl, #0x0a ; timeout value
38224 E1DA           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
38225 E1DD           E8         CBBF              call detect_serial
38226 E1E0           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
38227 E1E3           E8         CBB9              call detect_serial
38228 E1E6           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
38229 E1E9           E8         CBB3              call detect_serial
38230 E1EC           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
38231 E1EF           E8         CBAD              call detect_serial
38232 E1F2           C1E3                   09    shl bx, #0x09
38233 E1F5           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
38234 E1F8           25                   F1FF    and ax, #0xf1ff
38235 E1FB           09D8                         or ax, bx ; set number of serial port
38236 E1FD           A3         0410              mov 0x410, ax
38237                                             ;; CMOS RTC
38238                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E200           B8                   FE6E    mov ax,  #int1a_handler
 +a   E203           A3         0068              mov 0x1A*4, ax
 +a   E206           B8                   F000    mov ax,  #0xF000
 +a   E209           A3         006A              mov 0x1A*4+2, ax
38239                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E20C           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E20F           A3         0128              mov 0x4A*4, ax
 +a   E212           B8                   F000    mov ax,  #0xF000
 +a   E215           A3         012A              mov 0x4A*4+2, ax
38240                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E218           B8                   FEA6    mov ax,  #int70_handler
 +a   E21B           A3         01C0              mov 0x70*4, ax
 +a   E21E           B8                   F000    mov ax,  #0xF000
 +a   E221           A3         01C2              mov 0x70*4+2, ax
38241                                             ;; BIOS DATA AREA 0x4CE ???
38242 E224           E8         C0AD              call timer_tick_post
38243                                             ;; PS/2 mouse setup
38244                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E227           B8                   9F09    mov ax,  #int74_handler
 +a   E22A           A3         01D0              mov 0x74*4, ax
 +a   E22D           B8                   F000    mov ax,  #0xF000
 +a   E230           A3         01D2              mov 0x74*4+2, ax
38245                                             ;; IRQ13 (FPU exception) setup
38246                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E233           B8                   E2C7    mov ax,  #int75_handler
 +a   E236           A3         01D4              mov 0x75*4, ax
 +a   E239           B8                   F000    mov ax,  #0xF000
 +a   E23C           A3         01D6              mov 0x75*4+2, ax
38247                                             ;; Video setup
38248                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E23F           B8                   F065    mov ax,  #int10_handler
 +a   E242           A3         0040              mov 0x10*4, ax
 +a   E245           B8                   F000    mov ax,  #0xF000
 +a   E248           A3         0042              mov 0x10*4+2, ax
38249                                             ;; PIC
38250 E24B           B0                     11    mov al, #0x11 ; send initialisation commands
38251 E24D           E6                     20    out 0x20, al
38252 E24F           E6                     A0    out 0xa0, al
38253 E251           B0                     08    mov al, #0x08
38254 E253           E6                     21    out 0x21, al
38255 E255           B0                     70    mov al, #0x70
38256 E257           E6                     A1    out 0xa1, al
38257 E259           B0                     04    mov al, #0x04
38258 E25B           E6                     21    out 0x21, al
38259 E25D           B0                     02    mov al, #0x02
38260 E25F           E6                     A1    out 0xa1, al
38261 E261           B0                     01    mov al, #0x01
38262 E263           E6                     21    out 0x21, al
38263 E265           E6                     A1    out 0xa1, al
38264 E267           B0                     B8    mov al, #0xb8
38265 E269           E6                     21    out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
38266 E26B           B0                     8F    mov al, #0x8f
38267 E26D           E6                     A1    out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
38268 E26F           E8         249E              call _enable_rom_write_access
38269 E272           E8         2D38              call _clobber_entry_point
38270 E275           E8         23E2              call _copy_e820_table
38271 E278           E8         CC1F              call smbios_init
38272 E27B           E8         249F              call _disable_rom_write_access
38273 E27E           E8         2DA3              call _init_boot_vectors
38274 E281           E8         CB61              call rom_scan
38275 E284           E8         2D54              call _print_bios_banner
38276                                             ;;
38277                                             ;; Floppy setup
38278                                             ;;
38279 E287           E8         BD69              call floppy_drive_post
38280                                             ;;
38281                                             ;; Hard Drive setup
38282                                             ;;
38283 E28A           E8         BDEE              call hard_drive_post
38284                                             ;;
38285                                             ;; ATA/ATAPI driver setup
38286                                             ;;
38287 E28D           E8         3489              call _ata_init
38288 E290           E8         3740              call _ata_detect
38289                                             ;;
38290                                             ;;
38291                                             ;; eltorito floppy/harddisk emulation from cd
38292                                             ;;
38293 E293           E8         5401              call _cdemu_init
38294                                             ;;
38295 E296           E8         341E              call _s3_resume
38296 E299           E8         32C5              call _interactive_bootkey
38297 E29C           E8         CC31              call tcpa_post_part2
38298                                             ;; Start the boot sequence. See the comments in int19_relocated
38299                                             ;; for why we use INT 18h instead of INT 19h here.
38300 E29F           CD                     18    int #0x18
38301 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
38302                       0000E2C3            nmi:
38303                                             ;; FIXME the NMI handler should not panic
38304                                             ;; but iret when called from int75 (fpu exception)
38305 E2C3           E8         3341              call _nmi_handler_msg
38306 E2C6           CF                           iret
38307                       0000E2C7            int75_handler:
38308 E2C7           E6                     F0    out 0xf0, al
38309 E2C9           E8         BFF0              call eoi_both_pics
38310 E2CC           CD                     02    int 2
38311 E2CE           CF                           iret
38312                                           ;-------------------------------------------
38313                                           ;- INT 13h Fixed Disk Services Entry Point -
38314                                           ;-------------------------------------------
38315 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
38316                       0000E3FE            int13_handler:
38317 E3FE           E9         BB45              jmp int13_relocated
38318 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
38319                                           ;----------
38320                                           ;- INT19h -
38321                                           ;----------
38322 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
38323                       0000E6F2            int19_handler:
38324 E6F2           E9         B8F1              jmp int19_relocated
38325                                           ;-------------------------------------------
38326                                           ;- System BIOS Configuration Data Table
38327                                           ;-------------------------------------------
38328 E6F5                                      .org 0xe6f5
38329 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
38330 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
38331 E6F7                        FC            db 0xFC
38332 E6F8                        00            db 0x00
38333 E6F9                        01            db 1
38334                                           ; Feature byte 1
38335                                           ; b7: 1=DMA channel 3 used by hard disk
38336                                           ; b6: 1=2 interrupt controllers present
38337                                           ; b5: 1=RTC present
38338                                           ; b4: 1=BIOS calls int 15h/4Fh every key
38339                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
38340                                           ; b2: 1=extended BIOS data area used
38341                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
38342                                           ; b0: 1=Dual bus (MicroChannel + ISA)
38343 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
38344                                           ; Feature byte 2
38345                                           ; b7: 1=32-bit DMA supported
38346                                           ; b6: 1=int16h, function 9 supported
38347                                           ; b5: 1=int15h/C6h (get POS data) supported
38348                                           ; b4: 1=int15h/C7h (get mem map info) supported
38349                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
38350                                           ; b2: 1=non-8042 kb controller
38351                                           ; b1: 1=data streaming supported
38352                                           ; b0: reserved
38353 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
38354                                           ; Feature byte 3
38355                                           ; b7: not used
38356                                           ; b6: reserved
38357                                           ; b5: reserved
38358                                           ; b4: POST supports ROM-to-RAM enable/disable
38359                                           ; b3: SCSI on system board
38360                                           ; b2: info panel installed
38361                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
38362                                           ; b0: SCSI supported in IML
38363 E6FC                        00            db 0x00
38364                                           ; Feature byte 4
38365                                           ; b7: IBM private
38366                                           ; b6: EEPROM present
38367                                           ; b5-3: ABIOS presence (011 = not supported)
38368                                           ; b2: private
38369                                           ; b1: memory split above 16Mb supported
38370                                           ; b0: POSTEXT directly supported by POST
38371 E6FD                        00            db 0x00
38372                                           ; Feature byte 5 (IBM)
38373                                           ; b1: enhanced mouse
38374                                           ; b0: flash EPROM
38375 E6FE                        00            db 0x00
38376 E729                                      .org 0xe729 ; Baud Rate Generator Table
38377                                           ;----------
38378                                           ;- INT14h -
38379                                           ;----------
38380 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
38381                       0000E739            int14_handler:
38382 E739           1E                           push ds
38383 E73A           60                           pusha
38384 E73B           B8                   0000    mov ax, #0x0000
38385 E73E           8ED8                         mov ds, ax
38386 E740           E8         5791              call _int14_function
38387 E743           61                           popa
38388 E744           1F                           pop ds
38389 E745           CF                           iret
38390                                           ;----------------------------------------
38391                                           ;- INT 16h Keyboard Service Entry Point -
38392                                           ;----------------------------------------
38393 E82E                                      .org 0xe82e
38394                       0000E82E            int16_handler:
38395 E82E           FB                           sti
38396 E82F           1E                           push ds
38397 E830           9C                           pushf
38398 E831           60                           pusha
38399 E832           80FC                   00    cmp ah, #0x00
38400 E835           74           24              je int16_F00
38401 E837           80FC                   10    cmp ah, #0x10
38402 E83A           74           1F              je int16_F00
38403 E83C           BB                   F000    mov bx, #0xf000
38404 E83F           8EDB                         mov ds, bx
38405 E841           E8         678F              call _int16_function
38406 E844           61                           popa
38407 E845           9D                           popf
38408 E846           1F                           pop ds
38409 E847           74           09              jz int16_zero_set
38410                       0000E849            int16_zero_clear:
38411 E849           55                           push bp
38412 E84A           89E5                         mov bp, sp
38413 E84C           8066         06        BF    and BYTE [bp + 0x06], #0xbf
38414 E850           5D                           pop bp
38415 E851           CF                           iret
38416                       0000E852            int16_zero_set:
38417 E852           55                           push bp
38418 E853           89E5                         mov bp, sp
38419 E855           804E         06        40    or BYTE [bp + 0x06], #0x40
38420 E859           5D                           pop bp
38421 E85A           CF                           iret
38422                       0000E85B            int16_F00:
38423 E85B           BB                   0040    mov bx, #0x0040
38424 E85E           8EDB                         mov ds, bx
38425                       0000E860            int16_wait_for_key:
38426 E860           FA                           cli
38427 E861           8B1E       001A              mov bx, 0x001a
38428 E865           3B1E       001C              cmp bx, 0x001c
38429 E869           75           04              jne int16_key_found
38430 E86B           FB                           sti
38431 E86C           90                           nop
38432 E86D           EB           F1              jmp int16_wait_for_key
38433                       0000E86F            int16_key_found:
38434 E86F           BB                   F000    mov bx, #0xf000
38435 E872           8EDB                         mov ds, bx
38436 E874           E8         675C              call _int16_function
38437 E877           61                           popa
38438 E878           9D                           popf
38439 E879           1F                           pop ds
38440 E87A           CF                           iret
38441                                           ;-------------------------------------------------
38442                                           ;- INT09h : Keyboard Hardware Service Entry Point -
38443                                           ;-------------------------------------------------
38444 E987                                      .org 0xe987
38445                       0000E987            int09_handler:
38446 E987           FA                           cli
38447 E988           50                           push ax
38448 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
38449 E98B           E6                     64    out #0x64, al
38450 E98D           B0                     0B    mov al, #0x0B
38451 E98F           E6                     20    out #0x20, al
38452 E991           E4                     20    in al, #0x20
38453 E993           24                     02    and al, #0x02
38454 E995           74           2E              jz int09_finish
38455 E997           E4                     60    in al, #0x60 ;;read key from keyboard controller
38456                                             ;; check for extended key
38457 E999           3C                     E0    cmp al, #0xe0
38458 E99B           75           11              jne int09_call_int15_4f
38459 E99D           1E                           push ds
38460 E99E           31C0                         xor ax, ax
38461 E9A0           8ED8                         mov ds, ax
38462 E9A2           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x01
38463 E9A5           0C                     01    or al, #0x01
38464 E9A7           A2         0496              mov BYTE [0x496], al
38465 E9AA           1F                           pop ds
38466 E9AB           E4                     60    in al, #0x60 ;;read another key from keyboard controller
38467 E9AD           FB                           sti
38468                       0000E9AE            int09_call_int15_4f:
38469 E9AE           1E                           push ds
38470 E9AF           60                           pusha
38471 E9B0           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
38472 E9B2           F9                           stc
38473 E9B3           CD                     15    int #0x15
38474 E9B5           73           08              jnc int09_done
38475 E9B7           BB                   F000    mov bx, #0xf000
38476 E9BA           8EDB                         mov ds, bx
38477 E9BC           E8         6C88              call _int09_function
38478                       0000E9BF            int09_done:
38479 E9BF           61                           popa
38480 E9C0           1F                           pop ds
38481 E9C1           FA                           cli
38482 E9C2           E8         B8FB              call eoi_master_pic
38483                       0000E9C5            int09_finish:
38484 E9C5           B0                     AE    mov al, #0xAE ;;enable keyboard
38485 E9C7           E6                     64    out #0x64, al
38486 E9C9           58                           pop ax
38487 E9CA           CF                           iret
38488                                           ;----------------------------------------
38489                                           ;- INT 13h Diskette Service Entry Point -
38490                                           ;----------------------------------------
38491 EC59                                      .org 0xec59
38492                       0000EC59            int13_diskette:
38493 EC59           E9         B339              jmp int13_noeltorito
38494                                           ;---------------------------------------------
38495                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
38496                                           ;---------------------------------------------
38497 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
38498                       0000EF57            int0e_handler:
38499 EF57           50                           push ax
38500 EF58           52                           push dx
38501 EF59           BA                   03F4    mov dx, #0x03f4
38502 EF5C           EC                           in al, dx
38503 EF5D           24                     C0    and al, #0xc0
38504 EF5F           3C                     C0    cmp al, #0xc0
38505 EF61           74           1E              je int0e_normal
38506 EF63           BA                   03F5    mov dx, #0x03f5
38507 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
38508 EF68           EE                           out dx, al
38509                       0000EF69            int0e_loop1:
38510 EF69           BA                   03F4    mov dx, #0x03f4
38511 EF6C           EC                           in al, dx
38512 EF6D           24                     C0    and al, #0xc0
38513 EF6F           3C                     C0    cmp al, #0xc0
38514 EF71           75           F6              jne int0e_loop1
38515                       0000EF73            int0e_loop2:
38516 EF73           BA                   03F5    mov dx, #0x03f5
38517 EF76           EC                           in al, dx
38518 EF77           BA                   03F4    mov dx, #0x03f4
38519 EF7A           EC                           in al, dx
38520 EF7B           24                     C0    and al, #0xc0
38521 EF7D           3C                     C0    cmp al, #0xc0
38522 EF7F           74           F2              je int0e_loop2
38523                       0000EF81            int0e_normal:
38524 EF81           1E                           push ds
38525 EF82           B8                   0000    mov ax, #0x0000 ;; segment 0000
38526 EF85           8ED8                         mov ds, ax
38527 EF87           E8         B336              call eoi_master_pic
38528 EF8A           A0         043E              mov al, 0x043e
38529 EF8D           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
38530 EF8F           A2         043E              mov 0x043e, al
38531 EF92           1F                           pop ds
38532 EF93           5A                           pop dx
38533 EF94           58                           pop ax
38534 EF95           CF                           iret
38535 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
38536                       0000EFC7            diskette_param_table:
38537                                           ;; Since no provisions are made for multiple drive types, most
38538                                           ;; values in this table are ignored. I set parameters for 1.44M
38539                                           ;; floppy here
38540 EFC7                        AF            db 0xAF
38541 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
38542 EFC9                        25            db 0x25
38543 EFCA                        02            db 0x02
38544 EFCB                        12            db 18
38545 EFCC                        1B            db 0x1B
38546 EFCD                        FF            db 0xFF
38547 EFCE                        6C            db 0x6C
38548 EFCF                        F6            db 0xF6
38549 EFD0                        0F            db 0x0F
38550 EFD1                        08            db 0x08
38551                                           ;----------------------------------------
38552                                           ;- INT17h : Printer Service Entry Point -
38553                                           ;----------------------------------------
38554 EFD2                                      .org 0xefd2
38555                       0000EFD2            int17_handler:
38556 EFD2           1E                           push ds
38557 EFD3           60                           pusha
38558 EFD4           B8                   0000    mov ax, #0x0000
38559 EFD7           8ED8                         mov ds, ax
38560 EFD9           E8         A713              call _int17_function
38561 EFDC           61                           popa
38562 EFDD           1F                           pop ds
38563 EFDE           CF                           iret
38564                       0000EFDF            diskette_param_table2:
38565                                           ;; New diskette parameter table adding 3 parameters from IBM
38566                                           ;; Since no provisions are made for multiple drive types, most
38567                                           ;; values in this table are ignored. I set parameters for 1.44M
38568                                           ;; floppy here
38569 EFDF                        AF            db 0xAF
38570 EFE0                        02            db 0x02 ;; head load time 0000001, DMA used
38571 EFE1                        25            db 0x25
38572 EFE2                        02            db 0x02
38573 EFE3                        12            db 18
38574 EFE4                        1B            db 0x1B
38575 EFE5                        FF            db 0xFF
38576 EFE6                        6C            db 0x6C
38577 EFE7                        F6            db 0xF6
38578 EFE8                        0F            db 0x0F
38579 EFE9                        08            db 0x08
38580 EFEA                        4F            db 79 ;; maximum track
38581 EFEB                        00            db 0 ;; data transfer rate
38582 EFEC                        04            db 4 ;; drive type in cmos
38583 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
38584                                             HALT(10480)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   28F0    mov ax,#10480
 +a   F04B           EF                           out dx,ax
38585 F04C           CF                           iret
38586                                           ;----------
38587                                           ;- INT10h -
38588                                           ;----------
38589 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
38590                       0000F065            int10_handler:
38591                                             ;; dont do anything, since the VGA BIOS handles int10h requests
38592 F065           CF                           iret
38593 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
38594                                           ;----------
38595                                           ;- INT12h -
38596                                           ;----------
38597 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
38598                                           ; ??? different for Pentium (machine check)?
38599                       0000F841            int12_handler:
38600 F841           1E                           push ds
38601 F842           B8                   0040    mov ax, #0x0040
38602 F845           8ED8                         mov ds, ax
38603 F847           A1         0013              mov ax, 0x0013
38604 F84A           1F                           pop ds
38605 F84B           CF                           iret
38606                                           ;----------
38607                                           ;- INT11h -
38608                                           ;----------
38609 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
38610                       0000F84D            int11_handler:
38611 F84D           1E                           push ds
38612 F84E           B8                   0040    mov ax, #0x0040
38613 F851           8ED8                         mov ds, ax
38614 F853           A1         0010              mov ax, 0x0010
38615 F856           1F                           pop ds
38616 F857           CF                           iret
38617                                           ;----------
38618                                           ;- INT15h -
38619                                           ;----------
38620 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
38621                       0000F859            int15_handler:
38622 F859           9C                           pushf
38623 F85A           80FC                   53    cmp ah, #0x53
38624 F85D           74           1C              je apm_call
38625 F85F           1E                           push ds
38626 F860           06                           push es
38627 F861           80FC                   86    cmp ah, #0x86
38628 F864           74           1D              je int15_handler32
38629 F866           80FC                   E8    cmp ah, #0xE8
38630 F869           74           18              je int15_handler32
38631 F86B           60                           pusha
38632 F86C           80FC                   C2    cmp ah, #0xC2
38633 F86F           74           0D              je int15_handler_mouse
38634 F871           E8         48D0              call _int15_function
38635                       0000F874            int15_handler_mouse_ret:
38636 F874           61                           popa
38637                       0000F875            int15_handler32_ret:
38638 F875           07                           pop es
38639 F876           1F                           pop ds
38640 F877           9D                           popf
38641 F878           E9         A6B7              jmp iret_modify_cf
38642                       0000F87B            apm_call:
38643 F87B           E9         ACC2              jmp _apmreal_entry
38644                       0000F87E            int15_handler_mouse:
38645 F87E           E8         4DFD              call _int15_function_mouse
38646 F881           EB           F1              jmp int15_handler_mouse_ret
38647                       0000F883            int15_handler32:
38648 F883     66    60                           pushad
38649 F885           E8         53CE              call _int15_function32
38650 F888     66    61                           popad
38651 F88A           EB           E9              jmp int15_handler32_ret
38652                                           ;; Protected mode IDT descriptor
38653                                           ;;
38654                                           ;; I just make the limit 0, so the machine will shutdown
38655                                           ;; if an exception occurs during protected mode memory
38656                                           ;; transfers.
38657                                           ;;
38658                                           ;; Set base to f0000 to correspond to beginning of BIOS,
38659                                           ;; in case I actually define an IDT later
38660                                           ;; Set limit to 0
38661                       0000F88C            pmode_IDT_info:
38662 F88C                      0000            dw 0x0000 ;; limit 15:00
38663 F88E                      0000            dw 0x0000 ;; base 15:00
38664 F890                        0F            db 0x0f ;; base 23:16
38665                                           ;; Real mode IDT descriptor
38666                                           ;;
38667                                           ;; Set to typical real-mode values.
38668                                           ;; base = 000000
38669                                           ;; limit = 03ff
38670                       0000F891            rmode_IDT_info:
38671 F891                      03FF            dw 0x03ff ;; limit 15:00
38672 F893                      0000            dw 0x0000 ;; base 15:00
38673 F895                        00            db 0x00 ;; base 23:16
38674                                           ;----------
38675                                           ;- INT1Ah -
38676                                           ;----------
38677 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
38678                       0000FE6E            int1a_handler:
38679 FE6E           80FC                   BB    cmp ah, #0xbb
38680 FE71           75           0E              jne no_tcg
38681 FE73           9C                           pushf
38682 FE74           1E                           push ds
38683 FE75           06                           push es
38684 FE76     66    60                           pushad
38685 FE78           E8         AAEC              call _int1a_function32
38686 FE7B     66    61                           popad
38687 FE7D           07                           pop es
38688 FE7E           1F                           pop ds
38689 FE7F           9D                           popf
38690 FE80           CF                           iret
38691                       0000FE81            no_tcg:
38692 FE81           80FC                   B1    cmp ah, #0xb1
38693 FE84           75           14              jne int1a_normal
38694 FE86           E8         AD3F              call pcibios_real
38695 FE89           72           03              jc pcibios_error
38696 FE8B           CA                   0002    retf 2
38697                       0000FE8E            pcibios_error:
38698 FE8E           88E3                         mov bl, ah
38699 FE90           B4                     B1    mov ah, #0xb1
38700 FE92           1E                           push ds
38701 FE93           60                           pusha
38702 FE94           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
38703 FE96           8ED8                         mov ds, ax ; on 16bit protected mode.
38704 FE98           EB           06              jmp int1a_callfunction
38705                       0000FE9A            int1a_normal:
38706 FE9A           1E                           push ds
38707 FE9B           60                           pusha
38708 FE9C           31C0                         xor ax, ax
38709 FE9E           8ED8                         mov ds, ax
38710                       0000FEA0            int1a_callfunction:
38711 FEA0           E8         9BC8              call _int1a_function
38712 FEA3           61                           popa
38713 FEA4           1F                           pop ds
38714 FEA5           CF                           iret
38715                                           ;;
38716                                           ;; int70h: IRQ8 - CMOS RTC
38717                                           ;;
38718                       0000FEA6            int70_handler:
38719 FEA6           1E                           push ds
38720 FEA7           60                           pusha
38721 FEA8           31C0                         xor ax, ax
38722 FEAA           8ED8                         mov ds, ax
38723 FEAC           E8         9F3F              call _int70_function
38724 FEAF           61                           popa
38725 FEB0           1F                           pop ds
38726 FEB1           CF                           iret
38727                                           ;---------
38728                                           ;- INT08 -
38729                                           ;---------
38730 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
38731                       0000FEA5            int08_handler:
38732 FEA5           FB                           sti
38733 FEA6     66    50                           push eax
38734 FEA8           1E                           push ds
38735 FEA9           31C0                         xor ax, ax
38736 FEAB           8ED8                         mov ds, ax
38737                                             ;; time to turn off drive(s)?
38738 FEAD           A0         0440              mov al,0x0440
38739 FEB0           08C0                         or al,al
38740 FEB2           74           10              jz int08_floppy_off
38741 FEB4           FEC8                         dec al
38742 FEB6           A2         0440              mov 0x0440,al
38743 FEB9           75           09              jnz int08_floppy_off
38744                                             ;; turn motor(s) off
38745 FEBB           52                           push dx
38746 FEBC           BA                   03F2    mov dx,#0x03f2
38747 FEBF           EC                           in al,dx
38748 FEC0           24                     CF    and al,#0xcf
38749 FEC2           EE                           out dx,al
38750 FEC3           5A                           pop dx
38751                       0000FEC4            int08_floppy_off:
38752 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
38753 FEC8     66    40                           inc eax
38754                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
38755 FECA     66    3D               001800B0    cmp eax, #0x001800B0
38756 FED0           72           07              jb int08_store_ticks
38757                                             ;; there has been a midnight rollover at this point
38758 FED2     66    31C0                         xor eax, eax ;; zero out counter
38759 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
38760                       0000FED9            int08_store_ticks:
38761 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
38762                                             ;; chain to user timer tick INT #0x1c
38763 FEDD           CD                     1C    int #0x1c
38764 FEDF           FA                           cli
38765 FEE0           E8         A3DD              call eoi_master_pic
38766 FEE3           1F                           pop ds
38767 FEE4     66    58                           pop eax
38768 FEE6           CF                           iret
38769 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
38770 FF00                                      .org 0xff00
38771 FF00                        28            .ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
38772                                           ;------------------------------------------------
38773                                           ;- IRET Instruction for Dummy Interrupt Handler -
38774                                           ;------------------------------------------------
38775 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
38776                       0000FF53            dummy_iret_handler:
38777 FF53           CF                           iret
38778 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
38779                                             HALT(10714)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   29DA    mov ax,#10714
 +a   FF5A           EF                           out dx,ax
38780 FF5B           CF                           iret
38781 FFF0                                      .org 0xfff0 ; Power-up Entry Point
38782 FFF0           EA         E05B      F000    jmp 0xf000:post
38783 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
38784 FFF5                        30            .ascii "06/23/99"
38785 FFFE                                      .org 0xfffe ; System Model ID
38786 FFFE                        FC            db 0xFC
38787 FFFF                        00            db 0x00 ; filler
38788 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
38789                                           ! 8039 endasm
38790                                           !BCC_ENDASM
38791                                           ! 8040 static Bit8u vgafont8[128*8]=
38792                                           ! 8041 {
38793                                           
38794                       0000FA6E            _vgafont8:
38795                                           ! 8042  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
38796 FA6E                        00            .byte	0
38797 FA6F                        00            .byte	0
38798 FA70                        00            .byte	0
38799 FA71                        00            .byte	0
38800 FA72                        00            .byte	0
38801 FA73                        00            .byte	0
38802 FA74                        00            .byte	0
38803 FA75                        00            .byte	0
38804                                           ! 8043  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
38805 FA76                        7E            .byte	$7E
38806 FA77                        81            .byte	$81
38807 FA78                        A5            .byte	$A5
38808 FA79                        81            .byte	$81
38809 FA7A                        BD            .byte	$BD
38810 FA7B                        99            .byte	$99
38811 FA7C                        81            .byte	$81
38812 FA7D                        7E            .byte	$7E
38813                                           ! 8044  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
38814 FA7E                        7E            .byte	$7E
38815 FA7F                        FF            .byte	$FF
38816 FA80                        DB            .byte	$DB
38817 FA81                        FF            .byte	$FF
38818 FA82                        C3            .byte	$C3
38819 FA83                        E7            .byte	$E7
38820 FA84                        FF            .byte	$FF
38821 FA85                        7E            .byte	$7E
38822                                           ! 8045  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
38823 FA86                        6C            .byte	$6C
38824 FA87                        FE            .byte	$FE
38825 FA88                        FE            .byte	$FE
38826 FA89                        FE            .byte	$FE
38827 FA8A                        7C            .byte	$7C
38828 FA8B                        38            .byte	$38
38829 FA8C                        10            .byte	$10
38830 FA8D                        00            .byte	0
38831                                           ! 8046  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
38832 FA8E                        10            .byte	$10
38833 FA8F                        38            .byte	$38
38834 FA90                        7C            .byte	$7C
38835 FA91                        FE            .byte	$FE
38836 FA92                        7C            .byte	$7C
38837 FA93                        38            .byte	$38
38838 FA94                        10            .byte	$10
38839 FA95                        00            .byte	0
38840                                           ! 8047  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
38841 FA96                        38            .byte	$38
38842 FA97                        7C            .byte	$7C
38843 FA98                        38            .byte	$38
38844 FA99                        FE            .byte	$FE
38845 FA9A                        FE            .byte	$FE
38846 FA9B                        7C            .byte	$7C
38847 FA9C                        38            .byte	$38
38848 FA9D                        7C            .byte	$7C
38849                                           ! 8048  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
38850 FA9E                        10            .byte	$10
38851 FA9F                        10            .byte	$10
38852 FAA0                        38            .byte	$38
38853 FAA1                        7C            .byte	$7C
38854 FAA2                        FE            .byte	$FE
38855 FAA3                        7C            .byte	$7C
38856 FAA4                        38            .byte	$38
38857 FAA5                        7C            .byte	$7C
38858                                           ! 8049  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
38859 FAA6                        00            .byte	0
38860 FAA7                        00            .byte	0
38861 FAA8                        18            .byte	$18
38862 FAA9                        3C            .byte	$3C
38863 FAAA                        3C            .byte	$3C
38864 FAAB                        18            .byte	$18
38865 FAAC                        00            .byte	0
38866 FAAD                        00            .byte	0
38867                                           ! 8050  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
38868 FAAE                        FF            .byte	$FF
38869 FAAF                        FF            .byte	$FF
38870 FAB0                        E7            .byte	$E7
38871 FAB1                        C3            .byte	$C3
38872 FAB2                        C3            .byte	$C3
38873 FAB3                        E7            .byte	$E7
38874 FAB4                        FF            .byte	$FF
38875 FAB5                        FF            .byte	$FF
38876                                           ! 8051  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
38877 FAB6                        00            .byte	0
38878 FAB7                        3C            .byte	$3C
38879 FAB8                        66            .byte	$66
38880 FAB9                        42            .byte	$42
38881 FABA                        42            .byte	$42
38882 FABB                        66            .byte	$66
38883 FABC                        3C            .byte	$3C
38884 FABD                        00            .byte	0
38885                                           ! 8052  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
38886 FABE                        FF            .byte	$FF
38887 FABF                        C3            .byte	$C3
38888 FAC0                        99            .byte	$99
38889 FAC1                        BD            .byte	$BD
38890 FAC2                        BD            .byte	$BD
38891 FAC3                        99            .byte	$99
38892 FAC4                        C3            .byte	$C3
38893 FAC5                        FF            .byte	$FF
38894                                           ! 8053  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
38895 FAC6                        0F            .byte	$F
38896 FAC7                        07            .byte	7
38897 FAC8                        0F            .byte	$F
38898 FAC9                        7D            .byte	$7D
38899 FACA                        CC            .byte	$CC
38900 FACB                        CC            .byte	$CC
38901 FACC                        CC            .byte	$CC
38902 FACD                        78            .byte	$78
38903                                           ! 8054  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
38904 FACE                        3C            .byte	$3C
38905 FACF                        66            .byte	$66
38906 FAD0                        66            .byte	$66
38907 FAD1                        66            .byte	$66
38908 FAD2                        3C            .byte	$3C
38909 FAD3                        18            .byte	$18
38910 FAD4                        7E            .byte	$7E
38911 FAD5                        18            .byte	$18
38912                                           ! 8055  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
38913 FAD6                        3F            .byte	$3F
38914 FAD7                        33            .byte	$33
38915 FAD8                        3F            .byte	$3F
38916 FAD9                        30            .byte	$30
38917 FADA                        30            .byte	$30
38918 FADB                        70            .byte	$70
38919 FADC                        F0            .byte	$F0
38920 FADD                        E0            .byte	$E0
38921                                           ! 8056  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
38922 FADE                        7F            .byte	$7F
38923 FADF                        63            .byte	$63
38924 FAE0                        7F            .byte	$7F
38925 FAE1                        63            .byte	$63
38926 FAE2                        63            .byte	$63
38927 FAE3                        67            .byte	$67
38928 FAE4                        E6            .byte	$E6
38929 FAE5                        C0            .byte	$C0
38930                                           ! 8057  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
38931 FAE6                        99            .byte	$99
38932 FAE7                        5A            .byte	$5A
38933 FAE8                        3C            .byte	$3C
38934 FAE9                        E7            .byte	$E7
38935 FAEA                        E7            .byte	$E7
38936 FAEB                        3C            .byte	$3C
38937 FAEC                        5A            .byte	$5A
38938 FAED                        99            .byte	$99
38939                                           ! 8058  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0xe0, 0x80, 0x00,
38940 FAEE                        80            .byte	$80
38941 FAEF                        E0            .byte	$E0
38942 FAF0                        F8            .byte	$F8
38943 FAF1                        FE            .byte	$FE
38944 FAF2                        F8            .byte	$F8
38945 FAF3                        E0            .byte	$E0
38946 FAF4                        80            .byte	$80
38947 FAF5                        00            .byte	0
38948                                           ! 8059  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
38949 FAF6                        02            .byte	2
38950 FAF7                        0E            .byte	$E
38951 FAF8                        3E            .byte	$3E
38952 FAF9                        FE            .byte	$FE
38953 FAFA                        3E            .byte	$3E
38954 FAFB                        0E            .byte	$E
38955 FAFC                        02            .byte	2
38956 FAFD                        00            .byte	0
38957                                           ! 8060  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
38958 FAFE                        18            .byte	$18
38959 FAFF                        3C            .byte	$3C
38960 FB00                        7E            .byte	$7E
38961 FB01                        18            .byte	$18
38962 FB02                        18            .byte	$18
38963 FB03                        7E            .byte	$7E
38964 FB04                        3C            .byte	$3C
38965 FB05                        18            .byte	$18
38966                                           ! 8061  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
38967 FB06                        66            .byte	$66
38968 FB07                        66            .byte	$66
38969 FB08                        66            .byte	$66
38970 FB09                        66            .byte	$66
38971 FB0A                        66            .byte	$66
38972 FB0B                        00            .byte	0
38973 FB0C                        66            .byte	$66
38974 FB0D                        00            .byte	0
38975                                           ! 8062  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
38976 FB0E                        7F            .byte	$7F
38977 FB0F                        DB            .byte	$DB
38978 FB10                        DB            .byte	$DB
38979 FB11                        7B            .byte	$7B
38980 FB12                        1B            .byte	$1B
38981 FB13                        1B            .byte	$1B
38982 FB14                        1B            .byte	$1B
38983 FB15                        00            .byte	0
38984                                           ! 8063  0x3e, 0x63, 0x38
38985 FB16                        3E            .byte	$3E
38986 FB17                        63            .byte	$63
38987                                           ! 8063 , 0x6c, 0x6c, 0x38, 0xcc, 0x78,
38988 FB18                        38            .byte	$38
38989 FB19                        6C            .byte	$6C
38990 FB1A                        6C            .byte	$6C
38991 FB1B                        38            .byte	$38
38992 FB1C                        CC            .byte	$CC
38993 FB1D                        78            .byte	$78
38994                                           ! 8064  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
38995 FB1E                        00            .byte	0
38996 FB1F                        00            .byte	0
38997 FB20                        00            .byte	0
38998 FB21                        00            .byte	0
38999 FB22                        7E            .byte	$7E
39000 FB23                        7E            .byte	$7E
39001 FB24                        7E            .byte	$7E
39002 FB25                        00            .byte	0
39003                                           ! 8065  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
39004 FB26                        18            .byte	$18
39005 FB27                        3C            .byte	$3C
39006 FB28                        7E            .byte	$7E
39007 FB29                        18            .byte	$18
39008 FB2A                        7E            .byte	$7E
39009 FB2B                        3C            .byte	$3C
39010 FB2C                        18            .byte	$18
39011 FB2D                        FF            .byte	$FF
39012                                           ! 8066  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
39013 FB2E                        18            .byte	$18
39014 FB2F                        3C            .byte	$3C
39015 FB30                        7E            .byte	$7E
39016 FB31                        18            .byte	$18
39017 FB32                        18            .byte	$18
39018 FB33                        18            .byte	$18
39019 FB34                        18            .byte	$18
39020 FB35                        00            .byte	0
39021                                           ! 8067  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
39022 FB36                        18            .byte	$18
39023 FB37                        18            .byte	$18
39024 FB38                        18            .byte	$18
39025 FB39                        18            .byte	$18
39026 FB3A                        7E            .byte	$7E
39027 FB3B                        3C            .byte	$3C
39028 FB3C                        18            .byte	$18
39029 FB3D                        00            .byte	0
39030                                           ! 8068  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
39031 FB3E                        00            .byte	0
39032 FB3F                        18            .byte	$18
39033 FB40                        0C            .byte	$C
39034 FB41                        FE            .byte	$FE
39035 FB42                        0C            .byte	$C
39036 FB43                        18            .byte	$18
39037 FB44                        00            .byte	0
39038 FB45                        00            .byte	0
39039                                           ! 8069  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
39040 FB46                        00            .byte	0
39041 FB47                        30            .byte	$30
39042 FB48                        60            .byte	$60
39043 FB49                        FE            .byte	$FE
39044 FB4A                        60            .byte	$60
39045 FB4B                        30            .byte	$30
39046 FB4C                        00            .byte	0
39047 FB4D                        00            .byte	0
39048                                           ! 8070  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
39049 FB4E                        00            .byte	0
39050 FB4F                        00            .byte	0
39051 FB50                        C0            .byte	$C0
39052 FB51                        C0            .byte	$C0
39053 FB52                        C0            .byte	$C0
39054 FB53                        FE            .byte	$FE
39055 FB54                        00            .byte	0
39056 FB55                        00            .byte	0
39057                                           ! 8071  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
39058 FB56                        00            .byte	0
39059 FB57                        24            .byte	$24
39060 FB58                        66            .byte	$66
39061 FB59                        FF            .byte	$FF
39062 FB5A                        66            .byte	$66
39063 FB5B                        24            .byte	$24
39064 FB5C                        00            .byte	0
39065 FB5D                        00            .byte	0
39066                                           ! 8072  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
39067 FB5E                        00            .byte	0
39068 FB5F                        18            .byte	$18
39069 FB60                        3C            .byte	$3C
39070 FB61                        7E            .byte	$7E
39071 FB62                        FF            .byte	$FF
39072 FB63                        FF            .byte	$FF
39073 FB64                        00            .byte	0
39074 FB65                        00            .byte	0
39075                                           ! 8073  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
39076 FB66                        00            .byte	0
39077 FB67                        FF            .byte	$FF
39078 FB68                        FF            .byte	$FF
39079 FB69                        7E            .byte	$7E
39080 FB6A                        3C            .byte	$3C
39081 FB6B                        18            .byte	$18
39082 FB6C                        00            .byte	0
39083 FB6D                        00            .byte	0
39084                                           ! 8074  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
39085 FB6E                        00            .byte	0
39086 FB6F                        00            .byte	0
39087 FB70                        00            .byte	0
39088 FB71                        00            .byte	0
39089 FB72                        00            .byte	0
39090 FB73                        00            .byte	0
39091 FB74                        00            .byte	0
39092 FB75                        00            .byte	0
39093                                           ! 8075  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
39094 FB76                        30            .byte	$30
39095 FB77                        78            .byte	$78
39096 FB78                        78            .byte	$78
39097 FB79                        30            .byte	$30
39098 FB7A                        30            .byte	$30
39099 FB7B                        00            .byte	0
39100 FB7C                        30            .byte	$30
39101 FB7D                        00            .byte	0
39102                                           ! 8076  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
39103 FB7E                        6C            .byte	$6C
39104 FB7F                        6C            .byte	$6C
39105 FB80                        6C            .byte	$6C
39106 FB81                        00            .byte	0
39107 FB82                        00            .byte	0
39108 FB83                        00            .byte	0
39109 FB84                        00            .byte	0
39110 FB85                        00            .byte	0
39111                                           ! 8077  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
39112 FB86                        6C            .byte	$6C
39113 FB87                        6C            .byte	$6C
39114 FB88                        FE            .byte	$FE
39115 FB89                        6C            .byte	$6C
39116 FB8A                        FE            .byte	$FE
39117 FB8B                        6C            .byte	$6C
39118 FB8C                        6C            .byte	$6C
39119 FB8D                        00            .byte	0
39120                                           ! 8078  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
39121 FB8E                        30            .byte	$30
39122 FB8F                        7C            .byte	$7C
39123 FB90                        C0            .byte	$C0
39124 FB91                        78            .byte	$78
39125 FB92                        0C            .byte	$C
39126 FB93                        F8            .byte	$F8
39127 FB94                        30            .byte	$30
39128 FB95                        00            .byte	0
39129                                           ! 8079  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
39130 FB96                        00            .byte	0
39131 FB97                        C6            .byte	$C6
39132 FB98                        CC            .byte	$CC
39133 FB99                        18            .byte	$18
39134 FB9A                        30            .byte	$30
39135 FB9B                        66            .byte	$66
39136 FB9C                        C6            .byte	$C6
39137 FB9D                        00            .byte	0
39138                                           ! 8080  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
39139 FB9E                        38            .byte	$38
39140 FB9F                        6C            .byte	$6C
39141 FBA0                        38            .byte	$38
39142 FBA1                        76            .byte	$76
39143 FBA2                        DC            .byte	$DC
39144 FBA3                        CC            .byte	$CC
39145 FBA4                        76            .byte	$76
39146 FBA5                        00            .byte	0
39147                                           ! 8081  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
39148 FBA6                        60            .byte	$60
39149 FBA7                        60            .byte	$60
39150 FBA8                        C0            .byte	$C0
39151 FBA9                        00            .byte	0
39152 FBAA                        00            .byte	0
39153 FBAB                        00            .byte	0
39154 FBAC                        00            .byte	0
39155 FBAD                        00            .byte	0
39156                                           ! 8082  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
39157 FBAE                        18            .byte	$18
39158 FBAF                        30            .byte	$30
39159 FBB0                        60            .byte	$60
39160 FBB1                        60            .byte	$60
39161 FBB2                        60            .byte	$60
39162 FBB3                        30            .byte	$30
39163 FBB4                        18            .byte	$18
39164 FBB5                        00            .byte	0
39165                                           ! 8083  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
39166 FBB6                        60            .byte	$60
39167 FBB7                        30            .byte	$30
39168 FBB8                        18            .byte	$18
39169 FBB9                        18            .byte	$18
39170 FBBA                        18            .byte	$18
39171 FBBB                        30            .byte	$30
39172 FBBC                        60            .byte	$60
39173 FBBD                        00            .byte	0
39174                                           ! 8084  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
39175 FBBE                        00            .byte	0
39176 FBBF                        66            .byte	$66
39177 FBC0                        3C            .byte	$3C
39178 FBC1                        FF            .byte	$FF
39179 FBC2                        3C            .byte	$3C
39180 FBC3                        66            .byte	$66
39181 FBC4                        00            .byte	0
39182 FBC5                        00            .byte	0
39183                                           ! 8085  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
39184 FBC6                        00            .byte	0
39185 FBC7                        30            .byte	$30
39186 FBC8                        30            .byte	$30
39187 FBC9                        FC            .byte	$FC
39188 FBCA                        30            .byte	$30
39189 FBCB                        30            .byte	$30
39190 FBCC                        00            .byte	0
39191 FBCD                        00            .byte	0
39192                                           ! 8086  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
39193 FBCE                        00            .byte	0
39194 FBCF                        00            .byte	0
39195 FBD0                        00            .byte	0
39196 FBD1                        00            .byte	0
39197 FBD2                        00            .byte	0
39198 FBD3                        30            .byte	$30
39199 FBD4                        30            .byte	$30
39200 FBD5                        60            .byte	$60
39201                                           ! 8087  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
39202 FBD6                        00            .byte	0
39203 FBD7                        00            .byte	0
39204 FBD8                        00            .byte	0
39205 FBD9                        FC            .byte	$FC
39206 FBDA                        00            .byte	0
39207 FBDB                        00            .byte	0
39208 FBDC                        00            .byte	0
39209 FBDD                        00            .byte	0
39210                                           ! 8088  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
39211 FBDE                        00            .byte	0
39212 FBDF                        00            .byte	0
39213 FBE0                        00            .byte	0
39214 FBE1                        00            .byte	0
39215 FBE2                        00            .byte	0
39216 FBE3                        30            .byte	$30
39217 FBE4                        30            .byte	$30
39218 FBE5                        00            .byte	0
39219                                           ! 8089  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
39220 FBE6                        06            .byte	6
39221 FBE7                        0C            .byte	$C
39222 FBE8                        18            .byte	$18
39223 FBE9                        30            .byte	$30
39224 FBEA                        60            .byte	$60
39225 FBEB                        C0            .byte	$C0
39226 FBEC                        80            .byte	$80
39227 FBED                        00            .byte	0
39228                                           ! 8090  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
39229 FBEE                        7C            .byte	$7C
39230 FBEF                        C6            .byte	$C6
39231 FBF0                        CE            .byte	$CE
39232 FBF1                        DE            .byte	$DE
39233 FBF2                        F6            .byte	$F6
39234 FBF3                        E6            .byte	$E6
39235 FBF4                        7C            .byte	$7C
39236 FBF5                        00            .byte	0
39237                                           ! 8091  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
39238 FBF6                        30            .byte	$30
39239 FBF7                        70            .byte	$70
39240 FBF8                        30            .byte	$30
39241 FBF9                        30            .byte	$30
39242 FBFA                        30            .byte	$30
39243 FBFB                        30            .byte	$30
39244 FBFC                        FC            .byte	$FC
39245 FBFD                        00            .byte	0
39246                                           ! 8092  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
39247 FBFE                        78            .byte	$78
39248 FBFF                        CC            .byte	$CC
39249 FC00                        0C            .byte	$C
39250 FC01                        38            .byte	$38
39251 FC02                        60            .byte	$60
39252 FC03                        CC            .byte	$CC
39253 FC04                        FC            .byte	$FC
39254 FC05                        00            .byte	0
39255                                           ! 8093  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
39256 FC06                        78            .byte	$78
39257 FC07                        CC            .byte	$CC
39258 FC08                        0C            .byte	$C
39259 FC09                        38            .byte	$38
39260 FC0A                        0C            .byte	$C
39261 FC0B                        CC            .byte	$CC
39262 FC0C                        78            .byte	$78
39263 FC0D                        00            .byte	0
39264                                           ! 8094  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
39265 FC0E                        1C            .byte	$1C
39266 FC0F                        3C            .byte	$3C
39267 FC10                        6C            .byte	$6C
39268 FC11                        CC            .byte	$CC
39269 FC12                        FE            .byte	$FE
39270 FC13                        0C            .byte	$C
39271 FC14                        1E            .byte	$1E
39272 FC15                        00            .byte	0
39273                                           ! 8095  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
39274 FC16                        FC            .byte	$FC
39275 FC17                        C0            .byte	$C0
39276 FC18                        F8            .byte	$F8
39277 FC19                        0C            .byte	$C
39278 FC1A                        0C            .byte	$C
39279 FC1B                        CC            .byte	$CC
39280 FC1C                        78            .byte	$78
39281 FC1D                        00            .byte	0
39282                                           ! 8096  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
39283 FC1E                        38            .byte	$38
39284 FC1F                        60            .byte	$60
39285 FC20                        C0            .byte	$C0
39286 FC21                        F8            .byte	$F8
39287 FC22                        CC            .byte	$CC
39288 FC23                        CC            .byte	$CC
39289 FC24                        78            .byte	$78
39290 FC25                        00            .byte	0
39291                                           ! 8097  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
39292 FC26                        FC            .byte	$FC
39293 FC27                        CC            .byte	$CC
39294 FC28                        0C            .byte	$C
39295 FC29                        18            .byte	$18
39296 FC2A                        30            .byte	$30
39297 FC2B                        30            .byte	$30
39298 FC2C                        30            .byte	$30
39299 FC2D                        00            .byte	0
39300                                           ! 8098  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
39301 FC2E                        78            .byte	$78
39302 FC2F                        CC            .byte	$CC
39303 FC30                        CC            .byte	$CC
39304 FC31                        78            .byte	$78
39305 FC32                        CC            .byte	$CC
39306 FC33                        CC            .byte	$CC
39307 FC34                        78            .byte	$78
39308 FC35                        00            .byte	0
39309                                           ! 8099  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
39310 FC36                        78            .byte	$78
39311 FC37                        CC            .byte	$CC
39312 FC38                        CC            .byte	$CC
39313 FC39                        7C            .byte	$7C
39314 FC3A                        0C            .byte	$C
39315 FC3B                        18            .byte	$18
39316 FC3C                        70            .byte	$70
39317 FC3D                        00            .byte	0
39318                                           ! 8100  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00,
39319 FC3E                        00            .byte	0
39320 FC3F                        30            .byte	$30
39321 FC40                        30            .byte	$30
39322 FC41                        00            .byte	0
39323 FC42                        00            .byte	0
39324 FC43                        30            .byte	$30
39325 FC44                        30            .byte	$30
39326 FC45                        00            .byte	0
39327                                           ! 8101  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
39328 FC46                        00            .byte	0
39329 FC47                        30            .byte	$30
39330 FC48                        30            .byte	$30
39331 FC49                        00            .byte	0
39332 FC4A                        00            .byte	0
39333 FC4B                        30            .byte	$30
39334 FC4C                        30            .byte	$30
39335 FC4D                        60            .byte	$60
39336                                           ! 8102  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
39337 FC4E                        18            .byte	$18
39338 FC4F                        30            .byte	$30
39339 FC50                        60            .byte	$60
39340 FC51                        C0            .byte	$C0
39341 FC52                        60            .byte	$60
39342 FC53                        30            .byte	$30
39343 FC54                        18            .byte	$18
39344 FC55                        00            .byte	0
39345                                           ! 8103  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
39346 FC56                        00            .byte	0
39347 FC57                        00            .byte	0
39348 FC58                        FC            .byte	$FC
39349 FC59                        00            .byte	0
39350 FC5A                        00            .byte	0
39351 FC5B                        FC            .byte	$FC
39352 FC5C                        00            .byte	0
39353 FC5D                        00            .byte	0
39354                                           ! 8104  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
39355 FC5E                        60            .byte	$60
39356 FC5F                        30            .byte	$30
39357 FC60                        18            .byte	$18
39358 FC61                        0C            .byte	$C
39359 FC62                        18            .byte	$18
39360 FC63                        30            .byte	$30
39361 FC64                        60            .byte	$60
39362 FC65                        00            .byte	0
39363                                           ! 8105  0x78, 
39364 FC66                        78            .byte	$78
39365                                           ! 8105 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
39366 FC67                        CC            .byte	$CC
39367 FC68                        0C            .byte	$C
39368 FC69                        18            .byte	$18
39369 FC6A                        30            .byte	$30
39370 FC6B                        00            .byte	0
39371 FC6C                        30            .byte	$30
39372 FC6D                        00            .byte	0
39373                                           ! 8106  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
39374 FC6E                        7C            .byte	$7C
39375 FC6F                        C6            .byte	$C6
39376 FC70                        DE            .byte	$DE
39377 FC71                        DE            .byte	$DE
39378 FC72                        DE            .byte	$DE
39379 FC73                        C0            .byte	$C0
39380 FC74                        78            .byte	$78
39381 FC75                        00            .byte	0
39382                                           ! 8107  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
39383 FC76                        30            .byte	$30
39384 FC77                        78            .byte	$78
39385 FC78                        CC            .byte	$CC
39386 FC79                        CC            .byte	$CC
39387 FC7A                        FC            .byte	$FC
39388 FC7B                        CC            .byte	$CC
39389 FC7C                        CC            .byte	$CC
39390 FC7D                        00            .byte	0
39391                                           ! 8108  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
39392 FC7E                        FC            .byte	$FC
39393 FC7F                        66            .byte	$66
39394 FC80                        66            .byte	$66
39395 FC81                        7C            .byte	$7C
39396 FC82                        66            .byte	$66
39397 FC83                        66            .byte	$66
39398 FC84                        FC            .byte	$FC
39399 FC85                        00            .byte	0
39400                                           ! 8109  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
39401 FC86                        3C            .byte	$3C
39402 FC87                        66            .byte	$66
39403 FC88                        C0            .byte	$C0
39404 FC89                        C0            .byte	$C0
39405 FC8A                        C0            .byte	$C0
39406 FC8B                        66            .byte	$66
39407 FC8C                        3C            .byte	$3C
39408 FC8D                        00            .byte	0
39409                                           ! 8110  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
39410 FC8E                        F8            .byte	$F8
39411 FC8F                        6C            .byte	$6C
39412 FC90                        66            .byte	$66
39413 FC91                        66            .byte	$66
39414 FC92                        66            .byte	$66
39415 FC93                        6C            .byte	$6C
39416 FC94                        F8            .byte	$F8
39417 FC95                        00            .byte	0
39418                                           ! 8111  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
39419 FC96                        FE            .byte	$FE
39420 FC97                        62            .byte	$62
39421 FC98                        68            .byte	$68
39422 FC99                        78            .byte	$78
39423 FC9A                        68            .byte	$68
39424 FC9B                        62            .byte	$62
39425 FC9C                        FE            .byte	$FE
39426 FC9D                        00            .byte	0
39427                                           ! 8112  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
39428 FC9E                        FE            .byte	$FE
39429 FC9F                        62            .byte	$62
39430 FCA0                        68            .byte	$68
39431 FCA1                        78            .byte	$78
39432 FCA2                        68            .byte	$68
39433 FCA3                        60            .byte	$60
39434 FCA4                        F0            .byte	$F0
39435 FCA5                        00            .byte	0
39436                                           ! 8113  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
39437 FCA6                        3C            .byte	$3C
39438 FCA7                        66            .byte	$66
39439 FCA8                        C0            .byte	$C0
39440 FCA9                        C0            .byte	$C0
39441 FCAA                        CE            .byte	$CE
39442 FCAB                        66            .byte	$66
39443 FCAC                        3E            .byte	$3E
39444 FCAD                        00            .byte	0
39445                                           ! 8114  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
39446 FCAE                        CC            .byte	$CC
39447 FCAF                        CC            .byte	$CC
39448 FCB0                        CC            .byte	$CC
39449 FCB1                        FC            .byte	$FC
39450 FCB2                        CC            .byte	$CC
39451 FCB3                        CC            .byte	$CC
39452 FCB4                        CC            .byte	$CC
39453 FCB5                        00            .byte	0
39454                                           ! 8115  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
39455 FCB6                        78            .byte	$78
39456 FCB7                        30            .byte	$30
39457 FCB8                        30            .byte	$30
39458 FCB9                        30            .byte	$30
39459 FCBA                        30            .byte	$30
39460 FCBB                        30            .byte	$30
39461 FCBC                        78            .byte	$78
39462 FCBD                        00            .byte	0
39463                                           ! 8116  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
39464 FCBE                        1E            .byte	$1E
39465 FCBF                        0C            .byte	$C
39466 FCC0                        0C            .byte	$C
39467 FCC1                        0C            .byte	$C
39468 FCC2                        CC            .byte	$CC
39469 FCC3                        CC            .byte	$CC
39470 FCC4                        78            .byte	$78
39471 FCC5                        00            .byte	0
39472                                           ! 8117  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
39473 FCC6                        E6            .byte	$E6
39474 FCC7                        66            .byte	$66
39475 FCC8                        6C            .byte	$6C
39476 FCC9                        78            .byte	$78
39477 FCCA                        6C            .byte	$6C
39478 FCCB                        66            .byte	$66
39479 FCCC                        E6            .byte	$E6
39480 FCCD                        00            .byte	0
39481                                           ! 8118  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
39482 FCCE                        F0            .byte	$F0
39483 FCCF                        60            .byte	$60
39484 FCD0                        60            .byte	$60
39485 FCD1                        60            .byte	$60
39486 FCD2                        62            .byte	$62
39487 FCD3                        66            .byte	$66
39488 FCD4                        FE            .byte	$FE
39489 FCD5                        00            .byte	0
39490                                           ! 8119  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
39491 FCD6                        C6            .byte	$C6
39492 FCD7                        EE            .byte	$EE
39493 FCD8                        FE            .byte	$FE
39494 FCD9                        FE            .byte	$FE
39495 FCDA                        D6            .byte	$D6
39496 FCDB                        C6            .byte	$C6
39497 FCDC                        C6            .byte	$C6
39498 FCDD                        00            .byte	0
39499                                           ! 8120  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
39500 FCDE                        C6            .byte	$C6
39501 FCDF                        E6            .byte	$E6
39502 FCE0                        F6            .byte	$F6
39503 FCE1                        DE            .byte	$DE
39504 FCE2                        CE            .byte	$CE
39505 FCE3                        C6            .byte	$C6
39506 FCE4                        C6            .byte	$C6
39507 FCE5                        00            .byte	0
39508                                           ! 8121  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
39509 FCE6                        38            .byte	$38
39510 FCE7                        6C            .byte	$6C
39511 FCE8                        C6            .byte	$C6
39512 FCE9                        C6            .byte	$C6
39513 FCEA                        C6            .byte	$C6
39514 FCEB                        6C            .byte	$6C
39515 FCEC                        38            .byte	$38
39516 FCED                        00            .byte	0
39517                                           ! 8122  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
39518 FCEE                        FC            .byte	$FC
39519 FCEF                        66            .byte	$66
39520 FCF0                        66            .byte	$66
39521 FCF1                        7C            .byte	$7C
39522 FCF2                        60            .byte	$60
39523 FCF3                        60            .byte	$60
39524 FCF4                        F0            .byte	$F0
39525 FCF5                        00            .byte	0
39526                                           ! 8123  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
39527 FCF6                        78            .byte	$78
39528 FCF7                        CC            .byte	$CC
39529 FCF8                        CC            .byte	$CC
39530 FCF9                        CC            .byte	$CC
39531 FCFA                        DC            .byte	$DC
39532 FCFB                        78            .byte	$78
39533 FCFC                        1C            .byte	$1C
39534 FCFD                        00            .byte	0
39535                                           ! 8124  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
39536 FCFE                        FC            .byte	$FC
39537 FCFF                        66            .byte	$66
39538 FD00                        66            .byte	$66
39539 FD01                        7C            .byte	$7C
39540 FD02                        6C            .byte	$6C
39541 FD03                        66            .byte	$66
39542 FD04                        E6            .byte	$E6
39543 FD05                        00            .byte	0
39544                                           ! 8125  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
39545 FD06                        78            .byte	$78
39546 FD07                        CC            .byte	$CC
39547 FD08                        E0            .byte	$E0
39548 FD09                        70            .byte	$70
39549 FD0A                        1C            .byte	$1C
39550 FD0B                        CC            .byte	$CC
39551 FD0C                        78            .byte	$78
39552 FD0D                        00            .byte	0
39553                                           ! 8126  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
39554 FD0E                        FC            .byte	$FC
39555 FD0F                        B4            .byte	$B4
39556 FD10                        30            .byte	$30
39557 FD11                        30            .byte	$30
39558 FD12                        30            .byte	$30
39559 FD13                        30            .byte	$30
39560 FD14                        78            .byte	$78
39561 FD15                        00            .byte	0
39562                                           ! 8127  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
39563 FD16                        CC            .byte	$CC
39564 FD17                        CC            .byte	$CC
39565 FD18                        CC            .byte	$CC
39566 FD19                        CC            .byte	$CC
39567 FD1A                        CC            .byte	$CC
39568 FD1B                        CC            .byte	$CC
39569 FD1C                        FC            .byte	$FC
39570 FD1D                        00            .byte	0
39571                                           ! 8128  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
39572 FD1E                        CC            .byte	$CC
39573 FD1F                        CC            .byte	$CC
39574 FD20                        CC            .byte	$CC
39575 FD21                        CC            .byte	$CC
39576 FD22                        CC            .byte	$CC
39577 FD23                        78            .byte	$78
39578 FD24                        30            .byte	$30
39579 FD25                        00            .byte	0
39580                                           ! 8129  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
39581 FD26                        C6            .byte	$C6
39582 FD27                        C6            .byte	$C6
39583 FD28                        C6            .byte	$C6
39584 FD29                        D6            .byte	$D6
39585 FD2A                        FE            .byte	$FE
39586 FD2B                        EE            .byte	$EE
39587 FD2C                        C6            .byte	$C6
39588 FD2D                        00            .byte	0
39589                                           ! 8130  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
39590 FD2E                        C6            .byte	$C6
39591 FD2F                        C6            .byte	$C6
39592 FD30                        6C            .byte	$6C
39593 FD31                        38            .byte	$38
39594 FD32                        38            .byte	$38
39595 FD33                        6C            .byte	$6C
39596 FD34                        C6            .byte	$C6
39597 FD35                        00            .byte	0
39598                                           ! 8131  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
39599 FD36                        CC            .byte	$CC
39600 FD37                        CC            .byte	$CC
39601 FD38                        CC            .byte	$CC
39602 FD39                        78            .byte	$78
39603 FD3A                        30            .byte	$30
39604 FD3B                        30            .byte	$30
39605 FD3C                        78            .byte	$78
39606 FD3D                        00            .byte	0
39607                                           ! 8132  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
39608 FD3E                        FE            .byte	$FE
39609 FD3F                        C6            .byte	$C6
39610 FD40                        8C            .byte	$8C
39611 FD41                        18            .byte	$18
39612 FD42                        32            .byte	$32
39613 FD43                        66            .byte	$66
39614 FD44                        FE            .byte	$FE
39615 FD45                        00            .byte	0
39616                                           ! 8133  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
39617 FD46                        78            .byte	$78
39618 FD47                        60            .byte	$60
39619 FD48                        60            .byte	$60
39620 FD49                        60            .byte	$60
39621 FD4A                        60            .byte	$60
39622 FD4B                        60            .byte	$60
39623 FD4C                        78            .byte	$78
39624 FD4D                        00            .byte	0
39625                                           ! 8134  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
39626 FD4E                        C0            .byte	$C0
39627 FD4F                        60            .byte	$60
39628 FD50                        30            .byte	$30
39629 FD51                        18            .byte	$18
39630 FD52                        0C            .byte	$C
39631 FD53                        06            .byte	6
39632 FD54                        02            .byte	2
39633 FD55                        00            .byte	0
39634                                           ! 8135  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
39635 FD56                        78            .byte	$78
39636 FD57                        18            .byte	$18
39637 FD58                        18            .byte	$18
39638 FD59                        18            .byte	$18
39639 FD5A                        18            .byte	$18
39640 FD5B                        18            .byte	$18
39641 FD5C                        78            .byte	$78
39642 FD5D                        00            .byte	0
39643                                           ! 8136  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
39644 FD5E                        10            .byte	$10
39645 FD5F                        38            .byte	$38
39646 FD60                        6C            .byte	$6C
39647 FD61                        C6            .byte	$C6
39648 FD62                        00            .byte	0
39649 FD63                        00            .byte	0
39650 FD64                        00            .byte	0
39651 FD65                        00            .byte	0
39652                                           ! 8137  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
39653 FD66                        00            .byte	0
39654 FD67                        00            .byte	0
39655 FD68                        00            .byte	0
39656 FD69                        00            .byte	0
39657 FD6A                        00            .byte	0
39658 FD6B                        00            .byte	0
39659 FD6C                        00            .byte	0
39660 FD6D                        FF            .byte	$FF
39661                                           ! 8138  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
39662 FD6E                        30            .byte	$30
39663 FD6F                        30            .byte	$30
39664 FD70                        18            .byte	$18
39665 FD71                        00            .byte	0
39666 FD72                        00            .byte	0
39667 FD73                        00            .byte	0
39668 FD74                        00            .byte	0
39669 FD75                        00            .byte	0
39670                                           ! 8139  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
39671 FD76                        00            .byte	0
39672 FD77                        00            .byte	0
39673 FD78                        78            .byte	$78
39674 FD79                        0C            .byte	$C
39675 FD7A                        7C            .byte	$7C
39676 FD7B                        CC            .byte	$CC
39677 FD7C                        76            .byte	$76
39678 FD7D                        00            .byte	0
39679                                           ! 8140  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
39680 FD7E                        E0            .byte	$E0
39681 FD7F                        60            .byte	$60
39682 FD80                        60            .byte	$60
39683 FD81                        7C            .byte	$7C
39684 FD82                        66            .byte	$66
39685 FD83                        66            .byte	$66
39686 FD84                        DC            .byte	$DC
39687 FD85                        00            .byte	0
39688                                           ! 8141  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
39689 FD86                        00            .byte	0
39690 FD87                        00            .byte	0
39691 FD88                        78            .byte	$78
39692 FD89                        CC            .byte	$CC
39693 FD8A                        C0            .byte	$C0
39694 FD8B                        CC            .byte	$CC
39695 FD8C                        78            .byte	$78
39696 FD8D                        00            .byte	0
39697                                           ! 8142  0x1c, 0x0c, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
39698 FD8E                        1C            .byte	$1C
39699 FD8F                        0C            .byte	$C
39700 FD90                        0C            .byte	$C
39701 FD91                        7C            .byte	$7C
39702 FD92                        CC            .byte	$CC
39703 FD93                        CC            .byte	$CC
39704 FD94                        76            .byte	$76
39705 FD95                        00            .byte	0
39706                                           ! 8143  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
39707 FD96                        00            .byte	0
39708 FD97                        00            .byte	0
39709 FD98                        78            .byte	$78
39710 FD99                        CC            .byte	$CC
39711 FD9A                        FC            .byte	$FC
39712 FD9B                        C0            .byte	$C0
39713 FD9C                        78            .byte	$78
39714 FD9D                        00            .byte	0
39715                                           ! 8144  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
39716 FD9E                        38            .byte	$38
39717 FD9F                        6C            .byte	$6C
39718 FDA0                        60            .byte	$60
39719 FDA1                        F0            .byte	$F0
39720 FDA2                        60            .byte	$60
39721 FDA3                        60            .byte	$60
39722 FDA4                        F0            .byte	$F0
39723 FDA5                        00            .byte	0
39724                                           ! 8145  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
39725 FDA6                        00            .byte	0
39726 FDA7                        00            .byte	0
39727 FDA8                        76            .byte	$76
39728 FDA9                        CC            .byte	$CC
39729 FDAA                        CC            .byte	$CC
39730 FDAB                        7C            .byte	$7C
39731 FDAC                        0C            .byte	$C
39732 FDAD                        F8            .byte	$F8
39733                                           ! 8146  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x0
39734 FDAE                        E0            .byte	$E0
39735 FDAF                        60            .byte	$60
39736 FDB0                        6C            .byte	$6C
39737 FDB1                        76            .byte	$76
39738 FDB2                        66            .byte	$66
39739 FDB3                        66            .byte	$66
39740 FDB4                        E6            .byte	$E6
39741                                           ! 8146 0,
39742 FDB5                        00            .byte	0
39743                                           ! 8147  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
39744 FDB6                        30            .byte	$30
39745 FDB7                        00            .byte	0
39746 FDB8                        70            .byte	$70
39747 FDB9                        30            .byte	$30
39748 FDBA                        30            .byte	$30
39749 FDBB                        30            .byte	$30
39750 FDBC                        78            .byte	$78
39751 FDBD                        00            .byte	0
39752                                           ! 8148  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
39753 FDBE                        0C            .byte	$C
39754 FDBF                        00            .byte	0
39755 FDC0                        0C            .byte	$C
39756 FDC1                        0C            .byte	$C
39757 FDC2                        0C            .byte	$C
39758 FDC3                        CC            .byte	$CC
39759 FDC4                        CC            .byte	$CC
39760 FDC5                        78            .byte	$78
39761                                           ! 8149  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
39762 FDC6                        E0            .byte	$E0
39763 FDC7                        60            .byte	$60
39764 FDC8                        66            .byte	$66
39765 FDC9                        6C            .byte	$6C
39766 FDCA                        78            .byte	$78
39767 FDCB                        6C            .byte	$6C
39768 FDCC                        E6            .byte	$E6
39769 FDCD                        00            .byte	0
39770                                           ! 8150  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
39771 FDCE                        70            .byte	$70
39772 FDCF                        30            .byte	$30
39773 FDD0                        30            .byte	$30
39774 FDD1                        30            .byte	$30
39775 FDD2                        30            .byte	$30
39776 FDD3                        30            .byte	$30
39777 FDD4                        78            .byte	$78
39778 FDD5                        00            .byte	0
39779                                           ! 8151  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
39780 FDD6                        00            .byte	0
39781 FDD7                        00            .byte	0
39782 FDD8                        CC            .byte	$CC
39783 FDD9                        FE            .byte	$FE
39784 FDDA                        FE            .byte	$FE
39785 FDDB                        D6            .byte	$D6
39786 FDDC                        C6            .byte	$C6
39787 FDDD                        00            .byte	0
39788                                           ! 8152  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
39789 FDDE                        00            .byte	0
39790 FDDF                        00            .byte	0
39791 FDE0                        F8            .byte	$F8
39792 FDE1                        CC            .byte	$CC
39793 FDE2                        CC            .byte	$CC
39794 FDE3                        CC            .byte	$CC
39795 FDE4                        CC            .byte	$CC
39796 FDE5                        00            .byte	0
39797                                           ! 8153  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
39798 FDE6                        00            .byte	0
39799 FDE7                        00            .byte	0
39800 FDE8                        78            .byte	$78
39801 FDE9                        CC            .byte	$CC
39802 FDEA                        CC            .byte	$CC
39803 FDEB                        CC            .byte	$CC
39804 FDEC                        78            .byte	$78
39805 FDED                        00            .byte	0
39806                                           ! 8154  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
39807 FDEE                        00            .byte	0
39808 FDEF                        00            .byte	0
39809 FDF0                        DC            .byte	$DC
39810 FDF1                        66            .byte	$66
39811 FDF2                        66            .byte	$66
39812 FDF3                        7C            .byte	$7C
39813 FDF4                        60            .byte	$60
39814 FDF5                        F0            .byte	$F0
39815                                           ! 8155  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
39816 FDF6                        00            .byte	0
39817 FDF7                        00            .byte	0
39818 FDF8                        76            .byte	$76
39819 FDF9                        CC            .byte	$CC
39820 FDFA                        CC            .byte	$CC
39821 FDFB                        7C            .byte	$7C
39822 FDFC                        0C            .byte	$C
39823 FDFD                        1E            .byte	$1E
39824                                           ! 8156  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
39825 FDFE                        00            .byte	0
39826 FDFF                        00            .byte	0
39827 FE00                        DC            .byte	$DC
39828 FE01                        76            .byte	$76
39829 FE02                        66            .byte	$66
39830 FE03                        60            .byte	$60
39831 FE04                        F0            .byte	$F0
39832 FE05                        00            .byte	0
39833                                           ! 8157  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
39834 FE06                        00            .byte	0
39835 FE07                        00            .byte	0
39836 FE08                        7C            .byte	$7C
39837 FE09                        C0            .byte	$C0
39838 FE0A                        78            .byte	$78
39839 FE0B                        0C            .byte	$C
39840 FE0C                        F8            .byte	$F8
39841 FE0D                        00            .byte	0
39842                                           ! 8158  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
39843 FE0E                        10            .byte	$10
39844 FE0F                        30            .byte	$30
39845 FE10                        7C            .byte	$7C
39846 FE11                        30            .byte	$30
39847 FE12                        30            .byte	$30
39848 FE13                        34            .byte	$34
39849 FE14                        18            .byte	$18
39850 FE15                        00            .byte	0
39851                                           ! 8159  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
39852 FE16                        00            .byte	0
39853 FE17                        00            .byte	0
39854 FE18                        CC            .byte	$CC
39855 FE19                        CC            .byte	$CC
39856 FE1A                        CC            .byte	$CC
39857 FE1B                        CC            .byte	$CC
39858 FE1C                        76            .byte	$76
39859 FE1D                        00            .byte	0
39860                                           ! 8160  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
39861 FE1E                        00            .byte	0
39862 FE1F                        00            .byte	0
39863 FE20                        CC            .byte	$CC
39864 FE21                        CC            .byte	$CC
39865 FE22                        CC            .byte	$CC
39866 FE23                        78            .byte	$78
39867 FE24                        30            .byte	$30
39868 FE25                        00            .byte	0
39869                                           ! 8161  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
39870 FE26                        00            .byte	0
39871 FE27                        00            .byte	0
39872 FE28                        C6            .byte	$C6
39873 FE29                        D6            .byte	$D6
39874 FE2A                        FE            .byte	$FE
39875 FE2B                        FE            .byte	$FE
39876 FE2C                        6C            .byte	$6C
39877 FE2D                        00            .byte	0
39878                                           ! 8162  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
39879 FE2E                        00            .byte	0
39880 FE2F                        00            .byte	0
39881 FE30                        C6            .byte	$C6
39882 FE31                        6C            .byte	$6C
39883 FE32                        38            .byte	$38
39884 FE33                        6C            .byte	$6C
39885 FE34                        C6            .byte	$C6
39886 FE35                        00            .byte	0
39887                                           ! 8163  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
39888 FE36                        00            .byte	0
39889 FE37                        00            .byte	0
39890 FE38                        CC            .byte	$CC
39891 FE39                        CC            .byte	$CC
39892 FE3A                        CC            .byte	$CC
39893 FE3B                        7C            .byte	$7C
39894 FE3C                        0C            .byte	$C
39895 FE3D                        F8            .byte	$F8
39896                                           ! 8164  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
39897 FE3E                        00            .byte	0
39898 FE3F                        00            .byte	0
39899 FE40                        FC            .byte	$FC
39900 FE41                        98            .byte	$98
39901 FE42                        30            .byte	$30
39902 FE43                        64            .byte	$64
39903 FE44                        FC            .byte	$FC
39904 FE45                        00            .byte	0
39905                                           ! 8165  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
39906 FE46                        1C            .byte	$1C
39907 FE47                        30            .byte	$30
39908 FE48                        30            .byte	$30
39909 FE49                        E0            .byte	$E0
39910 FE4A                        30            .byte	$30
39911 FE4B                        30            .byte	$30
39912 FE4C                        1C            .byte	$1C
39913 FE4D                        00            .byte	0
39914                                           ! 8166  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
39915 FE4E                        18            .byte	$18
39916 FE4F                        18            .byte	$18
39917 FE50                        18            .byte	$18
39918 FE51                        00            .byte	0
39919 FE52                        18            .byte	$18
39920 FE53                        18            .byte	$18
39921 FE54                        18            .byte	$18
39922 FE55                        00            .byte	0
39923                                           ! 8167  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
39924 FE56                        E0            .byte	$E0
39925 FE57                        30            .byte	$30
39926 FE58                        30            .byte	$30
39927 FE59                        1C            .byte	$1C
39928 FE5A                        30            .byte	$30
39929 FE5B                        30            .byte	$30
39930 FE5C                        E0            .byte	$E0
39931 FE5D                        00            .byte	0
39932                                           ! 8168  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
39933 FE5E                        76            .byte	$76
39934 FE5F                        DC            .byte	$DC
39935 FE60                        00            .byte	0
39936 FE61                        00            .byte	0
39937 FE62                        00            .byte	0
39938 FE63                        00            .byte	0
39939 FE64                        00            .byte	0
39940 FE65                        00            .byte	0
39941                                           ! 8169  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
39942 FE66                        00            .byte	0
39943 FE67                        10            .byte	$10
39944 FE68                        38            .byte	$38
39945 FE69                        6C            .byte	$6C
39946 FE6A                        C6            .byte	$C6
39947 FE6B                        C6            .byte	$C6
39948 FE6C                        FE            .byte	$FE
39949 FE6D                        00            .byte	0
39950                                           ! 8170 };
39951                                           !BCC_EOS
39952                                           ! 8171 #asm
39953                                           !BCC_ASM
39954 CB00                                      .org 0xcb00
39955                       0000CB00            jmptable:
39956 CB00                        5F            db 0x5F, 0x5F, 0x5F, 0x4A, 0x4D, 0x50, 0x54 ;; ___JMPT
39957 CB07                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 64 bytes
39958 CB47                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 128 bytes
39959 CB87                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 192 bytes
39960 CC00                                      .org 0xcc00
39961 CC00                        5F            db 0x5F, 0x5F, 0x5F, 0x48, 0x56, 0x4D, 0x4D, 0x50 ;; ___HVMMP
39962 CC08                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 64 bytes
39963 CC48                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 128 bytes
39964 CC88                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 192 bytes
39965 CCC8                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 256 bytes
39966 CD08                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 320 bytes
39967 CD48                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 384 bytes
39968 CD88                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 448 bytes
39969 CDC8                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 512 bytes
39970 CE08                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 576 bytes
39971 CE48                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 640 bytes
39972 CE88                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 704 bytes
39973 CEC8                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 768 bytes
39974 CF08                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 832 bytes
39975 CF48                      0000            dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;; 896 bytes
39976 CF88                  00000010            .align 16
39977                       0000CF90            smbios_entry_point:
39978 CF90                        00            db 0,0,0,0,0,0,0,0 ; 8 bytes
39979 CF98                        00            db 0,0,0,0,0,0,0,0 ; 16 bytes
39980 CFA0                        00            db 0,0,0,0,0,0,0,0 ; 24 bytes
39981 CFA8                        00            db 0,0,0,0,0,0,0 ; 31 bytes
39982                                           ! 8200 endasm
39983                                           !BCC_ENDASM
39984                                           ! 8201 
39985                       0000CFAF            .6F9:
39986                       0000CFAF            .71E:
39987 CFAF                        50            .ascii	"PCI device %04x:%04x not found"
39988 CFCD                        0A            .byte	$A
39989 CFCE                        00            .byte	0
39990                       0000CFCF            .6F5:
39991                       0000CFCF            .71F:
39992 CFCF                        62            .ascii	"bad PCI vendor ID %04x"
39993 CFE5                        0A            .byte	$A
39994 CFE6                        00            .byte	0
39995                       0000CFE7            .6F1:
39996                       0000CFE7            .720:
39997 CFE7                        75            .ascii	"unsupported PCI BIOS function 0x%02x"
39998 D00B                        0A            .byte	$A
39999 D00C                        00            .byte	0
40000                       0000D00D            .6ED:
40001                       0000D00D            .721:
40002 D00D                        50            .ascii	"PCI BIOS: PCI not present"
40003 D026                        0A            .byte	$A
40004 D027                        00            .byte	0
40005                       0000D028            .6BE:
40006                       0000D028            .722:
40007 D028                        49            .ascii	"Invalid boot device (0x%x)"
40008 D042                        0A            .byte	$A
40009 D043                        00            .byte	0
40010                       0000D044            .6BB:
40011                       0000D044            .723:
40012 D044                        4E            .ascii	"No bootable device."
40013 D057                        0A            .byte	$A
40014 D058                        00            .byte	0
40015                       0000D059            .6A8:
40016                       0000D059            .724:
40017 D059                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
40018 D07E                        0A            .byte	$A
40019 D07F                        00            .byte	0
40020                       0000D080            .6A3:
40021                       0000D080            .725:
40022 D080                        69            .ascii	"int13_diskette: unsupported AH=%02x"
40023 D0A3                        0A            .byte	$A
40024 D0A4                        00            .byte	0
40025                       0000D0A5            .691:
40026                       0000D0A5            .726:
40027 D0A5                        66            .ascii	"floppy: int13: bad floppy type"
40028 D0C3                        0A            .byte	$A
40029 D0C4                        00            .byte	0
40030                       0000D0C5            .679:
40031                       0000D0C5            .727:
40032 D0C5                        69            .ascii	"int13_diskette_function: write error"
40033 D0E9                        0A            .byte	$A
40034 D0EA                        00            .byte	0
40035                       0000D0EB            .673:
40036                       0000D0EB            .728:
40037 D0EB                        69            .ascii	"int13_diskette: ctrl not ready"
40038 D109                        0A            .byte	$A
40039 D10A                        00            .byte	0
40040                       0000D10B            .66C:
40041                       0000D10B            .729:
40042 D10B                        69            .ascii	"int13_diskette:f05: ctrl not ready"
40043 D12D                        0A            .byte	$A
40044 D12E                        00            .byte	0
40045                       0000D12F            .654:
40046                       0000D12F            .72A:
40047 D12F                        69            .ascii	"int13_diskette_function: read error"
40048 D152                        0A            .byte	$A
40049 D153                        00            .byte	0
40050                       0000D154            .64E:
40051                       0000D154            .72B:
40052 D154                        69            .ascii	"int13_diskette: ctrl not ready"
40053 D172                        0A            .byte	$A
40054 D173                        00            .byte	0
40055                       0000D174            .647:
40056                       0000D174            .72C:
40057 D174                        69            .ascii	"int13_diskette:f03: ctrl not ready"
40058 D196                        0A            .byte	$A
40059 D197                        00            .byte	0
40060                       0000D198            .638:
40061                       0000D198            .72D:
40062 D198                        69            .ascii	"int13_diskette: ctrl not ready"
40063 D1B6                        0A            .byte	$A
40064 D1B7                        00            .byte	0
40065                       0000D1B8            .631:
40066                       0000D1B8            .72E:
40067 D1B8                        69            .ascii	"int13_diskette:f02: ctrl not ready"
40068 D1DA                        0A            .byte	$A
40069 D1DB                        00            .byte	0
40070                       0000D1DC            .61F:
40071                       0000D1DC            .72F:
40072 D1DC                        66            .ascii	"floppy: drive>1 || head>1 ..."
40073 D1F9                        0A            .byte	$A
40074 D1FA                        00            .byte	0
40075                       0000D1FB            .5FB:
40076                       0000D1FB            .730:
40077 D1FB                        66            .ascii	"floppy recal:f07: ctrl not ready"
40078 D21B                        0A            .byte	$A
40079 D21C                        00            .byte	0
40080                       0000D21D            .5C9:
40081                       0000D21D            .731:
40082 D21D                        69            .ascii	"int13_cdemu function AH=%02x unsupported"
40083 D245                        2C            .ascii	", returns fail"
40084 D253                        0A            .byte	$A
40085 D254                        00            .byte	0
40086                       0000D255            .5B1:
40087                       0000D255            .732:
40088 D255                        69            .ascii	"int13_cdemu: function %02x, error %02x !"
40089 D27D                        0A            .byte	$A
40090 D27E                        00            .byte	0
40091                       0000D27F            .593:
40092                       0000D27F            .733:
40093 D27F                        69            .ascii	"int13_cdemu: function %02x, emulation no"
40094 D2A7                        74            .ascii	"t active for DL= %02x"
40095 D2BC                        0A            .byte	$A
40096 D2BD                        00            .byte	0
40097                       0000D2BE            .58F:
40098                       0000D2BE            .734:
40099 D2BE                        69            .ascii	"int13_eltorito: unsupported AH=%02x"
40100 D2E1                        0A            .byte	$A
40101 D2E2                        00            .byte	0
40102                       0000D2E3            .58A:
40103                       0000D2E3            .735:
40104 D2E3                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
40105 D30B                        20            .ascii	" report"
40106 D312                        0A            .byte	$A
40107 D313                        00            .byte	0
40108                       0000D314            .57F:
40109                       0000D314            .736:
40110 D314                        69            .ascii	"int13_cdrom: unsupported AH=%02x"
40111 D334                        0A            .byte	$A
40112 D335                        00            .byte	0
40113                       0000D336            .538:
40114                       0000D336            .737:
40115 D336                        69            .ascii	"int13_cdrom: function %02x, status %02x "
40116 D35E                        21            .ascii	"!"
40117 D35F                        0A            .byte	$A
40118 D360                        00            .byte	0
40119                       0000D361            .532:
40120                       0000D361            .738:
40121 D361                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
40122 D389                        62            .ascii	"bits lba"
40123 D391                        0A            .byte	$A
40124 D392                        00            .byte	0
40125                       0000D393            .518:
40126                       0000D393            .739:
40127 D393                        69            .ascii	"int13_cdrom: function %02x, unmapped dev"
40128 D3BB                        69            .ascii	"ice for ELDL=%02x"
40129 D3CC                        0A            .byte	$A
40130 D3CD                        00            .byte	0
40131                       0000D3CE            .515:
40132                       0000D3CE            .73A:
40133 D3CE                        69            .ascii	"int13_cdrom: function %02x, ELDL out of "
40134 D3F6                        72            .ascii	"range %02x"
40135 D400                        0A            .byte	$A
40136 D401                        00            .byte	0
40137                       0000D402            .50D:
40138                       0000D402            .73B:
40139 D402                        69            .ascii	"int13_harddisk function %02xh unsupporte"
40140 D42A                        64            .ascii	"d, returns fail"
40141 D439                        0A            .byte	$A
40142 D43A                        00            .byte	0
40143                       0000D43B            .507:
40144                       0000D43B            .73C:
40145 D43B                        69            .ascii	"int13h_harddisk function %02xh unimpleme"
40146 D463                        6E            .ascii	"nted, returns success"
40147 D478                        0A            .byte	$A
40148 D479                        00            .byte	0
40149                       0000D47A            .4D0:
40150                       0000D47A            .73D:
40151 D47A                        69            .ascii	"int13_harddisk: function %02x, error %02"
40152 D4A2                        78            .ascii	"x !"
40153 D4A5                        0A            .byte	$A
40154 D4A6                        00            .byte	0
40155                       0000D4A7            .4C7:
40156                       0000D4A7            .73E:
40157 D4A7                        69            .ascii	"int13_harddisk: function %02x. LBA out o"
40158 D4CF                        66            .ascii	"f range"
40159 D4D6                        0A            .byte	$A
40160 D4D7                        00            .byte	0
40161                       0000D4D8            .4C4:
40162                       0000D4D8            .73F:
40163 D4D8                        69            .ascii	"int13_harddisk: function %02x. Can't use"
40164 D500                        20            .ascii	" 64bits lba"
40165 D50B                        0A            .byte	$A
40166 D50C                        00            .byte	0
40167                       0000D50D            .4B6:
40168                       0000D50D            .740:
40169 D50D                        66            .ascii	"format disk track called"
40170 D525                        0A            .byte	$A
40171 D526                        00            .byte	0
40172                       0000D527            .4B4:
40173                       0000D527            .741:
40174 D527                        69            .ascii	"int13_harddisk: function %02x, error %02"
40175 D54F                        78            .ascii	"x !"
40176 D552                        0A            .byte	$A
40177 D553                        00            .byte	0
40178                       0000D554            .4A9:
40179                       0000D554            .742:
40180 D554                        69            .ascii	"int13_harddisk: function %02x, parameter"
40181 D57C                        73            .ascii	"s out of range %04x/%04x/%04x!"
40182 D59A                        0A            .byte	$A
40183 D59B                        00            .byte	0
40184                       0000D59C            .4A4:
40185                       0000D59C            .743:
40186 D59C                        69            .ascii	"int13_harddisk: function %02x, count out"
40187 D5C4                        20            .ascii	" of range!"
40188 D5CE                        0A            .byte	$A
40189 D5CF                        00            .byte	0
40190                       0000D5D0            .495:
40191                       0000D5D0            .744:
40192 D5D0                        69            .ascii	"int13_harddisk: function %02x, unmapped "
40193 D5F8                        64            .ascii	"device for ELDL=%02x"
40194 D60C                        0A            .byte	$A
40195 D60D                        00            .byte	0
40196                       0000D60E            .492:
40197                       0000D60E            .745:
40198 D60E                        69            .ascii	"int13_harddisk: function %02x, ELDL out "
40199 D636                        6F            .ascii	"of range %02x"
40200 D643                        0A            .byte	$A
40201 D644                        00            .byte	0
40202                       0000D645            .481:
40203                       0000D645            .746:
40204 D645                        4B            .ascii	"KBD: int09h_handler(): scancode & asciic"
40205 D66D                        6F            .ascii	"ode are zero?"
40206 D67A                        0A            .byte	$A
40207 D67B                        00            .byte	0
40208                       0000D67C            .46E:
40209                       0000D67C            .747:
40210 D67C                        4B            .ascii	"KBD: int09h_handler(): unknown scancode "
40211 D6A4                        28            .ascii	"(%x) read!"
40212 D6AE                        0A            .byte	$A
40213 D6AF                        00            .byte	0
40214                       0000D6B0            .444:
40215                       0000D6B0            .748:
40216 D6B0                        4B            .ascii	"KBD: int09 handler: AL=0"
40217 D6C8                        0A            .byte	$A
40218 D6C9                        00            .byte	0
40219                       0000D6CA            .441:
40220                       0000D6CA            .749:
40221 D6CA                        73            .ascii	"setkbdcomm"
40222 D6D4                        00            .byte	0
40223                       0000D6D5            .43A:
40224                       0000D6D5            .74A:
40225 D6D5                        73            .ascii	"sendmouse"
40226 D6DE                        00            .byte	0
40227                       0000D6DF            .437:
40228                       0000D6DF            .74B:
40229 D6DF                        65            .ascii	"enabmouse"
40230 D6E8                        00            .byte	0
40231                       0000D6E9            .430:
40232                       0000D6E9            .74C:
40233 D6E9                        65            .ascii	"enabmouse"
40234 D6F2                        00            .byte	0
40235                       0000D6F3            .42D:
40236                       0000D6F3            .74D:
40237 D6F3                        69            .ascii	"inhibmouse"
40238 D6FD                        00            .byte	0
40239                       0000D6FE            .426:
40240                       0000D6FE            .74E:
40241 D6FE                        69            .ascii	"inhibmouse"
40242 D708                        00            .byte	0
40243                       0000D709            .419:
40244                       0000D709            .74F:
40245 D709                        4B            .ascii	"KBD: unsupported int 16h function %02x"
40246 D72F                        0A            .byte	$A
40247 D730                        00            .byte	0
40248                       0000D731            .408:
40249                       0000D731            .750:
40250 D731                        4B            .ascii	"KBD: int16h: out of keyboard input"
40251 D753                        0A            .byte	$A
40252 D754                        00            .byte	0
40253                       0000D755            .3DA:
40254                       0000D755            .751:
40255 D755                        4B            .ascii	"KBD: int16h: out of keyboard input"
40256 D777                        0A            .byte	$A
40257 D778                        00            .byte	0
40258                       0000D779            .3D3:
40259                       0000D779            .752:
40260 D779                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
40261 D7A1                        74            .ascii	"t yet supported!"
40262 D7B1                        0A            .byte	$A
40263 D7B2                        00            .byte	0
40264                       0000D7B3            .3A2:
40265                       0000D7B3            .753:
40266 D7B3                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
40267 D7DB                        74            .ascii	"t yet supported!"
40268 D7EB                        0A            .byte	$A
40269 D7EC                        00            .byte	0
40270                       0000D7ED            .396:
40271                       0000D7ED            .754:
40272 D7ED                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
40273 D805                        0A            .byte	$A
40274 D806                        00            .byte	0
40275                       0000D807            .380:
40276                       0000D807            .755:
40277 D807                        4D            .ascii	"Mouse status returned %02x (should be ac"
40278 D82F                        6B            .ascii	"k)"
40279 D831                        0A            .byte	$A
40280 D832                        00            .byte	0
40281                       0000D833            .357:
40282                       0000D833            .756:
40283 D833                        4D            .ascii	"Mouse reset returned %02x (should be ack"
40284 D85B                        29            .ascii	")"
40285 D85C                        0A            .byte	$A
40286 D85D                        00            .byte	0
40287                       0000D85E            .330:
40288                       0000D85E            .757:
40289 D85E                        2A            .ascii	"*** int 15h function AX=%04x, BX=%04x no"
40290 D886                        74            .ascii	"t yet supported!"
40291 D896                        0A            .byte	$A
40292 D897                        00            .byte	0
40293                       0000D898            .32E:
40294                       0000D898            .758:
40295 D898                        45            .ascii	"EISA BIOS not present"
40296 D8AD                        0A            .byte	$A
40297 D8AE                        00            .byte	0
40298                       0000D8AF            .32A:
40299                       0000D8AF            .759:
40300 D8AF                        2A            .ascii	"*** int 15h function AH=bf not yet suppo"
40301 D8D7                        72            .ascii	"rted!"
40302 D8DC                        0A            .byte	$A
40303 D8DD                        00            .byte	0
40304                       0000D8DE            .313:
40305                       0000D8DE            .75A:
40306 D8DE                        69            .ascii	"int15: Func 24h, subfunc %02xh, A20 gate"
40307 D906                        20            .ascii	" control not supported"
40308 D91C                        0A            .byte	$A
40309 D91D                        00            .byte	0
40310                       0000D91E            .258:
40311                       0000D91E            .75B:
40312 D91E                        61            .ascii	"ata_cmd_packet: DATA_OUT not supported y"
40313 D946                        65            .ascii	"et"
40314 D948                        0A            .byte	$A
40315 D949                        00            .byte	0
40316                       0000D94A            .1F5:
40317                       0000D94A            .75C:
40318 D94A                        0A            .byte	$A
40319 D94B                        00            .byte	0
40320                       0000D94C            .1F0:
40321                       0000D94C            .75D:
40322 D94C                        6D            .ascii	"master"
40323 D952                        00            .byte	0
40324                       0000D953            .1EF:
40325                       0000D953            .75E:
40326 D953                        20            .ascii	" slave"
40327 D959                        00            .byte	0
40328                       0000D95A            .1EE:
40329                       0000D95A            .75F:
40330 D95A                        61            .ascii	"ata%d %s: Unknown device"
40331 D972                        0A            .byte	$A
40332 D973                        00            .byte	0
40333                       0000D974            .1EC:
40334                       0000D974            .760:
40335 D974                        20            .ascii	" ATAPI-%d Device"
40336 D984                        0A            .byte	$A
40337 D985                        00            .byte	0
40338                       0000D986            .1EA:
40339                       0000D986            .761:
40340 D986                        20            .ascii	" ATAPI-%d CD-Rom/DVD-Rom"
40341 D99E                        0A            .byte	$A
40342 D99F                        00            .byte	0
40343                       0000D9A0            .1E6:
40344                       0000D9A0            .762:
40345 D9A0                        25            .ascii	"%c"
40346 D9A2                        00            .byte	0
40347                       0000D9A3            .1DF:
40348                       0000D9A3            .763:
40349 D9A3                        6D            .ascii	"master"
40350 D9A9                        00            .byte	0
40351                       0000D9AA            .1DE:
40352                       0000D9AA            .764:
40353 D9AA                        20            .ascii	" slave"
40354 D9B0                        00            .byte	0
40355                       0000D9B1            .1DD:
40356                       0000D9B1            .765:
40357 D9B1                        61            .ascii	"ata%d %s: "
40358 D9BB                        00            .byte	0
40359                       0000D9BC            .1DB:
40360                       0000D9BC            .766:
40361 D9BC                        20            .ascii	" ATA-%d Hard-Disk (%04u GBytes)"
40362 D9DB                        0A            .byte	$A
40363 D9DC                        00            .byte	0
40364                       0000D9DD            .1D9:
40365                       0000D9DD            .767:
40366 D9DD                        20            .ascii	" ATA-%d Hard-Disk (%04u MBytes)"
40367 D9FC                        0A            .byte	$A
40368 D9FD                        00            .byte	0
40369                       0000D9FE            .1D5:
40370                       0000D9FE            .768:
40371 D9FE                        25            .ascii	"%c"
40372 DA00                        00            .byte	0
40373                       0000DA01            .1CE:
40374                       0000DA01            .769:
40375 DA01                        6D            .ascii	"master"
40376 DA07                        00            .byte	0
40377                       0000DA08            .1CD:
40378                       0000DA08            .76A:
40379 DA08                        20            .ascii	" slave"
40380 DA0E                        00            .byte	0
40381                       0000DA0F            .1CC:
40382                       0000DA0F            .76B:
40383 DA0F                        61            .ascii	"ata%d %s: "
40384 DA19                        00            .byte	0
40385                       0000DA1A            .1A8:
40386                       0000DA1A            .76C:
40387 DA1A                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
40388 DA42                        65            .ascii	"e"
40389 DA43                        0A            .byte	$A
40390 DA44                        00            .byte	0
40391                       0000DA45            .1A3:
40392                       0000DA45            .76D:
40393 DA45                        20            .ascii	" LCHS=%d/%d/%d"
40394 DA53                        0A            .byte	$A
40395 DA54                        00            .byte	0
40396                       0000DA55            .183:
40397                       0000DA55            .76E:
40398 DA55                        72            .ascii	"r-echs"
40399 DA5B                        00            .byte	0
40400                       0000DA5C            .181:
40401                       0000DA5C            .76F:
40402 DA5C                        6C            .ascii	"large"
40403 DA61                        00            .byte	0
40404                       0000DA62            .17F:
40405                       0000DA62            .770:
40406 DA62                        6C            .ascii	"lba"
40407 DA65                        00            .byte	0
40408                       0000DA66            .17D:
40409                       0000DA66            .771:
40410 DA66                        6E            .ascii	"none"
40411 DA6A                        00            .byte	0
40412                       0000DA6B            .173:
40413                       0000DA6B            .772:
40414 DA6B                        61            .ascii	"ata%d-%d: PCHS=%u/%d/%d translation="
40415 DA8F                        00            .byte	0
40416                       0000DA90            .16C:
40417                       0000DA90            .773:
40418 DA90                        61            .ascii	"ata-detect: Failed to detect ATA device"
40419 DAB7                        0A            .byte	$A
40420 DAB8                        00            .byte	0
40421                       0000DAB9            .137:
40422                       0000DAB9            .774:
40423 DAB9                        25            .ascii	"%s"
40424 DABB                        0A            .byte	$A
40425 DABC                        00            .byte	0
40426                       0000DABD            .136:
40427                       0000DABD            .775:
40428 DABD                        49            .ascii	"INT18: BOOT FAILURE"
40429 DAD0                        0A            .byte	$A
40430 DAD1                        00            .byte	0
40431                       0000DAD2            .135:
40432                       0000DAD2            .776:
40433 DAD2                        4E            .ascii	"NMI Handler called"
40434 DAE4                        0A            .byte	$A
40435 DAE5                        00            .byte	0
40436                       0000DAE6            .12A:
40437                       0000DAE6            .777:
40438 DAE6                        0A            .byte	$A,$A
40439 DAE8                        50            .ascii	"Press F10 to select boot device."
40440 DB08                        0A            .byte	$A
40441 DB09                        00            .byte	0
40442                       0000DB0A            .109:
40443                       0000DB0A            .778:
40444 DB0A                        0A            .byte	$A,$A
40445 DB0C                        20            .ascii	"          Currently selected: %d"
40446 DB2C                        0A            .byte	$A
40447 DB2D                        00            .byte	0
40448                       0000DB2E            .108:
40449                       0000DB2E            .779:
40450 DB2E                        20            .ascii	"            4. Network"
40451 DB44                        0A            .byte	$A
40452 DB45                        00            .byte	0
40453                       0000DB46            .105:
40454                       0000DB46            .77A:
40455 DB46                        20            .ascii	"            3. CD-ROM"
40456 DB5B                        0A            .byte	$A
40457 DB5C                        00            .byte	0
40458                       0000DB5D            .104:
40459                       0000DB5D            .77B:
40460 DB5D                        20            .ascii	"            2. Hard drive"
40461 DB76                        0A            .byte	$A
40462 DB77                        00            .byte	0
40463                       0000DB78            .103:
40464                       0000DB78            .77C:
40465 DB78                        20            .ascii	"            1. Floppy"
40466 DB8D                        0A            .byte	$A
40467 DB8E                        00            .byte	0
40468                       0000DB8F            .102:
40469                       0000DB8F            .77D:
40470 DB8F                        20            .ascii	"          Select boot device"
40471 DBAB                        0A            .byte	$A,$A
40472 DBAD                        00            .byte	0
40473                       0000DBAE            .101:
40474                       0000DBAE            .77E:
40475 DBAE                        0A            .byte	$A,$A,$A,$A,$A,$A,$A
40476 DBB5                        00            .byte	0
40477                       0000DBB6            .F7:
40478                       0000DBB6            .77F:
40479 DBB6                        4B            .ascii	"Key pressed: %x"
40480 DBC5                        0A            .byte	$A
40481 DBC6                        00            .byte	0
40482                       0000DBC7            .EC:
40483                       0000DBC7            .780:
40484 DBC7                        43            .ascii	"CDROM boot failure code : %04x"
40485 DBE5                        0A            .byte	$A
40486 DBE6                        00            .byte	0
40487                       0000DBE7            .EB:
40488                       0000DBE7            .781:
40489 DBE7                        0A            .byte	$A
40490 DBE8                        00            .byte	0
40491                       0000DBE9            .EA:
40492                       0000DBE9            .782:
40493 DBE9                        3A            .ascii	": could not read the boot disk"
40494 DC07                        00            .byte	0
40495                       0000DC08            .E8:
40496                       0000DC08            .783:
40497 DC08                        3A            .ascii	": not a bootable disk"
40498 DC1D                        00            .byte	0
40499                       0000DC1E            .E3:
40500                       0000DC1E            .784:
40501 DC1E                        42            .ascii	"Boot from %s failed"
40502 DC31                        00            .byte	0
40503                       0000DC32            .E2:
40504                       0000DC32            .785:
40505 DC32                        42            .ascii	"Bad drive type"
40506 DC40                        0A            .byte	$A
40507 DC41                        00            .byte	0
40508                       0000DC42            .DE:
40509                       0000DC42            .786:
40510 DC42                        42            .ascii	"Booting from %s..."
40511 DC54                        0A            .byte	$A
40512 DC55                        00            .byte	0
40513                       0000DC56            .DD:
40514                       0000DC56            .787:
40515 DC56                        42            .ascii	"Bad drive type"
40516 DC64                        0A            .byte	$A
40517 DC65                        00            .byte	0
40518                       0000DC66            .D0:
40519                       0000DC66            .788:
40520 DC66                        0A            .byte	$A
40521 DC67                        00            .byte	0
40522                       0000DC68            .CF:
40523                       0000DC68            .789:
40524 DC68                        54            .ascii	"TCG-enabled BIOS."
40525 DC79                        0A            .byte	$A
40526 DC7A                        00            .byte	0
40527                       0000DC7B            .CE:
40528                       0000DC7B            .78A:
40529 DC7B                        25            .ascii	"%s %s"
40530 DC80                        0A            .byte	$A
40531 DC81                        00            .byte	0
40532                       0000DC82            .CD:
40533                       0000DC82            .78B:
40534 DC82                        00            .byte	0
40535                       0000DC83            .CC:
40536                       0000DC83            .78C:
40537 DC83                        73            .ascii	"s"
40538 DC84                        00            .byte	0
40539                       0000DC85            .CB:
40540                       0000DC85            .78D:
40541 DC85                        48            .ascii	"HVMAssist BIOS, %d cpu%s, "
40542 DC9F                        00            .byte	0
40543                       0000DCA0            .CA:
40544                       0000DCA0            .78E:
40545 DCA0                        55            .ascii	"Unimplemented shutdown status: %02x"
40546 DCC3                        0A            .byte	$A
40547 DCC4                        00            .byte	0
40548                       0000DCC5            .C9:
40549                       0000DCC5            .78F:
40550 DCC5                        43            .ascii	"Couldn't reset the machine"
40551 DCDF                        0A            .byte	$A
40552 DCE0                        00            .byte	0
40553                       0000DCE1            .C8:
40554                       0000DCE1            .790:
40555 DCE1                        4B            .ascii	"Keyboard error:%u"
40556 DCF2                        0A            .byte	$A
40557 DCF3                        00            .byte	0
40558                       0000DCF4            .51:
40559                       0000DCF4            .791:
40560 DCF4                        62            .ascii	"bios_printf: unknown format"
40561 DD0F                        0A            .byte	$A
40562 DD10                        00            .byte	0
40563                       0000DD11            .28:
40564                       0000DD11            .792:
40565 DD11                        46            .ascii	"FATAL: "
40566 DD18                        00            .byte	0
40567 DD19                                      .bss
40568                                           
40569                                           ! 0 errors detected

Symbols:
..FFD8                      0 FFFC A   ..FFD9                      0 FFFC A   
..FFDA                      0 FFE2 A   ..FFDB                      0 FFE0 A   
..FFDC                      0 FFCA A   ..FFDD                      0 FFCA A   
..FFDE                      0 FFCA A   ..FFDF                      0 FFCA A   
..FFE0                      0 FFCA A   ..FFE1                      0 FFCA A   
..FFE2                      0 FFFC A   ..FFE3                      0 FFFC A   
..FFE4                      0 FFFC A   ..FFE5                      0 FFDE A   
..FFE6                      0 FFDE A   ..FFE7                      0 FFDE A   
..FFE8                      0 FFDE A   ..FFE9                      0 FFD2 A   
..FFEA                      0 FFDE A   ..FFEB                      0 FFDC A   
..FFEC                      0 FFDC A   ..FFED                      0 FFDC A   
..FFEE                      0 FFDC A   ..FFEF                      0 FFCE A   
..FFF0                      0 FFDC A   ..FFF1                      0 FFF8 A   
..FFF2                      0 FFF6 A   ..FFF3                      0 FFE6 A   
..FFF4                      0 FFE6 A   ..FFF5                      0 FFF0 A   
..FFF6                      0 FFEC A   ..FFF7                      0 FFF6 A   
..FFF8                      0 F7E2 A   ..FFF9                      0 FDBA A   
..FFFA                      0 FDBA A   ..FFFB                      0 FDDC A   
..FFFC                      0 FDDC A   ..FFFD                      0 FFFA A   
..FFFE                      0 FFFA A   ..FFFF                      0 FFFA A   
.1                          0 0164 A   .10                         0 07A1 A   
.100                        0 13F1 A   .101                        0 DBAE A   
.102                        0 DB8F A   .103                        0 DB78 A   
.104                        0 DB5D A   .105                        0 DB46 A   
.106                        0 145E A   .107                        0 1450 A   
.108                        0 DB2E A   .109                        0 DB0A A   
.10A                        0 1487 A   .10B                        0 1480 A   
.10C                        0 146F A   .10D                        0 1487 A   
.10E                        0 1512 A   .11                         0 0786 A   
.110                        0 14F4 A   .111                        0 148C A   
.112                        0 148C A   .113                        0 148C A   
.114                        0 1497 A   .115                        0 14AA A   
.116                        0 149F A   .117                        0 14AF A   
.118                        0 14B1 A   .119                        0 14C6 A   
.11A                        0 14C0 A   .11B                        0 14CD A   
.11C                        0 14E2 A   .11D                        0 14DC A   
.11E                        0 14E9 A   .11F                        0 14EB A   
.12                         0 0796 A   .120                        0 151B A   
.121                        0 1519 A   .122                        0 155D A   
.124                        0 1547 A   .125                        0 1523 A   
.126                        0 152A A   .127                        0 1531 A   
.128                        0 1538 A   .129                        0 153F A   
.12A                        0 DAE6 A   .12B                        0 15A8 A   
.12C                        0 1592 A   .12D                        0 1603 A   
.12F                        0 15F1 A   .13                         0 078D A   
.130                        0 15AD A   .131                        0 15BD A   
.132                        0 15CD A   .133                        0 15DD A   
.134                        0 15ED A   .135                        0 DAD2 A   
.136                        0 DABD A   .137                        0 DAB9 A   
.138                        0 166D A   .139                        0 1659 A   
.13A                        0 167F A   .13B                        0 168C A   
.13C                        0 168E A   .13D                        0 16D7 A   
.13E                        0 16D3 A   .13F                        0 16F1 A   
.14                         0 07D1 A   .140                        0 16ED A   
.141                        0 17B7 A   .142                        0 17A9 A   
.143                        0 17B0 A   .144                        0 1739 A   
.145                        0 17B7 A   .146                        0 1968 A   
.147                        0 1958 A   .148                        0 195F A   
.149                        0 17BF A   .14A                        0 1968 A   
.14B                        0 19AF A   .14C                        0 19A1 A   
.14D                        0 19A8 A   .14E                        0 196F A   
.14F                        0 19AF A   .15                         0 07BB A   
.150                        0 27A2 A   .151                        0 2792 A   
.152                        0 2799 A   .153                        0 1B09 A   
.154                        0 1B7C A   .155                        0 1B78 A   
.156                        0 1B7E A   .157                        0 1D43 A   
.158                        0 1C2D A   .159                        0 1C23 A   
.15A                        0 1C62 A   .15B                        0 1C5E A   
.15C                        0 1C64 A   .15D                        0 1D43 A   
.15E                        0 1CAA A   .15F                        0 1CA0 A   
.16                         0 07FF A   .160                        0 1D0D A   
.161                        0 1CED A   .162                        0 1CE5 A   
.163                        0 1D43 A   .164                        0 1D43 A   
.165                        0 1D25 A   .166                        0 1D1D A   
.167                        0 1D15 A   .168                        0 2299 A   
.169                        0 1D69 A   .16A                        0 1DEB A   
.16B                        0 1DDD A   .16C                        0 DA90 A   
.16D                        0 1E04 A   .16E                        0 1E00 A   
.16F                        0 1E06 A   .17                         0 07EB A   
.170                        0 1E21 A   .171                        0 1E1D A   
.172                        0 1E23 A   .173                        0 DA6B A   
.174                        0 1FEF A   .175                        0 1FDE A   
.176                        0 1FE7 A   .177                        0 1FD0 A   
.178                        0 1FEF A   .179                        0 2072 A   
.17B                        0 2062 A   .17C                        0 2020 A   
.17D                        0 DA66 A   .17E                        0 2030 A   
.17F                        0 DA62 A   .18                         0 07E0 A   
.180                        0 2040 A   .181                        0 DA5C A   
.182                        0 2050 A   .183                        0 DA55 A   
.184                        0 21F0 A   .186                        0 21DA A   
.187                        0 2079 A   .188                        0 207C A   
.189                        0 20D3 A   .18A                        0 20CA A   
.18B                        0 2110 A   .18C                        0 20E5 A   
.18D                        0 20DC A   .18E                        0 2110 A   
.18F                        0 20F7 A   .19                         0 07D3 A   
.190                        0 20EE A   .191                        0 2110 A   
.192                        0 2109 A   .193                        0 2100 A   
.194                        0 2110 A   .195                        0 2131 A   
.196                        0 21AC A   .197                        0 213A A   
.198                        0 2165 A   .199                        0 215E A   
.19A                        0 21AC A   .19B                        0 21D6 A   
.19C                        0 21CD A   .19D                        0 21AE A   
.19E                        0 21CD A   .19F                        0 21CB A   
.1A                         0 07EB A   .1A0                        0 21D6 A   
.1A1                        0 2200 A   .1A2                        0 21F9 A   
.1A3                        0 DA45 A   .1A4                        0 2422 A   
.1A5                        0 22A2 A   .1A6                        0 2324 A   
.1A7                        0 2316 A   .1A8                        0 DA1A A   
.1A9                        0 2352 A   .1AA                        0 234E A   
.1AB                        0 2354 A   .1AC                        0 236F A   
.1AD                        0 236B A   .1AE                        0 2371 A   
.1AF                        0 25D4 A   .1B                         0 07FF A   
.1B1                        0 25C8 A   .1B2                        0 242B A   
.1B3                        0 246D A   .1B4                        0 24CE A   
.1B5                        0 24BD A   .1B6                        0 24C6 A   
.1B7                        0 24A4 A   .1B8                        0 24BD A   
.1B9                        0 24BB A   .1BA                        0 24CE A   
.1BB                        0 255C A   .1BC                        0 2549 A   
.1BD                        0 2552 A   .1BE                        0 24D7 A   
.1BF                        0 255C A   .1C                         0 07F2 A   
.1C0                        0 25C4 A   .1C1                        0 25B3 A   
.1C2                        0 25BC A   .1C3                        0 2576 A   
.1C4                        0 25B1 A   .1C5                        0 2593 A   
.1C6                        0 25B3 A   .1C7                        0 25C4 A   
.1C8                        0 278C A   .1CA                        0 277C A   
.1CB                        0 25DA A   .1CC                        0 DA0F A   
.1CD                        0 DA08 A   .1CE                        0 DA01 A   
.1CF                        0 25E7 A   .1D                         0 0854 A   
.1D0                        0 25E2 A   .1D1                        0 25EA A   
.1D2                        0 2644 A   .1D3                        0 261D A   
.1D4                        0 2608 A   .1D5                        0 D9FE A   
.1D6                        0 2644 A   .1D7                        0 266D A   
.1D8                        0 2652 A   .1D9                        0 D9DD A   
.1DA                        0 2699 A   .1DB                        0 D9BC A   
.1DC                        0 269C A   .1DD                        0 D9B1 A   
.1DE                        0 D9AA A   .1DF                        0 D9A3 A   
.1E                         0 083E A   .1E0                        0 26A9 A   
.1E1                        0 26A4 A   .1E2                        0 26AC A   
.1E3                        0 2706 A   .1E4                        0 26DF A   
.1E5                        0 26CA A   .1E6                        0 D9A0 A   
.1E7                        0 2706 A   .1E8                        0 273B A   
.1E9                        0 2724 A   .1EA                        0 D986 A   
.1EB                        0 2750 A   .1EC                        0 D974 A   
.1ED                        0 2752 A   .1EE                        0 D95A A   
.1EF                        0 D953 A   .1F                         0 0882 A   
.1F0                        0 D94C A   .1F1                        0 275F A   
.1F2                        0 275A A   .1F3                        0 2762 A   
.1F4                        0 27A2 A   .1F5                        0 D94A A   
.1F6                        0 2893 A   .1F7                        0 2888 A   
.1F8                        0 2868 A   .1F9                        0 2886 A   
.1FA                        0 2882 A   .1FB                        0 2893 A   
.1FC                        0 293B A   .1FD                        0 28C0 A   
.1FE                        0 28CB A   .1FF                        0 28C7 A   
.2                          0 0177 A   .20                         0 086E A   
.200                        0 28CD A   .201                        0 293B A   
.202                        0 2908 A   .203                        0 2901 A   
.204                        0 293B A   .205                        0 2930 A   
.206                        0 2910 A   .207                        0 292E A   
.208                        0 292A A   .209                        0 293B A   
.20A                        0 296E A   .20B                        0 2963 A   
.20C                        0 2943 A   .20D                        0 2961 A   
.20E                        0 295D A   .20F                        0 296E A   
.21                         0 0863 A   .210                        0 2A1F A   
.211                        0 2A13 A   .212                        0 2A27 A   
.213                        0 2A6E A   .214                        0 2A67 A   
.215                        0 2BAB A   .216                        0 2A88 A   
.217                        0 2B5C A   .218                        0 2AB7 A   
.219                        0 2A90 A   .21A                        0 2C0B A   
.21B                        0 2C07 A   .21C                        0 2C0D A   
.21D                        0 2C4C A   .21E                        0 2C4A A   
.21F                        0 2C30 A   .22                         0 0856 A   
.220                        0 2C4A A   .221                        0 2C48 A   
.222                        0 2C4C A   .223                        0 2C5E A   
.224                        0 2C55 A   .225                        0 2C6E A   
.226                        0 2C6E A   .227                        0 2C67 A   
.228                        0 2D03 A   .229                        0 2D00 A   
.22A                        0 2C6F A   .22B                        0 2CEE A   
.22C                        0 2CDA A   .22D                        0 2CEA A   
.22E                        0 2CE3 A   .22F                        0 2D00 A   
.23                         0 086E A   .230                        0 2CFE A   
.231                        0 2CF7 A   .232                        0 2D03 A   
.233                        0 2DAF A   .234                        0 2DA3 A   
.235                        0 2DB7 A   .236                        0 2DFE A   
.237                        0 2DF7 A   .238                        0 2F3B A   
.239                        0 2E18 A   .23A                        0 2EEC A   
.23B                        0 2E47 A   .23C                        0 2E20 A   
.23D                        0 2F9B A   .23E                        0 2F97 A   
.23F                        0 2F9D A   .24                         0 0882 A   
.240                        0 2FDC A   .241                        0 2FDA A   
.242                        0 2FC0 A   .243                        0 2FDA A   
.244                        0 2FD8 A   .245                        0 2FDC A   
.246                        0 2FEE A   .247                        0 2FE5 A   
.248                        0 2FFE A   .249                        0 2FFE A   
.24A                        0 2FF7 A   .24B                        0 3095 A   
.24C                        0 3092 A   .24D                        0 2FFF A   
.24E                        0 3080 A   .24F                        0 306C A   
.25                         0 0875 A   .250                        0 307C A   
.251                        0 3075 A   .252                        0 3092 A   
.253                        0 3090 A   .254                        0 3089 A   
.255                        0 3095 A   .256                        0 30F1 A   
.257                        0 30DC A   .258                        0 D91E A   
.259                        0 3101 A   .25A                        0 30FA A   
.25B                        0 316A A   .25C                        0 3165 A   
.25D                        0 3176 A   .25E                        0 3171 A   
.25F                        0 31C2 A   .26                         0 08E9 A   
.260                        0 31BB A   .261                        0 3200 A   
.262                        0 31FC A   .263                        0 3202 A   
.264                        0 323F A   .265                        0 323D A   
.266                        0 3223 A   .267                        0 323D A   
.268                        0 323B A   .269                        0 323F A   
.26A                        0 3251 A   .26B                        0 3248 A   
.26C                        0 3261 A   .26D                        0 3261 A   
.26E                        0 325A A   .26F                        0 32A7 A   
.27                         0 08CE A   .270                        0 3295 A   
.271                        0 34C6 A   .272                        0 34C6 A   
.273                        0 34C3 A   .274                        0 32A7 A   
.275                        0 32C2 A   .276                        0 32BF A   
.277                        0 32D2 A   .278                        0 32CB A   
.279                        0 32E2 A   .27A                        0 32DB A   
.27B                        0 3341 A   .27C                        0 332B A   
.27D                        0 3355 A   .27E                        0 3382 A   
.27F                        0 3362 A   .28                         0 DD11 A   
.280                        0 33A3 A   .281                        0 33BD A   
.282                        0 33B8 A   .283                        0 33CB A   
.284                        0 33C6 A   .285                        0 33D9 A   
.286                        0 33D4 A   .287                        0 3400 A   
.288                        0 33E2 A   .289                        0 3400 A   
.28A                        0 33F9 A   .28B                        0 33F0 A   
.28C                        0 3427 A   .28D                        0 3407 A   
.28E                        0 343F A   .28F                        0 34C6 A   
.29                         0 0A7D A   .290                        0 34D6 A   
.291                        0 34CF A   .292                        0 3548 A   
.293                        0 3541 A   .294                        0 3569 A   
.295                        0 3551 A   .296                        0 35BE A   
.297                        0 35B7 A   .298                        0 361F A   
.299                        0 35CA A   .29A                        0 3613 A   
.29B                        0 360C A   .29C                        0 3648 A   
.29D                        0 3642 A   .29E                        0 366C A   
.29F                        0 3666 A   .2A                         0 0A67 A   
.2A0                        0 3690 A   .2A1                        0 368A A   
.2A2                        0 370F A   .2A3                        0 3715 A   
.2A4                        0 3772 A   .2A5                        0 3761 A   
.2A6                        0 376A A   .2A7                        0 374F A   
.2A8                        0 3761 A   .2A9                        0 375F A   
.2AA                        0 3772 A   .2AB                        0 3781 A   
.2AC                        0 377A A   .2AD                        0 37F8 A   
.2AE                        0 37F1 A   .2AF                        0 3807 A   
.2B                         0 08EC A   .2B0                        0 3800 A   
.2B1                        0 3853 A   .2B2                        0 3841 A   
.2B3                        0 384A A   .2B4                        0 380F A   
.2B5                        0 3841 A   .2B6                        0 383A A   
.2B7                        0 3853 A   .2B8                        0 38A1 A   
.2B9                        0 388F A   .2BA                        0 3898 A   
.2BB                        0 385B A   .2BC                        0 388F A   
.2BD                        0 3888 A   .2BE                        0 38A1 A   
.2BF                        0 39D9 A   .2C                         0 0901 A   
.2C0                        0 39D2 A   .2C1                        0 39E8 A   
.2C2                        0 39E1 A   .2C3                        0 39F7 A   
.2C4                        0 39F0 A   .2C5                        0 3A06 A   
.2C6                        0 39FF A   .2C7                        0 3A15 A   
.2C8                        0 3A0E A   .2C9                        0 3A24 A   
.2CA                        0 3A1D A   .2CB                        0 3A8A A   
.2CC                        0 3A77 A   .2CD                        0 3AB5 A   
.2CE                        0 3AA4 A   .2CF                        0 3A92 A   
.2D                         0 08F3 A   .2D0                        0 3AB5 A   
.2D1                        0 3B08 A   .2D2                        0 3B01 A   
.2D3                        0 3CCD A   .2D4                        0 3CC6 A   
.2D5                        0 3E37 A   .2D7                        0 3E1F A   
.2D8                        0 3CFF A   .2D9                        0 3D35 A   
.2DA                        0 3D6B A   .2DB                        0 3DA1 A   
.2DC                        0 3E9A A   .2DD                        0 3E48 A   
.2DE                        0 3E7C A   .2DF                        0 3E59 A   
.2E                         0 0A60 A   .2E0                        0 3E9A A   
.2E1                        0 3EBC A   .2E2                        0 3EAB A   
.2E3                        0 4138 A   .2E4                        0 3F15 A   
.2E5                        0 3F0C A   .2E6                        0 4136 A   
.2E8                        0 411E A   .2E9                        0 3F1B A   
.2EA                        0 3F60 A   .2EB                        0 3F42 A   
.2EC                        0 3F99 A   .2ED                        0 3FD7 A   
.2EE                        0 4029 A   .2EF                        0 4010 A   
.2F                         0 0A51 A   .2F0                        0 3FEA A   
.2F1                        0 4010 A   .2F2                        0 4003 A   
.2F3                        0 4029 A   .2F4                        0 4022 A   
.2F5                        0 403F A   .2F6                        0 4030 A   
.2F7                        0 405D A   .2F8                        0 4055 A   
.2F9                        0 4068 A   .2FA                        0 40BA A   
.2FB                        0 40A1 A   .2FC                        0 407B A   
.2FD                        0 40A1 A   .2FE                        0 4094 A   
.2FF                        0 40BA A   .3                          0 0194 A   
.30                         0 090A A   .300                        0 40B3 A   
.301                        0 40D3 A   .302                        0 40C1 A   
.303                        0 40E2 A   .304                        0 40EC A   
.305                        0 4114 A   .306                        0 4140 A   
.307                        0 467A A   .309                        0 4629 A   
.30A                        0 4163 A   .30B                        0 4208 A   
.30D                        0 41F2 A   .30E                        0 4169 A   
.30F                        0 4181 A   .31                         0 0939 A   
.310                        0 4199 A   .311                        0 41BA A   
.312                        0 41CF A   .313                        0 D8DE A   
.314                        0 420B A   .315                        0 421B A   
.316                        0 4226 A   .317                        0 4236 A   
.318                        0 4300 A   .319                        0 423F A   
.31A                        0 42F1 A   .31B                        0 4255 A   
.31C                        0 42FE A   .31D                        0 4354 A   
.31E                        0 4340 A   .31F                        0 4307 A   
.32                         0 0918 A   .320                        0 4354 A   
.321                        0 4357 A   .322                        0 4392 A   
.323                        0 438B A   .324                        0 4564 A   
.325                        0 458A A   .326                        0 4584 A   
.327                        0 4595 A   .328                        0 4598 A   
.329                        0 459B A   .32A                        0 D8AF A   
.32B                        0 45B9 A   .32C                        0 45D5 A   
.32D                        0 45E6 A   .32E                        0 D898 A   
.32F                        0 4604 A   .33                         0 0911 A   
.330                        0 D85E A   .331                        0 4C52 A   
.333                        0 4C4A A   .334                        0 469D A   
.335                        0 4C23 A   .337                        0 4BFE A   
.338                        0 46A3 A   .339                        0 47A0 A   
.33B                        0 4792 A   .33C                        0 46A9 A   
.33D                        0 46EA A   .33E                        0 46BF A   
.33F                        0 46EA A   .34                         0 0A4F A   
.340                        0 46D9 A   .341                        0 46D2 A   
.342                        0 46FF A   .343                        0 4729 A   
.344                        0 4718 A   .345                        0 476D A   
.346                        0 473F A   .347                        0 476D A   
.348                        0 4759 A   .349                        0 4752 A   
.34A                        0 477F A   .34B                        0 47A3 A   
.34C                        0 47A3 A   .34D                        0 4808 A   
.34E                        0 47AA A   .34F                        0 47C2 A   
.35                         0 09B5 A   .350                        0 47B1 A   
.351                        0 48A7 A   .352                        0 4820 A   
.353                        0 483F A   .354                        0 4833 A   
.355                        0 485A A   .356                        0 4846 A   
.357                        0 D833 A   .358                        0 48A7 A   
.359                        0 4861 A   .35A                        0 48A7 A   
.35B                        0 4874 A   .35C                        0 48A7 A   
.35D                        0 4887 A   .35E                        0 48B9 A   
.35F                        0 4919 A   .36                         0 0957 A   
.361                        0 48F6 A   .362                        0 48BE A   
.363                        0 48C5 A   .364                        0 48CC A   
.365                        0 48D3 A   .366                        0 48DA A   
.367                        0 48E1 A   .368                        0 48E8 A   
.369                        0 48EF A   .36A                        0 4917 A   
.36B                        0 4909 A   .36C                        0 4979 A   
.36D                        0 4922 A   .36E                        0 496A A   
.36F                        0 4935 A   .37                         0 0964 A   
.370                        0 4977 A   .371                        0 4986 A   
.372                        0 4989 A   .373                        0 4999 A   
.374                        0 49DC A   .375                        0 49AF A   
.376                        0 49E9 A   .377                        0 49EC A   
.378                        0 4B62 A   .37A                        0 4B4E A   
.37B                        0 49F2 A   .37C                        0 4AA4 A   
.37D                        0 4A0D A   .37E                        0 4A34 A   
.37F                        0 4A20 A   .38                         0 095E A   
.380                        0 D807 A   .381                        0 4AA4 A   
.382                        0 4A3D A   .383                        0 4AA4 A   
.384                        0 4A50 A   .385                        0 4AA4 A   
.386                        0 4A63 A   .387                        0 4AA4 A   
.388                        0 4A76 A   .389                        0 4AC1 A   
.38A                        0 4AC1 A   .38B                        0 4ADC A   
.38C                        0 4ACE A   .38D                        0 4AE8 A   
.38E                        0 4B08 A   .38F                        0 4AEF A   
.39                         0 09B2 A   .390                        0 4B03 A   
.391                        0 4B05 A   .392                        0 4B1E A   
.393                        0 4B0F A   .394                        0 4B2B A   
.395                        0 4B38 A   .396                        0 D7ED A   
.397                        0 4B65 A   .398                        0 4BC5 A   
.399                        0 4BAF A   .39A                        0 4BA8 A   
.39B                        0 4BC3 A   .39C                        0 4BB8 A   
.39D                        0 4BCD A   .39E                        0 4BEF A   
.39F                        0 4C21 A   .3A                         0 09A4 A   
.3A0                        0 4C11 A   .3A1                        0 4C25 A   
.3A2                        0 D7B3 A   .3A3                        0 4FCF A   
.3A5                        0 4FC1 A   .3A6                        0 4C6F A   
.3A7                        0 4CB0 A   .3A8                        0 4F9A A   
.3AA                        0 4F8C A   .3AB                        0 4CB6 A   
.3AC                        0 4CEB A   .3AD                        0 4CE5 A   
.3AE                        0 4D84 A   .3AF                        0 4D00 A   
.3B                         0 09AB A   .3B0                        0 4D26 A   
.3B1                        0 4D0B A   .3B2                        0 4D81 A   
.3B3                        0 4D77 A   .3B4                        0 4E3F A   
.3B5                        0 4E39 A   .3B6                        0 4D8E A   
.3B7                        0 4DFF A   .3B8                        0 4DEE A   
.3B9                        0 4DF7 A   .3BA                        0 4D95 A   
.3BB                        0 4DEE A   .3BC                        0 4DEC A   
.3BD                        0 4DD4 A   .3BE                        0 4DFF A   
.3BF                        0 4E12 A   .3C                         0 096D A   
.3C0                        0 4E07 A   .3C1                        0 4E3F A   
.3C2                        0 4E61 A   .3C3                        0 4EA5 A   
.3C4                        0 4E9F A   .3C5                        0 4F16 A   
.3C6                        0 4F05 A   .3C7                        0 4F0E A   
.3C8                        0 4EAC A   .3C9                        0 4F05 A   
.3CA                        0 4F03 A   .3CB                        0 4EEB A   
.3CC                        0 4F16 A   .3CD                        0 4F77 A   
.3CE                        0 4F23 A   .3CF                        0 4F77 A   
.3D                         0 0994 A   .3D0                        0 4F4F A   
.3D1                        0 4F85 A   .3D2                        0 4F9C A   
.3D3                        0 D779 A   .3D4                        0 5318 A   
.3D6                        0 52CE A   .3D7                        0 4FE3 A   
.3D8                        0 5007 A   .3D9                        0 4FF9 A   
.3DA                        0 D755 A   .3DB                        0 501C A   
.3DC                        0 5015 A   .3DD                        0 500E A   
.3DE                        0 5028 A   .3DF                        0 5028 A   
.3E                         0 098C A   .3E0                        0 5023 A   
.3E1                        0 503A A   .3E2                        0 505B A   
.3E3                        0 504F A   .3E4                        0 5070 A   
.3E5                        0 5069 A   .3E6                        0 5062 A   
.3E7                        0 507C A   .3E8                        0 507C A   
.3E9                        0 5077 A   .3EA                        0 5096 A   
.3EB                        0 50B5 A   .3EC                        0 50D9 A   
.3ED                        0 50CD A   .3EE                        0 50E3 A   
.3EF                        0 50E6 A   .3F                         0 099A A   
.3F0                        0 50F3 A   .3F1                        0 513A A   
.3F2                        0 5120 A   .3F3                        0 5113 A   
.3F4                        0 513A A   .3F5                        0 512F A   
.3F6                        0 51AE A   .3F7                        0 5141 A   
.3F8                        0 51AE A   .3F9                        0 514E A   
.3FA                        0 51AE A   .3FB                        0 51A3 A   
.3FC                        0 514E A   .3FD                        0 517D A   
.3FE                        0 5163 A   .3FF                        0 5156 A   
.4                          0 05F7 A   .40                         0 09B2 A   
.400                        0 517D A   .401                        0 5172 A   
.402                        0 51A3 A   .403                        0 5184 A   
.404                        0 51AE A   .405                        0 51B7 A   
.406                        0 51DB A   .407                        0 51CD A   
.408                        0 D731 A   .409                        0 51EE A   
.40A                        0 51E9 A   .40B                        0 51E2 A   
.40C                        0 5200 A   .40D                        0 5221 A   
.40E                        0 5215 A   .40F                        0 5234 A   
.41                         0 0A4A A   .410                        0 522F A   
.411                        0 5228 A   .412                        0 524E A   
.413                        0 5295 A   .414                        0 52A2 A   
.415                        0 52A4 A   .416                        0 52B6 A   
.417                        0 52AB A   .418                        0 52B6 A   
.419                        0 D709 A   .41A                        0 5307 A   
.41B                        0 52E1 A   .41C                        0 53F3 A   
.41D                        0 5370 A   .41E                        0 53EA A   
.41F                        0 53C3 A   .42                         0 09D0 A   
.420                        0 53D9 A   .421                        0 53D3 A   
.422                        0 53F9 A   .423                        0 53FD A   
.424                        0 5443 A   .425                        0 5431 A   
.426                        0 D6FE A   .427                        0 5462 A   
.428                        0 5453 A   .429                        0 5453 A   
.42A                        0 5462 A   .42B                        0 5495 A   
.42C                        0 5483 A   .42D                        0 D6F3 A   
.42E                        0 54F0 A   .42F                        0 54DE A   
.43                         0 09BC A   .430                        0 D6E9 A   
.431                        0 550F A   .432                        0 5500 A   
.433                        0 5500 A   .434                        0 550F A   
.435                        0 553C A   .436                        0 552A A   
.437                        0 D6DF A   .438                        0 5594 A   
.439                        0 5582 A   .43A                        0 D6D5 A   
.43B                        0 55CF A   .43C                        0 55C0 A   
.43D                        0 55C0 A   .43E                        0 55CF A   
.43F                        0 561C A   .44                         0 0A4A A   
.440                        0 560B A   .441                        0 D6CA A   
.442                        0 566C A   .443                        0 565A A   
.444                        0 D6B0 A   .445                        0 5C9A A   
.447                        0 5C3D A   .448                        0 56BB A   
.449                        0 5712 A   .44A                        0 5731 A   
.44B                        0 576C A   .44C                        0 578B A   
.44D                        0 57C6 A   .44E                        0 57E5 A   
.44F                        0 5814 A   .45                         0 0A0F A   
.450                        0 580A A   .451                        0 581C A   
.452                        0 5833 A   .453                        0 5862 A   
.454                        0 5858 A   .455                        0 586A A   
.456                        0 5881 A   .457                        0 58B0 A   
.458                        0 58A6 A   .459                        0 58B8 A   
.45A                        0 58CF A   .45B                        0 58FE A   
.45C                        0 58F4 A   .45D                        0 5906 A   
.45E                        0 591D A   .45F                        0 597A A   
.46                         0 09D7 A   .460                        0 5926 A   
.461                        0 597D A   .462                        0 59A2 A   
.463                        0 5986 A   .464                        0 59A5 A   
.465                        0 59FC A   .466                        0 5A1B A   
.467                        0 5A27 A   .468                        0 5A24 A   
.469                        0 5A27 A   .46A                        0 5A34 A   
.46B                        0 5A30 A   .46C                        0 5A53 A   
.46D                        0 5A3B A   .46E                        0 D67C A   
.46F                        0 5A99 A   .47                         0 09FB A   
.470                        0 5A5C A   .471                        0 5C0B A   
.472                        0 5ADF A   .473                        0 5AA2 A   
.474                        0 5C0B A   .475                        0 5B7C A   
.476                        0 5AEA A   .477                        0 5B3F A   
.478                        0 5B09 A   .479                        0 5B79 A   
.47A                        0 5C0B A   .47B                        0 5BD7 A   
.47C                        0 5B9B A   .47D                        0 5C0B A   
.47E                        0 5C27 A   .47F                        0 5C19 A   
.48                         0 09E1 A   .480                        0 5C12 A   
.481                        0 D645 A   .482                        0 5D0C A   
.483                        0 5D06 A   .484                        0 5D1A A   
.485                        0 5D14 A   .486                        0 5D91 A   
.487                        0 5D8D A   .488                        0 5DCA A   
.489                        0 5DC6 A   .48A                        0 5E57 A   
.48B                        0 5E06 A   .48C                        0 5E55 A   
.48D                        0 5E4F A   .48E                        0 5E5E A   
.48F                        0 5ED0 A   .49                         0 0A0D A   
.490                        0 5EAE A   .491                        0 5EA7 A   
.492                        0 D60E A   .493                        0 5F14 A   
.494                        0 5EF2 A   .495                        0 D5D0 A   
.496                        0 6CDF A   .498                        0 6C61 A   
.499                        0 5F1E A   .49A                        0 5F32 A   
.49B                        0 5F7A A   .49C                        0 5F72 A   
.49D                        0 5F80 A   .49E                        0 5F83 A   
.49F                        0 5F83 A   .4A                         0 0A4A A   
.4A0                        0 5F83 A   .4A1                        0 5FF2 A   
.4A2                        0 5FD6 A   .4A3                        0 5FCF A   
.4A4                        0 D59C A   .4A5                        0 6086 A   
.4A6                        0 6061 A   .4A7                        0 6059 A   
.4A8                        0 6051 A   .4A9                        0 D554 A   
.4AA                        0 6098 A   .4AB                        0 6092 A   
.4AC                        0 614A A   .4AD                        0 60E2 A   
.4AE                        0 60DA A   .4AF                        0 6183 A   
.4B                         0 0A27 A   .4B0                        0 6156 A   
.4B1                        0 61AE A   .4B2                        0 61FD A   
.4B3                        0 61D0 A   .4B4                        0 D527 A   
.4B5                        0 6206 A   .4B6                        0 D50D A   
.4B7                        0 6221 A   .4B8                        0 62FF A   
.4B9                        0 6337 A   .4BA                        0 632F A   
.4BB                        0 6348 A   .4BC                        0 634B A   
.4BD                        0 63FC A   .4BE                        0 641C A   
.4BF                        0 641C A   .4C                         0 0A16 A   
.4C0                        0 641C A   .4C1                        0 641C A   
.4C2                        0 649F A   .4C3                        0 6483 A   
.4C4                        0 D4D8 A   .4C5                        0 64F7 A   
.4C6                        0 64DB A   .4C7                        0 D4A7 A   
.4C8                        0 6515 A   .4C9                        0 650F A   
.4CA                        0 6503 A   .4CB                        0 654E A   
.4CC                        0 6521 A   .4CD                        0 6579 A   
.4CE                        0 65CF A   .4CF                        0 65A2 A   
.4D                         0 0A4A A   .4D0                        0 D47A A   
.4D1                        0 65D8 A   .4D2                        0 65D8 A   
.4D3                        0 65E1 A   .4D4                        0 65F5 A   
.4D5                        0 6613 A   .4D6                        0 660D A   
.4D7                        0 675B A   .4D8                        0 661D A   
.4D9                        0 69A9 A   .4DA                        0 6765 A   
.4DB                        0 6840 A   .4DC                        0 683C A   
.4DD                        0 6842 A   .4DE                        0 685A A   
.4DF                        0 6856 A   .4E                         0 0A3C A   
.4E0                        0 685C A   .4E1                        0 686F A   
.4E2                        0 686B A   .4E3                        0 6871 A   
.4E4                        0 6884 A   .4E5                        0 6880 A   
.4E6                        0 6886 A   .4E7                        0 698C A   
.4E8                        0 697E A   .4E9                        0 6985 A   
.4EA                        0 695D A   .4EB                        0 698C A   
.4EC                        0 6BEE A   .4ED                        0 69B3 A   
.4EE                        0 6AAC A   .4EF                        0 6A5B A   
.4F                         0 0A2E A   .4F0                        0 6AAC A   
.4F1                        0 6B40 A   .4F2                        0 6B02 A   
.4F3                        0 6B40 A   .4F4                        0 6BCE A   
.4F5                        0 6BC0 A   .4F6                        0 6BC7 A   
.4F7                        0 6BA2 A   .4F8                        0 6BCE A   
.4F9                        0 6BF7 A   .4FA                        0 6C1E A   
.4FC                        0 6C0C A   .4FD                        0 6BFC A   
.4FE                        0 6BFC A   .4FF                        0 6BFC A   
.5                          0 05EC A   .50                         0 0A4A A   
.500                        0 6BFC A   .501                        0 6C04 A   
.502                        0 6C21 A   .503                        0 6C21 A   
.504                        0 6C21 A   .505                        0 6C21 A   
.506                        0 6C21 A   .507                        0 D43B A   
.508                        0 6C40 A   .509                        0 6C40 A   
.50A                        0 6C40 A   .50B                        0 6C40 A   
.50C                        0 6C40 A   .50D                        0 D402 A   
.50E                        0 6CA9 A   .50F                        0 6C77 A   
.51                         0 DCF4 A   .510                        0 6CDC A   
.511                        0 6CBC A   .512                        0 6D90 A   
.513                        0 6D6E A   .514                        0 6D67 A   
.515                        0 D3CE A   .516                        0 6DD4 A   
.517                        0 6DB2 A   .518                        0 D393 A   
.519                        0 780E A   .51B                        0 7790 A   
.51C                        0 6DDE A   .51D                        0 6DDE A   
.51E                        0 6DDE A   .51F                        0 6DDE A   
.52                         0 0A60 A   .520                        0 6DDE A   
.521                        0 6DDE A   .522                        0 6DDE A   
.523                        0 6DDE A   .524                        0 6DE7 A   
.525                        0 6DE7 A   .526                        0 6DE7 A   
.527                        0 6DFB A   .528                        0 6E43 A   
.529                        0 6E3B A   .52A                        0 6E49 A   
.52B                        0 6E4C A   .52C                        0 6E60 A   
.52D                        0 6E80 A   .52E                        0 6E80 A   
.52F                        0 6E80 A   .53                         0 0A7D A   
.530                        0 6F03 A   .531                        0 6EE7 A   
.532                        0 D361 A   .533                        0 6F39 A   
.534                        0 6F33 A   .535                        0 6F27 A   
.536                        0 705C A   .537                        0 702F A   
.538                        0 D336 A   .539                        0 7065 A   
.53A                        0 7072 A   .53B                        0 706C A   
.53C                        0 717A A   .53E                        0 716A A   
.53F                        0 7095 A   .54                         0 0A8A A   
.540                        0 70B7 A   .541                        0 709C A   
.542                        0 70E8 A   .543                        0 710A A   
.544                        0 70EF A   .545                        0 7139 A   
.546                        0 7135 A   .547                        0 713B A   
.548                        0 714B A   .549                        0 7156 A   
.54A                        0 7152 A   .54B                        0 7158 A   
.54C                        0 7183 A   .54D                        0 71B8 A   
.54E                        0 71A7 A   .54F                        0 71E3 A   
.55                         0 0A86 A   .550                        0 71D2 A   
.551                        0 71EC A   .552                        0 720A A   
.553                        0 7204 A   .554                        0 72E0 A   
.555                        0 7214 A   .556                        0 74E3 A   
.557                        0 72EA A   .558                        0 73BE A   
.559                        0 73BA A   .55A                        0 73C0 A   
.55B                        0 74C6 A   .55C                        0 74B8 A   
.55D                        0 74BF A   .55E                        0 7497 A   
.55F                        0 74C6 A   .56                         0 0AC2 A   
.560                        0 7728 A   .561                        0 74ED A   
.562                        0 75E6 A   .563                        0 7595 A   
.564                        0 75E6 A   .565                        0 767A A   
.566                        0 763C A   .567                        0 767A A   
.568                        0 7708 A   .569                        0 76FA A   
.56A                        0 7701 A   .56B                        0 76DC A   
.56C                        0 7708 A   .56D                        0 7731 A   
.56E                        0 7745 A   .56F                        0 776C A   
.57                         0 0AA8 A   .571                        0 775A A   
.572                        0 774A A   .573                        0 774A A   
.574                        0 774A A   .575                        0 774A A   
.576                        0 7752 A   .577                        0 776F A   
.578                        0 776F A   .579                        0 776F A   
.57A                        0 776F A   .57B                        0 776F A   
.57C                        0 776F A   .57D                        0 776F A   
.57E                        0 776F A   .57F                        0 D314 A   
.58                         0 0A9B A   .580                        0 77D8 A   
.581                        0 77A6 A   .582                        0 780B A   
.583                        0 77EB A   .584                        0 7A61 A   
.586                        0 7A43 A   .587                        0 7885 A   
.588                        0 7885 A   .589                        0 7885 A   
.58A                        0 D2E3 A   .58B                        0 789F A   
.58C                        0 7A1D A   .58D                        0 7A0D A   
.58E                        0 7A24 A   .58F                        0 D2BE A   
.59                         0 0AC2 A   .590                        0 7B57 A   
.591                        0 7B35 A   .592                        0 7B1C A   
.593                        0 D27F A   .594                        0 80BA A   
.596                        0 803F A   .597                        0 7B61 A   
.598                        0 7B61 A   .599                        0 7B61 A   
.59A                        0 7B61 A   .59B                        0 7B61 A   
.59C                        0 7B61 A   .59D                        0 7B61 A   
.59E                        0 7B61 A   .59F                        0 7B6A A   
.5A                         0 0AB7 A   .5A0                        0 7B6A A   
.5A1                        0 7B7E A   .5A2                        0 7BC6 A   
.5A3                        0 7BBE A   .5A4                        0 7BCC A   
.5A5                        0 7BCF A   .5A6                        0 7BCF A   
.5A7                        0 7C64 A   .5A8                        0 7C5E A   
.5A9                        0 7C82 A   .5AA                        0 7C7C A   
.5AB                        0 7C74 A   .5AC                        0 7C6C A   
.5AD                        0 7C94 A   .5AE                        0 7C8E A   
.5AF                        0 7F0D A   .5B                         0 0B00 A   
.5B0                        0 7ED6 A   .5B1                        0 D255 A   
.5B2                        0 7F16 A   .5B3                        0 7FF5 A   
.5B5                        0 7FE9 A   .5B6                        0 7FC3 A   
.5B7                        0 7FCF A   .5B8                        0 7FDB A   
.5B9                        0 800B A   .5BA                        0 801F A   
.5BB                        0 801F A   .5BC                        0 801F A   
.5BD                        0 801F A   .5BE                        0 801F A   
.5BF                        0 801F A   .5C                         0 0AF5 A   
.5C0                        0 801F A   .5C1                        0 801F A   
.5C2                        0 801F A   .5C3                        0 801F A   
.5C4                        0 801F A   .5C5                        0 801F A   
.5C6                        0 801F A   .5C7                        0 801F A   
.5C8                        0 801F A   .5C9                        0 D21D A   
.5CA                        0 8084 A   .5CB                        0 8052 A   
.5CC                        0 80B7 A   .5CD                        0 8097 A   
.5CE                        0 8136 A   .5CF                        0 812C A   
.5D                         0 0ACA A   .5D0                        0 814B A   
.5D1                        0 8145 A   .5D2                        0 815F A   
.5D3                        0 8158 A   .5D4                        0 818A A   
.5D5                        0 8184 A   .5D6                        0 81A9 A   
.5D7                        0 81A3 A   .5D8                        0 81CA A   
.5D9                        0 81BC A   .5DA                        0 81D2 A   
.5DB                        0 81EC A   .5DC                        0 81D9 A   
.5DD                        0 82AE A   .5DE                        0 8206 A   
.5DF                        0 81F3 A   .5E                         0 0AF5 A   
.5E0                        0 82AE A   .5E1                        0 8220 A   
.5E2                        0 820D A   .5E3                        0 82AE A   
.5E4                        0 823B A   .5E5                        0 8229 A   
.5E6                        0 82AE A   .5E7                        0 8254 A   
.5E8                        0 8242 A   .5E9                        0 82AE A   
.5EA                        0 826D A   .5EB                        0 825B A   
.5EC                        0 82AE A   .5ED                        0 8286 A   
.5EE                        0 8274 A   .5EF                        0 82AE A   
.5F                         0 0AE6 A   .5F0                        0 829F A   
.5F1                        0 828D A   .5F2                        0 82AE A   
.5F3                        0 82BD A   .5F4                        0 82B5 A   
.5F5                        0 82C3 A   .5F6                        0 8330 A   
.5F7                        0 8329 A   .5F8                        0 8335 A   
.5F9                        0 838B A   .5FA                        0 837D A   
.5FB                        0 D1FB A   .5FC                        0 83D4 A   
.5FD                        0 83CD A   .5FE                        0 83BB A   
.5FF                        0 83D4 A   .6                          0 05D7 A   
.60                         0 0B00 A   .600                        0 8409 A   
.601                        0 83F9 A   .602                        0 8417 A   
.603                        0 8468 A   .604                        0 845A A   
.605                        0 8470 A   .606                        0 847F A   
.607                        0 8477 A   .608                        0 8486 A   
.609                        0 96A1 A   .60B                        0 9662 A   
.60C                        0 84A0 A   .60D                        0 84CD A   
.60E                        0 84AD A   .60F                        0 84EE A   
.61                         0 0B3D A   .610                        0 84E0 A   
.611                        0 84F6 A   .612                        0 851D A   
.613                        0 84FD A   .614                        0 854A A   
.615                        0 8588 A   .616                        0 8580 A   
.617                        0 858C A   .618                        0 858C A   
.619                        0 858C A   .61A                        0 8606 A   
.61B                        0 85CE A   .61C                        0 85C7 A   
.61D                        0 85C0 A   .61E                        0 85B9 A   
.61F                        0 D1DC A   .62                         0 0B23 A   
.620                        0 863F A   .621                        0 8615 A   
.622                        0 8687 A   .623                        0 864E A   
.624                        0 8687 A   .625                        0 865D A   
.626                        0 8A99 A   .627                        0 8690 A   
.628                        0 86C0 A   .629                        0 86B9 A   
.62A                        0 8709 A   .62B                        0 86DF A   
.62C                        0 87E9 A   .62D                        0 87E2 A   
.62E                        0 87EE A   .62F                        0 8844 A   
.63                         0 0B16 A   .630                        0 8836 A   
.631                        0 D1B8 A   .632                        0 8907 A   
.633                        0 8900 A   .634                        0 88EE A   
.635                        0 8907 A   .636                        0 895B A   
.637                        0 894D A   .638                        0 D198 A   
.639                        0 8A6E A   .63A                        0 8A44 A   
.63B                        0 8EC5 A   .63C                        0 8E9D A   
.63D                        0 8AA2 A   .63E                        0 8AD2 A   
.63F                        0 8ACB A   .64                         0 0B3D A   
.640                        0 8B1B A   .641                        0 8AF1 A   
.642                        0 8BED A   .643                        0 8BE6 A   
.644                        0 8BF2 A   .645                        0 8C48 A   
.646                        0 8C3A A   .647                        0 D174 A   
.648                        0 8D0B A   .649                        0 8D04 A   
.64A                        0 8CF2 A   .64B                        0 8D0B A   
.64C                        0 8D5F A   .64D                        0 8D51 A   
.64E                        0 D154 A   .64F                        0 8E73 A   
.65                         0 0B32 A   .650                        0 8E48 A   
.651                        0 8E65 A   .652                        0 8E51 A   
.653                        0 8E73 A   .654                        0 D12F A   
.655                        0 8EC5 A   .656                        0 8EC5 A   
.657                        0 8F24 A   .658                        0 8F08 A   
.659                        0 8F01 A   .65A                        0 8EFA A   
.65B                        0 8EF3 A   .65C                        0 8EEC A   
.65D                        0 8F53 A   .65E                        0 8F33 A   
.65F                        0 8F9B A   .66                         0 0B4C A   
.660                        0 8F62 A   .661                        0 8F9B A   
.662                        0 8F71 A   .663                        0 8FCB A   
.664                        0 8FC4 A   .665                        0 9013 A   
.666                        0 8FE9 A   .667                        0 90E5 A   
.668                        0 90DE A   .669                        0 90EA A   
.66A                        0 9140 A   .66B                        0 9132 A   
.66C                        0 D10B A   .66D                        0 91CC A   
.66E                        0 91C5 A   .66F                        0 91B3 A   
.67                         0 0B44 A   .670                        0 91CC A   
.671                        0 9220 A   .672                        0 9212 A   
.673                        0 D0EB A   .674                        0 9334 A   
.675                        0 9309 A   .676                        0 9326 A   
.677                        0 9312 A   .678                        0 9334 A   
.679                        0 D0C5 A   .67A                        0 9361 A   
.67B                        0 93A3 A   .67C                        0 936E A   
.67D                        0 93C4 A   .67E                        0 93BD A   
.67F                        0 93D4 A   .68                         0 0B7C A   
.680                        0 93CD A   .681                        0 93E9 A   
.682                        0 93DB A   .683                        0 93F1 A   
.684                        0 950E A   .686                        0 94E7 A   
.687                        0 942B A   .688                        0 943D A   
.689                        0 9451 A   .68A                        0 9465 A   
.68B                        0 9479 A   .68C                        0 948D A   
.68D                        0 94A0 A   .68E                        0 94B2 A   
.68F                        0 94C4 A   .69                         0 0B62 A   
.690                        0 94D7 A   .691                        0 D0A5 A   
.692                        0 950C A   .693                        0 94FA A   
.694                        0 9527 A   .695                        0 954A A   
.696                        0 9534 A   .697                        0 956B A   
.698                        0 955D A   .699                        0 9573 A   
.69A                        0 958E A   .69B                        0 9582 A   
.69C                        0 9599 A   .69D                        0 959D A   
.69E                        0 95CA A   .69F                        0 95AA A   
.6A                         0 0B54 A   .6A0                        0 95EA A   
.6A1                        0 960A A   .6A2                        0 962A A   
.6A3                        0 D080 A   .6A4                        0 9687 A   
.6A5                        0 9675 A   .6A6                        0 96D4 A   
.6A7                        0 96C7 A   .6A8                        0 D059 A   
.6A9                        0 981B A   .6AA                        0 9728 A   
.6AB                        0 971F A   .6AC                        0 9715 A   
.6AD                        0 97AF A   .6AE                        0 9749 A   
.6AF                        0 97AF A   .6B                         0 0B7C A   
.6B0                        0 9798 A   .6B1                        0 9791 A   
.6B2                        0 97AF A   .6B3                        0 97A8 A   
.6B4                        0 97ED A   .6B5                        0 97B6 A   
.6B6                        0 9811 A   .6B7                        0 9809 A   
.6B8                        0 9823 A   .6B9                        0 9897 A   
.6BA                        0 9889 A   .6BB                        0 D044 A   
.6BC                        0 98C4 A   .6BD                        0 98AF A   
.6BE                        0 D028 A   .6BF                        0 9A4D A   
.6C                         0 0B71 A   .6C1                        0 9A31 A   
.6C2                        0 98D2 A   .6C3                        0 98D2 A   
.6C4                        0 98DE A   .6C5                        0 98DA A   
.6C6                        0 98E0 A   .6C7                        0 9931 A   
.6C8                        0 9920 A   .6C9                        0 9969 A   
.6CA                        0 9947 A   .6CB                        0 9938 A   
.6CC                        0 9969 A   .6CD                        0 9959 A   
.6CE                        0 99B7 A   .6CF                        0 99DD A   
.6D                         0 0B8C A   .6D0                        0 99C4 A   
.6D1                        0 9A0F A   .6D2                        0 9A2B A   
.6D3                        0 9DEA A   .6D5                        0 9DBF A   
.6D6                        0 9A77 A   .6D7                        0 9A9B A   
.6D8                        0 9ABE A   .6D9                        0 9AD0 A   
.6DA                        0 9AC5 A   .6DB                        0 9B17 A   
.6DC                        0 9B21 A   .6DD                        0 9B1E A   
.6DE                        0 9B91 A   .6DF                        0 9BA8 A   
.6E                         0 0B83 A   .6E0                        0 9B9D A   
.6E1                        0 9BE9 A   .6E2                        0 9BFE A   
.6E3                        0 9BF0 A   .6E4                        0 9C72 A   
.6E5                        0 9C97 A   .6E6                        0 9C8C A   
.6E7                        0 9CA1 A   .6E8                        0 9C9E A   
.6E9                        0 9D08 A   .6EA                        0 9D3C A   
.6EB                        0 9D53 A   .6EC                        0 9D43 A   
.6ED                        0 D00D A   .6EE                        0 9DA5 A   
.6EF                        0 9D70 A   .6F                         0 0BA2 A   
.6F0                        0 9D5A A   .6F1                        0 CFE7 A   
.6F2                        0 9DA5 A   .6F3                        0 9D8A A   
.6F4                        0 9D77 A   .6F5                        0 CFCF A   
.6F6                        0 9DA5 A   .6F7                        0 9DA5 A   
.6F8                        0 9D91 A   .6F9                        0 CFAF A   
.6FA                        0 9DB5 A   .6FB                        0 9DE2 A   
.6FC                        0 9DD2 A   .6FD                        0 9F02 A   
.6FE                        0 9E20 A   .6FF                        0 9E2D A   
.7                          0 05EC A   .70                         0 0B99 A   
.700                        0 9E29 A   .701                        0 9F02 A   
.702                        0 9E38 A   .703                        0 9F02 A   
.704                        0 9E4C A   .705                        0 9ECF A   
.706                        0 9E72 A   .707                        0 9EFF A   
.708                        0 AA36 A   .70A                        0 AA2E A   
.70B                        0 A972 A   .70C                        0 A99E A   
.70D                        0 A992 A   .70E                        0 A979 A   
.70F                        0 AA20 A   .71                         0 0BE0 A   
.711                        0 A9FB A   .712                        0 A9A3 A   
.713                        0 A9A3 A   .714                        0 A9A3 A   
.715                        0 A9A3 A   .716                        0 A9A3 A   
.717                        0 A9A3 A   .718                        0 A9A3 A   
.719                        0 A9A3 A   .71A                        0 A9F1 A   
.71B                        0 AA1E A   .71C                        0 AA0E A   
.71D                        0 AA22 A   .71E                        0 CFAF A   
.71F                        0 CFCF A   .72                         0 0BC6 A   
.720                        0 CFE7 A   .721                        0 D00D A   
.722                        0 D028 A   .723                        0 D044 A   
.724                        0 D059 A   .725                        0 D080 A   
.726                        0 D0A5 A   .727                        0 D0C5 A   
.728                        0 D0EB A   .729                        0 D10B A   
.72A                        0 D12F A   .72B                        0 D154 A   
.72C                        0 D174 A   .72D                        0 D198 A   
.72E                        0 D1B8 A   .72F                        0 D1DC A   
.73                         0 0BB8 A   .730                        0 D1FB A   
.731                        0 D21D A   .732                        0 D255 A   
.733                        0 D27F A   .734                        0 D2BE A   
.735                        0 D2E3 A   .736                        0 D314 A   
.737                        0 D336 A   .738                        0 D361 A   
.739                        0 D393 A   .73A                        0 D3CE A   
.73B                        0 D402 A   .73C                        0 D43B A   
.73D                        0 D47A A   .73E                        0 D4A7 A   
.73F                        0 D4D8 A   .74                         0 0BE0 A   
.740                        0 D50D A   .741                        0 D527 A   
.742                        0 D554 A   .743                        0 D59C A   
.744                        0 D5D0 A   .745                        0 D60E A   
.746                        0 D645 A   .747                        0 D67C A   
.748                        0 D6B0 A   .749                        0 D6CA A   
.74A                        0 D6D5 A   .74B                        0 D6DF A   
.74C                        0 D6E9 A   .74D                        0 D6F3 A   
.74E                        0 D6FE A   .74F                        0 D709 A   
.75                         0 0BD5 A   .750                        0 D731 A   
.751                        0 D755 A   .752                        0 D779 A   
.753                        0 D7B3 A   .754                        0 D7ED A   
.755                        0 D807 A   .756                        0 D833 A   
.757                        0 D85E A   .758                        0 D898 A   
.759                        0 D8AF A   .75A                        0 D8DE A   
.75B                        0 D91E A   .75C                        0 D94A A   
.75D                        0 D94C A   .75E                        0 D953 A   
.75F                        0 D95A A   .76                         0 0BF0 A   
.760                        0 D974 A   .761                        0 D986 A   
.762                        0 D9A0 A   .763                        0 D9A3 A   
.764                        0 D9AA A   .765                        0 D9B1 A   
.766                        0 D9BC A   .767                        0 D9DD A   
.768                        0 D9FE A   .769                        0 DA01 A   
.76A                        0 DA08 A   .76B                        0 DA0F A   
.76C                        0 DA1A A   .76D                        0 DA45 A   
.76E                        0 DA55 A   .76F                        0 DA5C A   
.77                         0 0BE7 A   .770                        0 DA62 A   
.771                        0 DA66 A   .772                        0 DA6B A   
.773                        0 DA90 A   .774                        0 DAB9 A   
.775                        0 DABD A   .776                        0 DAD2 A   
.777                        0 DAE6 A   .778                        0 DB0A A   
.779                        0 DB2E A   .77A                        0 DB46 A   
.77B                        0 DB5D A   .77C                        0 DB78 A   
.77D                        0 DB8F A   .77E                        0 DBAE A   
.77F                        0 DBB6 A   .78                         0 0C20 A   
.780                        0 DBC7 A   .781                        0 DBE7 A   
.782                        0 DBE9 A   .783                        0 DC08 A   
.784                        0 DC1E A   .785                        0 DC32 A   
.786                        0 DC42 A   .787                        0 DC56 A   
.788                        0 DC66 A   .789                        0 DC68 A   
.78A                        0 DC7B A   .78B                        0 DC82 A   
.78C                        0 DC83 A   .78D                        0 DC85 A   
.78E                        0 DCA0 A   .78F                        0 DCC5 A   
.79                         0 0C06 A   .790                        0 DCE1 A   
.791                        0 DCF4 A   .792                        0 DD11 A   
.7A                         0 0BF8 A   .7B                         0 0C20 A   
.7C                         0 0C15 A   .7D                         0 0C30 A   
.7E                         0 0C27 A   .7F                         0 0C46 A   
.8                          0 05E6 A   .80                         0 0C3D A   
.81                         0 0CA0 A   .82                         0 0C86 A   
.83                         0 0C78 A   .84                         0 0CA0 A   
.85                         0 0C95 A   .86                         0 0CB0 A   
.87                         0 0CA7 A   .88                         0 0CE0 A   
.89                         0 0CC6 A   .8A                         0 0CB8 A   
.8B                         0 0CE0 A   .8C                         0 0CD5 A   
.8D                         0 0CF0 A   .8E                         0 0CE7 A   
.8F                         0 0D06 A   .9                          0 05F7 A   
.90                         0 0CFD A   .91                         0 0D36 A   
.92                         0 0D1C A   .93                         0 0D0E A   
.94                         0 0D36 A   .95                         0 0D2B A   
.96                         0 0D46 A   .97                         0 0D3D A   
.98                         0 0D5C A   .99                         0 0D53 A   
.9A                         0 0D9A A   .9B                         0 0D80 A   
.9C                         0 0D72 A   .9D                         0 0D9A A   
.9E                         0 0D8F A   .9F                         0 0DAA A   
.A                          0 067E A   .A0                         0 0DA1 A   
.A1                         0 0DDA A   .A2                         0 0DC0 A   
.A3                         0 0DB2 A   .A4                         0 0DDA A   
.A5                         0 0DCF A   .A6                         0 0DEA A   
.A7                         0 0DE1 A   .A8                         0 0E00 A   
.A9                         0 0DF7 A   .AA                         0 0E3E A   
.AB                         0 0E24 A   .AC                         0 0E16 A   
.AD                         0 0E3E A   .AE                         0 0E33 A   
.AF                         0 0E4E A   .B                          0 0679 A   
.B0                         0 0E45 A   .B1                         0 0E8C A   
.B2                         0 0E72 A   .B3                         0 0E64 A   
.B4                         0 0E8C A   .B5                         0 0E81 A   
.B6                         0 0E9C A   .B7                         0 0E93 A   
.B8                         0 0EDA A   .B9                         0 0EC0 A   
.BA                         0 0EB2 A   .BB                         0 0EDA A   
.BC                         0 0ECF A   .BD                         0 0EEA A   
.BE                         0 0EE1 A   .BF                         0 0F1A A   
.C                          0 0765 A   .C0                         0 0F00 A   
.C1                         0 0EF2 A   .C2                         0 0F1A A   
.C3                         0 0F0F A   .C4                         0 0F2A A   
.C5                         0 0F21 A   .C6                         0 0F40 A   
.C7                         0 0F37 A   .C8                         0 DCE1 A   
.C9                         0 DCC5 A   .CA                         0 DCA0 A   
.CB                         0 DC85 A   .CC                         0 DC83 A   
.CD                         0 DC82 A   .CE                         0 DC7B A   
.CF                         0 DC68 A   .D                          0 0756 A   
.D0                         0 DC66 A   .D1                         0 1184 A   
.D2                         0 117E A   .D3                         0 11A6 A   
.D4                         0 11B0 A   .D5                         0 11BA A   
.D6                         0 11C4 A   .D7                         0 11CE A   
.D8                         0 11E9 A   .D9                         0 11E3 A   
.DA                         0 1205 A   .DB                         0 11F8 A   
.DC                         0 11F0 A   .DD                         0 DC56 A   
.DE                         0 DC42 A   .DF                         0 1245 A   
.E                          0 077D A   .E0                         0 1238 A   
.E1                         0 1230 A   .E2                         0 DC32 A   
.E3                         0 DC1E A   .E4                         0 128F A   
.E5                         0 126C A   .E6                         0 1282 A   
.E7                         0 1273 A   .E8                         0 DC08 A   
.E9                         0 128F A   .EA                         0 DBE9 A   
.EB                         0 DBE7 A   .EC                         0 DBC7 A   
.ED                         0 13A7 A   .EE                         0 1399 A   
.EF                         0 12F5 A   .F                          0 076E A   
.F0                         0 133E A   .F1                         0 1318 A   
.F2                         0 135E A   .F3                         0 135E A   
.F4                         0 134C A   .F5                         0 1399 A   
.F6                         0 1371 A   .F7                         0 DBB6 A   
.F8                         0 1399 A   .F9                         0 1392 A   
.FA                         0 13A7 A   .FB                         0 151E A   
.FC                         0 151B A   .FD                         0 13E9 A   
.FE                         0 13FF A   .FF                         0 13F9 A   
.FFDC                       0 80F1 A   .FFDD                       0 80DB A   
.FFDE                       0 80C5 A   .FFDF                       0 80E7 A   
.FFE1                       0 80BA A   .FFE2                       0 7A8E A   
.FFE3                       0 7A61 A   .FFE5                       0 7848 A   
.FFE6                       0 7832 A   .FFE7                       0 781C A   
.FFE8                       0 783E A   .FFEA                       0 7811 A   
.FFEB                       0 6CED A   .FFEC                       0 6D19 A   
.FFED                       0 6D03 A   .FFEE                       0 6D0F A   
.FFF0                       0 6CE2 A   .FFF3                       0 4F9C A   
BcdToBin                    0 A2C5 A   Upcall                      0 A868 A   
_CVSID                      0 0194 A   _TCGInterruptHandler        0 A960 A E 
_apm16_entry                0 A473 A   _apm32_entry                0 A38A A   
_apmreal_entry              0 A540 A   _ata_cmd_data_in            0 298A A E 
_ata_cmd_data_out           0 2D1A A E _ata_cmd_non_data           0 2983 A E 
_ata_cmd_packet             0 30AC A E _ata_detect                 0 19D3 A E 
_ata_init                   0 1719 A E _ata_reset                  0 27EE A E 
_atapi_get_sense            0 34ED A E _atapi_is_cdrom             0 3625 A E 
_atapi_is_ready             0 356F A E _bios_cvs_version_string    0 0164 A   
_bios_date_string           0 0177 A   _bios_printf                0 08A9 A E 
_bootmenu                   0 13D2 A E _cdemu_emulated_drive       0 36E8 A E 
_cdemu_init                 0 3697 A E _cdemu_isactive             0 36C1 A E 
_cdrom_boot                 0 372D A E _check_for_keystroke        0 12B3 A E 
_clearscreen                0 13AE A   _clobber_entry_point        0 0FAD A E 
_copy_e820_table            0 065A A E _debugger_off               0 16A6 A E 
_debugger_on                0 1694 A E _dequeue_key                0 531C A E 
_determine_floppy_media     0 96EE A E _disable_rom_write_access   0 071D A E 
_drivetypes                 0 11A6 A   _ebda_ss_offset32           0 A732 A E 
_eltorito                   0 3715 A   _enable_mouse_int_and_even+ 0 54CA A E 
_enable_rom_write_access    0 0710 A E _enqueue_key                0 5CA6 A E 
_floppy_drive_exists        0 8442 A E _floppy_drive_recal         0 82F1 A E 
_floppy_media_known         0 810E A E _floppy_media_sense         0 8191 A E 
_get_CS                     0 0654 A E _get_SS                     0 0657 A E 
_get_boot_vector            0 1159 A   _get_keystroke              0 12C1 A E 
_get_mouse_data             0 55B8 A E _get_register_cs            0 A830 A E 
_get_register_ds            0 A83E A E _get_register_es            0 A84C A E 
_get_register_esp_hi        0 A85A A E _get_returnaddress          0 A822 A E 
_get_s3_waking_vector       0 AA3A A E _inb                        0 0548 A E 
_inb_cmos                   0 058D A E _inhibit_mouse_int_and_eve+ 0 541D A E 
_init_boot_vectors          0 1024 A   _init_rtc                   0 0599 A E 
_int09_function             0 5647 A E _int13_cdemu                0 7AB5 A E 
_int13_cdrom                0 6D36 A E _int13_diskette_function    0 848A A E 
_int13_eltorito             0 7865 A E _int13_harddisk             0 5E75 A E 
_int14_function             0 3ED4 A E _int15_function             0 4144 A E 
_int15_function32           0 4C56 A E _int15_function_mouse       0 467E A E 
_int16_function             0 4FD3 A E _int17_function             0 96EF A E 
_int18_function             0 9827 A E _int18_panic_msg            0 1619 A E 
_int1a_function             0 9A6B A E _int1a_function32           0 A967 A E 
_int70_function             0 9DEE A E _int74_function             0 5D5A A E 
_interactive_bootkey        0 1561 A E _inw                        0 0553 A E 
_isotag                     0 370F A   _keyboard_init              0 0A8E A E 
_keyboard_panic             0 0F52 A E _log_bios_start             0 162B A E 
_machine_reset              0 0F67 A E _memcpyb                    0 0025 A E 
_memsetb                    0 0000 A E _nmi_handler_msg            0 1607 A E 
_outb                       0 055E A E _outb_cmos                  0 057E A E 
_outw                       0 056E A E _panic_msg_keyb_buffer_ful+ 0 53FD A   
_print_bios_banner          0 0FDB A E _print_boot_device          0 11D8 A E 
_print_boot_failure         0 1226 A E _print_cdromboot_failure    0 129E A E 
_put_int                    0 07A3 A E _put_uint                   0 0826 A E 
_read_byte                  0 05FE A E _read_dword                 0 0055 A E 
_read_dword_from_ebda       0 A764 A E _read_word                  0 0611 A E 
_read_word_from_ebda        0 A73E A E _rtc_updating               0 05CA A E 
_s3_resume                  0 16B7 A E _scan_to_scanascii          0 01CE A   
_send                       0 073B A E _send_to_mouse_ctrl         0 556E A E 
_set_diskette_current_cyl   0 96BD A E _set_diskette_ret_status    0 96A5 A E 
_set_enable_a20             0 1641 A E _set_kbd_command_byte       0 55F9 A E 
_set_rom_write_access       0 06F1 A E _shutdown_status_panic      0 0FC3 A E 
_store_returnaddress        0 A7F8 A E _store_segment_registers    0 A78E A E 
_tcpa_acpi_init             0 A8B9 A E _tcpa_add_bootdevice        0 A8E3 A E 
_tcpa_add_event_separators  0 A8CB A E _tcpa_calling_int19h        0 A8BF A E 
_tcpa_do_measure_POSTs      0 A8FE A E _tcpa_extend_acpi_log       0 A8B3 A E 
_tcpa_initialize_tpm        0 A8F0 A E _tcpa_ipl                   0 A8E9 A E 
_tcpa_measure_post          0 A8F7 A E _tcpa_option_rom            0 A8DD A E 
_tcpa_returned_int19h       0 A8C5 A E _tcpa_start_option_rom_sca+ 0 A8D7 A E 
_tcpa_wake_event            0 A8D1 A E _vgafont8                   0 FA6E A   
_wait                       0 12C9 A E _wrch                       0 072B A E 
_write_byte                 0 0624 A E _write_dword                0 006C A E 
_write_word                 0 063C A E apm16_04                    0 A474 A   
apm16_05                    0 A47B A   apm16_07                    0 A486 A   
apm16_07_1                  0 A4AA A   apm16_07_poweroff           0 A4A0 A   
apm16_07_poweroff_str       0 A45A A   apm16_07_standby            0 A4BC A   
apm16_07_standby_str        0 A46B A   apm16_07_suspend            0 A4AD A   
apm16_07_suspend_str        0 A463 A   apm16_08                    0 A4CB A   
apm16_0a                    0 A4D1 A   apm16_0b                    0 A4E5 A   
apm16_0e                    0 A4ED A   apm16_0f                    0 A4F7 A   
apm16_10                    0 A4FD A   apm16_error                 0 A50B A   
apm16_ok                    0 A508 A   apm16_out_str               0 A442 A   
apm16_out_str1              0 A449 A   apm16_out_str2              0 A455 A   
apm16_unimplemented         0 A50B A   apm32_04                    0 A38C A   
apm32_05                    0 A395 A   apm32_07                    0 A3A4 A   
apm32_07_1                  0 A3D5 A   apm32_07_poweroff           0 A3C7 A   
apm32_07_poweroff_str       0 A371 A   apm32_07_standby            0 A3E9 A   
apm32_07_standby_str        0 A382 A   apm32_07_suspend            0 A3D8 A   
apm32_07_suspend_str        0 A37A A   apm32_08                    0 A3FA A   
apm32_0a                    0 A400 A   apm32_0b                    0 A416 A   
apm32_0e                    0 A41E A   apm32_0f                    0 A428 A   
apm32_10                    0 A42E A   apm32_error                 0 A43E A   
apm32_ok                    0 A43A A   apm32_out_str               0 A35E A   
apm32_out_str1              0 A362 A   apm32_out_str2              0 A36E A   
apm32_unimplemented         0 A43E A   apm_call                    0 F87B A   
apmreal_00                  0 A540 A   apmreal_01                  0 A552 A   
apmreal_02                  0 A559 A   apmreal_03                  0 A56F A   
apmreal_04                  0 A58E A   apmreal_05                  0 A595 A   
apmreal_07                  0 A5A0 A   apmreal_07_1                0 A5C4 A   
apmreal_07_poweroff         0 A5BA A   apmreal_07_poweroff_str     0 A526 A   
apmreal_07_standby          0 A5D6 A   apmreal_07_standby_str      0 A537 A   
apmreal_07_suspend          0 A5C7 A   apmreal_07_suspend_str      0 A52F A   
apmreal_08                  0 A5E5 A   apmreal_0a                  0 A5EB A   
apmreal_0b                  0 A5FF A   apmreal_0e                  0 A607 A   
apmreal_0f                  0 A611 A   apmreal_10                  0 A617 A   
apmreal_error               0 A627 A   apmreal_ok                  0 A622 A   
apmreal_out_str             0 A50E A   apmreal_out_str1            0 A515 A   
apmreal_out_str2            0 A521 A   apmreal_unimplemented       0 A627 A   
ata_in_16                   0 2C95 A   ata_in_32                   0 2C99 A   
ata_in_adjust               0 2C81 A   ata_in_done                 0 2C9C A   
ata_in_no_adjust            0 2C88 A   ata_out_16                  0 3025 A   
ata_out_32                  0 302A A   ata_out_adjust              0 3011 A   
ata_out_done                0 302E A   ata_out_no_adjust           0 3018 A   
ata_packet_after            0 347B A   ata_packet_done             0 3495 A   
ata_packet_in_16            0 3474 A   ata_packet_in_32            0 3478 A   
ata_packet_in_after_16      0 3488 A   ata_packet_in_after_32      0 348D A   
ata_packet_in_after_32_loo+ 0 348F A   ata_packet_in_before_16     0 3452 A   
ata_packet_in_before_32     0 3457 A   ata_packet_in_before_32_lo+ 0 3459 A   
ata_packet_no_before        0 345F A   bios32_end                  0 AA94 A   
bios32_entry_point          0 AA60 A   bios32_structure            0 AA50 A   
block_count_rounded         0 AE0E A   carry_set                   0 9F3D A   
check_for_hd1               0 A1B2 A   checksum_loop               0 ADD3 A   
detect_parport              0 AD80 A   detect_serial               0 AD9F A   
diskette_param_table        0 EFC7 A   diskette_param_table2       0 EFDF A   
done                        0 12C0 A   dummy_iret_handler          0 FF53 A   
ebda_post                   0 A29C A   eoi_both_pics               0 A2BC A   
eoi_jmp_post                0 A2B1 A   eoi_master_pic              0 A2C0 A   
f0_missing                  0 A02F A   f1_missing                  0 A03A A   
floppy_drive_post           0 9FF3 A   gdt_base                    0 A6A0 A   
gdt_entry_end               0 A6C0 A   gdt_entry_pm_16bit_cs       0 A6B0 A   
gdt_entry_pm_32bit_ds       0 A6B8 A   gdt_entry_pm_cs             0 A6A8 A   
halt2_loop                  0 0A87 A   hard_drive_post             0 A07B A   
hd0_post_above_2048         0 A174 A   hd0_post_above_4096         0 A182 A   
hd0_post_above_8192         0 A190 A   hd0_post_checksum_loop      0 A1A5 A   
hd0_post_logical_chs        0 A153 A   hd0_post_physical_chs       0 A145 A   
hd0_post_store_logical      0 A196 A   hd1_post_above_2048         0 A25D A   
hd1_post_above_4096         0 A26B A   hd1_post_above_8192         0 A279 A   
hd1_post_checksum_loop      0 A28E A   hd1_post_logical_chs        0 A23C A   
hd1_post_physical_chs       0 A22F A   hd1_post_store_logical      0 A27F A   
idiv_                       0 0135 A   idiv_u                      0 0139 A   
int08_floppy_off            0 FEC4 A   int08_handler               0 FEA5 A   
int08_store_ticks           0 FED9 A   int09_call_int15_4f         0 E9AE A   
int09_done                  0 E9BF A   int09_finish                0 E9C5 A   
int09_handler               0 E987 A   int0e_handler               0 EF57 A   
int0e_loop1                 0 EF69 A   int0e_loop2                 0 EF73 A   
int0e_normal                0 EF81 A   int10_handler               0 F065 A   
int11_handler               0 F84D A   int12_handler               0 F841 A   
int13_cdemu_inactive        0 9F91 A   int13_cdrom_rme_end         0 71CA A   
int13_disk                  0 9FC0 A   int13_diskette              0 EC59 A   
int13_handler               0 E3FE A   int13_legacy                0 9F99 A   
int13_nocdemu               0 9F7E A   int13_noeltorito            0 9F95 A   
int13_not_eltorito          0 9F5B A   int13_notcdrom              0 9FC0 A   
int13_notfloppy             0 9FAC A   int13_out                   0 9FC3 A   
int13_relocated             0 9F46 A   int14_handler               0 E739 A   
int1586_tick                0 4C9F A   int1586_tick_end            0 4CAD A   
int15_handler               0 F859 A   int15_handler32             0 F883 A   
int15_handler32_ret         0 F875 A   int15_handler_mouse         0 F87E A   
int15_handler_mouse_ret     0 F874 A   int16_F00                   0 E85B A   
int16_handler               0 E82E A   int16_key_found             0 E86F A   
int16_wait_for_key          0 E860 A   int16_zero_clear            0 E849 A   
int16_zero_set              0 E852 A   int17_handler               0 EFD2 A   
int18_handler               0 9FC7 A   int19_handler               0 E6F2 A   
int19_load_done             0 9914 A   int19_relocated             0 9FE6 A   
int1a_callfunction          0 FEA0 A   int1a_handler               0 FE6E A   
int1a_normal                0 FE9A A   int1c_handler               0 9FF2 A   
int70_handler               0 FEA6 A   int74_done                  0 9F28 A   
int74_handler               0 9F09 A   int75_handler               0 E2C7 A   
int76_handler               0 A34B A   iret_modify_cf              0 9F32 A   
jmptable                    0 CB00 A   laddl                       0 0093 A   
laddul                      0 0093 A   landl                       0 008B A   
landul                      0 008B A   lcmpl                       0 009B A   
lcmpul                      0 009B A   ldecl                       0 00D2 A   
ldecul                      0 00D2 A   ldivul                      0 013E A   
lincl                       0 00DF A   lincul                      0 00DF A   
lmull                       0 00B9 A   lmulul                      0 00B9 A   
look_drive0                 0 A026 A   look_drive1                 0 A031 A   
lorl                        0 00D7 A   lorul                       0 00D7 A   
lsl_exit                    0 0134 A   lsl_loop                    0 0128 A   
lsll                        0 0117 A   lslul                       0 0117 A   
lsr_exit                    0 0116 A   lsr_loop                    0 010A A   
lsrul                       0 00F9 A   lsubl                       0 00B1 A   
lsubul                      0 00B1 A   ltstl                       0 00E4 A   
ltstul                      0 00E4 A   memcpyb_end                 0 004D A   
memsetb_end                 0 001F A   my_gdtdesc                  0 A6C0 A   
nmi                         0 E2C3 A   no_bev                      0 AE85 A   
no_key                      0 12BE A   no_parport                  0 AD9E A   
no_serial                   0 ADC2 A   no_tcg                      0 FE81 A   
pci_present                 0 ABEA A   pci_pro_devloop             0 AACF A   
pci_pro_f02                 0 AABD A   pci_pro_f08                 0 AAFA A   
pci_pro_f09                 0 AB19 A   pci_pro_f0a                 0 AB37 A   
pci_pro_f0b                 0 AB4B A   pci_pro_f0c                 0 AB67 A   
pci_pro_f0d                 0 AB85 A   pci_pro_fail                0 AB9B A   
pci_pro_nextdev             0 AAEA A   pci_pro_ok                  0 ABA2 A   
pci_pro_select_reg          0 ABAB A   pci_pro_unknown             0 AB99 A   
pci_real_devloop            0 AC1F A   pci_real_f02                0 AC0B A   
pci_real_f08                0 AC47 A   pci_real_f09                0 AC5E A   
pci_real_f0a                0 AC75 A   pci_real_f0b                0 AC88 A   
pci_real_f0c                0 AC9F A   pci_real_f0d                0 ACB6 A   
pci_real_fail               0 ACCB A   pci_real_nextdev            0 AC35 A   
pci_real_ok                 0 ACD1 A   pci_real_select_reg         0 ACD9 A   
pci_real_unknown            0 ACC9 A   pci_routing_table_structur+ 0 AD00 A   
pcibios_error               0 FE8E A   pcibios_protected           0 AAA0 A   
pcibios_real                0 ABC8 A   pmode_IDT_info              0 F88C A   
pnp_string                  0 ADE1 A   post                        0 E05B A   
post_d0_extended            0 A0DE A   post_d0_type47              0 A0EF A   
post_d1_exists              0 A1BD A   post_d1_extended            0 A1C8 A   
post_d1_type47              0 A1D9 A   post_default_ints           0 E0AA A   
protected_mode              0 450D A   real_mode                   0 4537 A   
realmode_gdtdesc            0 A6C6 A   rmode_IDT_info              0 F891 A   
rom_checksum                0 ADC4 A   rom_scan                    0 ADE5 A   
rom_scan_increment          0 AE87 A   rom_scan_loop               0 ADEB A   
smbios_entry_point          0 CF90 A   smbios_init                 0 AE9A A   
switch_to_protmode          0 A62C A   switch_to_protmode_goon_1   0 A684 A   
switch_to_realmode          0 A6CC A   switch_to_realmode_goon_1   0 A6E2 A   
switch_to_realmode_goon_2   0 A6EF A   tcpa_post_part1             0 AEBD A   
tcpa_post_part2             0 AED0 A   timer_tick_post             0 A2D4 A   
unknown_service             0 AA92 A   

00000 errors
00000 warnings
